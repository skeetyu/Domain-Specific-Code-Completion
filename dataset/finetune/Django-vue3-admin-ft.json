[{"input": "from django . db . models import F \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import FieldPermission , MenuField \n from dvadmin . utils . json_response import DetailResponse \n from dvadmin . utils . models import get_custom_app_models \n class FieldPermissionMixin : \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def field_permission ( self , request ) : \n finded = False \n for model in get_custom_app_models ( ) : \n if model [ '<STR_LIT>' ] is self . serializer_class . Meta . model : \n finded = True \n break \n if finded : \n break \n if finded is False : \n return [ ] \n user = request . user \n if user . is_superuser == <NUM_LIT> : \n data = MenuField . objects . filter ( model = model [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' )", "output": "for item in data : \n item [ '<STR_LIT>' ] = True \n item [ '<STR_LIT>' ] = True \n item [ '<STR_LIT>' ] = True \n else : \n roles = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n data = FieldPermission . objects . filter ( \n field__model = model [ '<STR_LIT>' ] , role__in = roles \n ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , field_name = F ( '<STR_LIT>' ) ) \n return DetailResponse ( data = data )"}, {"input": "import logging \n from django . core . management . base import BaseCommand \n from application import settings \n logger = logging . getLogger ( __name__ ) \n class Command ( BaseCommand ) : \n def add_arguments ( self , parser ) : \n parser . add_argument ( \n \"<STR_LIT>\" , \n nargs = \"<STR_LIT>\" , \n type = str , \n ) \n parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) \n parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) \n parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) \n parser . add_argument ( \"<STR_LIT>\" , nargs = \"<STR_LIT>\" ) \n def handle ( self , * args , ** options ) : \n reset = False \n if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : \n reset = True \n if isinstance ( options . get ( \"<STR_LIT>\" ) , list ) or isinstance ( options . get ( \"<STR_LIT>\" ) , list ) : \n reset = False \n for app in settings . INSTALLED_APPS :", "output": "try : \n exec ( \n ) \n except ModuleNotFoundError : \n try : \n exec ( \n ) \n except ModuleNotFoundError : \n pass \n print ( \"<STR_LIT>\" )"}, {"input": "from rest_framework import serializers \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import Role , Menu , MenuButton , Dept \n from dvadmin . system . views . dept import DeptSerializer \n from dvadmin . system . views . menu import MenuSerializer \n from dvadmin . system . views . menu_button import MenuButtonSerializer \n from dvadmin . utils . crud_mixin import FastCrudMixin \n from dvadmin . utils . field_permission import FieldPermissionMixin \n from dvadmin . utils . json_response import SuccessResponse , DetailResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . validator import CustomUniqueValidator \n from dvadmin . utils . viewset import CustomModelViewSet \n class RoleSerializer ( CustomModelSerializer ) : \n class Meta : \n model = Role \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class RoleCreateUpdateSerializer ( CustomModelSerializer ) : \n menu = MenuSerializer ( many = True , read_only = True ) \n dept = DeptSerializer ( many = True , read_only = True ) \n permission = MenuButtonSerializer ( many = True , read_only = True ) \n key = serializers . CharField ( max_length = <NUM_LIT> , \n validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) , message = \"<STR_LIT>\" ) ] ) \n name = serializers . CharField ( max_length = <NUM_LIT> , validators = [ CustomUniqueValidator ( queryset = Role . objects . all ( ) ) ] ) \n def validate ( self , attrs : dict ) :", "output": "return super ( ) . validate ( attrs ) \n class Meta : \n model = Role \n fields = '<STR_LIT>' \n class MenuPermissionSerializer ( CustomModelSerializer ) : \n menuPermission = serializers . SerializerMethodField ( ) \n def get_menuPermission ( self , instance ) : \n is_superuser = self . request . user . is_superuser \n if is_superuser : \n queryset = MenuButton . objects . filter ( menu__id = instance . id ) \n else : \n menu_permission_id_list = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n queryset = MenuButton . objects . filter ( id__in = menu_permission_id_list , menu__id = instance . id ) \n serializer = MenuButtonSerializer ( queryset , many = True , read_only = True ) \n return serializer . data \n class Meta : \n model = Menu \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n class MenuButtonPermissionSerializer ( CustomModelSerializer ) : \n isCheck = serializers . SerializerMethodField ( ) \n def get_isCheck ( self , instance ) : \n is_superuser = self . request . user . is_superuser \n if is_superuser : \n return True \n else : \n return MenuButton . objects . filter ( \n menu__id = instance . id , \n role__id__in = self . request . user . role . values_list ( '<STR_LIT>' , flat = True ) , \n ) . exists ( ) \n class Meta : \n model = Menu \n fields = '<STR_LIT>' \n class RoleViewSet ( CustomModelViewSet , FastCrudMixin , FieldPermissionMixin ) : \n queryset = Role . objects . all ( ) \n serializer_class = RoleSerializer \n create_serializer_class = RoleCreateUpdateSerializer \n update_serializer_class = RoleCreateUpdateSerializer \n search_fields = [ '<STR_LIT>' , '<STR_LIT>' ]"}, {"input": "from django . db . models import F \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import RoleMenuPermission , Menu , MenuButton \n from dvadmin . utils . json_response import DetailResponse , ErrorResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class RoleMenuPermissionSerializer ( CustomModelSerializer ) : \n class Meta : \n model = RoleMenuPermission \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class RoleMenuPermissionInitSerializer ( CustomModelSerializer ) : \n class Meta : \n model = RoleMenuPermission \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class RoleMenuPermissionCreateUpdateSerializer ( CustomModelSerializer ) : \n class Meta : \n model = RoleMenuPermission \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class RoleMenuPermissionViewSet ( CustomModelViewSet ) : \n queryset = RoleMenuPermission . objects . all ( ) \n serializer_class = RoleMenuPermissionSerializer \n create_serializer_class = RoleMenuPermissionCreateUpdateSerializer \n update_serializer_class = RoleMenuPermissionCreateUpdateSerializer \n extra_filter_class = [ ] \n @ action ( methods = [ '<STR_LIT>' ] , detail = False ) \n def save_auth ( self , request ) : \n body = request . data \n role_id = body . get ( '<STR_LIT>' , None ) \n if role_id is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n menu_list = body . get ( '<STR_LIT>' , None ) \n if menu_list is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" )", "output": "obj_list = RoleMenuPermission . objects . filter ( role__id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) \n old_set = set ( obj_list ) \n new_set = set ( menu_list ) \n need_del = old_set . difference ( new_set ) \n need_add = new_set . difference ( old_set ) \n RoleMenuPermission . objects . filter ( role__id = role_id , menu__in = list ( need_del ) ) . delete ( ) \n data = [ { \"<STR_LIT>\" : role_id , \"<STR_LIT>\" : item } for item in list ( need_add ) ] \n serializer = RoleMenuPermissionSerializer ( data = data , many = True , request = request ) \n if serializer . is_valid ( raise_exception = True ) : \n serializer . save ( ) \n return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data )"}, {"input": "import json \n import os \n from django . apps import apps \n from rest_framework import request \n from application import settings \n from dvadmin . system . models import Users \n class CoreInitialize : \n creator_id = None \n reset = False \n request = request \n file_path = None \n def __init__ ( self , reset = False , creator_id = None , app = None ) : \n self . reset = reset or self . reset \n self . creator_id = creator_id or self . creator_id \n self . app = app or '<STR_LIT>' \n self . request . user = Users . objects . order_by ( '<STR_LIT>' ) . first ( ) \n def init_base ( self , Serializer , unique_fields = None ) : \n model = Serializer . Meta . model \n path_file = os . path . join ( apps . get_app_config ( self . app . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] ) . path , '<STR_LIT>' , \n f'<STR_LIT>' ) \n if not os . path . isfile ( path_file ) : \n print ( \"<STR_LIT>\" ) \n return \n with open ( path_file , encoding = \"<STR_LIT>\" ) as f : \n for data in json . load ( f ) : \n filter_data = { } \n if unique_fields : \n for field in unique_fields : \n if field in data : \n filter_data [ field ] = data [ field ] \n else : \n for key , value in data . items ( ) : \n if isinstance ( value , list ) or value == None or value == '<STR_LIT>' : \n continue \n filter_data [ key ] = value \n instance = model . objects . filter ( ** filter_data ) . first ( ) \n data [ \"<STR_LIT>\" ] = self . reset \n serializer = Serializer ( instance , data = data , request = self . request ) \n serializer . is_valid ( raise_exception = True ) \n serializer . save ( ) \n print ( f\"<STR_LIT>\" ) \n def save ( self , obj , data : list , name = None , no_reset = False ) : \n name = name or obj . _meta . verbose_name \n print ( f\"<STR_LIT>\" ) \n if not no_reset and self . reset and obj not in settings . INITIALIZE_RESET_LIST : \n try : \n obj . objects . all ( ) . delete ( ) \n settings . INITIALIZE_RESET_LIST . append ( obj ) \n except Exception : \n pass", "output": "for ele in data : \n m2m_dict = { } \n new_data = { } \n for key , value in ele . items ( ) : \n if isinstance ( value , list ) and value and isinstance ( value [ <NUM_LIT> ] , int ) : \n m2m_dict [ key ] = value \n else : \n new_data [ key ] = value \n object , _ = obj . objects . get_or_create ( id = ele . get ( \"<STR_LIT>\" ) , defaults = new_data ) \n for key , m2m in m2m_dict . items ( ) : \n m2m = list ( set ( m2m ) ) \n if m2m and len ( m2m ) > <NUM_LIT> and m2m [ <NUM_LIT> ] : \n exec ( ) \n print ( f\"<STR_LIT>\" ) \n def run ( self ) : \n raise NotImplementedError ( '<STR_LIT>' )"}, {"input": "from rest_framework import serializers \n from rest_framework . decorators import action \n from dvadmin . system . models import Menu , RoleMenuPermission \n from dvadmin . system . views . menu_button import MenuButtonSerializer \n from dvadmin . utils . json_response import SuccessResponse , ErrorResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class MenuSerializer ( CustomModelSerializer ) : \n menuPermission = serializers . SerializerMethodField ( read_only = True ) \n hasChild = serializers . SerializerMethodField ( ) \n def get_menuPermission ( self , instance ) : \n queryset = instance . menuPermission . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n if queryset : \n return queryset \n else : \n return None \n def get_hasChild ( self , instance ) : \n hasChild = Menu . objects . filter ( parent = instance . id ) \n if hasChild : \n return True \n return False \n class Meta : \n model = Menu \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class MenuCreateSerializer ( CustomModelSerializer ) : \n name = serializers . CharField ( required = False ) \n def create ( self , validated_data ) : \n menu_obj = Menu . objects . filter ( parent_id = validated_data . get ( '<STR_LIT>' , None ) ) . order_by ( '<STR_LIT>' ) . first ( ) \n last_sort = menu_obj . sort if menu_obj else <NUM_LIT> \n validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> \n return super ( ) . create ( validated_data ) \n class Meta : \n model = Menu \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class WebRouterSerializer ( CustomModelSerializer ) : \n path = serializers . CharField ( source = \"<STR_LIT>\" ) \n title = serializers . CharField ( source = \"<STR_LIT>\" ) \n class Meta : \n model = Menu \n fields = ( \n '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n read_only_fields = [ \"<STR_LIT>\" ] \n class MenuViewSet ( CustomModelViewSet ) : \n queryset = Menu . objects . all ( ) \n serializer_class = MenuSerializer \n create_serializer_class = MenuCreateSerializer \n update_serializer_class = MenuCreateSerializer \n search_fields = [ '<STR_LIT>' , '<STR_LIT>' ] \n filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n def list ( self , request ) : \n request . query_params . _mutable = True \n params = request . query_params \n parent = params . get ( '<STR_LIT>' , None ) \n page = params . get ( '<STR_LIT>' , None ) \n limit = params . get ( '<STR_LIT>' , None ) \n if page : \n del params [ '<STR_LIT>' ] \n if limit : \n del params [ '<STR_LIT>' ] \n if params : \n if parent : \n queryset = self . queryset . filter ( parent = parent ) \n else : \n queryset = self . queryset . filter ( ) \n else : \n queryset = self . queryset . filter ( parent__isnull = True ) \n queryset = self . filter_queryset ( queryset ) \n serializer = MenuSerializer ( queryset , many = True , request = request ) \n data = serializer . data \n return SuccessResponse ( data = data ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) \n def web_router ( self , request ) : \n user = request . user \n if user . is_superuser : \n queryset = self . queryset . filter ( status = <NUM_LIT> ) \n else : \n role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) \n menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' , flat = True ) \n queryset = Menu . objects . filter ( id__in = menu_list ) \n serializer = WebRouterSerializer ( queryset , many = True , request = request ) \n data = serializer . data \n return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) \n def get_all_menu ( self , request ) : \n user = request . user \n queryset = self . queryset . all ( ) \n if not user . is_superuser : \n role_list = user . role . values_list ( '<STR_LIT>' , flat = True ) \n menu_list = RoleMenuPermission . objects . filter ( role__in = role_list ) . values_list ( '<STR_LIT>' ) \n queryset = Menu . objects . filter ( id__in = menu_list ) \n serializer = WebRouterSerializer ( queryset , many = True , request = request ) \n data = serializer . data \n return SuccessResponse ( data = data , total = len ( data ) , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) \n def move_up ( self , request ) : \n menu_id = request . data . get ( '<STR_LIT>' ) \n try : \n menu = Menu . objects . get ( id = menu_id ) \n except Menu . DoesNotExist : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n previous_menu = Menu . objects . filter ( sort__lt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) \n if previous_menu : \n previous_menu . sort , menu . sort = menu . sort , previous_menu . sort", "output": "previous_menu . save ( ) \n menu . save ( ) \n return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) \n def move_down ( self , request ) : \n menu_id = request . data [ '<STR_LIT>' ] \n try : \n menu = Menu . objects . get ( id = menu_id ) \n except Menu . DoesNotExist : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n next_menu = Menu . objects . filter ( sort__gt = menu . sort , parent = menu . parent ) . order_by ( '<STR_LIT>' ) . first ( ) \n if next_menu : \n next_menu . sort , menu . sort = menu . sort , next_menu . sort \n next_menu . save ( ) \n menu . save ( ) \n return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" )"}, {"input": "import os \n import django \n os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n django . setup ( ) \n from dvadmin . utils . core_initialize import CoreInitialize \n from dvadmin . system . fixtures . initSerializer import ( \n UsersInitSerializer , DeptInitSerializer , RoleInitSerializer , \n MenuInitSerializer , ApiWhiteListInitSerializer , DictionaryInitSerializer , \n SystemConfigInitSerializer , RoleMenuInitSerializer , RoleMenuButtonInitSerializer \n ) \n class Initialize ( CoreInitialize ) : \n def init_dept ( self ) : \n self . init_base ( DeptInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) \n def init_role ( self ) : \n self . init_base ( RoleInitSerializer , unique_fields = [ '<STR_LIT>' ] ) \n def init_users ( self ) : \n self . init_base ( UsersInitSerializer , unique_fields = [ '<STR_LIT>' ] ) \n def init_menu ( self ) : \n self . init_base ( MenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] )", "output": "def init_role_menu ( self ) : \n self . init_base ( RoleMenuInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) \n def init_role_menu_button ( self ) : \n self . init_base ( RoleMenuButtonInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' ] ) \n def init_api_white_list ( self ) : \n self . init_base ( ApiWhiteListInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) \n def init_dictionary ( self ) : \n self . init_base ( DictionaryInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) \n def init_system_config ( self ) : \n self . init_base ( SystemConfigInitSerializer , unique_fields = [ '<STR_LIT>' , '<STR_LIT>' , ] ) \n def run ( self ) : \n self . init_dept ( ) \n self . init_role ( ) \n self . init_users ( ) \n self . init_menu ( ) \n self . init_role_menu ( ) \n self . init_role_menu_button ( ) \n self . init_api_white_list ( ) \n self . init_dictionary ( ) \n self . init_system_config ( ) \n if __name__ == \"<STR_LIT>\" : \n Initialize ( app = '<STR_LIT>' ) . run ( )"}, {"input": "from rest_framework import serializers \n from rest_framework . fields import empty \n from rest_framework . request import Request \n from rest_framework . serializers import ModelSerializer \n from django . utils . functional import cached_property \n from rest_framework . utils . serializer_helpers import BindingDict \n from dvadmin . system . models import Users \n from django_restql . mixins import DynamicFieldsMixin \n class CustomModelSerializer ( DynamicFieldsMixin , ModelSerializer ) : \n modifier_field_id = \"<STR_LIT>\" \n modifier_name = serializers . SerializerMethodField ( read_only = True ) \n dept_belong_id = serializers . IntegerField ( required = False , allow_null = True ) \n def get_modifier_name ( self , instance ) : \n if not hasattr ( instance , \"<STR_LIT>\" ) : \n return None \n queryset = ( \n Users . objects . filter ( id = instance . modifier ) \n . values_list ( \"<STR_LIT>\" , flat = True ) \n . first ( ) \n ) \n if queryset : \n return queryset \n return None \n creator_field_id = \"<STR_LIT>\" \n creator_name = serializers . SlugRelatedField ( \n slug_field = \"<STR_LIT>\" , source = \"<STR_LIT>\" , read_only = True \n ) \n dept_belong_id_field_name = \"<STR_LIT>\" \n create_datetime = serializers . DateTimeField ( \n format = \"<STR_LIT>\" , required = False , read_only = True \n ) \n update_datetime = serializers . DateTimeField ( \n format = \"<STR_LIT>\" , required = False \n ) \n def __init__ ( self , instance = None , data = empty , request = None , ** kwargs ) : \n super ( ) . __init__ ( instance , data , ** kwargs ) \n self . request : Request = request or self . context . get ( \"<STR_LIT>\" , None ) \n def save ( self , ** kwargs ) : \n return super ( ) . save ( ** kwargs ) \n def create ( self , validated_data ) : \n if self . request : \n if str ( self . request . user ) != \"<STR_LIT>\" : \n if self . modifier_field_id in self . fields . fields : \n validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) \n if self . creator_field_id in self . fields . fields : \n validated_data [ self . creator_field_id ] = self . request . user \n if ( \n self . dept_belong_id_field_name in self . fields . fields \n and validated_data . get ( self . dept_belong_id_field_name , None ) is None \n ) : \n validated_data [ self . dept_belong_id_field_name ] = getattr ( \n self . request . user , \"<STR_LIT>\" , None \n ) \n return super ( ) . create ( validated_data ) \n def update ( self , instance , validated_data ) : \n if self . request : \n if str ( self . request . user ) != \"<STR_LIT>\" : \n if self . modifier_field_id in self . fields . fields : \n validated_data [ self . modifier_field_id ] = self . get_request_user_id ( ) \n if hasattr ( self . instance , self . modifier_field_id ) : \n setattr ( \n self . instance , self . modifier_field_id , self . get_request_user_id ( ) \n ) \n return super ( ) . update ( instance , validated_data ) \n def get_request_username ( self ) : \n if getattr ( self . request , \"<STR_LIT>\" , None ) : \n return getattr ( self . request . user , \"<STR_LIT>\" , None ) \n return None", "output": "def get_request_name ( self ) : \n if getattr ( self . request , \"<STR_LIT>\" , None ) : \n return getattr ( self . request . user , \"<STR_LIT>\" , None ) \n return None \n def get_request_user_id ( self ) : \n if getattr ( self . request , \"<STR_LIT>\" , None ) : \n return getattr ( self . request . user , \"<STR_LIT>\" , None ) \n return None \n @ property \n def errors ( self ) : \n errors = super ( ) . errors \n verbose_errors = { } \n fields = { field . name : field . verbose_name for field in \n self . Meta . model . _meta . get_fields ( ) if hasattr ( field , '<STR_LIT>' ) } \n for field_name , error in errors . items ( ) : \n if field_name in fields : \n verbose_errors [ str ( fields [ field_name ] ) ] = error \n else : \n verbose_errors [ field_name ] = error \n return verbose_errors"}, {"input": "import os \n exclude = [ \"<STR_LIT>\" ] \n for root , dirs , files in os . walk ( '<STR_LIT>' ) :", "output": "dirs [ : ] = list ( set ( dirs ) - set ( exclude ) ) \n if '<STR_LIT>' in dirs : \n dir = dirs [ dirs . index ( '<STR_LIT>' ) ] \n for root_j , dirs_j , files_j in os . walk ( os . path . join ( root , dir ) ) : \n for file_k in files_j : \n if file_k != '<STR_LIT>' : \n dst_file = os . path . join ( root_j , file_k ) \n print ( '<STR_LIT>' , dst_file ) \n os . remove ( dst_file )"}, {"input": "from rest_framework . decorators import action \n from rest_framework . permissions import AllowAny \n from dvadmin . utils . json_response import DetailResponse \n class FastCrudMixin : \n crud_fields = None \n exclude_fields = None \n custom_crud_json = None \n crud_update_key_value = None \n def __handle_type ( self , type ) : \n if type in [ '<STR_LIT>' , '<STR_LIT>' ] : \n return \"<STR_LIT>\" \n if type == '<STR_LIT>' : \n return \"<STR_LIT>\" \n if type == '<STR_LIT>' : \n return \"<STR_LIT>\" \n if type == '<STR_LIT>' : \n return \"<STR_LIT>\" \n if type == '<STR_LIT>' : \n return \"<STR_LIT>\" \n def __get_field_attribute ( self ) : \n result = [ ] \n queryset = self . get_queryset ( ) \n __name = \"<STR_LIT>\" \n __verbose_name = \"<STR_LIT>\" \n __type = \"<STR_LIT>\" \n if self . crud_fields and type ( self . crud_fields == list ) : \n for item in self . crud_fields : \n try : \n field = queryset . model . _meta . get_field ( item ) \n field_type = field . get_internal_type ( ) \n __name = field . name \n if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] :", "output": "continue \n else : \n __verbose_name = field . verbose_name \n __type = self . __handle_type ( field_type ) \n except : \n continue \n result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) \n else : \n model_fields = queryset . model . _meta . get_fields ( ) \n for field in model_fields : \n field_type = field . get_internal_type ( ) \n __name = field . name \n if self . exclude_fields and type ( self . exclude_fields == list ) : \n if __name in self . exclude_fields : \n continue \n if field_type in [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] : \n continue \n else : \n __verbose_name = field . verbose_name \n __type = self . __handle_type ( field_type ) \n result . append ( { \"<STR_LIT>\" : __name , \"<STR_LIT>\" : __verbose_name , \"<STR_LIT>\" : __type } ) \n return result \n def __find_key ( self , dct : dict , \n target_key : str , \n level : int = - <NUM_LIT> , \n index : int = - <NUM_LIT> ) -> tuple : \n for k , v in dct . items ( ) : \n level += <NUM_LIT> \n index += <NUM_LIT> \n if k == target_key : \n return level , index \n elif isinstance ( v , list ) : \n for i , dct_ in enumerate ( v ) : \n if isinstance ( dct_ , dict ) : \n result = self . __find_key ( dct_ , target_key ) \n if result is not None : \n return result \n else : \n continue \n elif isinstance ( v , str ) or isinstance ( v , int ) or isinstance ( v , float ) : \n continue \n def __update_nested_dict ( self , nested_dict : dict , \n target_key : str , \n new_value ) -> dict : \n split_target_key = target_key . split ( '<STR_LIT>' ) \n if len ( split_target_key ) > <NUM_LIT> : \n new_dict = nested_dict [ split_target_key [ <NUM_LIT> ] ] \n for item in split_target_key [ <NUM_LIT> : - <NUM_LIT> ] : \n new_dict = new_dict [ item ] \n self . __update_nested_dict ( new_dict , split_target_key [ - <NUM_LIT> ] , new_value ) \n else : \n nested_dict [ target_key ] = new_value \n return nested_dict \n def __handle_crud ( self ) : \n result = self . __get_field_attribute ( ) \n columns = dict ( ) \n for item in result : \n key = item . get ( '<STR_LIT>' ) \n title = item . get ( '<STR_LIT>' ) \n type = item . get ( '<STR_LIT>' ) \n columns [ key ] = { \n \"<STR_LIT>\" : title , \n \"<STR_LIT>\" : key , \n \"<STR_LIT>\" : type \n } \n if self . custom_crud_json and isinstance ( self . custom_crud_json , dict ) : \n columns = columns | self . custom_crud_json \n if self . crud_update_key_value and isinstance ( self . crud_update_key_value , dict ) : \n for key , value in self . crud_update_key_value . items ( ) : \n columns = self . __update_nested_dict ( columns , key , value ) \n return columns \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ AllowAny ] ) \n def init_crud ( self , request ) : \n self . permission_classes = [ AllowAny ] \n columns = self . __handle_crud ( ) \n expose = \"<STR_LIT>\" \n ret = \"<STR_LIT>\" \n res = \"<STR_LIT>\" \n data = \n return DetailResponse ( data = data )"}, {"input": "import hashlib \n import logging \n from django . contrib . auth import get_user_model \n from django . contrib . auth . backends import ModelBackend \n from django . contrib . auth . hashers import check_password \n from django . utils import timezone \n from dvadmin . utils . validator import CustomValidationError \n logger = logging . getLogger ( __name__ ) \n UserModel = get_user_model ( ) \n class CustomBackend ( ModelBackend ) : \n def authenticate ( self , request , username = None , password = None , ** kwargs ) : \n msg = '<STR_LIT>' % username \n logger . info ( msg ) \n if username is None : \n username = kwargs . get ( UserModel . USERNAME_FIELD ) \n try :", "output": "user = UserModel . _default_manager . get_by_natural_key ( username ) \n except UserModel . DoesNotExist : \n UserModel ( ) . set_password ( password ) \n else : \n verify_password = check_password ( password , user . password ) \n if not verify_password : \n password = hashlib . md5 ( password . encode ( encoding = '<STR_LIT>' ) ) . hexdigest ( ) \n verify_password = check_password ( password , user . password ) \n if verify_password : \n if self . user_can_authenticate ( user ) : \n user . last_login = timezone . now ( ) \n user . save ( ) \n return user \n raise CustomValidationError ( \"<STR_LIT>\" )"}, {"input": "import os \n import re \n from datetime import datetime \n import openpyxl \n from django . conf import settings \n from dvadmin . utils . validator import CustomValidationError \n def import_to_data ( file_url , field_data , m2m_fields = None ) : \n file_path_dir = os . path . join ( settings . BASE_DIR , file_url ) \n workbook = openpyxl . load_workbook ( file_path_dir ) \n table = workbook [ workbook . sheetnames [ <NUM_LIT> ] ] \n theader = tuple ( table . values ) [ <NUM_LIT> ] \n is_update = '<STR_LIT>' in theader \n if is_update is False : \n field_data . pop ( '<STR_LIT>' ) \n validation_data_dict = { } \n for key , value in field_data . items ( ) : \n if isinstance ( value , dict ) : \n choices = value . get ( \"<STR_LIT>\" , { } ) \n data_dict = { } \n if choices . get ( \"<STR_LIT>\" ) : \n for k , v in choices . get ( \"<STR_LIT>\" ) . items ( ) : \n data_dict [ k ] = v \n elif choices . get ( \"<STR_LIT>\" ) and choices . get ( \"<STR_LIT>\" ) : \n data_list = choices . get ( \"<STR_LIT>\" ) . values ( choices . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) \n for ele in data_list : \n data_dict [ ele . get ( choices . get ( \"<STR_LIT>\" ) ) ] = ele . get ( \"<STR_LIT>\" ) \n else : \n continue \n validation_data_dict [ key ] = data_dict", "output": "tables = [ ] \n for i , row in enumerate ( range ( table . max_row ) ) : \n if i == <NUM_LIT> : \n continue \n array = { } \n for index , item in enumerate ( field_data . items ( ) ) : \n items = list ( item ) \n key = items [ <NUM_LIT> ] \n values = items [ <NUM_LIT> ] \n value_type = '<STR_LIT>' \n if isinstance ( values , dict ) : \n value_type = values . get ( '<STR_LIT>' , '<STR_LIT>' ) \n cell_value = table . cell ( row = row + <NUM_LIT> , column = index + <NUM_LIT> ) . value \n if cell_value is None or cell_value == '<STR_LIT>' : \n continue \n elif value_type == '<STR_LIT>' : \n print ( <NUM_LIT> , datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) ) \n try : \n cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) . date ( ) \n except : \n raise CustomValidationError ( '<STR_LIT>' ) \n elif value_type == '<STR_LIT>' : \n cell_value = datetime . strptime ( str ( cell_value ) , '<STR_LIT>' ) \n else : \n if type ( cell_value ) is float and str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] == \"<STR_LIT>\" : \n cell_value = int ( str ( cell_value ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ) \n elif type ( cell_value ) is str : \n cell_value = cell_value . strip ( \"<STR_LIT>\" ) \n if key in validation_data_dict : \n array [ key ] = validation_data_dict . get ( key , { } ) . get ( cell_value , None ) \n if key in m2m_fields : \n array [ key ] = list ( \n filter ( \n lambda x : x , \n [ \n validation_data_dict . get ( key , { } ) . get ( value , None ) \n for value in re . split ( r\"<STR_LIT>\" , cell_value ) \n ] , \n ) \n ) \n else : \n array [ key ] = cell_value \n tables . append ( array ) \n return tables"}, {"input": "from rest_framework import serializers \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import Dept , RoleMenuButtonPermission , Users \n from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class DeptSerializer ( CustomModelSerializer ) : \n parent_name = serializers . CharField ( read_only = True , source = '<STR_LIT>' ) \n status_label = serializers . SerializerMethodField ( ) \n has_children = serializers . SerializerMethodField ( ) \n hasChild = serializers . SerializerMethodField ( ) \n dept_user_count = serializers . SerializerMethodField ( ) \n def get_dept_user_count ( self , obj : Dept ) : \n return Users . objects . filter ( dept = obj ) . count ( ) \n def get_hasChild ( self , instance ) : \n hasChild = Dept . objects . filter ( parent = instance . id ) \n if hasChild : \n return True \n return False \n def get_status_label ( self , obj : Dept ) : \n if obj . status : \n return \"<STR_LIT>\" \n return \"<STR_LIT>\"", "output": "def get_has_children ( self , obj : Dept ) : \n return Dept . objects . filter ( parent_id = obj . id ) . count ( ) \n class Meta : \n model = Dept \n fields = '<STR_LIT>' \n read_only_fields = [ \"<STR_LIT>\" ] \n class DeptImportSerializer ( CustomModelSerializer ) : \n class Meta : \n model = Dept \n fields = '<STR_LIT>' \n read_only_fields = [ \"<STR_LIT>\" ] \n class DeptCreateUpdateSerializer ( CustomModelSerializer ) : \n def create ( self , validated_data ) : \n value = validated_data . get ( '<STR_LIT>' , None ) \n if value is None : \n validated_data [ '<STR_LIT>' ] = self . request . user . dept \n dept_obj = Dept . objects . filter ( parent = self . request . user . dept ) . order_by ( '<STR_LIT>' ) . first ( ) \n last_sort = dept_obj . sort if dept_obj else <NUM_LIT> \n validated_data [ '<STR_LIT>' ] = last_sort + <NUM_LIT> \n instance = super ( ) . create ( validated_data ) \n instance . dept_belong_id = instance . id \n instance . save ( ) \n return instance \n class Meta : \n model = Dept \n fields = '<STR_LIT>' \n class DeptViewSet ( CustomModelViewSet ) : \n queryset = Dept . objects . all ( ) \n serializer_class = DeptSerializer \n create_serializer_class = DeptCreateUpdateSerializer \n update_serializer_class = DeptCreateUpdateSerializer \n filter_fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n search_fields = [ ] \n import_serializer_class = DeptImportSerializer \n import_field_dict = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n def list ( self , request , * args , ** kwargs ) : \n request . query_params . _mutable = True \n params = request . query_params \n parent = params . get ( '<STR_LIT>' , None ) \n page = params . get ( '<STR_LIT>' , None ) \n limit = params . get ( '<STR_LIT>' , None ) \n if page : \n del params [ '<STR_LIT>' ] \n if limit : \n del params [ '<STR_LIT>' ] \n if params and parent : \n queryset = self . queryset . filter ( status = True , parent = parent ) \n else : \n queryset = self . queryset . filter ( status = True ) \n queryset = self . filter_queryset ( queryset ) \n serializer = DeptSerializer ( queryset , many = True , request = request ) \n data = serializer . data \n return SuccessResponse ( data = data ) \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) \n def dept_lazy_tree ( self , request , * args , ** kwargs ) : \n parent = self . request . query_params . get ( '<STR_LIT>' ) \n is_superuser = request . user . is_superuser \n if is_superuser : \n queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n else : \n role_ids = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n data_range = RoleMenuButtonPermission . objects . filter ( role__in = role_ids ) . values_list ( '<STR_LIT>' , flat = True ) \n user_dept_id = request . user . dept . id \n dept_list = [ user_dept_id ] \n data_range_list = list ( set ( data_range ) ) \n for item in data_range_list : \n if item in [ <NUM_LIT> , <NUM_LIT> ] : \n dept_list = [ user_dept_id ] \n elif item == <NUM_LIT> : \n dept_list = Dept . recursion_all_dept ( dept_id = user_dept_id ) \n elif item == <NUM_LIT> : \n dept_list = Dept . objects . values_list ( '<STR_LIT>' , flat = True ) \n elif item == <NUM_LIT> : \n dept_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n else : \n dept_list = [ ] \n queryset = Dept . objects . filter ( id__in = dept_list ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n return DetailResponse ( data = queryset , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ \"<STR_LIT>\" ] , detail = False , permission_classes = [ IsAuthenticated ] , extra_filter_class = [ ] ) \n def all_dept ( self , request , * args , ** kwargs ) : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n data = queryset . filter ( status = True ) . order_by ( '<STR_LIT>' ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n return DetailResponse ( data = data , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def move_up ( self , request ) : \n dept_id = request . data . get ( '<STR_LIT>' ) \n try : \n dept = Dept . objects . get ( id = dept_id ) \n except Dept . DoesNotExist : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n previous_menu = Dept . objects . filter ( sort__lt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) \n if previous_menu : \n previous_menu . sort , dept . sort = dept . sort , previous_menu . sort \n previous_menu . save ( ) \n dept . save ( ) \n return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def move_down ( self , request ) : \n dept_id = request . data [ '<STR_LIT>' ] \n try : \n dept = Dept . objects . get ( id = dept_id ) \n except Dept . DoesNotExist : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n next_menu = Dept . objects . filter ( sort__gt = dept . sort , parent = dept . parent ) . order_by ( '<STR_LIT>' ) . first ( ) \n if next_menu : \n next_menu . sort , dept . sort = dept . sort , next_menu . sort \n next_menu . save ( ) \n dept . save ( ) \n return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ ] ) \n def dept_info ( self , request ) : \n def inner ( did , li ) : \n sub = Dept . objects . filter ( parent_id = did ) \n if not sub . exists ( ) : \n return li \n for i in sub : \n li . append ( i . pk ) \n inner ( i , li ) \n return li \n dept_id = request . query_params . get ( '<STR_LIT>' ) \n show_all = request . query_params . get ( '<STR_LIT>' ) \n if dept_id is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n if not show_all : \n show_all = <NUM_LIT> \n if int ( show_all ) : \n all_did = [ dept_id ] \n inner ( dept_id , all_did ) \n users = Users . objects . filter ( dept_id__in = all_did ) \n else : \n if dept_id != '<STR_LIT>' : \n users = Users . objects . filter ( dept_id = dept_id ) \n else : \n users = Users . objects . none ( ) \n dept_obj = Dept . objects . get ( id = dept_id ) if dept_id != '<STR_LIT>' else None \n sub_dept = Dept . objects . filter ( parent_id = dept_obj . pk ) if dept_id != '<STR_LIT>' else [ ] \n data = { \n '<STR_LIT>' : dept_obj and dept_obj . name , \n '<STR_LIT>' : users . count ( ) , \n '<STR_LIT>' : dept_obj and dept_obj . owner , \n '<STR_LIT>' : dept_obj and dept_obj . description , \n '<STR_LIT>' : { \n '<STR_LIT>' : users . filter ( gender = <NUM_LIT> ) . count ( ) , \n '<STR_LIT>' : users . filter ( gender = <NUM_LIT> ) . count ( ) , \n '<STR_LIT>' : users . filter ( gender = <NUM_LIT> ) . count ( ) , \n } , \n '<STR_LIT>' : [ ] \n } \n for dept in sub_dept : \n all_did = [ dept . pk ] \n inner ( dept . pk , all_did ) \n sub_data = { \n '<STR_LIT>' : dept . name , \n '<STR_LIT>' : Users . objects . filter ( dept_id__in = all_did ) . count ( ) \n } \n data [ '<STR_LIT>' ] . append ( sub_data ) \n return SuccessResponse ( data )"}, {"input": "import re \n from django . contrib . auth . models import AnonymousUser \n from django . db . models import F \n from rest_framework . permissions import BasePermission \n from dvadmin . system . models import ApiWhiteList , RoleMenuButtonPermission \n def ValidationApi ( reqApi , validApi ) : \n if validApi is not None : \n valid_api = validApi . replace ( '<STR_LIT>' , '<STR_LIT>' ) \n matchObj = re . match ( valid_api , reqApi , re . M | re . I ) \n if matchObj : \n return True \n else : \n return False \n else : \n return False \n class AnonymousUserPermission ( BasePermission ) :", "output": "def has_permission ( self , request , view ) : \n if isinstance ( request . user , AnonymousUser ) : \n return False \n return True \n def ReUUID ( api ) : \n pattern = re . compile ( r'<STR_LIT>' ) \n m = pattern . search ( api ) \n if m : \n res = api . replace ( m . group ( <NUM_LIT> ) , \"<STR_LIT>\" ) \n return res \n else : \n return None \n class CustomPermission ( BasePermission ) : \n def has_permission ( self , request , view ) : \n if isinstance ( request . user , AnonymousUser ) : \n return False \n if request . user . is_superuser : \n return True \n else : \n api = request . path \n method = request . method \n methodList = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n method = methodList . index ( method ) \n api_white_list = ApiWhiteList . objects . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) \n api_white_list = [ \n str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( \n item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in api_white_list if item . get ( '<STR_LIT>' ) ] \n if not hasattr ( request . user , \"<STR_LIT>\" ) : \n return False \n role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n userApiList = RoleMenuButtonPermission . objects . filter ( role__in = role_id_list ) . values ( permission__api = F ( '<STR_LIT>' ) , permission__method = F ( '<STR_LIT>' ) ) \n ApiList = [ \n str ( item . get ( '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) ) + \"<STR_LIT>\" + str ( \n item . get ( '<STR_LIT>' ) ) + '<STR_LIT>' for item in userApiList if item . get ( '<STR_LIT>' ) ] \n new_api_ist = api_white_list + ApiList \n new_api = api + \"<STR_LIT>\" + str ( method ) \n for item in new_api_ist : \n matchObj = re . match ( item , new_api , re . M | re . I ) \n if matchObj is None : \n continue \n else : \n return True \n else : \n return False"}, {"input": "from django . db . models import F , Subquery , OuterRef , Exists \n from rest_framework import serializers \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import RoleMenuButtonPermission , Menu , MenuButton , Dept , RoleMenuPermission , FieldPermission , MenuField \n from dvadmin . system . views . menu import MenuSerializer \n from dvadmin . utils . json_response import DetailResponse , ErrorResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class RoleMenuButtonPermissionSerializer ( CustomModelSerializer ) : \n class Meta : \n model = RoleMenuButtonPermission \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class RoleMenuButtonPermissionCreateUpdateSerializer ( CustomModelSerializer ) : \n menu_button__name = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) \n menu_button__value = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) \n class Meta : \n model = RoleMenuButtonPermission \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class RoleButtonPermissionSerializer ( CustomModelSerializer ) : \n isCheck = serializers . SerializerMethodField ( ) \n data_range = serializers . SerializerMethodField ( ) \n def get_isCheck ( self , instance ) : \n params = self . request . query_params \n return RoleMenuButtonPermission . objects . filter ( \n menu_button__id = instance [ '<STR_LIT>' ] , \n role__id = params . get ( '<STR_LIT>' ) , \n ) . exists ( ) \n def get_data_range ( self , instance ) : \n params = self . request . query_params \n obj = RoleMenuButtonPermission . objects . filter ( \n menu_button__id = instance [ '<STR_LIT>' ] , \n role__id = params . get ( '<STR_LIT>' ) , \n ) . first ( ) \n if obj is None : \n return None \n return obj . data_range \n class Meta : \n model = MenuButton \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n class RoleFieldPermissionSerializer ( CustomModelSerializer ) : \n class Meta : \n model = FieldPermission \n fields = \"<STR_LIT>\" \n class RoleMenuFieldSerializer ( CustomModelSerializer ) : \n is_query = serializers . SerializerMethodField ( ) \n is_create = serializers . SerializerMethodField ( ) \n is_update = serializers . SerializerMethodField ( ) \n def get_is_query ( self , instance ) : \n params = self . request . query_params \n queryset = instance . menu_field . filter ( role = params . get ( '<STR_LIT>' ) ) . first ( ) \n if queryset : \n return queryset . is_query \n return False \n def get_is_create ( self , instance ) : \n params = self . request . query_params \n queryset = instance . menu_field . filter ( role = params . get ( '<STR_LIT>' ) ) . first ( ) \n if queryset : \n return queryset . is_create \n return False \n def get_is_update ( self , instance ) : \n params = self . request . query_params \n queryset = instance . menu_field . filter ( role = params . get ( '<STR_LIT>' ) ) . first ( ) \n if queryset : \n return queryset . is_update \n return False \n class Meta : \n model = MenuField \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n class RoleMenuPermissionSerializer ( CustomModelSerializer ) : \n name = serializers . SerializerMethodField ( ) \n isCheck = serializers . SerializerMethodField ( ) \n btns = serializers . SerializerMethodField ( ) \n columns = serializers . SerializerMethodField ( ) \n def get_name ( self , instance ) : \n parent_list = Menu . get_all_parent ( instance [ '<STR_LIT>' ] ) \n names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] \n return \"<STR_LIT>\" . join ( names ) \n def get_isCheck ( self , instance ) : \n params = self . request . query_params \n return RoleMenuPermission . objects . filter ( \n menu__id = instance [ '<STR_LIT>' ] , \n role__id = params . get ( '<STR_LIT>' ) , \n ) . exists ( ) \n def get_btns ( self , instance ) : \n btn_list = MenuButton . objects . filter ( menu__id = instance [ '<STR_LIT>' ] ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n serializer = RoleButtonPermissionSerializer ( btn_list , many = True , request = self . request ) \n return serializer . data \n def get_columns ( self , instance ) : \n col_list = MenuField . objects . filter ( menu = instance [ '<STR_LIT>' ] ) \n serializer = RoleMenuFieldSerializer ( col_list , many = True , request = self . request ) \n return serializer . data \n class Meta : \n model = Menu \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n class RoleMenuButtonPermissionViewSet ( CustomModelViewSet ) : \n queryset = RoleMenuButtonPermission . objects . all ( ) \n serializer_class = RoleMenuButtonPermissionSerializer \n create_serializer_class = RoleMenuButtonPermissionCreateUpdateSerializer \n update_serializer_class = RoleMenuButtonPermissionCreateUpdateSerializer \n extra_filter_class = [ ] \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def get_role_premission ( self , request ) : \n params = request . query_params \n role = params . get ( '<STR_LIT>' , None ) \n if role is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n is_superuser = request . user . is_superuser \n data = [ ] \n if is_superuser : \n queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) . all ( ) \n else : \n role_id = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n menu_list = RoleMenuPermission . objects . filter ( role__in = role_id ) . values_list ( '<STR_LIT>' , flat = True ) \n queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False , id__in = menu_list ) . values ( '<STR_LIT>' , '<STR_LIT>' ) \n for item in queryset : \n parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) \n names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] \n completeName = \"<STR_LIT>\" . join ( names ) \n isCheck = RoleMenuPermission . objects . filter ( \n menu__id = item [ '<STR_LIT>' ] , \n role__id = role , \n ) . exists ( ) \n mbCheck = RoleMenuButtonPermission . objects . filter ( \n menu_button = OuterRef ( \"<STR_LIT>\" ) , \n role__id = role , \n ) \n btns = MenuButton . objects . filter ( \n menu__id = item [ '<STR_LIT>' ] , \n ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n data_range = F ( '<STR_LIT>' ) ) \n dicts = { \n '<STR_LIT>' : completeName , \n '<STR_LIT>' : item [ '<STR_LIT>' ] , \n '<STR_LIT>' : isCheck , \n '<STR_LIT>' : btns , \n } \n data . append ( dicts ) \n return DetailResponse ( data = data ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = True , permission_classes = [ IsAuthenticated ] ) \n def set_role_premission ( self , request , pk ) : \n body = request . data \n RoleMenuPermission . objects . filter ( role = pk ) . delete ( ) \n RoleMenuButtonPermission . objects . filter ( role = pk ) . delete ( ) \n for menu in body : \n if menu . get ( '<STR_LIT>' ) : \n menu_parent = Menu . get_all_parent ( menu . get ( '<STR_LIT>' ) ) \n role_menu_permission_list = [ ] \n for d in menu_parent : \n role_menu_permission_list . append ( RoleMenuPermission ( role_id = pk , menu_id = d [ \"<STR_LIT>\" ] ) ) \n RoleMenuPermission . objects . bulk_create ( role_menu_permission_list ) \n for btn in menu . get ( '<STR_LIT>' ) : \n if btn . get ( '<STR_LIT>' ) : \n data_range = btn . get ( '<STR_LIT>' , <NUM_LIT> ) or <NUM_LIT> \n instance = RoleMenuButtonPermission . objects . create ( role_id = pk , menu_button_id = btn . get ( '<STR_LIT>' ) , data_range = data_range ) \n instance . dept . set ( btn . get ( '<STR_LIT>' , [ ] ) ) \n for col in menu . get ( '<STR_LIT>' ) : \n FieldPermission . objects . update_or_create ( role_id = pk , field_id = col . get ( '<STR_LIT>' ) , is_query = col . get ( '<STR_LIT>' ) , is_create = col . get ( '<STR_LIT>' ) , is_update = col . get ( '<STR_LIT>' ) ) \n return DetailResponse ( msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def role_menu_get_button ( self , request ) : \n if params := request . query_params : \n if menu_id := params . get ( '<STR_LIT>' , None ) : \n is_superuser = request . user . is_superuser \n if is_superuser : \n queryset = MenuButton . objects . filter ( menu = menu_id ) . values ( '<STR_LIT>' , '<STR_LIT>' ) \n else : \n role_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n queryset = RoleMenuButtonPermission . objects . filter ( \n role__in = role_list , menu_button__menu = menu_id \n ) . values ( btn_id = F ( '<STR_LIT>' ) , name = F ( '<STR_LIT>' ) ) \n return DetailResponse ( data = queryset ) \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def data_scope ( self , request ) : \n is_superuser = request . user . is_superuser \n if is_superuser : \n data = [ \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } \n ] \n return DetailResponse ( data = data ) \n else : \n data = [ ] \n role_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n if params := request . query_params : \n if menu_button_id := params . get ( '<STR_LIT>' , None ) : \n role_queryset = RoleMenuButtonPermission . objects . filter ( \n role__in = role_list , menu_button__id = menu_button_id \n ) . values_list ( '<STR_LIT>' , flat = True ) \n data_range_list = list ( set ( role_queryset ) ) \n for item in data_range_list : \n if item == <NUM_LIT> : \n data = [ { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } ] \n elif item == <NUM_LIT> : \n data = [ { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } ] \n elif item == <NUM_LIT> : \n data = [ { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } ] \n elif item == <NUM_LIT> : \n data = [ { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , ] \n elif item == <NUM_LIT> : \n data = [ { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } , \n { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : '<STR_LIT>' \n } ] \n else : \n data = [ ] \n return DetailResponse ( data = data ) \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def role_to_dept_all ( self , request ) : \n params = request . query_params \n is_superuser = request . user . is_superuser \n if is_superuser : \n queryset = Dept . objects . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n else : \n if not params : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n menu_button = params . get ( '<STR_LIT>' ) \n if menu_button is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n role_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n queryset = RoleMenuButtonPermission . objects . filter ( role__in = role_list , menu_button = None ) . values ( \n dept_id = F ( '<STR_LIT>' ) , \n name = F ( '<STR_LIT>' ) , \n parent = F ( '<STR_LIT>' ) \n ) \n return DetailResponse ( data = queryset ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def menu_to_button ( self , request ) : \n params = request . query_params \n menu_id = params . get ( '<STR_LIT>' , None ) \n if menu_id is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n is_superuser = request . user . is_superuser \n if is_superuser : \n queryset = RoleMenuButtonPermission . objects . filter ( menu_button__menu = menu_id ) . values ( \n '<STR_LIT>' , \n '<STR_LIT>' , \n '<STR_LIT>' , \n '<STR_LIT>' , \n '<STR_LIT>' \n ) \n return DetailResponse ( data = queryset ) \n else : \n if params : \n role_id = params . get ( '<STR_LIT>' , None ) \n if role_id is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n queryset = RoleMenuButtonPermission . objects . filter ( role = role_id , menu_button__menu = menu_id ) . values ( \n '<STR_LIT>' , \n '<STR_LIT>' , \n '<STR_LIT>' , \n '<STR_LIT>' , \n '<STR_LIT>' \n ) \n return DetailResponse ( data = queryset ) \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def role_to_menu ( self , request ) : \n params = request . query_params", "output": "role_id = params . get ( '<STR_LIT>' , None ) \n if role_id is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n queryset = RoleMenuPermission . objects . filter ( role_id = role_id ) . values_list ( '<STR_LIT>' , flat = True ) . distinct ( ) \n return DetailResponse ( data = queryset )"}, {"input": "from dvadmin . system . models import ApiWhiteList \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class ApiWhiteListSerializer ( CustomModelSerializer ) : \n class Meta : \n model = ApiWhiteList", "output": "fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class ApiWhiteListViewSet ( CustomModelViewSet ) : \n queryset = ApiWhiteList . objects . all ( ) \n serializer_class = ApiWhiteListSerializer"}, {"input": "from importlib import import_module \n from django . apps import apps \n from django . db import models \n from django . conf import settings \n from application import settings \n table_prefix = settings . TABLE_PREFIX \n class SoftDeleteQuerySet ( models . QuerySet ) : \n pass \n class SoftDeleteManager ( models . Manager ) : \n def __init__ ( self , * args , ** kwargs ) : \n self . __add_is_del_filter = False \n super ( SoftDeleteManager , self ) . __init__ ( * args , ** kwargs ) \n def filter ( self , * args , ** kwargs ) : \n if not kwargs . get ( '<STR_LIT>' ) is None : \n self . __add_is_del_filter = True \n return super ( SoftDeleteManager , self ) . filter ( * args , ** kwargs ) \n def get_queryset ( self ) : \n if self . __add_is_del_filter : \n return SoftDeleteQuerySet ( self . model , using = self . _db ) . exclude ( is_deleted = False ) \n return SoftDeleteQuerySet ( self . model ) . exclude ( is_deleted = True ) \n def get_by_natural_key ( self , name ) : \n return SoftDeleteQuerySet ( self . model ) . get ( username = name ) \n class SoftDeleteModel ( models . Model ) : \n is_deleted = models . BooleanField ( verbose_name = \"<STR_LIT>\" , help_text = '<STR_LIT>' , default = False , db_index = True ) \n objects = SoftDeleteManager ( ) \n class Meta : \n abstract = True \n verbose_name = '<STR_LIT>' \n verbose_name_plural = verbose_name \n def delete ( self , using = None , soft_delete = True , * args , ** kwargs ) : \n self . is_deleted = True \n self . save ( using = using ) \n class CoreModel ( models . Model ) : \n id = models . BigAutoField ( primary_key = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) \n description = models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" , null = True , blank = True , help_text = \"<STR_LIT>\" ) \n creator = models . ForeignKey ( to = settings . AUTH_USER_MODEL , related_query_name = '<STR_LIT>' , null = True , \n verbose_name = '<STR_LIT>' , help_text = \"<STR_LIT>\" , on_delete = models . SET_NULL , \n db_constraint = False ) \n modifier = models . CharField ( max_length = <NUM_LIT> , null = True , blank = True , help_text = \"<STR_LIT>\" , verbose_name = \"<STR_LIT>\" ) \n dept_belong_id = models . CharField ( max_length = <NUM_LIT> , help_text = \"<STR_LIT>\" , null = True , blank = True , \n verbose_name = \"<STR_LIT>\" ) \n update_datetime = models . DateTimeField ( auto_now = True , null = True , blank = True , help_text = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" ) \n create_datetime = models . DateTimeField ( auto_now_add = True , null = True , blank = True , help_text = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" ) \n class Meta : \n abstract = True \n verbose_name = '<STR_LIT>' \n verbose_name_plural = verbose_name", "output": "def get_all_models_objects ( model_name = None ) : \n settings . ALL_MODELS_OBJECTS = { } \n if not settings . ALL_MODELS_OBJECTS : \n all_models = apps . get_models ( ) \n for item in list ( all_models ) : \n table = { \n \"<STR_LIT>\" : item . _meta . verbose_name , \n \"<STR_LIT>\" : item . __name__ , \n \"<STR_LIT>\" : [ ] \n } \n for field in item . _meta . fields : \n fields = { \n \"<STR_LIT>\" : field . verbose_name , \n \"<STR_LIT>\" : field . name \n } \n table [ '<STR_LIT>' ] . append ( fields ) \n settings . ALL_MODELS_OBJECTS . setdefault ( item . __name__ , { \"<STR_LIT>\" : table , \"<STR_LIT>\" : item } ) \n if model_name : \n return settings . ALL_MODELS_OBJECTS [ model_name ] or { } \n return settings . ALL_MODELS_OBJECTS or { } \n def get_model_from_app ( app_name ) : \n model_module = import_module ( app_name + '<STR_LIT>' ) \n filter_model = [ \n getattr ( model_module , item ) for item in dir ( model_module ) \n if item != '<STR_LIT>' and issubclass ( getattr ( model_module , item ) . __class__ , models . base . ModelBase ) \n ] \n model_list = [ ] \n for model in filter_model : \n if model . __name__ == '<STR_LIT>' : \n continue \n fields = [ \n { '<STR_LIT>' : field . verbose_name , '<STR_LIT>' : field . name , '<STR_LIT>' : field } \n for field in model . _meta . fields \n ] \n model_list . append ( { \n '<STR_LIT>' : app_name , \n '<STR_LIT>' : model . _meta . verbose_name , \n '<STR_LIT>' : model . __name__ , \n '<STR_LIT>' : model , \n '<STR_LIT>' : fields \n } ) \n return model_list \n def get_custom_app_models ( app_name = None ) : \n if app_name : \n return get_model_from_app ( app_name ) \n all_apps = apps . get_app_configs ( ) \n res = [ ] \n for app in all_apps : \n if app . name . startswith ( '<STR_LIT>' ) : \n continue \n if app . name in settings . COLUMN_EXCLUDE_APPS : \n continue \n try : \n all_models = get_model_from_app ( app . name ) \n if all_models : \n for model in all_models : \n res . append ( model ) \n except Exception as e : \n pass \n return res"}, {"input": "import hashlib \n import random \n CHAR_SET = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \n \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ,", "output": "\"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \n \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n def random_str ( number = <NUM_LIT> ) : \n result = \"<STR_LIT>\" \n for i in range ( <NUM_LIT> , number ) : \n inx = random . randint ( <NUM_LIT> , len ( CHAR_SET ) - <NUM_LIT> ) \n result += CHAR_SET [ inx ] \n return result \n def has_md5 ( str , salt = '<STR_LIT>' ) : \n str = str + salt \n md = hashlib . md5 ( ) \n md . update ( str . encode ( ) ) \n res = md . hexdigest ( ) \n return res"}, {"input": "from rest_framework import serializers \n from rest_framework . views import APIView \n from application import dispatch \n from dvadmin . system . models import Dictionary \n from dvadmin . utils . json_response import SuccessResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class DictionarySerializer ( CustomModelSerializer ) : \n class Meta : \n model = Dictionary \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class DictionaryCreateUpdateSerializer ( CustomModelSerializer ) : \n value = serializers . CharField ( max_length = <NUM_LIT> ) \n def validate_value ( self , value ) : \n initial_data = self . initial_data \n parent = initial_data . get ( '<STR_LIT>' , None ) \n if parent is None : \n unique = Dictionary . objects . filter ( value = value ) . exists ( )", "output": "if unique : \n raise serializers . ValidationError ( \"<STR_LIT>\" ) \n return value \n class Meta : \n model = Dictionary \n fields = '<STR_LIT>' \n class DictionaryViewSet ( CustomModelViewSet ) : \n queryset = Dictionary . objects . all ( ) \n serializer_class = DictionarySerializer \n create_serializer_class = DictionaryCreateUpdateSerializer \n extra_filter_class = [ ] \n search_fields = [ '<STR_LIT>' ] \n def get_queryset ( self ) : \n if self . action == '<STR_LIT>' : \n params = self . request . query_params \n parent = params . get ( '<STR_LIT>' , None ) \n if params : \n if parent : \n queryset = self . queryset . filter ( parent = parent ) \n else : \n queryset = self . queryset . filter ( parent__isnull = True ) \n else : \n queryset = self . queryset . filter ( parent__isnull = True ) \n return queryset \n else : \n return self . queryset \n class InitDictionaryViewSet ( APIView ) : \n authentication_classes = [ ] \n permission_classes = [ ] \n queryset = Dictionary . objects . all ( ) \n def get ( self , request ) : \n dictionary_key = self . request . query_params . get ( '<STR_LIT>' ) \n if dictionary_key : \n if dictionary_key == '<STR_LIT>' : \n data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] \n if not data : \n dispatch . refresh_dictionary ( ) \n data = [ ele for ele in dispatch . get_dictionary_config ( ) . values ( ) ] \n else : \n data = self . queryset . filter ( parent__value = dictionary_key , status = True ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , \n '<STR_LIT>' ) \n return SuccessResponse ( data = data , msg = \"<STR_LIT>\" ) \n return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" )"}, {"input": "import hashlib \n import mimetypes \n from rest_framework import serializers \n from rest_framework . decorators import action \n from application import dispatch \n from dvadmin . system . models import FileList \n from dvadmin . utils . json_response import DetailResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class FileSerializer ( CustomModelSerializer ) : \n url = serializers . SerializerMethodField ( read_only = True ) \n def get_url ( self , instance ) : \n return instance . file_url or ( f'<STR_LIT>' ) \n class Meta : \n model = FileList \n fields = \"<STR_LIT>\" \n def create ( self , validated_data ) : \n file_engine = dispatch . get_system_config_values ( \"<STR_LIT>\" ) or '<STR_LIT>' \n file_backup = dispatch . get_system_config_values ( \"<STR_LIT>\" ) \n file = self . initial_data . get ( '<STR_LIT>' ) \n file_size = file . size \n validated_data [ '<STR_LIT>' ] = str ( file ) \n validated_data [ '<STR_LIT>' ] = file_size \n md5 = hashlib . md5 ( ) \n for chunk in file . chunks ( ) : \n md5 . update ( chunk ) \n validated_data [ '<STR_LIT>' ] = md5 . hexdigest ( ) \n validated_data [ '<STR_LIT>' ] = file_engine \n validated_data [ '<STR_LIT>' ] = file . content_type \n if file_backup : \n validated_data [ '<STR_LIT>' ] = file \n if file_engine == '<STR_LIT>' :", "output": "from dvadmin_cloud_storage . views . aliyun import ali_oss_upload \n file_path = ali_oss_upload ( file ) \n if file_path : \n validated_data [ '<STR_LIT>' ] = file_path \n else : \n raise ValueError ( \"<STR_LIT>\" ) \n elif file_engine == '<STR_LIT>' : \n from dvadmin_cloud_storage . views . tencent import tencent_cos_upload \n file_path = tencent_cos_upload ( file ) \n if file_path : \n validated_data [ '<STR_LIT>' ] = file_path \n else : \n raise ValueError ( \"<STR_LIT>\" ) \n else : \n validated_data [ '<STR_LIT>' ] = file \n try : \n request_user = self . request . user \n validated_data [ '<STR_LIT>' ] = request_user . dept . id \n validated_data [ '<STR_LIT>' ] = request_user . id \n validated_data [ '<STR_LIT>' ] = request_user . id \n except : \n pass \n return super ( ) . create ( validated_data ) \n class FileViewSet ( CustomModelViewSet ) : \n queryset = FileList . objects . all ( ) \n serializer_class = FileSerializer \n filter_fields = [ '<STR_LIT>' , ] \n permission_classes = [ ]"}, {"input": "from django . db . models import F \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import MenuButton , RoleMenuButtonPermission \n from dvadmin . utils . json_response import DetailResponse , SuccessResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class MenuButtonSerializer ( CustomModelSerializer ) : \n class Meta : \n model = MenuButton \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n read_only_fields = [ \"<STR_LIT>\" ] \n class MenuButtonCreateUpdateSerializer ( CustomModelSerializer ) : \n class Meta : \n model = MenuButton", "output": "fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class MenuButtonViewSet ( CustomModelViewSet ) : \n queryset = MenuButton . objects . order_by ( '<STR_LIT>' ) \n serializer_class = MenuButtonSerializer \n create_serializer_class = MenuButtonCreateUpdateSerializer \n update_serializer_class = MenuButtonCreateUpdateSerializer \n extra_filter_class = [ ] \n def list ( self , request , * args , ** kwargs ) : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) . order_by ( '<STR_LIT>' ) \n serializer = self . get_serializer ( queryset , many = True , request = request ) \n return SuccessResponse ( serializer . data , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def menu_button_all_permission ( self , request ) : \n is_superuser = request . user . is_superuser \n if is_superuser : \n queryset = MenuButton . objects . values_list ( '<STR_LIT>' , flat = True ) \n else : \n role_id = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n queryset = RoleMenuButtonPermission . objects . filter ( role__in = role_id ) . values_list ( '<STR_LIT>' , flat = True ) . distinct ( ) \n return DetailResponse ( data = queryset )"}, {"input": "import logging \n import traceback \n from django . db . models import ProtectedError \n from django . http import Http404 \n from rest_framework . exceptions import APIException as DRFAPIException , AuthenticationFailed , NotAuthenticated \n from rest_framework . status import HTTP_401_UNAUTHORIZED \n from rest_framework . views import set_rollback , exception_handler \n from dvadmin . utils . json_response import ErrorResponse", "output": "logger = logging . getLogger ( __name__ ) \n class CustomAuthenticationFailed ( NotAuthenticated ) : \n status_code = <NUM_LIT> \n def CustomExceptionHandler ( ex , context ) : \n msg = '<STR_LIT>' \n code = <NUM_LIT> \n response = exception_handler ( ex , context ) \n if isinstance ( ex , AuthenticationFailed ) : \n if response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : \n code = <NUM_LIT> \n msg = ex . detail \n elif response and response . data . get ( '<STR_LIT>' ) == \"<STR_LIT>\" : \n return ErrorResponse ( status = HTTP_401_UNAUTHORIZED ) \n else : \n code = <NUM_LIT> \n msg = ex . detail \n elif isinstance ( ex , Http404 ) : \n code = <NUM_LIT> \n msg = \"<STR_LIT>\" \n elif isinstance ( ex , DRFAPIException ) : \n set_rollback ( ) \n msg = ex . detail \n if isinstance ( msg , dict ) : \n for k , v in msg . items ( ) : \n for i in v : \n msg = \"<STR_LIT>\" % ( k , i ) \n elif isinstance ( ex , ProtectedError ) : \n set_rollback ( ) \n msg = \"<STR_LIT>\" \n elif isinstance ( ex , Exception ) : \n logger . exception ( traceback . format_exc ( ) ) \n msg = str ( ex ) \n return ErrorResponse ( msg = msg , code = code )"}, {"input": "import functools \n import os \n os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' )", "output": "from django . conf import settings \n from celery import platforms \n if \"<STR_LIT>\" in settings . INSTALLED_APPS : \n from tenant_schemas_celery . app import CeleryApp as TenantAwareCeleryApp \n app = TenantAwareCeleryApp ( ) \n else : \n from celery import Celery \n app = Celery ( f\"<STR_LIT>\" ) \n app . config_from_object ( '<STR_LIT>' ) \n app . autodiscover_tasks ( lambda : settings . INSTALLED_APPS ) \n platforms . C_FORCE_ROOT = True \n def retry_base_task_error ( ) : \n def wraps ( func ) : \n @ app . task ( bind = True , retry_delay = <NUM_LIT> , max_retries = <NUM_LIT> ) \n @ functools . wraps ( func ) \n def wrapper ( self , * args , ** kwargs ) : \n try : \n return func ( * args , ** kwargs ) \n except Exception as exc : \n raise self . retry ( exc = exc ) \n return wrapper \n return wraps"}, {"input": "import os \n import sys \n from pathlib import Path \n from datetime import timedelta \n BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent \n from conf . env import * \n SECRET_KEY = \"<STR_LIT>\" \n PLUGINS_PATH = os . path . join ( BASE_DIR , \"<STR_LIT>\" ) \n sys . path . insert ( <NUM_LIT> , os . path . join ( PLUGINS_PATH ) ) \n [ \n sys . path . insert ( <NUM_LIT> , os . path . join ( PLUGINS_PATH , ele ) ) \n for ele in os . listdir ( PLUGINS_PATH ) \n if os . path . isdir ( os . path . join ( PLUGINS_PATH , ele ) ) and not ele . startswith ( \"<STR_LIT>\" ) \n ] \n DEBUG = locals ( ) . get ( \"<STR_LIT>\" , True ) \n ALLOWED_HOSTS = locals ( ) . get ( \"<STR_LIT>\" , [ \"<STR_LIT>\" ] ) \n COLUMN_EXCLUDE_APPS = [ '<STR_LIT>' , '<STR_LIT>' ] + locals ( ) . get ( \"<STR_LIT>\" , [ ] ) \n INSTALLED_APPS = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n MIDDLEWARE = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n ROOT_URLCONF = \"<STR_LIT>\" \n TEMPLATES = [ \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : [ os . path . join ( BASE_DIR , \"<STR_LIT>\" ) ] , \n \"<STR_LIT>\" : True , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] , \n } , \n } , \n ] \n WSGI_APPLICATION = \"<STR_LIT>\" \n DATABASES = { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : DATABASE_ENGINE , \n \"<STR_LIT>\" : DATABASE_NAME , \n \"<STR_LIT>\" : DATABASE_USER , \n \"<STR_LIT>\" : DATABASE_PASSWORD , \n \"<STR_LIT>\" : DATABASE_HOST , \n \"<STR_LIT>\" : DATABASE_PORT , \n } \n } \n AUTH_USER_MODEL = \"<STR_LIT>\" \n USERNAME_FIELD = \"<STR_LIT>\" \n AUTH_PASSWORD_VALIDATORS = [ \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n ] \n LANGUAGE_CODE = \"<STR_LIT>\" \n TIME_ZONE = \"<STR_LIT>\" \n USE_I18N = True \n USE_L10N = True \n USE_TZ = False \n STATIC_URL = \"<STR_LIT>\" \n STATICFILES_DIRS = [ \n os . path . join ( BASE_DIR , \"<STR_LIT>\" ) , \n ] \n MEDIA_ROOT = \"<STR_LIT>\" \n MEDIA_URL = \"<STR_LIT>\" \n STATICFILES_FINDERS = ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" \n ) \n CORS_ORIGIN_ALLOW_ALL = True \n CORS_ALLOW_CREDENTIALS = True \n ASGI_APPLICATION = '<STR_LIT>' \n CHANNEL_LAYERS = { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" \n } \n } \n SERVER_LOGS_FILE = os . path . join ( BASE_DIR , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n ERROR_LOGS_FILE = os . path . join ( BASE_DIR , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n LOGS_FILE = os . path . join ( BASE_DIR , \"<STR_LIT>\" ) \n if not os . path . exists ( os . path . join ( BASE_DIR , \"<STR_LIT>\" ) ) : \n os . makedirs ( os . path . join ( BASE_DIR , \"<STR_LIT>\" ) ) \n STANDARD_LOG_FORMAT = ( \n \"<STR_LIT>\" \n ) \n CONSOLE_LOG_FORMAT = ( \n \"<STR_LIT>\" \n ) \n LOGGING = { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : False , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : STANDARD_LOG_FORMAT } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : CONSOLE_LOG_FORMAT , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : CONSOLE_LOG_FORMAT , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : SERVER_LOGS_FILE , \n \"<STR_LIT>\" : <NUM_LIT> * <NUM_LIT> * <NUM_LIT> , \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : ERROR_LOGS_FILE , \n \"<STR_LIT>\" : <NUM_LIT> * <NUM_LIT> * <NUM_LIT> , \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : \"<STR_LIT>\" ,", "output": "} , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : False , \n } , \n '<STR_LIT>' : { \n '<STR_LIT>' : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n '<STR_LIT>' : False , \n '<STR_LIT>' : \"<STR_LIT>\" \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n } , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : \"<STR_LIT>\" \n } , \n } , \n } \n REST_FRAMEWORK = { \n '<STR_LIT>' : ( \n '<STR_LIT>' , \n '<STR_LIT>' , \n ) , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ) , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ) , \n \"<STR_LIT>\" : [ \n \"<STR_LIT>\" , \n ] , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n AUTHENTICATION_BACKENDS = [ \"<STR_LIT>\" ] \n SIMPLE_JWT = { \n \"<STR_LIT>\" : timedelta ( minutes = <NUM_LIT> ) , \n \"<STR_LIT>\" : timedelta ( days = <NUM_LIT> ) , \n \"<STR_LIT>\" : ( \"<STR_LIT>\" , ) , \n \"<STR_LIT>\" : True , \n } \n SWAGGER_SETTINGS = { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : { \"<STR_LIT>\" : \"<STR_LIT>\" } } , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : True , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : None , \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n CAPTCHA_IMAGE_SIZE = ( <NUM_LIT> , <NUM_LIT> ) \n CAPTCHA_LENGTH = <NUM_LIT> \n CAPTCHA_TIMEOUT = <NUM_LIT> \n CAPTCHA_OUTPUT_FORMAT = \"<STR_LIT>\" \n CAPTCHA_FONT_SIZE = <NUM_LIT> \n CAPTCHA_FOREGROUND_COLOR = \"<STR_LIT>\" \n CAPTCHA_BACKGROUND_COLOR = \"<STR_LIT>\" \n CAPTCHA_NOISE_FUNCTIONS = ( \n \"<STR_LIT>\" , \n ) \n CAPTCHA_CHALLENGE_FUNCT = \"<STR_LIT>\" \n DEFAULT_AUTO_FIELD = \"<STR_LIT>\" \n API_LOG_ENABLE = True \n API_LOG_METHODS = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n API_MODEL_MAP = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n DJANGO_CELERY_BEAT_TZ_AWARE = False \n CELERY_TIMEZONE = \"<STR_LIT>\" \n STATICFILES_STORAGE = \"<STR_LIT>\" \n ALL_MODELS_OBJECTS = [ ] \n INITIALIZE_LIST = [ ] \n INITIALIZE_RESET_LIST = [ ] \n TABLE_PREFIX = locals ( ) . get ( '<STR_LIT>' , \"<STR_LIT>\" ) \n SYSTEM_CONFIG = { } \n DICTIONARY_CONFIG = { } \n TENANT_SHARED_APPS = [ ] \n PLUGINS_URL_PATTERNS = [ ]"}, {"input": "import django_filters \n from django . db . models import Q \n from django_filters . rest_framework import BooleanFilter \n from rest_framework import serializers \n from rest_framework . views import APIView \n from application import dispatch \n from dvadmin . system . models import SystemConfig \n from dvadmin . utils . json_response import DetailResponse , SuccessResponse , ErrorResponse \n from dvadmin . utils . models import get_all_models_objects \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . validator import CustomValidationError \n from dvadmin . utils . viewset import CustomModelViewSet \n class SystemConfigCreateSerializer ( CustomModelSerializer ) : \n form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) \n class Meta : \n model = SystemConfig \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n def validate_key ( self , value ) : \n instance = SystemConfig . objects . filter ( key = value , parent__isnull = True ) . exists ( ) \n if instance : \n raise CustomValidationError ( '<STR_LIT>' ) \n return value \n class SystemConfigSerializer ( CustomModelSerializer ) : \n form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) \n class Meta : \n model = SystemConfig \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class SystemConfigChinldernSerializer ( CustomModelSerializer ) : \n children = serializers . SerializerMethodField ( ) \n form_item_type_label = serializers . CharField ( source = '<STR_LIT>' , read_only = True ) \n def get_children ( self , instance ) : \n queryset = SystemConfig . objects . filter ( parent = instance ) \n serializer = SystemConfigSerializer ( queryset , many = True ) \n return serializer . data \n class Meta : \n model = SystemConfig \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class SystemConfigListSerializer ( CustomModelSerializer ) : \n def update ( self , instance , validated_data ) : \n instance_mapping = { obj . id : obj for obj in instance } \n data_mapping = { item [ '<STR_LIT>' ] : item for item in validated_data } \n for obj_id , data in data_mapping . items ( ) : \n instance_obj = instance_mapping . get ( obj_id , None ) \n if instance_obj is None : \n return SystemConfig . objects . create ( ** data ) \n else : \n return instance_obj . objects . update ( ** data ) \n class Meta : \n model = SystemConfig \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class SystemConfigSaveSerializer ( serializers . Serializer ) : \n class Meta : \n read_only_fields = [ \"<STR_LIT>\" ] \n list_serializer_class = SystemConfigListSerializer \n class SystemConfigFilter ( django_filters . rest_framework . FilterSet ) : \n parent__isnull = BooleanFilter ( field_name = '<STR_LIT>' , lookup_expr = \"<STR_LIT>\" ) \n class Meta : \n model = SystemConfig \n fields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] \n class SystemConfigViewSet ( CustomModelViewSet ) : \n queryset = SystemConfig . objects . order_by ( '<STR_LIT>' , '<STR_LIT>' ) \n serializer_class = SystemConfigChinldernSerializer \n create_serializer_class = SystemConfigCreateSerializer \n retrieve_serializer_class = SystemConfigChinldernSerializer \n filter_class = SystemConfigFilter \n def save_content ( self , request ) : \n body = request . data \n data_mapping = { item [ '<STR_LIT>' ] : item for item in body } \n for obj_id , data in data_mapping . items ( ) : \n instance_obj = SystemConfig . objects . filter ( id = obj_id ) . first ( ) \n if instance_obj is None : \n serializer = SystemConfigCreateSerializer ( data = data ) \n else : \n serializer = SystemConfigCreateSerializer ( instance_obj , data = data ) \n if serializer . is_valid ( raise_exception = True ) : \n serializer . save ( )", "output": "return DetailResponse ( msg = \"<STR_LIT>\" ) \n def get_association_table ( self , request ) : \n res = [ ele . get ( '<STR_LIT>' ) for ele in get_all_models_objects ( ) . values ( ) ] \n return DetailResponse ( msg = \"<STR_LIT>\" , data = res ) \n def get_table_data ( self , request , pk ) : \n instance = SystemConfig . objects . filter ( id = pk ) . first ( ) \n if instance is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n setting = instance . setting \n if setting is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n table = setting . get ( '<STR_LIT>' ) \n model = get_all_models_objects ( table ) . get ( \"<STR_LIT>\" , { } ) \n queryset = model . objects . values ( ) \n body = request . query_params \n search_value = body . get ( '<STR_LIT>' , None ) \n if search_value : \n search_fields = setting . get ( '<STR_LIT>' ) \n filters = Q ( ) \n filters . connector = '<STR_LIT>' \n for item in search_fields : \n filed = '<STR_LIT>' . format ( item . get ( '<STR_LIT>' ) ) \n filters . children . append ( ( filed , search_value ) ) \n queryset = model . objects . filter ( filters ) . values ( ) \n page = self . paginate_queryset ( queryset ) \n if page is not None : \n return self . get_paginated_response ( queryset ) \n return SuccessResponse ( msg = \"<STR_LIT>\" , data = queryset , total = len ( queryset ) ) \n def get_relation_info ( self , request ) : \n body = request . query_params \n var_name = body . get ( '<STR_LIT>' , None ) \n table = body . get ( '<STR_LIT>' , None ) \n instance = SystemConfig . objects . filter ( key = var_name , setting__table = table ) . first ( ) \n if instance is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n relation_id = body . get ( '<STR_LIT>' , None ) \n relationIds = [ ] \n if relation_id is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n if instance . form_item_type in [ <NUM_LIT> ] : \n relationIds = [ relation_id ] \n elif instance . form_item_type in [ <NUM_LIT> ] : \n relationIds = relation_id . split ( '<STR_LIT>' ) \n queryset = SystemConfig . objects . filter ( value__in = relationIds ) . first ( ) \n if queryset is None : \n return ErrorResponse ( msg = \"<STR_LIT>\" ) \n serializer = SystemConfigChinldernSerializer ( queryset . parent ) \n return DetailResponse ( msg = \"<STR_LIT>\" , data = serializer . data ) \n class InitSettingsViewSet ( APIView ) : \n authentication_classes = [ ] \n permission_classes = [ ] \n def filter_system_config_values ( self , data : dict ) : \n if not self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) : \n return data \n new_data = { } \n for key in self . request . query_params . get ( '<STR_LIT>' , '<STR_LIT>' ) . split ( '<STR_LIT>' ) : \n if key : \n new_data . update ( ** dict ( filter ( lambda x : x [ <NUM_LIT> ] . startswith ( key ) , data . items ( ) ) ) ) \n return new_data \n def get ( self , request ) : \n data = dispatch . get_system_config ( ) \n if not data : \n dispatch . refresh_system_config ( ) \n data = dispatch . get_system_config ( ) \n backend_config = [ f\"<STR_LIT>\" for ele in \n SystemConfig . objects . filter ( status = False , parent_id__isnull = False ) . values ( '<STR_LIT>' , \n '<STR_LIT>' ) ] \n data = dict ( filter ( lambda x : x [ <NUM_LIT> ] not in backend_config , data . items ( ) ) ) \n data = self . filter_system_config_values ( data = data ) \n return DetailResponse ( data = data )"}, {"input": "from rest_framework . views import APIView \n from django . shortcuts import render \n class PrivacyView ( APIView ) : \n permission_classes = [ ] \n def get ( self , request , * args , ** kwargs ) : \n return render ( request , '<STR_LIT>' ) \n class TermsServiceView ( APIView ) :", "output": "permission_classes = [ ] \n def get ( self , request , * args , ** kwargs ) : \n return render ( request , '<STR_LIT>' )"}, {"input": "from drf_yasg . generators import OpenAPISchemaGenerator \n from drf_yasg . inspectors import SwaggerAutoSchema \n from application . settings import SWAGGER_SETTINGS", "output": "def get_summary ( string ) : \n if string is not None : \n result = string . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . split ( \"<STR_LIT>\" ) \n return result [ <NUM_LIT> ] \n class CustomSwaggerAutoSchema ( SwaggerAutoSchema ) : \n def get_tags ( self , operation_keys = None ) : \n tags = super ( ) . get_tags ( operation_keys ) \n if \"<STR_LIT>\" in tags and operation_keys : \n tags [ <NUM_LIT> ] = operation_keys [ SWAGGER_SETTINGS . get ( '<STR_LIT>' , <NUM_LIT> ) ] \n return tags \n def get_summary_and_description ( self ) : \n summary_and_description = super ( ) . get_summary_and_description ( ) \n summary = get_summary ( self . __dict__ . get ( '<STR_LIT>' ) . __doc__ ) \n description = summary_and_description [ <NUM_LIT> ] \n return summary , description \n class CustomOpenAPISchemaGenerator ( OpenAPISchemaGenerator ) : \n def get_schema ( self , request = None , public = False ) : \n swagger = super ( ) . get_schema ( request , public ) \n swagger . tags = [ \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" \n } , \n ] \n return swagger"}, {"input": "import os \n from channels . auth import AuthMiddlewareStack \n from channels . security . websocket import AllowedHostsOriginValidator \n from channels . routing import ProtocolTypeRouter , URLRouter \n from django . core . asgi import get_asgi_application \n os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' ) \n os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" \n http_application = get_asgi_application ( ) \n from application . routing import websocket_urlpatterns \n application = ProtocolTypeRouter ( { \n \"<STR_LIT>\" : http_application , \n '<STR_LIT>' : AllowedHostsOriginValidator ( \n AuthMiddlewareStack ( \n URLRouter ( \n websocket_urlpatterns \n ) \n )", "output": ") , \n } )"}, {"input": "import json \n import requests \n from django . conf import settings \n from django . contrib . auth . models import AbstractBaseUser \n from django . contrib . auth . models import AnonymousUser \n from django . urls . resolvers import ResolverMatch \n from rest_framework_simplejwt . authentication import JWTAuthentication \n from user_agents import parse \n from dvadmin . system . models import LoginLog \n def get_request_user ( request ) : \n user : AbstractBaseUser = getattr ( request , '<STR_LIT>' , None ) \n if user and user . is_authenticated : \n return user \n try : \n user , tokrn = JWTAuthentication ( ) . authenticate ( request ) \n except Exception as e : \n pass \n return user or AnonymousUser ( ) \n def get_request_ip ( request ) : \n x_forwarded_for = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) \n if x_forwarded_for : \n ip = x_forwarded_for . split ( '<STR_LIT>' ) [ - <NUM_LIT> ] . strip ( ) \n return ip \n ip = request . META . get ( '<STR_LIT>' , '<STR_LIT>' ) or getattr ( request , '<STR_LIT>' , None ) \n return ip or '<STR_LIT>' \n def get_request_data ( request ) : \n request_data = getattr ( request , '<STR_LIT>' , None ) \n if request_data : \n return request_data \n data : dict = { ** request . GET . dict ( ) , ** request . POST . dict ( ) } \n if not data : \n try : \n body = request . body \n if body : \n data = json . loads ( body ) \n except Exception as e : \n pass \n if not isinstance ( data , dict ) : \n data = { '<STR_LIT>' : data } \n return data \n def get_request_path ( request , * args , ** kwargs ) : \n request_path = getattr ( request , '<STR_LIT>' , None ) \n if request_path : \n return request_path \n values = [ ] \n for arg in args : \n if len ( arg ) == <NUM_LIT> : \n continue \n if isinstance ( arg , str ) : \n values . append ( arg ) \n elif isinstance ( arg , ( tuple , set , list ) ) : \n values . extend ( arg ) \n elif isinstance ( arg , dict ) : \n values . extend ( arg . values ( ) ) \n if len ( values ) == <NUM_LIT> : \n return request . path \n path : str = request . path \n for value in values : \n path = path . replace ( '<STR_LIT>' + value , '<STR_LIT>' + '<STR_LIT>' ) \n return path \n def get_request_canonical_path ( request , ) : \n request_path = getattr ( request , '<STR_LIT>' , None ) \n if request_path : \n return request_path \n path : str = request . path \n resolver_match : ResolverMatch = request . resolver_match \n for value in resolver_match . args : \n path = path . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) \n for key , value in resolver_match . kwargs . items ( ) : \n if key == '<STR_LIT>' : \n path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) \n continue \n path = path . replace ( f\"<STR_LIT>\" , f\"<STR_LIT>\" ) \n return path \n def get_browser ( request , ) : \n ua_string = request . META [ '<STR_LIT>' ] \n user_agent = parse ( ua_string ) \n return user_agent . get_browser ( ) \n def get_os ( request , ) : \n ua_string = request . META [ '<STR_LIT>' ] \n user_agent = parse ( ua_string ) \n return user_agent . get_os ( ) \n def get_verbose_name ( queryset = None , view = None , model = None ) : \n try : \n if queryset is not None and hasattr ( queryset , '<STR_LIT>' ) : \n model = queryset . model \n elif view and hasattr ( view . get_queryset ( ) , '<STR_LIT>' ) : \n model = view . get_queryset ( ) . model \n elif view and hasattr ( view . get_serializer ( ) , '<STR_LIT>' ) and hasattr ( view . get_serializer ( ) . Meta , '<STR_LIT>' ) :", "output": "model = view . get_serializer ( ) . Meta . model \n if model : \n return getattr ( model , '<STR_LIT>' ) . verbose_name \n else : \n model = queryset . model . _meta . verbose_name \n except Exception as e : \n pass \n return model if model else \"<STR_LIT>\" \n def get_ip_analysis ( ip ) : \n data = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" \n } \n if ip != '<STR_LIT>' and ip : \n if getattr ( settings , '<STR_LIT>' , True ) : \n try : \n res = requests . get ( url = '<STR_LIT>' , params = { \"<STR_LIT>\" : ip } , timeout = <NUM_LIT> ) \n if res . status_code == <NUM_LIT> : \n res_data = res . json ( ) \n if res_data . get ( '<STR_LIT>' ) == <NUM_LIT> : \n data = res_data . get ( '<STR_LIT>' ) \n return data \n except Exception as e : \n print ( e ) \n return data \n def save_login_log ( request ) : \n ip = get_request_ip ( request = request ) \n analysis_data = get_ip_analysis ( ip ) \n analysis_data [ '<STR_LIT>' ] = request . user . username \n analysis_data [ '<STR_LIT>' ] = ip \n analysis_data [ '<STR_LIT>' ] = str ( parse ( request . META [ '<STR_LIT>' ] ) ) \n analysis_data [ '<STR_LIT>' ] = get_browser ( request ) \n analysis_data [ '<STR_LIT>' ] = get_os ( request ) \n analysis_data [ '<STR_LIT>' ] = request . user . id \n analysis_data [ '<STR_LIT>' ] = getattr ( request . user , '<STR_LIT>' , '<STR_LIT>' ) \n LoginLog . objects . create ( ** analysis_data )"}, {"input": "from dvadmin . system . models import OperationLog \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class OperationLogSerializer ( CustomModelSerializer ) : \n class Meta : \n model = OperationLog", "output": "fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class OperationLogCreateUpdateSerializer ( CustomModelSerializer ) : \n class Meta : \n model = OperationLog \n fields = '<STR_LIT>' \n class OperationLogViewSet ( CustomModelViewSet ) : \n queryset = OperationLog . objects . order_by ( '<STR_LIT>' ) \n serializer_class = OperationLogSerializer"}, {"input": "from django . conf . urls . static import static \n from django . urls import path , include , re_path \n from drf_yasg import openapi \n from drf_yasg . views import get_schema_view \n from rest_framework import permissions \n from rest_framework_simplejwt . views import ( \n TokenRefreshView , \n ) \n from application import dispatch \n from application import settings \n from dvadmin . system . views . dictionary import InitDictionaryViewSet \n from dvadmin . system . views . login import ( \n LoginView , \n CaptchaView , \n ApiLogin , \n LogoutView , \n LoginTokenView \n ) \n from dvadmin . system . views . system_config import InitSettingsViewSet \n from dvadmin . utils . swagger import CustomOpenAPISchemaGenerator \n dispatch . init_system_config ( ) \n dispatch . init_dictionary ( ) \n schema_view = get_schema_view ( \n openapi . Info ( \n title = \"<STR_LIT>\" , \n default_version = \"<STR_LIT>\" , \n description = \"<STR_LIT>\" , \n terms_of_service = \"<STR_LIT>\" , \n contact = openapi . Contact ( email = \"<STR_LIT>\" ) , \n license = openapi . License ( name = \"<STR_LIT>\" ) , \n ) , \n public = True , \n permission_classes = ( permissions . AllowAny , ) , \n generator_class = CustomOpenAPISchemaGenerator , \n ) \n urlpatterns = ( \n [ \n re_path ( \n r\"<STR_LIT>\" , \n schema_view . without_ui ( cache_timeout = <NUM_LIT> ) , \n name = \"<STR_LIT>\" , \n ) , \n path ( \n \"<STR_LIT>\" , \n schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , \n name = \"<STR_LIT>\" , \n ) , \n path ( \n r\"<STR_LIT>\" , \n schema_view . with_ui ( \"<STR_LIT>\" , cache_timeout = <NUM_LIT> ) , \n name = \"<STR_LIT>\" , \n ) , \n path ( \"<STR_LIT>\" , include ( \"<STR_LIT>\" ) ) , \n path ( \"<STR_LIT>\" , LoginView . as_view ( ) , name = \"<STR_LIT>\" ) , \n path ( \"<STR_LIT>\" , LogoutView . as_view ( ) , name = \"<STR_LIT>\" ) , \n path ( \"<STR_LIT>\" , TokenRefreshView . as_view ( ) , name = \"<STR_LIT>\" ) , \n re_path ( \n r\"<STR_LIT>\" , include ( \"<STR_LIT>\" , namespace = \"<STR_LIT>\" ) \n ) , \n path ( \"<STR_LIT>\" , CaptchaView . as_view ( ) ) , \n path ( \"<STR_LIT>\" , InitDictionaryViewSet . as_view ( ) ) , \n path ( \"<STR_LIT>\" , InitSettingsViewSet . as_view ( ) ) , \n path ( \"<STR_LIT>\" , ApiLogin . as_view ( ) ) , \n path ( \"<STR_LIT>\" , LoginTokenView . as_view ( ) ) , \n ] \n + static ( settings . MEDIA_URL , document_root = settings . MEDIA_ROOT ) \n + static ( settings . STATIC_URL , document_root = settings . STATIC_URL )", "output": "+ [ re_path ( ele . get ( '<STR_LIT>' ) , include ( ele . get ( '<STR_LIT>' ) ) ) for ele in settings . PLUGINS_URL_PATTERNS ] \n )"}, {"input": "from django . urls import path \n from rest_framework import routers \n from dvadmin . system . views . api_white_list import ApiWhiteListViewSet \n from dvadmin . system . views . area import AreaViewSet \n from dvadmin . system . views . clause import PrivacyView , TermsServiceView \n from dvadmin . system . views . dept import DeptViewSet \n from dvadmin . system . views . dictionary import DictionaryViewSet \n from dvadmin . system . views . file_list import FileViewSet \n from dvadmin . system . views . login_log import LoginLogViewSet \n from dvadmin . system . views . menu import MenuViewSet \n from dvadmin . system . views . menu_button import MenuButtonViewSet \n from dvadmin . system . views . message_center import MessageCenterViewSet \n from dvadmin . system . views . operation_log import OperationLogViewSet \n from dvadmin . system . views . role import RoleViewSet \n from dvadmin . system . views . role_menu import RoleMenuPermissionViewSet \n from dvadmin . system . views . role_menu_button_permission import RoleMenuButtonPermissionViewSet \n from dvadmin . system . views . system_config import SystemConfigViewSet \n from dvadmin . system . views . user import UserViewSet \n from dvadmin . system . views . menu_field import MenuFieldViewSet \n system_url = routers . SimpleRouter ( ) \n system_url . register ( r'<STR_LIT>' , MenuViewSet ) \n system_url . register ( r'<STR_LIT>' , MenuButtonViewSet ) \n system_url . register ( r'<STR_LIT>' , RoleViewSet ) \n system_url . register ( r'<STR_LIT>' , DeptViewSet ) \n system_url . register ( r'<STR_LIT>' , UserViewSet ) \n system_url . register ( r'<STR_LIT>' , OperationLogViewSet ) \n system_url . register ( r'<STR_LIT>' , DictionaryViewSet ) \n system_url . register ( r'<STR_LIT>' , AreaViewSet ) \n system_url . register ( r'<STR_LIT>' , FileViewSet ) \n system_url . register ( r'<STR_LIT>' , ApiWhiteListViewSet ) \n system_url . register ( r'<STR_LIT>' , SystemConfigViewSet ) \n system_url . register ( r'<STR_LIT>' , MessageCenterViewSet ) \n system_url . register ( r'<STR_LIT>' , RoleMenuButtonPermissionViewSet ) \n system_url . register ( r'<STR_LIT>' , RoleMenuPermissionViewSet ) \n system_url . register ( r'<STR_LIT>' , MenuFieldViewSet ) \n urlpatterns = [ \n path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , } ) ) , \n path ( '<STR_LIT>' , UserViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) ,", "output": "path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , SystemConfigViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , LoginLogViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , DeptViewSet . as_view ( { '<STR_LIT>' : '<STR_LIT>' } ) ) , \n path ( '<STR_LIT>' , PrivacyView . as_view ( ) ) , \n path ( '<STR_LIT>' , TermsServiceView . as_view ( ) ) , \n ] \n urlpatterns += system_url . urls"}, {"input": "from django . db import transaction \n from django_filters import DateTimeFromToRangeFilter \n from django_filters . rest_framework import FilterSet \n from drf_yasg import openapi \n from drf_yasg . utils import swagger_auto_schema \n from rest_framework . decorators import action \n from rest_framework . viewsets import ModelViewSet \n from dvadmin . utils . filters import DataLevelPermissionsFilter , CoreModelFilterBankend \n from dvadmin . utils . import_export_mixin import ExportSerializerMixin , ImportSerializerMixin \n from dvadmin . utils . json_response import SuccessResponse , ErrorResponse , DetailResponse \n from dvadmin . utils . permission import CustomPermission \n from dvadmin . utils . models import get_custom_app_models , CoreModel \n from dvadmin . system . models import FieldPermission , MenuField \n from django_restql . mixins import QueryArgumentsMixin \n class CustomModelViewSet ( ModelViewSet , ImportSerializerMixin , ExportSerializerMixin , QueryArgumentsMixin ) : \n values_queryset = None \n ordering_fields = '<STR_LIT>' \n create_serializer_class = None \n update_serializer_class = None \n filter_fields = '<STR_LIT>' \n search_fields = ( ) \n extra_filter_class = [ CoreModelFilterBankend , DataLevelPermissionsFilter ] \n permission_classes = [ CustomPermission ] \n import_field_dict = { } \n export_field_label = { } \n def filter_queryset ( self , queryset ) : \n for backend in set ( set ( self . filter_backends ) | set ( self . extra_filter_class or [ ] ) ) : \n queryset = backend ( ) . filter_queryset ( self . request , queryset , self ) \n return queryset \n def get_queryset ( self ) : \n if getattr ( self , '<STR_LIT>' , None ) : \n return self . values_queryset \n return super ( ) . get_queryset ( ) \n def get_serializer_class ( self ) : \n action_serializer_name = f\"<STR_LIT>\" \n action_serializer_class = getattr ( self , action_serializer_name , None ) \n if action_serializer_class : \n return action_serializer_class \n return super ( ) . get_serializer_class ( ) \n def get_serializer ( self , * args , ** kwargs ) : \n serializer_class = self . get_serializer_class ( ) \n kwargs . setdefault ( '<STR_LIT>' , self . get_serializer_context ( ) ) \n can_see = self . get_menu_field ( serializer_class ) \n self . request . permission_fields = can_see \n if isinstance ( self . request . data , list ) : \n with transaction . atomic ( ) : \n return serializer_class ( many = True , * args , ** kwargs ) \n else : \n return serializer_class ( * args , ** kwargs ) \n def get_menu_field ( self , serializer_class ) : \n finded = False \n for model in get_custom_app_models ( ) : \n if model [ '<STR_LIT>' ] is serializer_class . Meta . model : \n finded = True \n break \n if finded is False : \n return [ ] \n return MenuField . objects . filter ( model = model [ '<STR_LIT>' ] \n ) . values ( '<STR_LIT>' , '<STR_LIT>' ) \n def create ( self , request , * args , ** kwargs ) : \n serializer = self . get_serializer ( data = request . data , request = request ) \n serializer . is_valid ( raise_exception = True ) \n self . perform_create ( serializer ) \n return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n def list ( self , request , * args , ** kwargs ) : \n queryset = self . filter_queryset ( self . get_queryset ( ) ) \n page = self . paginate_queryset ( queryset ) \n if page is not None : \n serializer = self . get_serializer ( page , many = True , request = request ) \n return self . get_paginated_response ( serializer . data ) \n serializer = self . get_serializer ( queryset , many = True , request = request ) \n return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n def retrieve ( self , request , * args , ** kwargs ) : \n instance = self . get_object ( ) \n serializer = self . get_serializer ( instance ) \n return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n def update ( self , request , * args , ** kwargs ) : \n partial = kwargs . pop ( '<STR_LIT>' , False ) \n instance = self . get_object ( ) \n serializer = self . get_serializer ( instance , data = request . data , request = request , partial = partial ) \n serializer . is_valid ( raise_exception = True ) \n self . perform_update ( serializer ) \n if getattr ( instance , '<STR_LIT>' , None ) : \n instance . _prefetched_objects_cache = { } \n return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n def destroy ( self , request , * args , ** kwargs ) : \n instance = self . get_object ( ) \n instance . delete ( ) \n return DetailResponse ( data = [ ] , msg = \"<STR_LIT>\" ) \n keys = openapi . Schema ( description = '<STR_LIT>' , type = openapi . TYPE_ARRAY , items = openapi . TYPE_STRING ) \n @ swagger_auto_schema ( request_body = openapi . Schema ( \n type = openapi . TYPE_OBJECT , \n required = [ '<STR_LIT>' ] , \n properties = { '<STR_LIT>' : keys } \n ) , operation_summary = '<STR_LIT>' ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False )", "output": "def multiple_delete ( self , request , * args , ** kwargs ) : \n request_data = request . data \n keys = request_data . get ( '<STR_LIT>' , None ) \n if keys : \n self . get_queryset ( ) . filter ( id__in = keys ) . delete ( ) \n return SuccessResponse ( data = [ ] , msg = \"<STR_LIT>\" ) \n else : \n return ErrorResponse ( msg = \"<STR_LIT>\" )"}, {"input": "import json \n from asgiref . sync import async_to_sync \n from channels . layers import get_channel_layer \n from django_restql . fields import DynamicSerializerMethodField \n from rest_framework import serializers \n from rest_framework . decorators import action , permission_classes \n from rest_framework . permissions import IsAuthenticated , AllowAny \n from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser \n from dvadmin . utils . json_response import SuccessResponse , DetailResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class MessageCenterSerializer ( CustomModelSerializer ) : \n role_info = DynamicSerializerMethodField ( ) \n user_info = DynamicSerializerMethodField ( ) \n dept_info = DynamicSerializerMethodField ( ) \n is_read = serializers . BooleanField ( read_only = True , source = '<STR_LIT>' ) \n def get_role_info ( self , instance , parsed_query ) : \n roles = instance . target_role . all ( ) \n from dvadmin . system . views . role import RoleSerializer \n serializer = RoleSerializer ( \n roles , \n many = True , \n parsed_query = parsed_query \n ) \n return serializer . data \n def get_user_info ( self , instance , parsed_query ) : \n users = instance . target_user . all ( ) \n from dvadmin . system . views . user import UserSerializer \n serializer = UserSerializer ( \n users , \n many = True , \n parsed_query = parsed_query \n ) \n return serializer . data \n def get_dept_info ( self , instance , parsed_query ) : \n dept = instance . target_dept . all ( ) \n from dvadmin . system . views . dept import DeptSerializer \n serializer = DeptSerializer ( \n dept , \n many = True , \n parsed_query = parsed_query \n ) \n return serializer . data \n class Meta : \n model = MessageCenter \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class MessageCenterTargetUserSerializer ( CustomModelSerializer ) : \n class Meta : \n model = MessageCenterTargetUser \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class MessageCenterTargetUserListSerializer ( CustomModelSerializer ) : \n is_read = serializers . SerializerMethodField ( ) \n def get_is_read ( self , instance ) : \n user_id = self . request . user . id \n message_center_id = instance . id \n queryset = MessageCenterTargetUser . objects . filter ( messagecenter__id = message_center_id , users_id = user_id ) . first ( ) \n if queryset : \n return queryset . is_read \n return False \n class Meta : \n model = MessageCenter \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n def websocket_push ( user_id , message ) : \n username = \"<STR_LIT>\" + str ( user_id ) \n channel_layer = get_channel_layer ( ) \n async_to_sync ( channel_layer . group_send ) ( \n username , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : message \n } \n ) \n class MessageCenterCreateSerializer ( CustomModelSerializer ) : \n def save ( self , ** kwargs ) : \n data = super ( ) . save ( ** kwargs ) \n initial_data = self . initial_data \n target_type = initial_data . get ( '<STR_LIT>' ) \n users = initial_data . get ( '<STR_LIT>' , [ ] ) \n if target_type in [ <NUM_LIT> ] :", "output": "target_role = initial_data . get ( '<STR_LIT>' , [ ] ) \n users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) \n if target_type in [ <NUM_LIT> ] : \n target_dept = initial_data . get ( '<STR_LIT>' , [ ] ) \n users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) \n if target_type in [ <NUM_LIT> ] : \n users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) \n targetuser_data = [ ] \n for user in users : \n targetuser_data . append ( { \n \"<STR_LIT>\" : data . id , \n \"<STR_LIT>\" : user \n } ) \n targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = self . request ) \n targetuser_instance . is_valid ( raise_exception = True ) \n targetuser_instance . save ( ) \n for user in users : \n unread_count = MessageCenterTargetUser . objects . filter ( users__id = user , is_read = False ) . count ( ) \n websocket_push ( user , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , \n \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) \n return data \n class Meta : \n model = MessageCenter \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class MessageCenterViewSet ( CustomModelViewSet ) : \n queryset = MessageCenter . objects . order_by ( '<STR_LIT>' ) \n serializer_class = MessageCenterSerializer \n create_serializer_class = MessageCenterCreateSerializer \n extra_filter_backends = [ ] \n def get_queryset ( self ) : \n if self . action == '<STR_LIT>' : \n return MessageCenter . objects . filter ( creator = self . request . user . id ) . all ( ) \n return MessageCenter . objects . all ( ) \n def retrieve ( self , request , * args , ** kwargs ) : \n pk = kwargs . get ( '<STR_LIT>' ) \n user_id = self . request . user . id \n queryset = MessageCenterTargetUser . objects . filter ( users__id = user_id , messagecenter__id = pk ) . first ( ) \n if queryset : \n queryset . is_read = True \n queryset . save ( ) \n instance = self . get_object ( ) \n serializer = self . get_serializer ( instance ) \n unread_count = MessageCenterTargetUser . objects . filter ( users__id = user_id , is_read = False ) . count ( ) \n websocket_push ( user_id , message = { \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : '<STR_LIT>' , \n \"<STR_LIT>\" : '<STR_LIT>' , \"<STR_LIT>\" : unread_count } ) \n return DetailResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def get_self_receive ( self , request ) : \n self_user_id = self . request . user . id \n queryset = MessageCenter . objects . filter ( target_user__id = self_user_id ) \n page = self . paginate_queryset ( queryset ) \n if page is not None : \n serializer = MessageCenterTargetUserListSerializer ( page , many = True , request = request ) \n return self . get_paginated_response ( serializer . data ) \n serializer = MessageCenterTargetUserListSerializer ( queryset , many = True , request = request ) \n return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def get_newest_msg ( self , request ) : \n self_user_id = self . request . user . id \n queryset = MessageCenterTargetUser . objects . filter ( users__id = self_user_id ) . order_by ( '<STR_LIT>' ) . last ( ) \n data = None \n if queryset : \n serializer = MessageCenterTargetUserListSerializer ( queryset . messagecenter , many = False , request = request ) \n data = serializer . data \n return DetailResponse ( data = data , msg = \"<STR_LIT>\" )"}, {"input": "from django . apps import apps \n from rest_framework import serializers \n from rest_framework . decorators import action \n from rest_framework . permissions import IsAuthenticated \n from dvadmin . system . models import Role , MenuField \n from dvadmin . utils . models import get_custom_app_models \n from dvadmin . utils . viewset import CustomModelViewSet \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . json_response import DetailResponse , ErrorResponse , SuccessResponse \n class MenuFieldSerializer ( CustomModelSerializer ) : \n class Meta : \n model = MenuField \n fields = '<STR_LIT>' \n read_only_fields = [ '<STR_LIT>' ] \n class MenuFieldViewSet ( CustomModelViewSet ) : \n queryset = MenuField . objects . order_by ( '<STR_LIT>' ) \n serializer_class = MenuFieldSerializer \n def list ( self , request , * args , ** kwargs ) : \n menu = request . query_params . get ( '<STR_LIT>' ) \n if not menu : \n return SuccessResponse ( [ ] ) \n queryset = self . filter_queryset ( self . get_queryset ( ) . filter ( menu = menu ) ) \n serializer = self . get_serializer ( queryset , many = True , request = request ) \n return SuccessResponse ( data = serializer . data , msg = \"<STR_LIT>\" ) \n def create ( self , request , * args , ** kwargs ) : \n payload = request . data \n for model in apps . get_models ( ) : \n if payload . get ( '<STR_LIT>' ) == model . __name__ : \n break \n else : \n return ErrorResponse ( msg = '<STR_LIT>' ) \n if MenuField . objects . filter ( menu = payload . get ( '<STR_LIT>' ) , model = model . __name__ , field_name = payload . get ( '<STR_LIT>' ) ) . exists ( ) : \n return ErrorResponse ( msg = '<STR_LIT>' % payload . get ( '<STR_LIT>' ) ) \n return super ( ) . create ( request , * args , ** kwargs ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def get_models ( self , request ) : \n res = [ ] \n for model in get_custom_app_models ( ) : \n res . append ( { \n '<STR_LIT>' : model [ '<STR_LIT>' ] , \n '<STR_LIT>' : model [ '<STR_LIT>' ] , \n '<STR_LIT>' : model [ '<STR_LIT>' ] \n } ) \n return DetailResponse ( res ) \n @ action ( methods = [ '<STR_LIT>' ] , detail = False , permission_classes = [ IsAuthenticated ] ) \n def auto_match_fields ( self , request ) : \n menu_id = request . data . get ( '<STR_LIT>' ) \n model_name = request . data . get ( '<STR_LIT>' ) \n if not menu_id or not model_name : \n return ErrorResponse ( msg = '<STR_LIT>' ) \n for model in get_custom_app_models ( ) : \n if model [ '<STR_LIT>' ] != model_name : \n continue \n for field in model [ '<STR_LIT>' ] : \n if MenuField . objects . filter (", "output": "menu_id = menu_id , model = model_name , field_name = field [ '<STR_LIT>' ] \n ) . exists ( ) : \n continue \n data = { \n '<STR_LIT>' : menu_id , \n '<STR_LIT>' : model_name , \n '<STR_LIT>' : field [ '<STR_LIT>' ] , \n '<STR_LIT>' : str ( field [ '<STR_LIT>' ] ) , \n } \n serializer = self . get_serializer ( data = data , request = request ) \n serializer . is_valid ( raise_exception = True ) \n serializer . save ( ) \n return SuccessResponse ( msg = '<STR_LIT>' )"}, {"input": "import json \n import logging \n from django . conf import settings \n from django . contrib . auth . models import AnonymousUser \n from django . http import HttpResponse , HttpResponseServerError \n from django . utils . deprecation import MiddlewareMixin \n from dvadmin . system . models import OperationLog \n from dvadmin . utils . request_util import get_request_user , get_request_ip , get_request_data , get_request_path , get_os , get_browser , get_verbose_name \n class ApiLoggingMiddleware ( MiddlewareMixin ) : \n def __init__ ( self , get_response = None ) : \n super ( ) . __init__ ( get_response ) \n self . enable = getattr ( settings , '<STR_LIT>' , None ) or False \n self . methods = getattr ( settings , '<STR_LIT>' , None ) or set ( ) \n self . operation_log_id = None \n @ classmethod \n def __handle_request ( cls , request ) : \n request . request_ip = get_request_ip ( request ) \n request . request_data = get_request_data ( request ) \n request . request_path = get_request_path ( request ) \n def __handle_response ( self , request , response ) : \n body = getattr ( request , '<STR_LIT>' , { } ) \n if isinstance ( body , dict ) and body . get ( '<STR_LIT>' , '<STR_LIT>' ) : \n body [ '<STR_LIT>' ] = '<STR_LIT>' * len ( body [ '<STR_LIT>' ] ) \n if not hasattr ( response , '<STR_LIT>' ) or not isinstance ( response . data , dict ) : \n response . data = { } \n try : \n if not response . data and response . content : \n content = json . loads ( response . content . decode ( ) ) \n response . data = content if isinstance ( content , dict ) else { } \n except Exception : \n return \n user = get_request_user ( request ) \n info = { \n '<STR_LIT>' : getattr ( request , '<STR_LIT>' , '<STR_LIT>' ) , \n '<STR_LIT>' : user if not isinstance ( user , AnonymousUser ) else None , \n '<STR_LIT>' : getattr ( request . user , '<STR_LIT>' , None ) , \n '<STR_LIT>' : request . method , \n '<STR_LIT>' : request . request_path , \n '<STR_LIT>' : body , \n '<STR_LIT>' : response . data . get ( '<STR_LIT>' ) , \n '<STR_LIT>' : get_os ( request ) , \n '<STR_LIT>' : get_browser ( request ) , \n '<STR_LIT>' : request . session . get ( '<STR_LIT>' ) ,", "output": "'<STR_LIT>' : True if response . data . get ( '<STR_LIT>' ) in [ <NUM_LIT> , ] else False , \n '<STR_LIT>' : { \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) , \"<STR_LIT>\" : response . data . get ( '<STR_LIT>' ) } , \n } \n operation_log , creat = OperationLog . objects . update_or_create ( defaults = info , id = self . operation_log_id ) \n if not operation_log . request_modular and settings . API_MODEL_MAP . get ( request . request_path , None ) : \n operation_log . request_modular = settings . API_MODEL_MAP [ request . request_path ] \n operation_log . save ( ) \n def process_view ( self , request , view_func , view_args , view_kwargs ) : \n if hasattr ( view_func , '<STR_LIT>' ) and hasattr ( view_func . cls , '<STR_LIT>' ) : \n if self . enable : \n if self . methods == '<STR_LIT>' or request . method in self . methods : \n log = OperationLog ( request_modular = get_verbose_name ( view_func . cls . queryset ) ) \n log . save ( ) \n self . operation_log_id = log . id \n return \n def process_request ( self , request ) : \n self . __handle_request ( request ) \n def process_response ( self , request , response ) : \n if self . enable : \n if self . methods == '<STR_LIT>' or request . method in self . methods : \n self . __handle_response ( request , response ) \n return response \n logger = logging . getLogger ( \"<STR_LIT>\" ) \n class HealthCheckMiddleware ( object ) : \n def __init__ ( self , get_response ) : \n self . get_response = get_response \n def __call__ ( self , request ) : \n if request . method == \"<STR_LIT>\" : \n if request . path == \"<STR_LIT>\" : \n return self . readiness ( request ) \n elif request . path == \"<STR_LIT>\" : \n return self . healthz ( request ) \n return self . get_response ( request ) \n def healthz ( self , request ) : \n return HttpResponse ( \"<STR_LIT>\" ) \n def readiness ( self , request ) : \n try : \n from django . db import connections \n for name in connections : \n cursor = connections [ name ] . cursor ( ) \n cursor . execute ( \"<STR_LIT>\" ) \n row = cursor . fetchone ( ) \n if row is None : \n return HttpResponseServerError ( \"<STR_LIT>\" ) \n except Exception as e : \n logger . exception ( e ) \n return HttpResponseServerError ( \"<STR_LIT>\" ) \n try : \n from django . core . cache import caches \n from django . core . cache . backends . memcached import BaseMemcachedCache \n for cache in caches . all ( ) : \n if isinstance ( cache , BaseMemcachedCache ) : \n stats = cache . _cache . get_stats ( ) \n if len ( stats ) != len ( cache . _servers ) : \n return HttpResponseServerError ( \"<STR_LIT>\" ) \n except Exception as e : \n logger . exception ( e ) \n return HttpResponseServerError ( \"<STR_LIT>\" ) \n return HttpResponse ( \"<STR_LIT>\" )"}, {"input": "from functools import wraps \n from django . db . models import Func , F , OuterRef , Exists \n from django . test import TestCase \n import django \n import os \n os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n django . setup ( ) \n from dvadmin . system . models import Menu , RoleMenuPermission , RoleMenuButtonPermission , MenuButton \n import time \n def timing_decorator ( func ) : \n @ wraps ( func ) \n def wrapper ( * args , ** kwargs ) : \n start_time = time . time ( ) \n result = func ( * args , ** kwargs ) \n end_time = time . time ( ) \n run_time = end_time - start_time \n print ( f\"<STR_LIT>\" ) \n return result \n return wrapper \n @ timing_decorator \n def getMenu ( ) : \n data = [ ] \n queryset = Menu . objects . filter ( status = <NUM_LIT> , is_catalog = False ) . values ( '<STR_LIT>' , '<STR_LIT>' ) \n for item in queryset : \n parent_list = Menu . get_all_parent ( item [ '<STR_LIT>' ] ) \n names = [ d [ \"<STR_LIT>\" ] for d in parent_list ] \n completeName = \"<STR_LIT>\" . join ( names ) \n isCheck = RoleMenuPermission . objects . filter ( \n menu__id = item [ '<STR_LIT>' ] , \n role__id = <NUM_LIT> , \n ) . exists ( ) \n mbCheck = RoleMenuButtonPermission . objects . filter ( \n menu_button = OuterRef ( \"<STR_LIT>\" ) , \n role__id = <NUM_LIT> , \n ) \n btns = MenuButton . objects . filter (", "output": "menu__id = item [ '<STR_LIT>' ] , \n ) . annotate ( isCheck = Exists ( mbCheck ) ) . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , data_range = F ( '<STR_LIT>' ) ) \n dicts = { \n '<STR_LIT>' : completeName , \n '<STR_LIT>' : item [ '<STR_LIT>' ] , \n '<STR_LIT>' : isCheck , \n '<STR_LIT>' : btns \n } \n print ( dicts ) \n data . append ( dicts ) \n if __name__ == '<STR_LIT>' : \n getMenu ( )"}, {"input": "import operator \n import re \n from collections import OrderedDict \n from functools import reduce \n import six \n from django . db import models \n from django . db . models import Q , F \n from django . db . models . constants import LOOKUP_SEP \n from django_filters import utils , FilterSet \n from django_filters . constants import ALL_FIELDS \n from django_filters . filters import CharFilter , DateTimeFromToRangeFilter \n from django_filters . rest_framework import DjangoFilterBackend \n from django_filters . utils import get_model_field \n from rest_framework . filters import BaseFilterBackend \n from django_filters . conf import settings \n from dvadmin . system . models import Dept , ApiWhiteList , RoleMenuButtonPermission \n from dvadmin . utils . models import CoreModel \n class CoreModelFilterBankend ( BaseFilterBackend ) : \n def filter_queryset ( self , request , queryset , view ) : \n create_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) \n create_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) \n update_datetime_after = request . query_params . get ( '<STR_LIT>' , None ) \n update_datetime_before = request . query_params . get ( '<STR_LIT>' , None ) \n if any ( [ create_datetime_after , create_datetime_before , update_datetime_after , update_datetime_before ] ) : \n create_filter = Q ( ) \n if create_datetime_after and create_datetime_before : \n create_filter &= Q ( create_datetime__gte = create_datetime_after ) & Q ( create_datetime__lte = create_datetime_before ) \n elif create_datetime_after : \n create_filter &= Q ( create_datetime__gte = create_datetime_after ) \n elif create_datetime_before : \n create_filter &= Q ( create_datetime__lte = create_datetime_before ) \n update_filter = Q ( ) \n if update_datetime_after and update_datetime_before : \n update_filter &= Q ( update_datetime__gte = update_datetime_after ) & Q ( update_datetime__lte = update_datetime_before ) \n elif update_datetime_after : \n update_filter &= Q ( update_datetime__gte = update_datetime_after ) \n elif update_datetime_before : \n update_filter &= Q ( update_datetime__lte = update_datetime_before ) \n queryset = queryset . filter ( create_filter & update_filter ) \n return queryset \n return queryset \n def get_dept ( dept_id : int , dept_all_list = None , dept_list = None ) : \n if not dept_all_list : \n dept_all_list = Dept . objects . all ( ) . values ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n if dept_list is None : \n dept_list = [ dept_id ] \n for ele in dept_all_list : \n if ele . get ( \"<STR_LIT>\" ) == dept_id : \n dept_list . append ( ele . get ( \"<STR_LIT>\" ) ) \n get_dept ( ele . get ( \"<STR_LIT>\" ) , dept_all_list , dept_list ) \n return list ( set ( dept_list ) ) \n class DataLevelPermissionsFilter ( BaseFilterBackend ) : \n def filter_queryset ( self , request , queryset , view ) : \n api = request . path \n method = request . method \n methodList = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n method = methodList . index ( method ) \n api_white_list = ApiWhiteList . objects . filter ( enable_datasource = False ) . values ( \n permission__api = F ( \"<STR_LIT>\" ) , permission__method = F ( \"<STR_LIT>\" ) \n ) \n api_white_list = [ \n str ( item . get ( \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) \n + \"<STR_LIT>\" \n + str ( item . get ( \"<STR_LIT>\" ) ) \n for item in api_white_list \n if item . get ( \"<STR_LIT>\" ) \n ] \n for item in api_white_list : \n new_api = f\"<STR_LIT>\" \n matchObj = re . match ( item , new_api , re . M | re . I ) \n if matchObj is None : \n continue \n else : \n return queryset \n if request . user . is_superuser == <NUM_LIT> : \n return self . _extracted_from_filter_queryset_33 ( request , queryset , api , method ) \n else : \n return queryset \n def _extracted_from_filter_queryset_33 ( self , request , queryset , api , method ) : \n user_dept_id = getattr ( request . user , \"<STR_LIT>\" , None ) \n if not user_dept_id : \n return queryset . none ( ) \n if not getattr ( queryset . model , \"<STR_LIT>\" , None ) : \n return queryset \n if not hasattr ( request . user , \"<STR_LIT>\" ) : \n return queryset . filter ( dept_belong_id = user_dept_id ) \n re_api = api \n _pk = request . parser_context [ \"<STR_LIT>\" ] . get ( '<STR_LIT>' ) \n if _pk : \n re_api = re . sub ( _pk , '<STR_LIT>' , api ) \n role_id_list = request . user . role . values_list ( '<STR_LIT>' , flat = True ) \n role_permission_list = RoleMenuButtonPermission . objects . filter ( \n role__in = role_id_list , \n role__status = <NUM_LIT> , \n menu_button__api = re_api , \n menu_button__method = method ) . values ( \n '<STR_LIT>' \n ) \n dataScope_list = [ ] \n for ele in role_permission_list : \n if ele . get ( \"<STR_LIT>\" ) == <NUM_LIT> : \n return queryset \n dataScope_list . append ( ele . get ( \"<STR_LIT>\" ) ) \n dataScope_list = list ( set ( dataScope_list ) ) \n if <NUM_LIT> in dataScope_list : \n return queryset . filter ( \n creator = request . user , dept_belong_id = user_dept_id \n ) \n dept_list = [ ] \n for ele in dataScope_list : \n if ele == <NUM_LIT> : \n dept_list . append ( user_dept_id ) \n dept_list . extend ( \n get_dept ( \n user_dept_id , \n ) \n ) \n elif ele == <NUM_LIT> : \n dept_list . append ( user_dept_id ) \n elif ele == <NUM_LIT> : \n dept_ids = RoleMenuButtonPermission . objects . filter ( \n role__in = role_id_list , \n role__status = <NUM_LIT> , \n data_range = <NUM_LIT> ) . values_list ( \n '<STR_LIT>' , flat = True \n ) \n dept_list . extend ( \n dept_ids \n ) \n if queryset . model . _meta . model_name == '<STR_LIT>' : \n return queryset . filter ( id__in = list ( set ( dept_list ) ) ) \n return queryset . filter ( dept_belong_id__in = list ( set ( dept_list ) ) ) \n class CustomDjangoFilterBackend ( DjangoFilterBackend ) : \n lookup_prefixes = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n filter_fields = \"<STR_LIT>\" \n def construct_search ( self , field_name , lookup_expr = None ) : \n lookup = self . lookup_prefixes . get ( field_name [ <NUM_LIT> ] ) \n if lookup : \n field_name = field_name [ <NUM_LIT> : ] \n else : \n lookup = lookup_expr \n if lookup : \n if field_name . endswith ( lookup ) : \n return field_name \n return LOOKUP_SEP . join ( [ field_name , lookup ] ) \n return field_name \n def find_filter_lookups ( self , orm_lookups , search_term_key ) : \n for lookup in orm_lookups : \n new_lookup = LOOKUP_SEP . join ( lookup . split ( LOOKUP_SEP ) [ : - <NUM_LIT> ] ) if len ( lookup . split ( LOOKUP_SEP ) ) > <NUM_LIT> else lookup \n if new_lookup == search_term_key : \n return lookup \n return None \n def get_filterset_class ( self , view , queryset = None ) : \n filterset_class = getattr ( view , \"<STR_LIT>\" , None ) \n filterset_fields = getattr ( view , \"<STR_LIT>\" , None ) \n if filterset_class is None and hasattr ( view , \"<STR_LIT>\" ) : \n utils . deprecate ( \n \"<STR_LIT>\" % view . __class__ . __name__ \n ) \n filterset_class = getattr ( view , \"<STR_LIT>\" , None ) \n if filterset_fields is None and hasattr ( view , \"<STR_LIT>\" ) : \n utils . deprecate ( \n \"<STR_LIT>\" % view . __class__ . __name__ \n ) \n self . filter_fields = getattr ( view , \"<STR_LIT>\" , None ) \n if isinstance ( self . filter_fields , ( list , tuple ) ) : \n filterset_fields = [ \n field [ <NUM_LIT> : ] if field [ <NUM_LIT> ] in self . lookup_prefixes . keys ( ) else field for field in self . filter_fields \n ] \n else : \n filterset_fields = self . filter_fields \n if filterset_class : \n filterset_model = filterset_class . _meta . model \n if filterset_model and queryset is not None : \n assert issubclass ( \n queryset . model , filterset_model \n ) , \"<STR_LIT>\" % ( \n filterset_model , \n queryset . model , \n ) \n return filterset_class \n if filterset_fields and queryset is not None : \n MetaBase = getattr ( self . filterset_base , \"<STR_LIT>\" , object ) \n class AutoFilterSet ( self . filterset_base ) : \n @ classmethod \n def get_all_model_fields ( cls , model ) : \n opts = model . _meta \n return [ \n f . name \n for f in sorted ( opts . fields + opts . many_to_many ) \n if ( f . name == \"<STR_LIT>\" ) \n or not isinstance ( f , models . AutoField ) \n and not ( getattr ( f . remote_field , \"<STR_LIT>\" , False ) ) \n ] \n @ classmethod \n def get_fields ( cls ) : \n model = cls . _meta . model \n fields = cls . _meta . fields \n exclude = cls . _meta . exclude \n assert not ( fields is None and exclude is None ) , ( \n \"<STR_LIT>\" \n \"<STR_LIT>\" \n \"<STR_LIT>\" % cls . __name__ \n ) \n if exclude is not None and fields is None : \n fields = ALL_FIELDS \n if fields == ALL_FIELDS : \n fields = cls . get_all_model_fields ( model ) \n exclude = exclude or [ ] \n if not isinstance ( fields , dict ) : \n fields = [ ( f , [ settings . DEFAULT_LOOKUP_EXPR ] ) for f in fields if f not in exclude ] \n else : \n fields = [ ( f , lookups ) for f , lookups in fields . items ( ) if f not in exclude ] \n return OrderedDict ( fields ) \n @ classmethod \n def get_filters ( cls ) : \n if not cls . _meta . model : \n return cls . declared_filters . copy ( ) \n filters = OrderedDict ( ) \n fields = cls . get_fields ( ) \n undefined = [ ] \n for field_name , lookups in fields . items ( ) : \n field = get_model_field ( cls . _meta . model , field_name ) \n from django . db import models \n from timezone_field import TimeZoneField \n if isinstance ( field , ( models . JSONField , TimeZoneField ) ) : \n continue \n if field is None : \n undefined . append ( field_name ) \n if ( \n isinstance ( field , ( models . CharField ) ) \n and filterset_fields == \"<STR_LIT>\" \n and lookups == [ \"<STR_LIT>\" ] \n ) : \n lookups = [ \"<STR_LIT>\" ] \n for lookup_expr in lookups : \n filter_name = cls . get_filter_name ( field_name , lookup_expr ) \n if filter_name in cls . declared_filters : \n filters [ filter_name ] = cls . declared_filters [ filter_name ] \n continue \n if field is not None : \n filters [ filter_name ] = cls . filter_for_field ( field , field_name , lookup_expr ) \n if isinstance ( cls . _meta . fields , ( list , tuple ) ) : \n undefined = [ f for f in undefined if f not in cls . declared_filters ] \n if undefined : \n raise TypeError ( \n \"<STR_LIT>\" % \"<STR_LIT>\" . join ( undefined ) \n ) \n filters . update ( cls . declared_filters ) \n return filters \n class Meta ( MetaBase ) : \n model = queryset . model \n fields = filterset_fields \n return AutoFilterSet \n return None \n def filter_queryset ( self , request , queryset , view ) : \n filterset = self . get_filterset ( request , queryset , view ) \n if filterset is None : \n return queryset \n if filterset . __class__ . __name__ == \"<STR_LIT>\" :", "output": "queryset = filterset . queryset \n filter_fields = filterset . filters if self . filter_fields == \"<STR_LIT>\" else self . filter_fields \n orm_lookup_dict = dict ( \n zip ( \n [ field for field in filter_fields ] , \n [ filterset . filters [ lookup ] . lookup_expr for lookup in filterset . filters . keys ( ) ] , \n ) \n ) \n orm_lookups = [ \n self . construct_search ( lookup , lookup_expr ) for lookup , lookup_expr in orm_lookup_dict . items ( ) \n ] \n conditions = [ ] \n queries = [ ] \n for search_term_key in filterset . data . keys ( ) : \n orm_lookup = self . find_filter_lookups ( orm_lookups , search_term_key ) \n if not orm_lookup or filterset . data . get ( search_term_key ) == '<STR_LIT>' : \n continue \n filterset_data_len = len ( filterset . data . getlist ( search_term_key ) ) \n if filterset_data_len == <NUM_LIT> : \n query = Q ( ** { orm_lookup : filterset . data [ search_term_key ] } ) \n queries . append ( query ) \n elif filterset_data_len == <NUM_LIT> : \n orm_lookup += '<STR_LIT>' \n query = Q ( ** { orm_lookup : filterset . data . getlist ( search_term_key ) } ) \n queries . append ( query ) \n if len ( queries ) > <NUM_LIT> : \n conditions . append ( reduce ( operator . and_ , queries ) ) \n queryset = queryset . filter ( reduce ( operator . and_ , conditions ) ) \n return queryset \n else : \n return queryset \n if not filterset . is_valid ( ) and self . raise_exception : \n raise utils . translate_validation ( filterset . errors ) \n return filterset . qs"}, {"input": "import multiprocessing \n workers = multiprocessing . cpu_count ( ) * <NUM_LIT> + <NUM_LIT> \n threads = <NUM_LIT> \n bind = '<STR_LIT>' \n daemon = '<STR_LIT>' \n worker_class = '<STR_LIT>' \n worker_connections = <NUM_LIT> \n max_requests = <NUM_LIT> \n max_requests_jitter = <NUM_LIT> \n pidfile = '<STR_LIT>' \n loglevel = '<STR_LIT>'", "output": "access_log_format = '<STR_LIT>' \n backlog = <NUM_LIT> \n proc_name = '<STR_LIT>' \n timeout = <NUM_LIT> \n graceful_timeout = <NUM_LIT> \n keepalive = <NUM_LIT> \n limit_request_line = <NUM_LIT> \n limit_request_fields = <NUM_LIT> \n limit_request_field_size = <NUM_LIT> \n accesslog = '<STR_LIT>'"}, {"input": "from django . db . models import Q \n from rest_framework import serializers \n from dvadmin . system . models import Area \n from dvadmin . utils . json_response import SuccessResponse \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . viewset import CustomModelViewSet \n class AreaSerializer ( CustomModelSerializer ) : \n pcode_count = serializers . SerializerMethodField ( read_only = True ) \n hasChild = serializers . SerializerMethodField ( ) \n def get_pcode_count ( self , instance : Area ) :", "output": "return Area . objects . filter ( pcode = instance ) . count ( ) \n def get_hasChild ( self , instance ) : \n hasChild = Area . objects . filter ( pcode = instance . code ) \n if hasChild : \n return True \n return False \n class Meta : \n model = Area \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n class AreaCreateUpdateSerializer ( CustomModelSerializer ) : \n class Meta : \n model = Area \n fields = '<STR_LIT>' \n class AreaViewSet ( CustomModelViewSet ) : \n queryset = Area . objects . all ( ) \n serializer_class = AreaSerializer \n extra_filter_class = [ ] \n def get_queryset ( self ) : \n self . request . query_params . _mutable = True \n params = self . request . query_params \n pcode = params . get ( '<STR_LIT>' , None ) \n page = params . get ( '<STR_LIT>' , None ) \n limit = params . get ( '<STR_LIT>' , None ) \n if page : \n del params [ '<STR_LIT>' ] \n if limit : \n del params [ '<STR_LIT>' ] \n if params and pcode : \n queryset = self . queryset . filter ( enable = True , pcode = pcode ) \n else : \n queryset = self . queryset . filter ( enable = True ) \n return queryset"}, {"input": "from rest_framework . response import Response \n class SuccessResponse ( Response ) : \n def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False ,", "output": "content_type = None , page = <NUM_LIT> , limit = <NUM_LIT> , total = <NUM_LIT> ) : \n std_data = { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : page , \n \"<STR_LIT>\" : limit , \n \"<STR_LIT>\" : total , \n \"<STR_LIT>\" : data , \n \"<STR_LIT>\" : msg \n } \n super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) \n class DetailResponse ( Response ) : \n def __init__ ( self , data = None , msg = '<STR_LIT>' , status = None , template_name = None , headers = None , exception = False , \n content_type = None , ) : \n std_data = { \n \"<STR_LIT>\" : <NUM_LIT> , \n \"<STR_LIT>\" : data , \n \"<STR_LIT>\" : msg \n } \n super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type ) \n class ErrorResponse ( Response ) : \n def __init__ ( self , data = None , msg = '<STR_LIT>' , code = <NUM_LIT> , status = None , template_name = None , headers = None , \n exception = False , content_type = None ) : \n std_data = { \n \"<STR_LIT>\" : code , \n \"<STR_LIT>\" : data , \n \"<STR_LIT>\" : msg \n } \n super ( ) . __init__ ( std_data , status , template_name , headers , exception , content_type )"}, {"input": "import urllib \n from asgiref . sync import sync_to_async , async_to_sync \n from channels . db import database_sync_to_async \n from channels . generic . websocket import AsyncJsonWebsocketConsumer , AsyncWebsocketConsumer \n import json \n from channels . layers import get_channel_layer \n from jwt import InvalidSignatureError \n from rest_framework . request import Request \n from application import settings \n from dvadmin . system . models import MessageCenter , Users , MessageCenterTargetUser \n from dvadmin . system . views . message_center import MessageCenterTargetUserSerializer \n from dvadmin . utils . serializers import CustomModelSerializer \n send_dict = { } \n def set_message ( sender , msg_type , msg , unread = <NUM_LIT> ) : \n text = { \n '<STR_LIT>' : sender , \n '<STR_LIT>' : msg_type , \n '<STR_LIT>' : msg , \n '<STR_LIT>' : unread \n } \n return text \n @ database_sync_to_async \n def _get_message_center_instance ( message_id ) : \n from dvadmin . system . models import MessageCenter \n _MessageCenter = MessageCenter . objects . filter ( id = message_id ) . values_list ( '<STR_LIT>' , flat = True ) \n if _MessageCenter : \n return _MessageCenter \n else : \n return [ ] \n @ database_sync_to_async \n def _get_message_unread ( user_id ) : \n from dvadmin . system . models import MessageCenterTargetUser \n count = MessageCenterTargetUser . objects . filter ( users = user_id , is_read = False ) . count ( ) \n return count or <NUM_LIT> \n def request_data ( scope ) : \n query_string = scope . get ( '<STR_LIT>' , b'<STR_LIT>' ) . decode ( '<STR_LIT>' ) \n qs = urllib . parse . parse_qs ( query_string ) \n return qs \n class DvadminWebSocket ( AsyncJsonWebsocketConsumer ) : \n async def connect ( self ) : \n try : \n import jwt \n self . service_uid = self . scope [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] \n decoded_result = jwt . decode ( self . service_uid , settings . SECRET_KEY , algorithms = [ \"<STR_LIT>\" ] ) \n if decoded_result : \n self . user_id = decoded_result . get ( '<STR_LIT>' ) \n self . chat_group_name = \"<STR_LIT>\" + str ( self . user_id ) \n await self . channel_layer . group_add ( \n self . chat_group_name , \n self . channel_name \n ) \n await self . accept ( ) \n unread_count = await _get_message_unread ( self . user_id ) \n if unread_count == <NUM_LIT> : \n await self . send_json ( set_message ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ) \n else : \n await self . send_json ( \n set_message ( '<STR_LIT>' , '<STR_LIT>' , \"<STR_LIT>\" , \n unread = unread_count ) ) \n except InvalidSignatureError : \n await self . disconnect ( None ) \n async def disconnect ( self , close_code ) : \n await self . channel_layer . group_discard ( self . chat_group_name , self . channel_name ) \n print ( \"<STR_LIT>\" ) \n try : \n await self . close ( close_code ) \n except Exception : \n pass \n class MegCenter ( DvadminWebSocket ) :", "output": "async def receive ( self , text_data ) : \n text_data_json = json . loads ( text_data ) \n message_id = text_data_json . get ( '<STR_LIT>' , None ) \n user_list = await _get_message_center_instance ( message_id ) \n for send_user in user_list : \n await self . channel_layer . group_send ( \n \"<STR_LIT>\" + str ( send_user ) , \n { '<STR_LIT>' : '<STR_LIT>' , '<STR_LIT>' : text_data_json } \n ) \n async def push_message ( self , event ) : \n message = event [ '<STR_LIT>' ] \n await self . send ( text_data = json . dumps ( message ) ) \n class MessageCreateSerializer ( CustomModelSerializer ) : \n class Meta : \n model = MessageCenter \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n def websocket_push ( user_id , message ) : \n username = \"<STR_LIT>\" + str ( user_id ) \n channel_layer = get_channel_layer ( ) \n async_to_sync ( channel_layer . group_send ) ( \n username , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : message \n } \n ) \n def create_message_push ( title : str , content : str , target_type : int = <NUM_LIT> , target_user : list = None , target_dept = None , \n target_role = None , message : dict = None , request = Request ) : \n if message is None : \n message = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } \n if target_role is None : \n target_role = [ ] \n if target_dept is None : \n target_dept = [ ] \n data = { \n \"<STR_LIT>\" : title , \n \"<STR_LIT>\" : content , \n \"<STR_LIT>\" : target_type , \n \"<STR_LIT>\" : target_user , \n \"<STR_LIT>\" : target_dept , \n \"<STR_LIT>\" : target_role \n } \n message_center_instance = MessageCreateSerializer ( data = data , request = request ) \n message_center_instance . is_valid ( raise_exception = True ) \n message_center_instance . save ( ) \n users = target_user or [ ] \n if target_type in [ <NUM_LIT> ] : \n users = Users . objects . filter ( role__id__in = target_role ) . values_list ( '<STR_LIT>' , flat = True ) \n if target_type in [ <NUM_LIT> ] : \n users = Users . objects . filter ( dept__id__in = target_dept ) . values_list ( '<STR_LIT>' , flat = True ) \n if target_type in [ <NUM_LIT> ] : \n users = Users . objects . values_list ( '<STR_LIT>' , flat = True ) \n targetuser_data = [ ] \n for user in users : \n targetuser_data . append ( { \n \"<STR_LIT>\" : message_center_instance . instance . id , \n \"<STR_LIT>\" : user \n } ) \n targetuser_instance = MessageCenterTargetUserSerializer ( data = targetuser_data , many = True , request = request ) \n targetuser_instance . is_valid ( raise_exception = True ) \n targetuser_instance . save ( ) \n for user in users : \n username = \"<STR_LIT>\" + str ( user ) \n unread_count = async_to_sync ( _get_message_unread ) ( user ) \n channel_layer = get_channel_layer ( ) \n async_to_sync ( channel_layer . group_send ) ( \n username , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : { ** message , '<STR_LIT>' : unread_count } \n } \n )"}, {"input": "import base64 \n import hashlib \n from datetime import datetime , timedelta \n from captcha . views import CaptchaStore , captcha_image \n from django . contrib import auth \n from django . contrib . auth import login \n from django . shortcuts import redirect \n from django . utils . translation import gettext_lazy as _ \n from drf_yasg import openapi \n from drf_yasg . utils import swagger_auto_schema \n from rest_framework import serializers \n from rest_framework . views import APIView \n from rest_framework_simplejwt . serializers import TokenObtainPairSerializer \n from rest_framework_simplejwt . views import TokenObtainPairView \n from django . conf import settings \n from application import dispatch \n from dvadmin . system . models import Users \n from dvadmin . utils . json_response import ErrorResponse , DetailResponse \n from dvadmin . utils . request_util import save_login_log \n from dvadmin . utils . serializers import CustomModelSerializer \n from dvadmin . utils . validator import CustomValidationError \n class CaptchaView ( APIView ) : \n authentication_classes = [ ] \n permission_classes = [ ] \n @ swagger_auto_schema ( \n responses = { \"<STR_LIT>\" : openapi . Response ( \"<STR_LIT>\" ) } , \n security = [ ] , \n operation_id = \"<STR_LIT>\" , \n operation_description = \"<STR_LIT>\" , \n ) \n def get ( self , request ) : \n data = { } \n if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : \n hashkey = CaptchaStore . generate_key ( ) \n id = CaptchaStore . objects . filter ( hashkey = hashkey ) . first ( ) . id \n imgage = captcha_image ( request , hashkey ) \n image_base = base64 . b64encode ( imgage . content ) \n data = { \n \"<STR_LIT>\" : id , \n \"<STR_LIT>\" : \"<STR_LIT>\" + image_base . decode ( \"<STR_LIT>\" ) , \n } \n return DetailResponse ( data = data ) \n class LoginSerializer ( TokenObtainPairSerializer ) : \n captcha = serializers . CharField ( \n max_length = <NUM_LIT> , required = False , allow_null = True , allow_blank = True \n ) \n class Meta : \n model = Users \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } \n def validate ( self , attrs ) : \n captcha = self . initial_data . get ( \"<STR_LIT>\" , None ) \n if dispatch . get_system_config_values ( \"<STR_LIT>\" ) : \n if captcha is None : \n raise CustomValidationError ( \"<STR_LIT>\" ) \n self . image_code = CaptchaStore . objects . filter ( \n id = self . initial_data [ \"<STR_LIT>\" ] \n ) . first ( ) \n five_minute_ago = datetime . now ( ) - timedelta ( hours = <NUM_LIT> , minutes = <NUM_LIT> , seconds = <NUM_LIT> ) \n if self . image_code and five_minute_ago > self . image_code . expiration :", "output": "self . image_code and self . image_code . delete ( ) \n raise CustomValidationError ( \"<STR_LIT>\" ) \n else : \n if self . image_code and ( \n self . image_code . response == captcha \n or self . image_code . challenge == captcha \n ) : \n self . image_code and self . image_code . delete ( ) \n else : \n self . image_code and self . image_code . delete ( ) \n raise CustomValidationError ( \"<STR_LIT>\" ) \n user = Users . objects . get ( username = attrs [ '<STR_LIT>' ] ) \n if not user . is_active : \n raise CustomValidationError ( \"<STR_LIT>\" ) \n data = super ( ) . validate ( attrs ) \n data [ \"<STR_LIT>\" ] = self . user . name \n data [ \"<STR_LIT>\" ] = self . user . id \n data [ \"<STR_LIT>\" ] = self . user . avatar \n data [ '<STR_LIT>' ] = self . user . user_type \n dept = getattr ( self . user , '<STR_LIT>' , None ) \n if dept : \n data [ '<STR_LIT>' ] = { \n '<STR_LIT>' : dept . id , \n '<STR_LIT>' : dept . name , \n } \n role = getattr ( self . user , '<STR_LIT>' , None ) \n if role : \n data [ '<STR_LIT>' ] = role . values ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) \n request = self . context . get ( \"<STR_LIT>\" ) \n request . user = self . user \n save_login_log ( request = request ) \n return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } \n class LoginView ( TokenObtainPairView ) : \n serializer_class = LoginSerializer \n permission_classes = [ ] \n class LoginTokenSerializer ( TokenObtainPairSerializer ) : \n class Meta : \n model = Users \n fields = \"<STR_LIT>\" \n read_only_fields = [ \"<STR_LIT>\" ] \n default_error_messages = { \"<STR_LIT>\" : _ ( \"<STR_LIT>\" ) } \n def validate ( self , attrs ) : \n if not getattr ( settings , \"<STR_LIT>\" , False ) : \n return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : None } \n data = super ( ) . validate ( attrs ) \n data [ \"<STR_LIT>\" ] = self . user . name \n data [ \"<STR_LIT>\" ] = self . user . id \n return { \"<STR_LIT>\" : <NUM_LIT> , \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : data } \n class LoginTokenView ( TokenObtainPairView ) : \n serializer_class = LoginTokenSerializer \n permission_classes = [ ] \n class LogoutView ( APIView ) : \n def post ( self , request ) : \n return DetailResponse ( msg = \"<STR_LIT>\" ) \n class ApiLoginSerializer ( CustomModelSerializer ) : \n username = serializers . CharField ( ) \n password = serializers . CharField ( ) \n class Meta : \n model = Users \n fields = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] \n class ApiLogin ( APIView ) : \n serializer_class = ApiLoginSerializer \n authentication_classes = [ ] \n permission_classes = [ ] \n def post ( self , request ) : \n username = request . data . get ( \"<STR_LIT>\" ) \n password = request . data . get ( \"<STR_LIT>\" ) \n user_obj = auth . authenticate ( \n request , \n username = username , \n password = hashlib . md5 ( password . encode ( encoding = \"<STR_LIT>\" ) ) . hexdigest ( ) , \n ) \n if user_obj : \n login ( request , user_obj ) \n return redirect ( \"<STR_LIT>\" ) \n else : \n return ErrorResponse ( msg = \"<STR_LIT>\" )"}, {"input": "import os \n from application . settings import BASE_DIR \n DATABASE_ENGINE = \"<STR_LIT>\" \n DATABASE_NAME = '<STR_LIT>' \n DATABASE_HOST = '<STR_LIT>' \n DATABASE_PORT = <NUM_LIT> \n DATABASE_USER = \"<STR_LIT>\" \n DATABASE_PASSWORD = \"<STR_LIT>\" \n TABLE_PREFIX = \"<STR_LIT>\"", "output": "REDIS_PASSWORD = '<STR_LIT>' \n REDIS_HOST = '<STR_LIT>' \n REDIS_URL = f'<STR_LIT>' \n DEBUG = True \n ENABLE_LOGIN_ANALYSIS_LOG = True \n LOGIN_NO_CAPTCHA_AUTH = True \n ALLOWED_HOSTS = [ \"<STR_LIT>\" ] \n COLUMN_EXCLUDE_APPS = [ ]"}, {"input": "from django . db import DataError \n from rest_framework . exceptions import APIException \n from rest_framework . validators import UniqueValidator", "output": "class CustomValidationError ( APIException ) : \n def __init__ ( self , detail ) : \n self . detail = detail \n def qs_exists ( queryset ) : \n try : \n return queryset . exists ( ) \n except ( TypeError , ValueError , DataError ) : \n return False \n def qs_filter ( queryset , ** kwargs ) : \n try : \n return queryset . filter ( ** kwargs ) \n except ( TypeError , ValueError , DataError ) : \n return queryset . none ( ) \n class CustomUniqueValidator ( UniqueValidator ) : \n def filter_queryset ( self , value , queryset , field_name ) : \n filter_kwargs = { '<STR_LIT>' % ( field_name , self . lookup ) : value } \n return qs_filter ( queryset , ** filter_kwargs ) \n def exclude_current_instance ( self , queryset , instance ) : \n if instance is not None : \n return queryset . exclude ( pk = instance . pk ) \n return queryset \n def __call__ ( self , value , serializer_field ) : \n field_name = serializer_field . source_attrs [ - <NUM_LIT> ] \n instance = getattr ( serializer_field . parent , '<STR_LIT>' , None ) \n queryset = self . queryset \n queryset = self . filter_queryset ( value , queryset , field_name ) \n queryset = self . exclude_current_instance ( queryset , instance ) \n if qs_exists ( queryset ) : \n raise CustomValidationError ( self . message ) \n def __repr__ ( self ) : \n return super ( ) . __repr__ ( )"}, {"input": "import os \n import sys \n def main ( ) : \n os . environ . setdefault ( '<STR_LIT>' , '<STR_LIT>' )", "output": "try : \n from django . core . management import execute_from_command_line \n except ImportError as exc : \n raise ImportError ( \n \"<STR_LIT>\" \n \"<STR_LIT>\" \n \"<STR_LIT>\" \n ) from exc \n execute_from_command_line ( sys . argv ) \n if __name__ == '<STR_LIT>' : \n main ( )"}]