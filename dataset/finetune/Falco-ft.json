[{"input": "from pathlib import Path \n BASE_DIR = Path ( __file__ ) . resolve ( ) . parent . parent \n SECRET_KEY = \"<STR_LIT>\" \n DEBUG = True \n ALLOWED_HOSTS = [ ] \n AUTH_USER_MODEL = \"<STR_LIT>\" \n INSTALLED_APPS = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n MIDDLEWARE = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n ROOT_URLCONF = \"<STR_LIT>\" \n TEMPLATES = [ \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : [ BASE_DIR / \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : True , \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] , \n } , \n } , \n ] \n WSGI_APPLICATION = \"<STR_LIT>\" \n DATABASES = { \n \"<STR_LIT>\" : { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : BASE_DIR / \"<STR_LIT>\" , \n } \n } \n AUTH_PASSWORD_VALIDATORS = [ \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } ,", "output": "{ \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } , \n ] \n LANGUAGE_CODE = \"<STR_LIT>\" \n TIME_ZONE = \"<STR_LIT>\" \n USE_I18N = True \n USE_TZ = True \n STATIC_URL = \"<STR_LIT>\" \n DEFAULT_AUTO_FIELD = \"<STR_LIT>\" \n CRISPY_ALLOWED_TEMPLATE_PACKS = \"<STR_LIT>\" \n CRISPY_TEMPLATE_PACK = \"<STR_LIT>\" \n SUPERUSER_EMAIL = \"<STR_LIT>\" \n SUPERUSER_PASSWORD = \"<STR_LIT>\""}, {"input": "import falco \n project = \"<STR_LIT>\" \n copyright = \"<STR_LIT>\" \n author = \"<STR_LIT>\" \n version = falco . falco_version \n release = version \n extensions = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n todo_include_todos = True \n extlinks = { \n \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n \"<STR_LIT>\" : ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n } \n templates_path = [ \"<STR_LIT>\" ] \n exclude_patterns = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n html_theme = \"<STR_LIT>\" \n html_static_path = [ \"<STR_LIT>\" ] \n html_baseurl = \"<STR_LIT>\" \n html_title = \"<STR_LIT>\" \n html_context = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n html_theme_options = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : <NUM_LIT> , \n } \n html_logo = \"<STR_LIT>\" \n html_favicon = \"<STR_LIT>\" \n html_css_files = [ \n \"<STR_LIT>\" ,", "output": "] \n html_js_files = [ \n ( \n \"<STR_LIT>\" , \n { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } , \n ) , \n \"<STR_LIT>\" , \n ] \n mermaid_version = \"<STR_LIT>\" \n mermaid_output_format = \"<STR_LIT>\""}, {"input": "import subprocess \n from contextlib import suppress \n import cappa", "output": "def clean_git_repo ( * , ignore_dirty : bool = False ) -> None : \n if ignore_dirty : \n return \n with suppress ( subprocess . CalledProcessError ) : \n result = subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , capture_output = True , text = True , check = True ) \n if result . stdout . strip ( ) == \"<STR_LIT>\" : \n return \n raise cappa . Exit ( \n \"<STR_LIT>\" , \n code = <NUM_LIT> , \n )"}, {"input": "from pathlib import Path \n from typing import Annotated \n import cappa \n from falco . config import FalcoConfig \n from falco . config import read_falco_config \n from falco . config import write_falco_config \n from falco . utils import get_project_name \n from falco . utils import get_pyproject_file \n from falco . utils import simple_progress \n from rich import print as rich_print \n from . utils import extract_python_file_templates \n from . utils import get_crud_blueprints_path \n from . utils import render_to_string \n from . utils import run_python_formatters \n @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) \n class InstallCrudUtils : \n output_dir : Annotated [ \n Path | None ,", "output": "cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , \n ] = None \n def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : \n try : \n pyproject_path = get_pyproject_file ( ) \n falco_config = read_falco_config ( pyproject_path ) \n except cappa . Exit : \n falco_config = { } \n pyproject_path = None \n output_dir = self . install ( project_name = project_name , falco_config = falco_config ) \n if pyproject_path : \n write_falco_config ( pyproject_path = pyproject_path , crud = { \"<STR_LIT>\" : str ( output_dir ) } ) \n rich_print ( f\"<STR_LIT>\" ) \n def install ( self , project_name : str , falco_config : FalcoConfig ) -> Path : \n output_dir = self . output_dir or self . get_install_path ( project_name = project_name , falco_config = falco_config ) [ <NUM_LIT> ] \n output_dir . mkdir ( parents = True , exist_ok = True ) \n ( output_dir / \"<STR_LIT>\" ) . touch ( exist_ok = True ) \n generated_files = [ ] \n context = { \"<STR_LIT>\" : project_name } \n with simple_progress ( \"<STR_LIT>\" ) : \n for file_path in ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) : \n imports_template , code_template = extract_python_file_templates ( file_path . read_text ( ) ) \n filename = \"<STR_LIT>\" . join ( file_path . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) \n output_file = output_dir / filename \n output_file . touch ( exist_ok = True ) \n output_file . write_text ( \n render_to_string ( imports_template , context ) \n + render_to_string ( code_template , context ) \n + output_file . read_text ( ) \n ) \n generated_files . append ( output_file ) \n for file in generated_files : \n run_python_formatters ( str ( file ) ) \n return output_dir \n @ classmethod \n def get_install_path ( cls , project_name : str , falco_config : FalcoConfig ) -> tuple [ Path , bool ] : \n if _import_path := falco_config . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" ) : \n return Path ( _import_path ) , True \n return Path ( f\"<STR_LIT>\" ) , False"}, {"input": "from django . urls import path \n from . import views \n app_name = \"<STR_LIT>\"", "output": "urlpatterns = [ \n path ( \"<STR_LIT>\" , views . product_list , name = \"<STR_LIT>\" ) , \n path ( \"<STR_LIT>\" , views . product_create , name = \"<STR_LIT>\" ) , \n path ( \"<STR_LIT>\" , views . product_detail , name = \"<STR_LIT>\" ) , \n path ( \"<STR_LIT>\" , views . product_update , name = \"<STR_LIT>\" ) , \n path ( \"<STR_LIT>\" , views . product_delete , name = \"<STR_LIT>\" ) , \n ]"}, {"input": "from django . db import models \n class Order ( models . Model ) : \n name = models . CharField ( max_length = <NUM_LIT> ) \n email = models . EmailField ( ) \n address = models . CharField ( max_length = <NUM_LIT> ) \n postal_code = models . CharField ( max_length = <NUM_LIT> ) \n city = models . CharField ( max_length = <NUM_LIT> ) \n products = models . ManyToManyField ( \"<STR_LIT>\" ) \n created = models . DateTimeField ( auto_now_add = True )", "output": "completed = models . BooleanField ( default = False ) \n receipt = models . FileField ( null = True , blank = True ) \n image = models . ImageField ( null = True , blank = True )"}, {"input": "import os \n import secrets \n from pathlib import Path \n from typing import Annotated \n import cappa \n import tomlkit \n from falco . utils import get_project_name \n from rich import print as rich_print \n from rich . prompt import Prompt", "output": "@ cappa . command ( help = \"<STR_LIT>\" ) \n class SyncDotenv : \n fill_missing : Annotated [ \n bool , \n cappa . Arg ( \n False , \n short = \"<STR_LIT>\" , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] = False \n print_env : Annotated [ \n bool , \n cappa . Arg ( \n False , \n short = \"<STR_LIT>\" , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] = False \n def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : \n dotenv_file = Path ( \"<STR_LIT>\" ) \n dotenv_template_file = Path ( \"<STR_LIT>\" ) \n dotenv_content = dotenv_file . read_text ( ) if dotenv_file . exists ( ) else \"<STR_LIT>\" \n dotenv_template_content = dotenv_template_file . read_text ( ) if dotenv_template_file . exists ( ) else \"<STR_LIT>\" \n debug = os . getenv ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . lower ( ) == \"<STR_LIT>\" \n base_config = { \"<STR_LIT>\" : True } if debug else self . get_prod_config ( project_name ) \n config = { \n ** parse ( dotenv_template_content ) , \n ** base_config , \n ** parse ( dotenv_content ) , \n } \n if self . fill_missing : \n for key , value in config . items ( ) : \n if not value : \n config [ key . upper ( ) ] = Prompt . ask ( f\"<STR_LIT>\" ) \n dotenv_content = get_updated ( dotenv_content , config ) \n if self . print_env : \n rich_print ( dotenv_content ) \n return \n dotenv_file . touch ( exist_ok = True ) \n dotenv_file . write_text ( dotenv_content ) \n dotenv_template_content = get_updated ( \n dotenv_template_content , \n { key : \"<STR_LIT>\" for key in config } , \n keep_original = True , \n keep_whitespace = True , \n ) \n dotenv_template_file . touch ( exist_ok = True ) \n dotenv_template_file . write_text ( dotenv_template_content ) \n rich_print ( f\"<STR_LIT>\" ) \n def get_prod_config ( self , project_name : str ) -> dict : \n return { \n \"<STR_LIT>\" : False , \n \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : get_superuser_email ( project_name ) , \n \"<STR_LIT>\" : secrets . token_urlsafe ( <NUM_LIT> ) , \n } \n def get_superuser_email ( project_name : str ) : \n pyproject_file = Path ( \"<STR_LIT>\" ) \n if pyproject_file . exists ( ) : \n pyproject = tomlkit . parse ( pyproject_file . read_text ( ) ) \n if authors := pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , [ ] ) : \n return authors [ <NUM_LIT> ] [ \"<STR_LIT>\" ] \n return f\"<STR_LIT>\" \n def parse ( env_content : str ) -> dict : \n result = { } \n for line in env_content . split ( \"<STR_LIT>\" ) : \n stripped_line = line . strip ( ) \n if stripped_line . startswith ( \"<STR_LIT>\" ) or not stripped_line : \n continue \n try : \n key , value = stripped_line . split ( \"<STR_LIT>\" , <NUM_LIT> ) \n except ValueError as e : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) from e \n result [ key ] = value \n return result \n def get_updated ( env_content : str , config : dict , * , keep_original = False , keep_whitespace = False ) -> str : \n content_list = env_content . split ( \"<STR_LIT>\" ) \n content_dict = { line . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] : line for line in content_list if \"<STR_LIT>\" in line } \n new_content_list = content_list . copy ( ) \n for key , value in config . items ( ) : \n line = content_dict . get ( key ) \n if line is not None : \n index = new_content_list . index ( line ) \n if not keep_original : \n new_content_list [ index ] = f\"<STR_LIT>\" \n else : \n new_content_list . append ( f\"<STR_LIT>\" ) \n if not keep_whitespace : \n new_content_list = [ line . strip ( ) for line in new_content_list if line . strip ( ) ] \n return \"<STR_LIT>\" . join ( new_content_list )"}, {"input": "import subprocess \n from pathlib import Path \n from typing import Annotated \n from typing import TypedDict \n import cappa \n import parso \n from falco import checks \n from falco . config import CRUDConfig \n from falco . config import read_falco_config \n from falco . utils import get_project_name \n from falco . utils import RICH_ERROR_MARKER \n from falco . utils import RICH_INFO_MARKER \n from falco . utils import RICH_SUCCESS_MARKER \n from falco . utils import run_in_shell \n from falco . utils import simple_progress \n from rich import print as rich_print \n from . install_crud_utils import InstallCrudUtils \n from . utils import extract_python_file_templates \n from . utils import get_crud_blueprints_path \n from . utils import render_to_string \n from . utils import run_html_formatters \n from . utils import run_python_formatters \n class DjangoField ( TypedDict ) : \n verbose_name : str \n editable : bool \n class_name : str \n accessor : str \n class DjangoModel ( TypedDict ) : \n name : str \n name_plural : str \n verbose_name : str \n verbose_name_plural : str \n fields : dict [ str , DjangoField ] \n has_file_field : bool \n has_editable_date_field : bool \n class PythonBlueprintContext ( TypedDict ) : \n project_name : str \n login_required : bool \n app_label : str \n model_name : str \n model_name_plural : str \n model_verbose_name_plural : str \n model_has_file_fields : bool \n model_has_editable_date_fields : bool \n model_fields : dict [ str , DjangoField ] \n crud_utils_import : str \n entry_point : bool \n class UrlsForContext ( TypedDict ) : \n list_view_url : str \n create_view_url : str \n detail_view_url : str \n update_view_url : str \n delete_view_url : str \n class HtmlBlueprintContext ( UrlsForContext ) : \n app_label : str \n model_name : str \n model_name_plural : str \n model_verbose_name : str \n model_verbose_name_plural : str \n model_has_file_fields : bool \n model_fields : dict [ str , DjangoField ] \n @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) \n class ModelCRUD : \n model_path : Annotated [ \n str , \n cappa . Arg ( \n help = \"<STR_LIT>\" \n ) , \n ] \n blueprints : Annotated [ \n str , \n cappa . Arg ( \n default = \"<STR_LIT>\" , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n excluded_fields : Annotated [ \n list [ str ] , \n cappa . Arg ( \n short = True , \n default = [ ] , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n only_python : Annotated [ \n bool , \n cappa . Arg ( default = False , long = \"<STR_LIT>\" , help = \"<STR_LIT>\" ) , \n ] \n only_html : Annotated [ \n bool , \n cappa . Arg ( default = False , long = \"<STR_LIT>\" , help = \"<STR_LIT>\" ) , \n ] \n entry_point : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n login_required : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n short = \"<STR_LIT>\" , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n skip_git_check : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : \n pyproject_path = Path ( \"<STR_LIT>\" ) \n falco_config = read_falco_config ( pyproject_path = pyproject_path ) if pyproject_path . exists ( ) else { } \n crud_config : CRUDConfig = falco_config . get ( \"<STR_LIT>\" , { } ) \n self . blueprints = crud_config . get ( \"<STR_LIT>\" , self . blueprints ) \n self . login_required = crud_config . get ( \"<STR_LIT>\" , self . login_required ) \n self . skip_git_check = crud_config . get ( \"<STR_LIT>\" , self . skip_git_check ) \n checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) \n v = self . model_path . split ( \"<STR_LIT>\" ) \n if len ( v ) == <NUM_LIT> : \n name = None \n app_label = v [ <NUM_LIT> ] \n else : \n name = v . pop ( ) \n app_label = \"<STR_LIT>\" . join ( v ) \n if crud_config . get ( \"<STR_LIT>\" , False ) : \n commands = [ \n f\"<STR_LIT>\" , \n f\"<STR_LIT>\" , \n ] \n with simple_progress ( \"<STR_LIT>\" ) : \n for cmd in commands : \n result = subprocess . run ( cmd . split ( ) , capture_output = True , check = False , text = True ) \n if result . returncode != <NUM_LIT> : \n msg = result . stderr \n raise cappa . Exit ( \"<STR_LIT>\" + msg , code = <NUM_LIT> ) \n if self . entry_point and not name : \n raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) \n with simple_progress ( \"<STR_LIT>\" ) : \n all_django_models = run_in_shell ( \n get_models_data , \n app_label = app_label , \n excluded_fields = self . excluded_fields , \n entry_point = self . entry_point , \n ) \n app_folder_path_str , app_name , templates_dir_str = run_in_shell ( \n get_app_path_name_and_templates_dir , app_label = app_label \n ) \n app_folder_path = Path ( app_folder_path_str ) \n templates_dir = Path ( templates_dir_str ) \n django_models = ( \n [ m for m in all_django_models if m [ \"<STR_LIT>\" ] . lower ( ) == name . lower ( ) ] if name else all_django_models \n ) \n if name and not django_models : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) \n python_blueprint_context : list [ PythonBlueprintContext ] = [ ] \n html_blueprint_context : list [ HtmlBlueprintContext ] = [ ] \n install_path , crud_utils_installed = InstallCrudUtils . get_install_path ( \n project_name = project_name , \n falco_config = falco_config , \n ) \n crud_utils_import = str ( install_path ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n for django_model in django_models : \n python_blueprint_context . append ( \n get_python_blueprint_context ( \n project_name = project_name , \n app_label = app_label , \n django_model = django_model , \n crud_utils_import = crud_utils_import , \n login_required = self . login_required , \n entry_point = self . entry_point , \n ) \n ) \n html_blueprint_context . append ( get_html_blueprint_context ( app_label = app_label , django_model = django_model ) ) \n updated_python_files = set ( ) \n if not self . only_html : \n python_blueprints = list ( ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) ) \n updated_python_files . update ( \n self . generate_python_code ( \n app_label = app_label , \n blueprints = python_blueprints , \n app_folder_path = app_folder_path , \n contexts = python_blueprint_context , \n entry_point = self . entry_point , \n ) \n ) \n updated_python_files . update ( \n self . generating_urls ( \n app_name = app_name , \n app_folder_path = app_folder_path , \n app_label = app_label , \n django_models = django_models , \n entry_point = self . entry_point , \n ) \n ) \n updated_html_files = set ( ) \n if not self . only_python : \n html_blueprints = ( \n list ( Path ( self . blueprints ) . glob ( \"<STR_LIT>\" ) ) \n if self . blueprints \n else list ( ( get_crud_blueprints_path ( ) / \"<STR_LIT>\" ) . iterdir ( ) ) \n ) \n updated_html_files . update ( \n self . generate_html_templates ( \n contexts = html_blueprint_context , \n entry_point = self . entry_point , \n blueprints = html_blueprints , \n templates_dir = templates_dir , \n ) \n ) \n for file in updated_python_files : \n run_python_formatters ( str ( file ) ) \n for file in updated_html_files : \n run_html_formatters ( str ( file ) ) \n display_names = \"<STR_LIT>\" . join ( m . get ( \"<STR_LIT>\" ) for m in django_models ) \n rich_print ( f\"<STR_LIT>\" ) \n if not crud_utils_installed : \n rich_print ( \n f\"<STR_LIT>\" \n f\"<STR_LIT>\" \n ) \n @ simple_progress ( \"<STR_LIT>\" ) \n def generate_python_code ( \n self , \n app_label : str , \n app_folder_path : Path , \n blueprints : list [ Path ] , \n contexts : list [ \"<STR_LIT>\" ] , \n * , \n entry_point : bool , \n ) -> list [ Path ] : \n updated_files = [ ] \n for blueprint in blueprints : \n imports_template , code_template = extract_python_file_templates ( blueprint . read_text ( ) ) \n file_name_without_jinja = \"<STR_LIT>\" . join ( blueprint . name . split ( \"<STR_LIT>\" ) [ : - <NUM_LIT> ] ) \n file_to_write_to = app_folder_path / file_name_without_jinja \n file_to_write_to . touch ( exist_ok = True ) \n imports_content , code_content = \"<STR_LIT>\" , \"<STR_LIT>\" \n for context in contexts : \n model_name_lower = context [ \"<STR_LIT>\" ] . lower ( ) \n imports_content += render_to_string ( imports_template , context ) \n code_content += render_to_string ( code_template , context ) \n if entry_point : \n code_content = code_content . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) \n code_content = code_content . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n file_to_write_to . write_text ( imports_content + file_to_write_to . read_text ( ) + code_content ) \n updated_files . append ( file_to_write_to ) \n model_name = contexts [ <NUM_LIT> ] [ \"<STR_LIT>\" ] if len ( contexts ) == <NUM_LIT> else None \n updated_files . append ( \n register_models_in_admin ( \n app_folder_path = app_folder_path , \n app_label = app_label , \n model_name = model_name , \n ) \n ) \n return updated_files \n @ simple_progress ( \"<STR_LIT>\" ) \n def generating_urls ( \n self , \n app_folder_path : Path , \n app_label : str , \n app_name : str , \n django_models : list [ \"<STR_LIT>\" ] , \n * , \n entry_point : bool , \n ) -> list [ Path ] : \n urls_content = \"<STR_LIT>\" \n for django_model in django_models : \n model_name_lower = django_model [ \"<STR_LIT>\" ] . lower ( ) \n urlsafe_model_verbose_name_plural = django_model [ \"<STR_LIT>\" ] . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n urls_content += get_urls ( \n model_name_lower = model_name_lower , \n urlsafe_model_verbose_name_plural = urlsafe_model_verbose_name_plural , \n ) \n if entry_point : \n urls_content = urls_content . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) \n urls_content = urls_content . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n urls_content = urls_content . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) \n app_urls = app_folder_path / \"<STR_LIT>\" \n updated_files = [ app_urls ] \n if app_urls . exists ( ) : \n urlpatterns = f\"<STR_LIT>\" \n app_urls . write_text ( app_urls . read_text ( ) + urlpatterns ) \n else :", "output": "app_urls . touch ( ) \n app_urls . write_text ( initial_urls_content ( app_label , urls_content ) ) \n updated_files . append ( register_app_urls ( app_label = app_label , app_name = app_name ) ) \n return updated_files \n @ simple_progress ( \"<STR_LIT>\" ) \n def generate_html_templates ( \n self , \n templates_dir : Path , \n blueprints : list [ Path ] , \n contexts : list [ \"<STR_LIT>\" ] , \n * , \n entry_point : bool , \n ) -> list [ Path ] : \n updated_files = [ ] \n templates_dir . mkdir ( exist_ok = True , parents = True ) \n for blueprint in blueprints : \n filecontent = blueprint . read_text ( ) \n for context in contexts : \n model_name_lower = context [ \"<STR_LIT>\" ] . lower ( ) \n new_filename = f\"<STR_LIT>\" \n if entry_point : \n new_filename = blueprint . name . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n if new_filename . startswith ( \"<STR_LIT>\" ) : \n new_filename = new_filename . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n file_to_write_to = templates_dir / new_filename \n file_to_write_to . touch ( exist_ok = True ) \n views_content = render_to_string ( filecontent , context = context ) \n if entry_point : \n views_content = views_content . replace ( f\"<STR_LIT>\" , \"<STR_LIT>\" ) \n views_content = views_content . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n file_to_write_to . write_text ( views_content ) \n updated_files . append ( file_to_write_to ) \n return updated_files \n def get_urls ( model_name_lower : str , urlsafe_model_verbose_name_plural : str ) -> str : \n prefix = urlsafe_model_verbose_name_plural \n return \n def get_urls_template_string ( app_label : str , model_name_lower : str ) -> UrlsForContext : \n return { \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n } \n def initial_urls_content ( app_label : str , urls_content : str ) -> str : \n return \n def register_app_urls ( app_label : str , app_name : str ) -> Path : \n root_url = run_in_shell ( get_root_url_config_path , eval_result = False ) \n root_url = root_url . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n rool_url_path = Path ( f\"<STR_LIT>\" ) \n module = parso . parse ( rool_url_path . read_text ( ) ) \n new_path = parso . parse ( f\"<STR_LIT>\" ) \n for node in module . children : \n try : \n if ( \n node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type \n and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value == \"<STR_LIT>\" \n ) : \n patterns = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] \n elements = patterns . children [ <NUM_LIT> ] \n elements . children . append ( new_path ) \n new_content = module . get_code ( ) \n new_content = \"<STR_LIT>\" + new_content \n rool_url_path . write_text ( new_content ) \n break \n except AttributeError : \n continue \n return rool_url_path \n def register_models_in_admin ( app_folder_path : Path , app_label : str , model_name : str | None = None ) -> Path : \n admin_file = app_folder_path / \"<STR_LIT>\" \n admin_file . touch ( exist_ok = True ) \n cmd_args = [ app_label ] \n if model_name : \n cmd_args . append ( model_name ) \n result = subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , * cmd_args ] , \n capture_output = True , \n text = True , \n check = False , \n ) \n if result . returncode != <NUM_LIT> : \n msg = result . stderr . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] \n rich_print ( f\"<STR_LIT>\" ) \n return admin_file \n admin_code = result . stdout . split ( \"<STR_LIT>\" , <NUM_LIT> ) [ <NUM_LIT> ] \n admin_file . write_text ( admin_file . read_text ( ) + admin_code ) \n if not model_name : \n return admin_file \n admin_lines = admin_file . read_text ( ) . split ( \"<STR_LIT>\" ) \n _imports = [ ] \n _code = [ ] \n for line in admin_lines : \n if line . startswith ( \"<STR_LIT>\" ) : \n _imports . append ( line ) \n else : \n _code . append ( line ) \n admin_file . write_text ( \"<STR_LIT>\" + \"<STR_LIT>\" . join ( _imports ) + \"<STR_LIT>\" + \"<STR_LIT>\" . join ( _code ) ) \n return admin_file \n def get_python_blueprint_context ( \n project_name : str , \n app_label : str , \n django_model : DjangoModel , \n crud_utils_import : str , \n * , \n login_required : bool , \n entry_point : bool , \n ) -> PythonBlueprintContext : \n model_fields = django_model [ \"<STR_LIT>\" ] \n model_name = django_model [ \"<STR_LIT>\" ] \n return { \n \"<STR_LIT>\" : project_name , \n \"<STR_LIT>\" : app_label , \n \"<STR_LIT>\" : login_required , \n \"<STR_LIT>\" : model_name , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : model_fields , \n \"<STR_LIT>\" : crud_utils_import , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : entry_point , \n } \n def get_html_blueprint_context ( app_label : str , django_model : DjangoModel ) -> HtmlBlueprintContext : \n return { \n \"<STR_LIT>\" : app_label , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n \"<STR_LIT>\" : django_model [ \"<STR_LIT>\" ] , \n ** get_urls_template_string ( \n app_label = app_label , \n model_name_lower = django_model [ \"<STR_LIT>\" ] . lower ( ) , \n ) , \n } \n def get_models_data ( app_label : str , excluded_fields : list [ str ] , * , entry_point : bool ) -> \"<STR_LIT>\" : \n from django . apps import apps \n models = apps . get_app_config ( app_label ) . get_models ( ) \n file_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n dates_fields = ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n def get_model_dict ( model ) -> \"<STR_LIT>\" : \n name = model . __name__ \n name_lower = name . lower ( ) \n if entry_point : \n name_plural = app_label . lower ( ) \n else : \n name_plural = f\"<STR_LIT>\" if name . endswith ( \"<STR_LIT>\" ) else f\"<STR_LIT>\" \n verbose_name = model . _meta . verbose_name \n verbose_name_plural = model . _meta . verbose_name_plural \n fields : dict [ str , \"<STR_LIT>\" ] = { \n field . name : { \n \"<STR_LIT>\" : field . verbose_name , \n \"<STR_LIT>\" : field . editable , \n \"<STR_LIT>\" : field . __class__ . __name__ , \n \"<STR_LIT>\" : \"<STR_LIT>\" \n f\"<STR_LIT>\" + ( \"<STR_LIT>\" if field . __class__ . __name__ in file_fields else \"<STR_LIT>\" ) , \n } \n for field in model . _meta . fields \n if field . name not in excluded_fields \n } \n return { \n \"<STR_LIT>\" : name , \n \"<STR_LIT>\" : name_plural , \n \"<STR_LIT>\" : fields , \n \"<STR_LIT>\" : verbose_name , \n \"<STR_LIT>\" : verbose_name_plural , \n \"<STR_LIT>\" : any ( f [ \"<STR_LIT>\" ] in file_fields for f in fields . values ( ) ) , \n \"<STR_LIT>\" : any ( f [ \"<STR_LIT>\" ] in dates_fields and f [ \"<STR_LIT>\" ] for f in fields . values ( ) ) , \n } \n return [ get_model_dict ( model ) for model in models ] \n def get_app_path_name_and_templates_dir ( app_label : str ) -> tuple [ str , str , str ] : \n from django . apps import apps \n from django . conf import settings \n from pathlib import Path \n app = apps . get_app_config ( app_label ) \n dirs = settings . TEMPLATES [ <NUM_LIT> ] . get ( \"<STR_LIT>\" , [ ] ) \n templates_dir = Path ( dirs [ <NUM_LIT> ] ) if dirs else Path ( app . path ) / \"<STR_LIT>\" \n app_templates_dir = templates_dir / app_label \n return str ( app . path ) , str ( app . name ) , str ( app_templates_dir ) \n def get_root_url_config_path ( ) -> str : \n from django . conf import settings \n return settings . ROOT_URLCONF"}, {"input": "import os \n import subprocess \n from unittest . mock import MagicMock \n from unittest . mock import patch \n import pytest \n from cappa . testing import CommandRunner \n from falco . __main__ import Falco \n @ pytest . fixture ( autouse = True ) \n def change_test_dir ( monkeypatch , tmp_path ) : \n monkeypatch . chdir ( tmp_path ) \n @ pytest . fixture \n def runner ( ) : \n return CommandRunner ( Falco ) \n @ pytest . fixture \n def django_project ( tmp_path ) : \n project_dir = tmp_path / \"<STR_LIT>\" \n subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) \n os . chdir ( project_dir ) \n subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = True ) \n model_code = \n ( project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" ) . write_text ( model_code ) \n settings_file = project_dir / \"<STR_LIT>\" / \"<STR_LIT>\" \n settings_content = settings_file . read_text ( ) \n settings_file . write_text ( settings_content + \"<STR_LIT>\" + \"<STR_LIT>\" ) \n ( project_dir / \"<STR_LIT>\" ) . write_text ( \n ) \n yield project_dir \n os . chdir ( tmp_path ) \n @ pytest . fixture", "output": "def set_git_repo_to_clean ( ) : \n def mock_run ( args , ** kwargs ) : \n if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : \n mock = MagicMock ( ) \n mock . returncode = <NUM_LIT> \n mock . stdout = \"<STR_LIT>\" \n return mock \n return original_run ( args , ** kwargs ) \n original_run = subprocess . run \n with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : \n yield \n @ pytest . fixture \n def pyproject_toml ( tmp_path ) : \n pyproject_toml = tmp_path / \"<STR_LIT>\" \n pyproject_toml . write_text ( \n ) \n yield pyproject_toml \n pyproject_toml . unlink ( ) \n @ pytest . fixture \n def git_user_infos ( ) : \n name = \"<STR_LIT>\" \n email = \"<STR_LIT>\" \n def mock_run ( args , ** kwargs ) : \n if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : \n mock = MagicMock ( ) \n mock . returncode = <NUM_LIT> \n mock . stdout = name \n return mock \n if args == [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] : \n mock = MagicMock ( ) \n mock . returncode = <NUM_LIT> \n mock . stdout = email \n return mock \n return original_run ( args , ** kwargs ) \n original_run = subprocess . run \n with patch ( \"<STR_LIT>\" , side_effect = mock_run ) : \n yield name , email"}, {"input": "from pathlib import Path \n root_dir = Path ( __file__ ) . parent . parent \n readme = root_dir / \"<STR_LIT>\" \n guides = root_dir / \"<STR_LIT>\" \n guides_index = guides / \"<STR_LIT>\" \n def get_rst_doc_title ( file : Path ) : \n title = \"<STR_LIT>\" \n for line in file . read_text ( ) . splitlines ( ) : \n if line . startswith ( \"<STR_LIT>\" ) : \n break \n title = line \n return title \n def guides_files ( ) : \n index_content = guides_index . read_text ( ) \n toc_tree_directive = \"<STR_LIT>\" \n start_index = index_content . find ( toc_tree_directive ) + len ( toc_tree_directive ) \n def valid_line ( line ) : \n return bool ( line ) and not line . strip ( ) . startswith ( \"<STR_LIT>\" ) \n lines = [ line . strip ( ) for line in index_content [ start_index : ] . split ( \"<STR_LIT>\" ) if valid_line ( line ) ] \n return [ guides / f\"<STR_LIT>\" for line in lines ] \n def get_guides_list ( ) : \n guides_md = [ ] \n for file in guides_files ( ) : \n if file . name . startswith ( \"<STR_LIT>\" ) : \n continue \n link = f\"<STR_LIT>\" \n title = get_rst_doc_title ( file ) \n guides_md . append ( f\"<STR_LIT>\" ) \n return \"<STR_LIT>\" + \"<STR_LIT>\" . join ( guides_md ) + \"<STR_LIT>\" \n def update_readme ( start_comment , end_comment , new_content ) : \n text = readme . read_text ( ) \n start_index = text . find ( start_comment ) + len ( start_comment ) \n end_index = text . find ( end_comment ) \n new_content = text [ : start_index ] + new_content + text [ end_index : ] \n readme . write_text ( new_content ) \n def main ( ) : \n update_readme ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n get_guides_list ( ) ,", "output": ") \n print ( \"<STR_LIT>\" ) \n if __name__ == \"<STR_LIT>\" : \n main ( )"}, {"input": "import os \n import sys \n from pathlib import Path \n from typing import Annotated \n import cappa \n from falco . config import read_falco_config \n from honcho . manager import Manager \n from . sync_dotenv import parse as parse_dotenv \n default_server_cmd = \"<STR_LIT>\" \n default_address = \"<STR_LIT>\" \n @ cappa . command ( help = \"<STR_LIT>\" ) \n class Work : \n address : Annotated [ str , cappa . Arg ( default = default_address , help = \"<STR_LIT>\" ) ] = default_address \n def __call__ ( self ) -> None : \n commands = self . get_commands ( ) \n manager = Manager ( ) \n django_env = self . resolve_django_env ( ) \n for name , cmd in commands . items ( ) : \n manager . add_process ( name , cmd , env = django_env ) \n try : \n manager . loop ( ) \n finally : \n manager . terminate ( ) \n sys . exit ( manager . returncode ) \n def resolve_django_env ( self ) -> dict : \n current_dir = Path ( ) . resolve ( ) \n env_file = current_dir / \"<STR_LIT>\" \n env_vars = parse_dotenv ( env_file . read_text ( ) ) if env_file . exists ( ) else { }", "output": "return { \n ** os . environ , \n \"<STR_LIT>\" : str ( current_dir ) , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n ** env_vars , \n } \n def get_commands ( self ) -> dict : \n commands = { \"<STR_LIT>\" : default_server_cmd } \n pyproject_file = Path ( \"<STR_LIT>\" ) \n if pyproject_file . exists ( ) : \n user_commands = read_falco_config ( pyproject_path = pyproject_file ) . get ( \"<STR_LIT>\" , { } ) \n else : \n user_commands = { } \n commands |= user_commands \n commands [ \"<STR_LIT>\" ] = commands [ \"<STR_LIT>\" ] . format ( address = self . address ) \n return commands"}, {"input": "from django . db import migrations \n from django . db import models \n class Migration ( migrations . Migration ) : \n dependencies = [ \n ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n ] \n operations = [ \n migrations . AlterField ( \n model_name = \"<STR_LIT>\" ,", "output": "name = \"<STR_LIT>\" , \n field = models . BooleanField ( default = False ) , \n ) , \n ]"}, {"input": "import ast \n import inspect \n import subprocess \n from collections . abc import Callable \n from contextlib import contextmanager \n from pathlib import Path \n from typing import TypeVar \n import cappa \n import httpx \n import tomlkit \n from falco import falco_version \n from rich . progress import Progress \n from rich . progress import SpinnerColumn \n from rich . progress import TextColumn \n ReturnType = TypeVar ( \"<STR_LIT>\" ) \n RICH_SUCCESS_MARKER = \"<STR_LIT>\" \n RICH_ERROR_MARKER = \"<STR_LIT>\" \n RICH_INFO_MARKER = \"<STR_LIT>\" \n def clean_project_name ( val : str ) -> str : \n return val . strip ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n def get_pyproject_file ( ) -> Path : \n pyproject_path = Path ( \"<STR_LIT>\" ) \n if pyproject_path . exists ( ) : \n return pyproject_path \n raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) \n def get_project_name ( ) -> str : \n pyproject = tomlkit . parse ( get_pyproject_file ( ) . read_text ( ) ) \n return pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ]", "output": "@ contextmanager \n def simple_progress ( description : str , display_text = \"<STR_LIT>\" ) : \n progress = Progress ( SpinnerColumn ( ) , TextColumn ( display_text ) , transient = True ) \n progress . add_task ( description = description , total = None ) \n try : \n yield progress . start ( ) \n finally : \n progress . stop ( ) \n @ contextmanager \n def network_request_with_progress ( url : str , description : str ) : \n try : \n with simple_progress ( description ) : \n yield httpx . get ( url ) \n except httpx . ConnectError as e : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) from e \n class ShellCodeError ( Exception ) : \n pass \n def run_in_shell ( func : Callable [ ... , ReturnType ] , * , eval_result : bool = True , ** kwargs ) -> ReturnType : \n source = inspect . getsource ( func ) \n arguments_list = [ ] \n for k , v in kwargs . items ( ) : \n if isinstance ( v , str ) : \n arguments_list . append ( f\"<STR_LIT>\" ) \n else : \n arguments_list . append ( f\"<STR_LIT>\" ) \n arguments = \"<STR_LIT>\" . join ( arguments_list ) \n func_call = f\"<STR_LIT>\" \n code = f\"<STR_LIT>\" \n result = subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , code ] , \n capture_output = True , \n text = True , \n check = False , \n ) \n if result . returncode != <NUM_LIT> : \n raise ShellCodeError ( result . stderr ) \n return ast . literal_eval ( result . stdout ) if eval_result else result . stdout . strip ( ) \n def is_new_falco_cli_available ( ) -> bool : \n try : \n with network_request_with_progress ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ) as response : \n latest_version = response . json ( ) [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] \n current_version = falco_version \n return latest_version != current_version \n except cappa . Exit : \n return False"}, {"input": "from __future__ import annotations \n from pathlib import Path \n from typing import Annotated \n import cappa \n from falco . config import read_falco_config \n from falco . config import write_falco_config \n from falco . utils import get_pyproject_file \n from falco . utils import network_request_with_progress \n from httpx import codes \n from rich import print as rich_print \n from rich . panel import Panel \n HTMX_DOWNLOAD_URL = \"<STR_LIT>\" \n HTMX_GH_RELEASE_LATEST_URL = \"<STR_LIT>\" \n HtmxConfig = tuple [ Path , str | None ] \n def get_latest_tag ( ) -> str : \n with network_request_with_progress ( HTMX_GH_RELEASE_LATEST_URL , \"<STR_LIT>\" ) as response : \n try : \n return response . json ( ) [ \"<STR_LIT>\" ] [ <NUM_LIT> : ] \n except KeyError as e : \n msg = ( \n \"<STR_LIT>\" \n \"<STR_LIT>\" \n ) \n raise cappa . Exit ( msg , code = <NUM_LIT> ) from e \n @ cappa . command ( help = \"<STR_LIT>\" ) \n class Htmx : \n version : Annotated [ str , cappa . Arg ( default = \"<STR_LIT>\" ) ] = \"<STR_LIT>\" \n output : Annotated [ Path | None , cappa . Arg ( default = None , short = \"<STR_LIT>\" , long = \"<STR_LIT>\" ) ] = None \n def __call__ ( self ) : \n latest_version = get_latest_tag ( ) \n version = self . version if self . version != \"<STR_LIT>\" else latest_version \n try : \n pyproject_path = get_pyproject_file ( ) \n falco_config = read_falco_config ( pyproject_path ) \n except cappa . Exit : \n falco_config = { } \n pyproject_path = None \n filepath = self . download ( version , falco_config = falco_config ) \n if pyproject_path : \n write_falco_config ( \n pyproject_path = pyproject_path , \n htmx = self . format_for_config ( filepath , version ) , \n ) \n subtitle = ( \n \"<STR_LIT>\" \n if version == latest_version \n else f\"<STR_LIT>\" \n ) \n rich_print ( \n Panel ( \n f\"<STR_LIT>\" , \n subtitle = subtitle , \n ) \n ) \n @ classmethod \n def format_for_config ( cls , filepath : Path , version : str | None ) -> str : \n return str ( filepath ) if version is None else f\"<STR_LIT>\" \n def download ( self , version : str , falco_config : dict ) -> Path : \n url = HTMX_DOWNLOAD_URL . format ( version = version ) \n with network_request_with_progress ( url , f\"<STR_LIT>\" ) as response : \n content = response . content . decode ( \"<STR_LIT>\" ) \n if response . status_code == codes . NOT_FOUND : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) \n filepath = self . resolve_filepath ( falco_config = falco_config ) \n filepath . parent . mkdir ( parents = True , exist_ok = True ) \n filepath . write_text ( content ) \n return filepath", "output": "def resolve_filepath ( self , falco_config : dict ) -> Path : \n if self . output : \n filepath = self . output if str ( self . output ) . endswith ( \"<STR_LIT>\" ) else self . output / \"<STR_LIT>\" \n elif self . output is None and \"<STR_LIT>\" in falco_config : \n htmx_config = self . read_from_config ( falco_config ) \n filepath , _ = htmx_config \n else : \n filepath = Path ( \"<STR_LIT>\" ) \n return filepath \n @ classmethod \n def read_from_config ( cls , falco_config : dict ) -> HtmxConfig : \n htmx = falco_config . get ( \"<STR_LIT>\" ) \n if not htmx : \n return Path ( \"<STR_LIT>\" ) , None \n try : \n filepath , version = htmx . split ( \"<STR_LIT>\" ) \n except ValueError : \n return Path ( htmx ) , None \n return Path ( filepath ) , version"}, {"input": "from __future__ import annotations \n import os \n import secrets \n import shutil \n import subprocess \n from contextlib import contextmanager \n from contextlib import suppress \n from pathlib import Path \n from typing import Annotated \n import cappa \n import httpx \n from cookiecutter . config import get_user_config \n from cookiecutter . exceptions import CookiecutterException \n from cookiecutter . main import cookiecutter \n from falco . commands import InstallCrudUtils \n from falco . commands . crud . utils import run_html_formatters \n from falco . commands . htmx import get_latest_tag as htmx_latest_tag \n from falco . commands . htmx import Htmx \n from falco . config import read_falco_config \n from falco . config import write_falco_config \n from falco . utils import clean_project_name \n from falco . utils import is_new_falco_cli_available \n from falco . utils import RICH_INFO_MARKER \n from falco . utils import RICH_SUCCESS_MARKER \n from falco . utils import simple_progress \n from rich import print as rich_print \n from rich . prompt import Prompt \n DEFAULT_SKIP = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n @ cappa . command ( help = \"<STR_LIT>\" ) \n class StartProject : \n project_name : Annotated [ \n str , \n cappa . Arg ( parse = clean_project_name , help = \"<STR_LIT>\" ) , \n ] \n directory : Annotated [ Path | None , cappa . Arg ( help = \"<STR_LIT>\" ) ] = None \n is_root : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n short = \"<STR_LIT>\" , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] = False \n skip_new_version_check : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] = False \n blueprint : Annotated [ \n str , \n cappa . Arg ( \n default = \"<STR_LIT>\" , \n long = \"<STR_LIT>\" , \n short = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] = \"<STR_LIT>\" \n local : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n long = \"<STR_LIT>\" , \n short = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] = False \n checkout : Annotated [ str | None , cappa . Arg ( default = None , long = \"<STR_LIT>\" , short = \"<STR_LIT>\" , hidden = True ) ] = None \n def __call__ ( self ) -> None : \n if self . is_root and not self . directory : \n raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) \n if not self . skip_new_version_check and is_new_falco_cli_available ( ) : \n message = ( \n f\"<STR_LIT>\" \n f\"<STR_LIT>\" \n ) \n rich_print ( message ) \n response = Prompt . ask ( \n f\"<STR_LIT>\" , \n default = \"<STR_LIT>\" , \n ) \n if response . lower ( ) == \"<STR_LIT>\" : \n rich_print ( \n f\"<STR_LIT>\" \n f\"<STR_LIT>\" \n ) \n raise cappa . Exit ( code = <NUM_LIT> ) \n with simple_progress ( \"<STR_LIT>\" ) : \n self . blueprint , revision = resolve_blueprint ( self . blueprint , use_local = self . local ) \n project_dir = self . init_project ( ) \n with change_directory ( project_dir ) : \n pyproject_path = Path ( \"<STR_LIT>\" ) \n falco_config = read_falco_config ( pyproject_path ) \n crud_utils = InstallCrudUtils ( ) . install ( project_name = self . project_name , falco_config = falco_config ) \n env_file = Path ( \"<STR_LIT>\" ) \n env_file . touch ( ) \n env_file . write_text ( \"<STR_LIT>\" ) \n config = { \n \"<STR_LIT>\" : { \"<STR_LIT>\" : str ( crud_utils ) } , \n \"<STR_LIT>\" : revision , \n \"<STR_LIT>\" : DEFAULT_SKIP , \n \"<STR_LIT>\" : self . blueprint , \n } \n if not self . local : \n with suppress ( cappa . Exit , httpx . TimeoutException , httpx . ConnectError ) : \n version = htmx_latest_tag ( ) \n filepath = Htmx ( ) . download ( version = htmx_latest_tag ( ) , falco_config = falco_config ) \n config [ \"<STR_LIT>\" ] = Htmx . format_for_config ( filepath , version ) \n write_falco_config ( pyproject_path = pyproject_path , ** config ) \n run_html_formatters ( project_dir / self . project_name / \"<STR_LIT>\" ) \n msg = f\"<STR_LIT>\" \n msg += ( \n f\"<STR_LIT>\" \n f\"<STR_LIT>\" \n ) \n rich_print ( msg ) \n def init_project ( self ) -> Path : \n author_name , author_email = get_authors_info ( ) \n with simple_progress ( \"<STR_LIT>\" ) : \n try : \n project_dir = cookiecutter ( \n self . blueprint , \n no_input = True , \n output_dir = self . directory or Path ( ) , \n checkout = self . checkout , \n extra_context = { \n \"<STR_LIT>\" : self . project_name , \n \"<STR_LIT>\" : author_name , \n \"<STR_LIT>\" : author_email , \n \"<STR_LIT>\" : f\"<STR_LIT>\" , \n } , \n ) \n except CookiecutterException as e : \n msg = str ( e ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n raise cappa . Exit ( msg , code = <NUM_LIT> ) from e \n if self . is_root : \n renamed_project_dir = self . directory / \"<STR_LIT>\" \n shutil . move ( project_dir , renamed_project_dir ) \n for obj in Path ( renamed_project_dir ) . iterdir ( ) : \n shutil . move ( obj , self . directory ) \n renamed_project_dir . rmdir ( ) \n project_dir = self . directory \n return Path ( project_dir ) \n def find_local_cookiecutter ( repo : str ) -> Path | None : \n repo_name = repo . split ( \"<STR_LIT>\" ) [ - <NUM_LIT> ] . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n cookiecutters_dir = Path ( get_user_config ( ) [ \"<STR_LIT>\" ] ) \n if not cookiecutters_dir . exists ( ) : \n return None \n for directory in cookiecutters_dir . iterdir ( ) : \n if not directory . is_dir ( ) : \n continue \n is_empty = not list ( directory . iterdir ( ) ) \n if directory . is_dir ( ) and not is_empty and directory . name == repo_name : \n return directory \n return None \n def resolve_blueprint ( blueprint : str , * , use_local : bool = False ) -> tuple [ str , str ] : \n name_to_urls = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n repo = name_to_urls . get ( blueprint , blueprint ) \n if repo . startswith ( \"<STR_LIT>\" ) and use_local : \n if local_repo := find_local_cookiecutter ( repo ) : \n repo = str ( local_repo . resolve ( ) ) \n else : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) \n result = subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , repo , \"<STR_LIT>\" ] , \n capture_output = True , \n text = True , \n check = False , \n ) \n if result . returncode != <NUM_LIT> : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) \n revision = result . stdout . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( ) [ <NUM_LIT> ] . strip ( ) \n return repo , revision \n def get_authors_info ( ) -> tuple [ str , str ] : \n default_author_name = \"<STR_LIT>\" \n default_author_email = \"<STR_LIT>\" \n git_config_cmd = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n try : \n user_name_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) \n user_email_cmd = subprocess . run ( [ * git_config_cmd , \"<STR_LIT>\" ] , capture_output = True , text = True , check = False ) \n except FileNotFoundError : \n return default_author_name , default_author_email \n if user_email_cmd . returncode != <NUM_LIT> : \n return default_author_name , default_author_email \n return ( \n user_name_cmd . stdout . strip ( \"<STR_LIT>\" ) , \n user_email_cmd . stdout . strip ( \"<STR_LIT>\" ) , \n ) \n @ contextmanager \n def change_directory ( new_directory : str | Path ) :", "output": "current_directory = Path . cwd ( ) \n try : \n os . chdir ( new_directory ) \n yield \n finally : \n os . chdir ( current_directory )"}, {"input": "import pathlib \n from tempfile import TemporaryDirectory \n from falco . commands import StartProject \n from rich . console import Console \n from rich . markup import escape \n from rich . terminal_theme import DIMMED_MONOKAI \n from rich . text import Text \n from rich . tree import Tree \n def walk_directory ( directory : pathlib . Path , tree : Tree ) -> None : \n paths = sorted ( \n pathlib . Path ( directory ) . iterdir ( ) , \n key = lambda path : ( path . is_file ( ) , path . name . lower ( ) ) , \n ) \n for path in paths :", "output": "if path . is_dir ( ) : \n style = \"<STR_LIT>\" if path . name . startswith ( \"<STR_LIT>\" ) else \"<STR_LIT>\" \n branch = tree . add ( \n f\"<STR_LIT>\" , \n style = style , \n guide_style = style , \n ) \n walk_directory ( path , branch ) \n else : \n text_filename = Text ( path . name , \"<STR_LIT>\" ) \n text_filename . highlight_regex ( r\"<STR_LIT>\" , \"<STR_LIT>\" ) \n text_filename . stylize ( f\"<STR_LIT>\" ) \n icon = \"<STR_LIT>\" if path . suffix == \"<STR_LIT>\" else \"<STR_LIT>\" \n tree . add ( Text ( icon ) + text_filename ) \n def main ( ) : \n tree = Tree ( \n \"<STR_LIT>\" \n ) \n with TemporaryDirectory ( ) as temp : \n temp_dir = pathlib . Path ( temp ) \n StartProject ( \n project_name = \"<STR_LIT>\" , \n directory = temp_dir . resolve ( ) , \n is_root = True , \n skip_new_version_check = True , \n ) ( ) \n walk_directory ( temp_dir , tree ) \n console = Console ( record = True ) \n with console . capture ( ) : \n console . print ( tree ) \n console . save_svg ( \n \"<STR_LIT>\" , \n title = \"<STR_LIT>\" , \n theme = DIMMED_MONOKAI , \n ) \n if __name__ == \"<STR_LIT>\" : \n main ( )"}, {"input": "import io \n import os \n from pathlib import Path \n from unittest . mock import patch \n import tomlkit \n from cappa . testing import CommandRunner \n def test_sync_dotenv ( runner : CommandRunner , pyproject_toml ) : \n runner . invoke ( \"<STR_LIT>\" ) \n env_file = Path ( \"<STR_LIT>\" ) \n env_template_file = Path ( \"<STR_LIT>\" ) \n assert env_file . exists ( ) \n assert env_template_file . exists ( ) \n assert \"<STR_LIT>\" in env_file . read_text ( ) \n assert \"<STR_LIT>\" in env_template_file . read_text ( ) \n def test_sync_dotenv_update_files ( runner : CommandRunner , pyproject_toml ) : \n env_file = Path ( \"<STR_LIT>\" ) \n env_template_file = Path ( \"<STR_LIT>\" ) \n env_file . write_text ( \"<STR_LIT>\" ) \n env_template_file . write_text ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" ) \n assert \"<STR_LIT>\" in env_file . read_text ( ) \n assert \"<STR_LIT>\" in env_template_file . read_text ( ) \n def test_sync_dotenv_priority ( runner : CommandRunner , pyproject_toml ) : \n env_file = Path ( \"<STR_LIT>\" ) \n env_template_file = Path ( \"<STR_LIT>\" ) \n env_file . write_text ( \"<STR_LIT>\" ) \n env_template_file . write_text ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" ) \n assert \"<STR_LIT>\" in env_file . read_text ( ) \n def test_print_value ( runner : CommandRunner , pyproject_toml ) : \n env_template_file = Path ( \"<STR_LIT>\" ) \n env_template_file . write_text ( \"<STR_LIT>\" ) \n with patch ( \"<STR_LIT>\" , new = io . StringIO ( ) ) as fake_stdout : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n stdout = fake_stdout . getvalue ( ) \n assert not Path ( \"<STR_LIT>\" ) . exists ( ) \n assert \"<STR_LIT>\" in stdout \n def test_prod_config ( runner : CommandRunner , pyproject_toml ) : \n os . environ [ \"<STR_LIT>\" ] = \"<STR_LIT>\" \n pyproject = tomlkit . parse ( pyproject_toml . read_text ( ) ) \n pyproject [ \"<STR_LIT>\" ] [ \"<STR_LIT>\" ] = [ { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } ] \n pyproject_toml . write_text ( tomlkit . dumps ( pyproject ) ) \n runner . invoke ( \"<STR_LIT>\" )", "output": "assert \"<STR_LIT>\" in Path ( \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" in Path ( \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" in Path ( \"<STR_LIT>\" ) . read_text ( )"}, {"input": "from functools import wraps \n from django . core . paginator import InvalidPage \n from django . core . paginator import Paginator \n from django . db . models import QuerySet \n from django . http import Http404 \n from django . http import HttpResponse \n from django . template . loader import render_to_string \n from django . utils . translation import gettext_lazy as _ \n from . types import HttpRequest \n def paginate_queryset ( request : HttpRequest , queryset : QuerySet , page_size : int = <NUM_LIT> ) : \n paginator = Paginator ( queryset , page_size ) \n page_number = request . GET . get ( \"<STR_LIT>\" ) or <NUM_LIT> \n try : \n page_number = int ( page_number ) \n except ValueError as e : \n if page_number == \"<STR_LIT>\" : \n page_number = paginator . num_pages \n else : \n msg = \"<STR_LIT>\" \n raise Http404 ( _ ( msg ) ) from e \n try : \n return paginator . page ( page_number ) \n except InvalidPage as exc : \n msg = \"<STR_LIT>\" \n raise Http404 ( _ ( msg ) % ( page_number , str ( exc ) ) ) from exc \n def for_htmx ( \n * , \n if_hx_target : str | None = None , \n use_template : str | None = None , \n use_partial : str | list [ str ] | None = None , \n use_partial_from_params : bool = False , \n ) : \n if len ( [ p for p in [ use_partial , use_template , use_partial_from_params ] if p ] ) != <NUM_LIT> : \n raise ValueError ( \"<STR_LIT>\" ) \n def decorator ( view ) : \n @ wraps ( view ) \n def _view ( request : HttpRequest , * args , ** kwargs ) :", "output": "resp = view ( request , * args , ** kwargs ) \n if not request . htmx : \n return resp \n apply_decorator = if_hx_target is None or request . headers . get ( \"<STR_LIT>\" , None ) == if_hx_target \n if not apply_decorator : \n return resp \n partials_to_use = use_partial \n if not hasattr ( resp , \"<STR_LIT>\" ) : \n if not resp . content and any ( \n h in resp . headers \n for h in ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ) \n ) : \n return resp \n raise ValueError ( \"<STR_LIT>\" ) \n if resp . is_rendered : \n raise ValueError ( \"<STR_LIT>\" ) \n if use_partial_from_params : \n use_partial_from_params_val = _get_param_from_request ( request , \"<STR_LIT>\" ) \n if use_partial_from_params_val is not None : \n partials_to_use = use_partial_from_params_val \n if use_template is not None : \n resp . template_name = use_template \n elif partials_to_use is not None : \n if not isinstance ( partials_to_use , list ) : \n partials_to_use = [ partials_to_use ] \n rendered_partials = [ \n render_to_string ( f\"<STR_LIT>\" , context = resp . context_data , request = request ) \n for b in partials_to_use \n ] \n resp = HttpResponse ( \n content = \"<STR_LIT>\" . join ( rendered_partials ) , \n status = resp . status_code , \n headers = resp . headers , \n ) \n return resp \n return _view \n return decorator \n def _get_param_from_request ( request , param ) : \n if param in request . GET : \n return request . GET . getlist ( param ) \n if request . method == \"<STR_LIT>\" and param in request . POST : \n return request . POST . getlist ( param ) \n return None"}, {"input": "from django . db import migrations \n from django . db import models \n class Migration ( migrations . Migration ) : \n initial = True \n dependencies = [ \n ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n ] \n operations = [ \n migrations . CreateModel ( \n name = \"<STR_LIT>\" , \n fields = [ \n ( \n \"<STR_LIT>\" , \n models . BigAutoField ( \n auto_created = True , \n primary_key = True , \n serialize = False , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , \n ( \"<STR_LIT>\" , models . EmailField ( max_length = <NUM_LIT> ) ) , \n ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) ,", "output": "( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , \n ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> ) ) , \n ( \"<STR_LIT>\" , models . ManyToManyField ( to = \"<STR_LIT>\" ) ) , \n ] , \n ) , \n ]"}, {"input": "import subprocess \n from pathlib import Path \n from typing import Annotated \n import cappa \n import parso \n from falco . commands . crud . utils import run_python_formatters \n from falco . utils import get_project_name \n from falco . utils import run_in_shell \n from falco . utils import simple_progress \n def get_settings_file_path ( ) -> str : \n from django . conf import settings \n s = settings . SETTINGS_MODULE \n s = s . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n return f\"<STR_LIT>\" \n @ cappa . command ( help = \"<STR_LIT>\" ) \n class StartApp : \n app_name : Annotated [ str , cappa . Arg ( help = \"<STR_LIT>\" ) ] \n def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : \n apps_dir = Path ( ) / project_name \n app_dir = apps_dir / self . app_name \n final_app_name = f\"<STR_LIT>\" \n try : \n app_dir . mkdir ( ) \n except FileExistsError as e : \n msg = f\"<STR_LIT>\" \n raise cappa . Exit ( msg , code = <NUM_LIT> ) from e \n with simple_progress ( f\"<STR_LIT>\" ) : \n result = subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , self . app_name , app_dir ] , \n capture_output = True , \n text = True , \n check = False , \n ) \n if result . returncode != <NUM_LIT> : \n msg = result . stderr . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n raise cappa . Exit ( msg , code = <NUM_LIT> ) \n ( app_dir / \"<STR_LIT>\" ) . unlink ( ) \n model_name = self . app_name [ : - <NUM_LIT> ] . capitalize ( ) if self . app_name . endswith ( \"<STR_LIT>\" ) else self . app_name . capitalize ( ) \n models_file = app_dir / \"<STR_LIT>\" \n models_file . write_text ( \n ) \n ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) \n ( app_dir / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) \n app_config_file = app_dir / \"<STR_LIT>\" \n app_config_file . write_text ( app_config_file . read_text ( ) . replace ( self . app_name , final_app_name ) ) \n run_python_formatters ( models_file ) \n run_python_formatters ( self . register_app ( app_name = final_app_name ) ) \n @ simple_progress ( \"<STR_LIT>\" ) \n def register_app ( self , app_name : str ) -> Path : \n names = [ \"<STR_LIT>\" , \"<STR_LIT>\" ] \n settings_file = Path ( run_in_shell ( get_settings_file_path , eval_result = False ) ) \n module = parso . parse ( settings_file . read_text ( ) ) \n for node in module . children :", "output": "try : \n if ( \n node . children [ <NUM_LIT> ] . type == parso . python . tree . ExprStmt . type \n and node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] . value in names \n ) : \n apps = node . children [ <NUM_LIT> ] . children [ <NUM_LIT> ] \n elements = apps . children [ <NUM_LIT> ] \n elements . children . append ( parso . parse ( f\"<STR_LIT>\" ) ) \n new_content = module . get_code ( ) \n settings_file . write_text ( new_content ) \n break \n except AttributeError : \n continue \n return settings_file"}, {"input": "import subprocess \n from pathlib import Path \n import cappa \n import pytest \n from cappa . testing import CommandRunner \n def makemigaration ( ) : \n subprocess . run ( [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , check = False ) \n def test_rm_migrations ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n apps_dir = Path ( ) \n makemigaration ( ) \n first_migration = apps_dir / \"<STR_LIT>\" \n assert first_migration . exists ( ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert not first_migration . exists ( ) \n def test_rm_migrations_fake_apps_dir ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n apps_dir = Path ( ) \n makemigaration ( ) \n first_migration = apps_dir / \"<STR_LIT>\" \n assert first_migration . exists ( ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert first_migration . exists ( ) \n def test_rm_migrations_not_clean_repo ( django_project , runner : CommandRunner ) :", "output": "with pytest . raises ( cappa . Exit ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" )"}, {"input": "from pathlib import Path \n from cappa . testing import CommandRunner \n from falco . config import write_falco_config \n def test_htmx_ext_download ( runner : CommandRunner ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n def test_htmx_ext_download_to_output_dir ( runner : CommandRunner ) : \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) \n assert ( output / \"<STR_LIT>\" ) . exists ( ) \n def test_htmx_ext_download_to_output_file ( runner : CommandRunner ) : \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) \n assert output . exists ( ) \n def test_htmx_ext_file_existing_config ( runner : CommandRunner ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert output . exists ( ) \n def test_htmx_ext_download_to_output_file_existing_config ( runner : CommandRunner ) :", "output": "pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert not output . exists ( ) \n assert Path ( \"<STR_LIT>\" ) . exists ( )"}, {"input": "from django . db import migrations \n from django . db import models \n class Migration ( migrations . Migration ) : \n dependencies = [ \n ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n ] \n operations = [ \n migrations . AddField ( \n model_name = \"<STR_LIT>\" , \n name = \"<STR_LIT>\" , \n field = models . DateTimeField ( blank = True , null = True ) , \n ) , \n migrations . AddField ( \n model_name = \"<STR_LIT>\" , \n name = \"<STR_LIT>\" , \n field = models . ImageField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , \n ) , \n migrations . AddField ( \n model_name = \"<STR_LIT>\" , \n name = \"<STR_LIT>\" ,", "output": "field = models . FileField ( blank = True , null = True , upload_to = \"<STR_LIT>\" ) , \n ) , \n ]"}, {"input": "from pathlib import Path \n from unittest . mock import patch \n import pytest \n from cappa . testing import CommandRunner \n from falco . commands . htmx import Htmx \n from falco . config import read_falco_config \n from falco . config import write_falco_config \n @ pytest . fixture ( autouse = True ) \n def mock_latest_tag_getter ( ) : \n def _get_latest_tag ( ) : \n return \"<STR_LIT>\" \n with patch ( \"<STR_LIT>\" , new = _get_latest_tag ) : \n yield \n def test_htmx_download ( runner : CommandRunner ) : \n runner . invoke ( \"<STR_LIT>\" ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n def test_htmx_download_with_version ( runner : CommandRunner ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert Path ( \"<STR_LIT>\" ) . exists ( )", "output": "def test_htmx_download_with_specific_version ( runner : CommandRunner ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n def test_htmx_download_to_output_dir ( runner : CommandRunner ) : \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) \n assert ( output / \"<STR_LIT>\" ) . exists ( ) \n def test_htmx_download_to_output_file ( runner : CommandRunner ) : \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , str ( output . resolve ( ) ) ) \n assert output . exists ( ) \n def test_htmx_with_pyproject_toml ( runner : CommandRunner ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml ) \n runner . invoke ( \"<STR_LIT>\" ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) \n assert filepath == Path ( \"<STR_LIT>\" ) \n def test_htmx_with_pyproject_toml_custom_folder ( runner : CommandRunner ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n output = Path ( \"<STR_LIT>\" ) \n assert output . exists ( ) \n filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) \n assert filepath == output \n def test_htmx_with_pyproject_toml_custom_file ( runner : CommandRunner ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n output = Path ( \"<STR_LIT>\" ) \n assert output . exists ( ) \n filepath , version = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) \n assert filepath == output \n def test_htmx_with_pyproject_toml_custom_file_existing_config ( runner : CommandRunner ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml , htmx = \"<STR_LIT>\" ) \n existing_path = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" ) \n filepath , _ = Htmx . read_from_config ( read_falco_config ( pyproject_toml ) ) \n assert filepath == existing_path \n assert existing_path . exists ( )"}, {"input": "import pytest \n from falco . commands . work import default_address \n from falco . commands . work import default_server_cmd \n from falco . commands . work import Work \n from falco . config import write_falco_config \n def test_env_resolution ( tmp_path ) : \n assert Work ( ) . resolve_django_env ( ) \n def test_env_resolution_with_env ( tmp_path ) : \n ( tmp_path / \"<STR_LIT>\" ) . write_text ( \"<STR_LIT>\" ) \n assert \"<STR_LIT>\" in Work ( ) . resolve_django_env ( ) \n def test_without_pyproject_file ( ) :", "output": "assert Work ( ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) } \n def test_with_pyproject_file ( pyproject_toml ) : \n write_falco_config ( pyproject_path = pyproject_toml , work = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) \n assert Work ( ) . get_commands ( ) == { \n \"<STR_LIT>\" : default_server_cmd . format ( address = default_address ) , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n } \n def test_override_server ( pyproject_toml ) : \n work = { \"<STR_LIT>\" : \"<STR_LIT>\" , \"<STR_LIT>\" : \"<STR_LIT>\" } \n write_falco_config ( pyproject_path = pyproject_toml , work = work ) \n assert Work ( ) . get_commands ( ) == work \n @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) \n def test_override_server_through_arg ( address ) : \n assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : default_server_cmd . format ( address = address ) } \n @ pytest . mark . parametrize ( \"<STR_LIT>\" , [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] ) \n def test_override_server_through_arg_by_pyproject ( pyproject_toml , address ) : \n work = { \"<STR_LIT>\" : \"<STR_LIT>\" } \n write_falco_config ( pyproject_path = pyproject_toml , work = work ) \n assert Work ( address = address ) . get_commands ( ) == { \"<STR_LIT>\" : work [ \"<STR_LIT>\" ] . format ( address = address ) }"}, {"input": "import django . utils . timezone \n from django . db import migrations \n from django . db import models \n class Migration ( migrations . Migration ) : \n dependencies = [ \n ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n ] \n operations = [ \n migrations . AddField ( \n model_name = \"<STR_LIT>\" , \n name = \"<STR_LIT>\" , \n field = models . DateTimeField ( auto_now_add = True , default = django . utils . timezone . now ) , \n preserve_default = False ,", "output": ") , \n ]"}, {"input": "import subprocess \n from pathlib import Path \n from typing import Annotated \n import cappa \n from falco . utils import get_project_name \n from falco . utils import run_in_shell \n from falco . utils import simple_progress \n from rich import print as rich_print \n from . rm_migrations import RmMigrations \n def reset_migrations_table ( ) -> None : \n from django . db import connection \n with connection . cursor ( ) as cursor : \n cursor . execute ( \"<STR_LIT>\" ) \n @ cappa . command ( help = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) \n class ResetMigrations : \n apps_dir : Annotated [ \n Path | None , \n cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , \n ] \n skip_git_check : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) : \n with simple_progress ( \"<STR_LIT>\" ) : \n result = subprocess . run (", "output": "[ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n check = False , \n capture_output = True , \n text = True , \n ) \n if result . returncode != <NUM_LIT> : \n raise cappa . Exit ( code = <NUM_LIT> ) \n RmMigrations ( skip_git_check = self . skip_git_check , apps_dir = self . apps_dir ) ( project_name ) \n with simple_progress ( \"<STR_LIT>\" ) : \n run_in_shell ( reset_migrations_table , eval_result = False ) \n subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n check = True , \n stdout = subprocess . DEVNULL , \n stderr = subprocess . DEVNULL , \n ) \n subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n check = True , \n stdout = subprocess . DEVNULL , \n stderr = subprocess . DEVNULL , \n ) \n rich_print ( \"<STR_LIT>\" )"}, {"input": "import subprocess \n from pathlib import Path \n import cappa \n import pytest \n from cappa . testing import CommandRunner \n from falco . config import write_falco_config \n views_functions = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n html_templates = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n views_functions_entry_point = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n html_templates_point = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n ] \n forms_attributes = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n admin_attributes = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n def create_pyproject_crud_config ( ** kwargs ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n pyproject_toml . touch ( ) \n write_falco_config ( pyproject_path = pyproject_toml , crud = kwargs ) \n def healthy_django_project ( ) -> bool : \n result = subprocess . run ( \n [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] , \n check = False , \n capture_output = True , \n text = True , \n ) \n return result . returncode == <NUM_LIT> \n def fix_users_import ( ) : \n types = Path ( \"<STR_LIT>\" ) \n types . write_text ( types . read_text ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) \n def install_crud_utils ( runner ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n fix_users_import ( ) \n def test_crud ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for a in forms_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for a in admin_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for f in views_functions : \n assert f in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates : \n assert ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_all_models ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for a in forms_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for a in admin_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for f in views_functions : \n assert f in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates : \n assert ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_login ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for a in forms_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for a in admin_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for f in views_functions : \n assert f in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates : \n assert ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_entry_point ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for a in forms_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for a in admin_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for f in views_functions_entry_point : \n assert f in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates_point : \n assert ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_entry_point_login ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for a in forms_attributes :", "output": "assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for a in admin_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for f in views_functions_entry_point : \n assert f in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates_point : \n assert ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_only_html ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert not ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n assert not ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for f in views_functions : \n assert f not in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates : \n assert ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_only_python ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert ( app_dir / \"<STR_LIT>\" ) . exists ( ) \n for a in forms_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for a in admin_attributes : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for f in views_functions : \n assert f in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n for t in html_templates : \n assert not ( app_dir / \"<STR_LIT>\" / \"<STR_LIT>\" / f\"<STR_LIT>\" ) . exists ( ) \n def test_crud_repo_not_clean ( django_project , runner : CommandRunner ) : \n with pytest . raises ( cappa . Exit ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n def test_crud_exclude_field ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n app_dir = Path ( \"<STR_LIT>\" ) \n assert \"<STR_LIT>\" not in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" not in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" not in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n forms_attributes_ = [ \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ] \n for a in forms_attributes_ : \n assert a in ( app_dir / \"<STR_LIT>\" ) . read_text ( ) \n def test_crud_login_required ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n views = ( Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" in views \n assert \"<STR_LIT>\" in views \n def test_crud_config_pyproject_skip_git_check_set ( django_project , runner : CommandRunner ) : \n create_pyproject_crud_config ( skip_git_check = True ) \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n views = ( Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" in views \n def test_crud_config_pyproject_login_required ( django_project , runner : CommandRunner ) : \n create_pyproject_crud_config ( skip_git_check = True , login_required = True ) \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n views = ( Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" ) . read_text ( ) \n assert \"<STR_LIT>\" in views \n assert \"<STR_LIT>\" in views \n def test_crud_config_pyproject_blueprints ( django_project , runner : CommandRunner ) : \n bp = django_project / \"<STR_LIT>\" \n bp . mkdir ( ) \n html_file = bp / \"<STR_LIT>\" \n html_file . touch ( ) \n html_file . write_text ( \"<STR_LIT>\" ) \n create_pyproject_crud_config ( blueprints = str ( Path ( \"<STR_LIT>\" ) ) , skip_git_check = True ) \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n views = ( Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" ) . read_text ( ) \n rendered_file = Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" / \"<STR_LIT>\" / \"<STR_LIT>\" \n assert rendered_file . exists ( ) \n assert \"<STR_LIT>\" in rendered_file . read_text ( ) \n assert \"<STR_LIT>\" in views \n def test_crud_always_migrate ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n create_pyproject_crud_config ( always_migrate = True ) \n settings = django_project / \"<STR_LIT>\" / \"<STR_LIT>\" \n settings . write_text ( settings . read_text ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" ) \n install_crud_utils ( runner ) \n with pytest . raises ( cappa . Exit ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert \"<STR_LIT>\" not in Path ( \"<STR_LIT>\" ) . read_text ( ) \n assert not healthy_django_project ( ) \n def test_forms_dates_widgets ( django_project , runner : CommandRunner , set_git_repo_to_clean ) : \n install_crud_utils ( runner ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n models = django_project / \"<STR_LIT>\" / \"<STR_LIT>\" / \"<STR_LIT>\" \n models . write_text ( \n models . read_text ( ) \n + \"<STR_LIT>\" \n + \"<STR_LIT>\" \n + \"<STR_LIT>\" \n ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert healthy_django_project ( ) \n assert \"<STR_LIT>\" not in ( django_project / \"<STR_LIT>\" / \"<STR_LIT>\" ) . read_text ( ) \n forms = django_project / \"<STR_LIT>\" / \"<STR_LIT>\" / \"<STR_LIT>\" \n assert \"<STR_LIT>\" in forms . read_text ( ) \n assert \"<STR_LIT>\" in forms . read_text ( ) \n assert \"<STR_LIT>\" in forms . read_text ( ) \n assert \"<STR_LIT>\" in forms . read_text ( )"}, {"input": "import django . utils . timezone \n from django . db import migrations \n from django . db import models \n class Migration ( migrations . Migration ) : \n initial = True \n dependencies = [ ] \n operations = [ \n migrations . CreateModel ( \n name = \"<STR_LIT>\" , \n fields = [ \n ( \n \"<STR_LIT>\" ,", "output": "models . BigAutoField ( \n auto_created = True , \n primary_key = True , \n serialize = False , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , \n ( \"<STR_LIT>\" , models . TextField ( ) ) , \n ( \"<STR_LIT>\" , models . DecimalField ( decimal_places = <NUM_LIT> , max_digits = <NUM_LIT> ) ) , \n ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , unique = True ) ) , \n ( \"<STR_LIT>\" , models . DateTimeField ( default = django . utils . timezone . now ) ) , \n ] , \n ) , \n ]"}, {"input": "import importlib \n import subprocess \n from pathlib import Path \n import cappa \n from falco . utils import simple_progress \n from jinja2 import Template \n IMPORT_START_COMMENT = \"<STR_LIT>\" \n IMPORT_END_COMMENT = \"<STR_LIT>\" \n CODE_START_COMMENT = \"<STR_LIT>\" \n CODE_END_COMMENT = \"<STR_LIT>\" \n def render_to_string ( template_content : str , context : dict ) : \n return Template ( template_content ) . render ( ** context ) \n def get_crud_blueprints_path ( ) -> Path : \n package = importlib . util . find_spec ( \"<STR_LIT>\" ) \n if package is None : \n raise cappa . Exit ( \"<STR_LIT>\" , code = <NUM_LIT> ) \n return Path ( package . submodule_search_locations [ <NUM_LIT> ] ) / \"<STR_LIT>\" \n @ simple_progress ( \"<STR_LIT>\" ) \n def run_python_formatters ( filepath : str | Path ) : \n autoflake = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n filepath , \n ] \n black = [ \"<STR_LIT>\" , filepath ] \n isort = [ \"<STR_LIT>\" , filepath ]", "output": "subprocess . run ( autoflake , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) \n subprocess . run ( isort , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) \n subprocess . run ( black , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) \n @ simple_progress ( \"<STR_LIT>\" ) \n def run_html_formatters ( filepath : str | Path ) : \n djlint = [ \"<STR_LIT>\" , filepath , \"<STR_LIT>\" ] \n subprocess . run ( djlint , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL , check = False ) \n def extract_python_file_templates ( file_content : str ) -> tuple [ str , str ] : \n imports_template = extract_content_from ( file_content , IMPORT_START_COMMENT , IMPORT_END_COMMENT ) \n code_template = extract_content_from ( file_content , CODE_START_COMMENT , CODE_END_COMMENT ) \n return imports_template , code_template \n def extract_content_from ( text : str , start_comment : str , end_comment : str ) : \n start_index = text . find ( start_comment ) + len ( start_comment ) \n end_index = text . find ( end_comment ) \n return text [ start_index : end_index ]"}, {"input": "from pathlib import Path \n from cappa . testing import CommandRunner \n from falco . config import write_falco_config \n def test_install_crud_utils ( runner : CommandRunner , pyproject_toml ) : \n runner . invoke ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n def test_install_crud_utils_to_output_dir ( runner : CommandRunner , pyproject_toml ) : \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" , str ( output . resolve ( ) ) ) \n assert ( output / \"<STR_LIT>\" ) . exists ( ) \n assert ( output / \"<STR_LIT>\" ) . exists ( ) \n assert ( output / \"<STR_LIT>\" ) . exists ( ) \n def test_install_crud_utils_to_existing_config ( runner : CommandRunner , pyproject_toml ) : \n pyproject_toml = Path ( \"<STR_LIT>\" ) \n write_falco_config ( pyproject_path = pyproject_toml , crud = { \"<STR_LIT>\" : \"<STR_LIT>\" } ) \n output = Path ( \"<STR_LIT>\" ) \n runner . invoke ( \"<STR_LIT>\" ) \n assert ( output / \"<STR_LIT>\" ) . exists ( ) \n assert ( output / \"<STR_LIT>\" ) . exists ( )", "output": "assert ( output / \"<STR_LIT>\" ) . exists ( )"}, {"input": "from pathlib import Path \n from typing import cast \n from typing import TypedDict \n import tomlkit \n from typing_extensions import Unpack \n class FalcoConfig ( TypedDict , total = False ) : \n revision : str \n blueprint : str \n skip : list [ str ] \n work : dict [ str , str ] \n htmx : str \n crud : \"<STR_LIT>\" \n class CRUDConfig ( TypedDict ) : \n blueprints : str \n utils_path : str \n login_required : bool \n skip_git_check : bool \n always_migrate : bool \n def parse_crud_config_from_pyproject ( values : dict ) -> dict : \n return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } \n def parse_crud_config_to_pyproject ( values : dict ) -> dict : \n return { key . lower ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) : value for key , value in values . items ( ) } \n def write_falco_config ( pyproject_path : Path , ** kwargs : Unpack [ TypedDict ] ) -> None : \n new_falco_config = kwargs \n new_crud_config = parse_crud_config_to_pyproject ( new_falco_config . pop ( \"<STR_LIT>\" , { } ) ) \n pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) \n existing_falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) \n existing_crud_config = existing_falco_config . pop ( \"<STR_LIT>\" , { } ) \n existing_crud_config . update ( new_crud_config ) \n existing_falco_config . update ( { ** new_falco_config , \"<STR_LIT>\" : existing_crud_config } ) \n tool = pyproject . get ( \"<STR_LIT>\" , { } )", "output": "tool . update ( { \"<STR_LIT>\" : existing_falco_config } ) \n pyproject [ \"<STR_LIT>\" ] = tool \n pyproject_path . write_text ( tomlkit . dumps ( pyproject ) ) \n def read_falco_config ( pyproject_path : Path ) -> FalcoConfig : \n pyproject = tomlkit . parse ( pyproject_path . read_text ( ) ) \n falco_config = pyproject . get ( \"<STR_LIT>\" , { } ) . get ( \"<STR_LIT>\" , { } ) \n crud_config = falco_config . pop ( \"<STR_LIT>\" , { } ) \n crud_config = parse_crud_config_from_pyproject ( crud_config ) \n return cast ( FalcoConfig , { ** falco_config , \"<STR_LIT>\" : crud_config } )"}, {"input": "import django . contrib . auth . models \n import django . contrib . auth . validators \n import django . utils . timezone \n from django . db import migrations \n from django . db import models \n class Migration ( migrations . Migration ) : \n initial = True \n dependencies = [ \n ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , \n ] \n operations = [ \n migrations . CreateModel ( \n name = \"<STR_LIT>\" , \n fields = [ \n ( \n \"<STR_LIT>\" , \n models . BigAutoField ( \n auto_created = True , \n primary_key = True , \n serialize = False , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \"<STR_LIT>\" , models . CharField ( max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) ) , \n ( \n \"<STR_LIT>\" , \n models . DateTimeField ( blank = True , null = True , verbose_name = \"<STR_LIT>\" ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . BooleanField ( \n default = False , \n help_text = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . CharField ( \n error_messages = { \"<STR_LIT>\" : \"<STR_LIT>\" } , \n help_text = \"<STR_LIT>\" , \n max_length = <NUM_LIT> , \n unique = True , \n validators = [ django . contrib . auth . validators . UnicodeUsernameValidator ( ) ] , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , \n ) , \n (", "output": "\"<STR_LIT>\" , \n models . CharField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . EmailField ( blank = True , max_length = <NUM_LIT> , verbose_name = \"<STR_LIT>\" ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . BooleanField ( \n default = False , \n help_text = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . BooleanField ( \n default = True , \n help_text = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . DateTimeField ( default = django . utils . timezone . now , verbose_name = \"<STR_LIT>\" ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . ManyToManyField ( \n blank = True , \n help_text = \"<STR_LIT>\" , \n related_name = \"<STR_LIT>\" , \n related_query_name = \"<STR_LIT>\" , \n to = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ( \n \"<STR_LIT>\" , \n models . ManyToManyField ( \n blank = True , \n help_text = \"<STR_LIT>\" , \n related_name = \"<STR_LIT>\" , \n related_query_name = \"<STR_LIT>\" , \n to = \"<STR_LIT>\" , \n verbose_name = \"<STR_LIT>\" , \n ) , \n ) , \n ] , \n options = { \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : \"<STR_LIT>\" , \n \"<STR_LIT>\" : False , \n } , \n managers = [ \n ( \"<STR_LIT>\" , django . contrib . auth . models . UserManager ( ) ) , \n ] , \n ) , \n ]"}, {"input": "import os \n import sys \n def main ( ) : \n os . environ . setdefault ( \"<STR_LIT>\" , \"<STR_LIT>\" ) \n try : \n from django . core . management import execute_from_command_line \n except ImportError as exc : \n raise ImportError ( \n \"<STR_LIT>\" \n \"<STR_LIT>\" \n \"<STR_LIT>\"", "output": ") from exc \n execute_from_command_line ( sys . argv ) \n if __name__ == \"<STR_LIT>\" : \n main ( )"}, {"input": "from pathlib import Path \n from cappa . testing import CommandRunner \n from falco . config import read_falco_config \n def all_files_are_correctly_generated ( project_name , project_dir : Path ) -> bool : \n required_files = [ \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n f\"<STR_LIT>\" , \n f\"<STR_LIT>\" , \n f\"<STR_LIT>\" , \n ] \n return all ( ( project_dir / file ) . exists ( ) for file in required_files ) \n blueprint_path = Path ( \"<STR_LIT>\" ) . resolve ( strict = True ) \n def test_start_project ( runner : CommandRunner ) : \n runner . invoke ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n str ( blueprint_path ) , \n ) \n assert Path ( \"<STR_LIT>\" ) . exists ( ) \n config = read_falco_config ( Path ( \"<STR_LIT>\" ) ) \n config_keys = config . keys ( ) \n assert \"<STR_LIT>\" in config . get ( \"<STR_LIT>\" ) \n assert \"<STR_LIT>\" in config_keys \n assert \"<STR_LIT>\" in config_keys \n assert \"<STR_LIT>\" in config_keys \n assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = Path ( \"<STR_LIT>\" ) ) \n def test_start_project_in_directory ( runner : CommandRunner , tmp_path ) : \n runner . invoke ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n str ( blueprint_path ) , \n ) \n project_dir = tmp_path / \"<STR_LIT>\" / \"<STR_LIT>\" \n assert project_dir . exists ( ) \n assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) \n def test_start_project_in_directory_with_root ( runner : CommandRunner , tmp_path ) : \n runner . invoke ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n str ( blueprint_path ) , \n ) \n project_dir = tmp_path / \"<STR_LIT>\" \n assert project_dir . exists ( )", "output": "assert all_files_are_correctly_generated ( \"<STR_LIT>\" , project_dir = project_dir ) \n def test_user_name_and_email ( runner : CommandRunner , git_user_infos ) : \n name , email = git_user_infos \n runner . invoke ( \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n \"<STR_LIT>\" , \n str ( blueprint_path ) , \n ) \n pyproject_content = ( Path ( \"<STR_LIT>\" ) / \"<STR_LIT>\" ) . read_text ( ) \n assert name in pyproject_content \n assert email in pyproject_content"}, {"input": "from pathlib import Path \n from typing import Annotated \n import cappa \n from falco import checks \n from falco . utils import get_project_name \n from falco . utils import run_in_shell \n from falco . utils import simple_progress \n from rich import print as rich_print \n def get_django_debug_value ( ) -> bool : \n from django . conf import settings \n return settings . DEBUG \n @ cappa . command ( help = \"<STR_LIT>\" ) \n class RmMigrations : \n apps_dir : Annotated [ \n Path | None , \n cappa . Arg ( default = None , help = \"<STR_LIT>\" ) , \n ] \n skip_git_check : Annotated [ \n bool , \n cappa . Arg ( \n default = False , \n long = \"<STR_LIT>\" , \n help = \"<STR_LIT>\" , \n ) , \n ] \n def __call__ ( self , project_name : Annotated [ str , cappa . Dep ( get_project_name ) ] ) :", "output": "checks . clean_git_repo ( ignore_dirty = self . skip_git_check ) \n django_debug_value = run_in_shell ( get_django_debug_value , eval_result = True ) \n if not django_debug_value : \n raise cappa . Exit ( \n \"<STR_LIT>\" , \n code = <NUM_LIT> , \n ) \n if not self . apps_dir : \n self . apps_dir = Path ( ) / project_name \n apps = set ( ) \n with simple_progress ( \"<STR_LIT>\" ) : \n for folder in self . apps_dir . iterdir ( ) : \n migration_dir = folder / \"<STR_LIT>\" \n if not migration_dir . exists ( ) : \n continue \n apps . add ( folder . stem ) \n for file in migration_dir . iterdir ( ) : \n if file . suffix == \"<STR_LIT>\" and file . name not in [ \"<STR_LIT>\" ] : \n file . unlink ( ) \n apps_ = \"<STR_LIT>\" . join ( apps ) \n rich_print ( f\"<STR_LIT>\" )"}]