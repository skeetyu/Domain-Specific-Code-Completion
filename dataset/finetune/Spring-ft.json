[{"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class TextUtil extends StringUtils { public static final String EMPTY_STRING = \"<STR_LIT>\" ; public static String concatByComma ( String [ ] arr ) { if ( arr == null || arr . length == <NUM_LIT> ) { return EMPTY_STRING ; } return concatByComma ( Arrays . asList ( arr ) ) ; } public static String concatByComma ( List < String > strList ) { if ( strList == null ) { return EMPTY_STRING ; } StringBuilder result = new StringBuilder ( ) ; for ( String str : strList ) { result . append ( str ) ; result . append ( \"<STR_LIT>\" ) ; } result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; return result . toString ( ) ; } public static String [ ] splitByComma ( String value ) { if ( value == null ) { return null ; } return value . split ( \"<STR_LIT>\" ) ; } public static boolean isNumberWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isNumber ( String keyWord ) { int index = keyWord . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> ) { String num1 = keyWord . substring ( <NUM_LIT> , index ) ; String num2 = keyWord . substring ( index + <NUM_LIT> ) ; return org . apache . commons . lang3 . StringUtils . isNumeric ( num1 ) && org . apache . commons . lang3 . StringUtils . isNumeric ( num2 ) ; } else { return org . apache . commons . lang3 . StringUtils . isNumeric ( keyWord ) ; } } public static boolean isW ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static boolean isCNWord ( String keyWord ) { boolean flag = false ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; flag = matcher . matches ( ) ; } return flag ; } public static int strPlaceHold ( String keyWord ) { int keyWordLength = <NUM_LIT> ; if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord . trim ( ) ) ; while ( matcher . find ( ) ) { keyWordLength += <NUM_LIT> ; } keyWordLength = keyWord . length ( ) + keyWordLength ; } return keyWordLength ; } public static boolean isMobile ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isPhoneNum ( String keyWord ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( keyWord ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( keyWord ) ; return matcher . matches ( ) ; } return false ; } public static boolean isEmail ( String email ) { if ( org . apache . commons . lang3 . StringUtils . isNotEmpty ( email ) ) { Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; } return false ; } public static String substringAfter ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex <= <NUM_LIT> ) { return rawString ; } return rawString . substring ( markIndex ) ; } public static String substringBefore ( String rawString , String mark ) { if ( rawString == null || mark == null ) { return null ; } int markIndex = rawString . indexOf ( mark ) ; if ( markIndex < <NUM_LIT> || markIndex == rawString . length ( ) - <NUM_LIT> ) { return rawString ; } return rawString . substring ( <NUM_LIT> , markIndex ) ; } public static String getRandomStr ( ) { String base = \"<STR_LIT>\" ; ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } public static long toLong ( String value , long defaultVal ) { try { return Long . parseLong ( value ) ; } catch ( NumberFormatException e ) { return defaultVal ; } catch ( NullPointerException e ) { return defaultVal ; } } public static Object parseToPrimitive ( String value , Class < ? > type ) { if ( value == null ) { return null ; } try { if ( type == String . class ) { return value ; } if ( type == Boolean . class ) { return Boolean . valueOf ( value ) ; } else if ( type == boolean . class ) { return Boolean . valueOf ( value ) . booleanValue ( ) ; } else if ( type == Byte . class ) { return Byte . valueOf ( value ) ; } else if ( type == byte . class ) { return Byte . valueOf ( value ) . byteValue ( ) ; } else if ( type == Character . class || type == char . class ) { return value . length ( ) > <NUM_LIT> ? value . charAt ( <NUM_LIT> ) : null ; } else if ( type == Short . class ) { return Short . valueOf ( value ) ; } else if ( type == short . class ) { return Short . valueOf ( value ) . shortValue ( ) ; } else if ( type == Integer . class ) { return Integer . valueOf ( value ) ; } else if ( type == int . class ) { return Integer . valueOf ( value ) . intValue ( ) ; } else if ( type == Long . class ) { return Long . valueOf ( value ) ; } else if ( type == long . class ) { return Long . valueOf ( value ) . longValue ( ) ; } else if ( type == Float . class ) { return Float . valueOf ( value ) ; } else if ( type == float . class ) { return Float . valueOf ( value ) . floatValue ( ) ; } else if ( type == Double . class ) { return Double . valueOf ( value ) ; } else if ( type == double . class ) { return Double . valueOf ( value ) . doubleValue ( ) ; } } catch ( Exception e ) { } return null ; } public static String filterEmoji ( String source ) { if ( isEmpty ( source ) ) { return source ; } source = source . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( ! containsEmoji ( source ) ) { return source ; } StringBuilder buf = null ; int len = source . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char codePoint = source . charAt ( i ) ; if ( isEmojiCharacter ( codePoint ) ) { if ( buf == null ) { buf = new StringBuilder ( source . length ( ) ) ; } buf . append ( codePoint ) ; } else { buf . append ( \"<STR_LIT>\" ) ; } } if ( buf == null ) { return source ; } if ( buf . length ( ) == len ) { buf = null ; return source ; } return buf . toString ( ) ; } public static boolean containsEmoji ( String source ) { if ( org . apache . commons . lang3 . StringUtils . isBlank ( source ) ) { return false ; } int len = source . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char codePoint = source . charAt ( i ) ; if ( isEmojiCharacter ( codePoint ) ) { return true ; } } return false ; } private static boolean isEmojiCharacter ( char codePoint ) { return ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( codePoint == <NUM_LIT> ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) || ( ( codePoint >= <NUM_LIT> ) && ( codePoint <= <NUM_LIT> ) ) ; } public static String maskMobile ( String mobile ) { if ( ! isMobile ( mobile ) ) { return mobile ; } StringBuilder result = new StringBuilder ( ) ; for ( int i = <NUM_LIT> ; i < mobile . length ( ) ; i ++ ) { if ( i == <NUM_LIT> || i == <NUM_LIT> || i == <NUM_LIT> || i == <NUM_LIT> ) { result . append ( \"<STR_LIT>\" ) ; } else { result . append ( mobile . charAt ( i ) ) ; } } return result . toString ( ) ; } public static String underscoreToCamel ( String str ) { if ( str == null ) { return null ; } if ( ! str . contains ( \"<STR_LIT>\" ) ) { return str ; } StringBuilder result = new StringBuilder ( ) ; String [ ] unitArr = str . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < unitArr . length ; i ++ ) { String unit = unitArr [ i ] ; if ( i == <NUM_LIT> ) { result . append ( unit ) ; continue ; } char firstChar = unit . charAt ( <NUM_LIT> ) ; String formattedUnit = String . valueOf ( firstChar ) . toUpperCase ( ) ; if ( unit . length ( ) > <NUM_LIT> ) { formattedUnit += unit . substring ( <NUM_LIT> ) ; } result . append ( formattedUnit ) ; } return result . toString ( ) ; } public static String camelToUnderscore ( String str ) {", "output": "if ( str == null ) { return null ; } String [ ] words = splitByCharacterTypeCamelCase ( str ) ; StringBuilder result = new StringBuilder ( ) ; for ( String word : words ) { if ( isEmpty ( word ) ) { continue ; } result . append ( word ) ; result . append ( \"<STR_LIT>\" ) ; } if ( result . length ( ) > <NUM_LIT> ) { result . deleteCharAt ( result . length ( ) - <NUM_LIT> ) ; } return result . toString ( ) ; } }"}, {"input": "package me . zhengjie . config . mybatis ; import cn . hutool . core . date . DateTime ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import me . zhengjie . utils . SecurityUtils ; import org . apache . ibatis . reflection . MetaObject ; import org . springframework . stereotype . Component ; import java . sql . Timestamp ; @ Component public class MyMetaObjectHandler implements MetaObjectHandler { @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Timestamp . class , DateTime . now ( ) . toTimestamp ( ) ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Timestamp . class , DateTime . now ( ) . toTimestamp ( ) ) ; String username = \"<STR_LIT>\" ; try { username = SecurityUtils . getCurrentUsername ( ) ; } catch ( Exception ignored ) { } this . strictInsertFill ( metaObject , \"<STR_LIT>\" , String . class , username ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , String . class , username ) ; } @ Override public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Timestamp . class , DateTime . now ( ) . toTimestamp ( ) ) ; String username = \"<STR_LIT>\" ;", "output": "try { username = SecurityUtils . getCurrentUsername ( ) ; } catch ( Exception ignored ) { } this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , String . class , username ) ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DesformData extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formDataJson ; private String processDefinitionId ; private String processInstanceId ; private String onlineFormCode ; private String onlineFormDataId ;", "output": "}"}, {"input": "package org . springblade . web . config . rabbitmq ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWebService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . List ; @ Component public class DetailXhQueueHandler { @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private IWebService webService ; @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMongoService mongoService ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; import java . util . Objects ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Server extends BaseEntity implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ip ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer port ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String password ; public void copy ( Server source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) {", "output": "return false ; } Server that = ( Server ) o ; return Objects . equals ( id , that . id ) && Objects . equals ( name , that . name ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id , name ) ; } }"}, {"input": "package cn . org . alan . exam . converter ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface OptionConverter {", "output": "}"}, {"input": "package com . yf . system . modules . plugin . controller ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdReqDTO ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . plugin . dto . PluginSchemaDTO ; import com . yf . system . modules . plugin . service . PluginSchemaService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class PluginSchemaController extends BaseController { @ Autowired private PluginSchemaService baseService ; @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody PluginSchemaDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ;", "output": "} @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest delete ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < PluginSchemaDTO > detail ( @ RequestBody BaseIdReqDTO reqDTO ) { PluginSchemaDTO dto = baseService . detail ( reqDTO . getId ( ) ) ; return super . success ( dto ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < IPage < PluginSchemaDTO > > paging ( @ RequestBody PagingReqDTO < PluginSchemaDTO > reqDTO ) { IPage < PluginSchemaDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < List < PluginSchemaDTO > > list ( @ RequestBody PluginSchemaDTO reqDTO ) { List < PluginSchemaDTO > dtoList = baseService . list ( reqDTO ) ; return super . success ( dtoList ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . yaml . snakeyaml . DumperOptions ; import org . yaml . snakeyaml . LoaderOptions ; import org . yaml . snakeyaml . Yaml ; import org . yaml . snakeyaml . constructor . Constructor ; import org . yaml . snakeyaml . nodes . MappingNode ; import org . yaml . snakeyaml . nodes . Tag ; import org . yaml . snakeyaml . parser . ParserException ; import org . yaml . snakeyaml . representer . Representer ; import org . yaml . snakeyaml . resolver . Resolver ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import java . util . regex . Pattern ; public class DefaultYamlConfigParse extends AbstractConfigParse { protected static final Logger LOGGER = LoggerFactory . getLogger ( DefaultYamlConfigParse . class ) ; protected static Yaml createYaml ( ) { MapAppenderConstructor mapAppenderConstructor = new MapAppenderConstructor ( ) ; Representer representer = new Representer ( ) ; DumperOptions dumperOptions = new DumperOptions ( ) ; LimitedResolver resolver = new LimitedResolver ( ) ; LoaderOptions loaderOptions = new LoaderOptions ( ) ; loaderOptions . setAllowDuplicateKeys ( false ) ; return new Yaml ( mapAppenderConstructor , representer , dumperOptions , loaderOptions , resolver ) ; } protected static boolean process ( MatchCallback callback , Yaml yaml , String content ) { int count = <NUM_LIT> ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + content ) ; } for ( Object object : yaml . loadAll ( content ) ) { if ( object != null && process ( asMap ( object ) , callback ) ) { count ++ ; } } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + count + \"<STR_LIT>\" + ( count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) + \"<STR_LIT>\" + content ) ; } return ( count > <NUM_LIT> ) ; } protected static boolean process ( Map < String , Object > map , MatchCallback callback ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"<STR_LIT>\" + map ) ; } callback . process ( getFlattenedMap ( map ) ) ; return true ; } @ SuppressWarnings ( \"<STR_LIT>\" ) protected static Map < String , Object > asMap ( Object object ) { Map < String , Object > result = new LinkedHashMap ( ) ; if ( ! ( object instanceof Map ) ) { result . put ( \"<STR_LIT>\" , object ) ; return result ; } Map < Object , Object > map = ( Map < Object , Object > ) object ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value instanceof Map ) { value = asMap ( value ) ; } if ( key instanceof CharSequence ) { result . put ( key . toString ( ) , value ) ;", "output": "} else { result . put ( \"<STR_LIT>\" + key . toString ( ) + \"<STR_LIT>\" , value ) ; } } return result ; } private static class LimitedResolver extends Resolver { @ Override public void addImplicitResolver ( Tag tag , Pattern regexp , String first ) { if ( tag == Tag . TIMESTAMP ) { return ; } super . addImplicitResolver ( tag , regexp , first ) ; } } protected static Map < String , Object > getFlattenedMap ( Map < String , Object > source ) { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; buildFlattenedMap ( result , source , null ) ; return result ; } protected static void buildFlattenedMap ( Map < String , Object > result , Map < String , Object > source , String path ) { for ( Map . Entry < String , Object > entry : source . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! StringUtils . isBlank ( path ) ) { if ( key . startsWith ( \"<STR_LIT>\" ) ) { key = path + key ; } else { key = path + '<STR_LIT>' + key ; } } Object value = entry . getValue ( ) ; if ( value instanceof String ) { result . put ( key , value ) ; } else if ( value instanceof Map ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Map < String , Object > map = ( Map < String , Object > ) value ; buildFlattenedMap ( result , map , key ) ; } else if ( value instanceof Collection ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Collection < Object > collection = ( Collection < Object > ) value ; int count = <NUM_LIT> ; for ( Object object : collection ) { buildFlattenedMap ( result , Collections . singletonMap ( \"<STR_LIT>\" + ( count ++ ) + \"<STR_LIT>\" , object ) , key ) ; } } else { result . put ( key , ( value != null ? value . toString ( ) : \"<STR_LIT>\" ) ) ; } } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < Map < String , Object > > ( ) ; process ( new MatchCallback ( ) { @ Override public void process ( Map < String , Object > map ) { result . set ( map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } @ Override public String processType ( ) { return ConfigType . YAML . getType ( ) ; } protected interface MatchCallback { void process ( Map < String , Object > map ) ; } protected static class MapAppenderConstructor extends Constructor { MapAppenderConstructor ( ) { super ( ) ; } @ Override protected Map < Object , Object > constructMapping ( MappingNode node ) { try { return super . constructMapping ( node ) ; } catch ( IllegalStateException ex ) { throw new ParserException ( \"<STR_LIT>\" , node . getStartMark ( ) , ex . getMessage ( ) , node . getEndMark ( ) ) ; } } @ Override protected Map < Object , Object > createDefaultMap ( int initSize ) { final Map < Object , Object > delegate = super . createDefaultMap ( initSize ) ; return new AbstractMap < Object , Object > ( ) { @ Override public Object put ( Object key , Object value ) { if ( delegate . containsKey ( key ) ) { throw new IllegalStateException ( \"<STR_LIT>\" + key ) ; } return delegate . put ( key , value ) ; } @ Override public Set < Entry < Object , Object > > entrySet ( ) { return delegate . entrySet ( ) ; } } ; } } }"}, {"input": "package com . youlai . system . model . vo ; import com . fasterxml . jackson . annotation . JsonFormat ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . time . LocalDateTime ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class DeptVO { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private Long parentId ; @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private String code ; @ Schema ( description = \"<STR_LIT>\" ) private Integer sort ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" ) private List < DeptVO > children ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime updateTime ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . QuestionConverter ; import cn . org . alan . exam . mapper . ExerciseRecordMapper ; import cn . org . alan . exam . mapper . OptionMapper ; import cn . org . alan . exam . mapper . QuestionMapper ; import cn . org . alan . exam . model . entity . ExerciseRecord ; import cn . org . alan . exam . model . entity . Option ; import cn . org . alan . exam . model . entity . Question ; import cn . org . alan . exam . model . entity . UserExerciseRecord ; import cn . org . alan . exam . model . form . question . QuestionExcelFrom ; import cn . org . alan . exam . model . form . question . QuestionFrom ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . service . IQuestionService ; import cn . org . alan . exam . util . AliOSSUtil ; import cn . org . alan . exam . util . CacheClient ; import cn . org . alan . exam . util . SecurityUtil ; import cn . org . alan . exam . util . excel . ExcelUtils ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import lombok . SneakyThrows ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . multipart . MultipartFile ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . TimeUnit ; import java . util . function . Function ; import java . util . stream . Collectors ; @ Service public class QuestionServiceImpl extends ServiceImpl < QuestionMapper , Question > implements IQuestionService { @ Resource private QuestionConverter questionConverter ; @ Resource private QuestionMapper questionMapper ; @ Resource private OptionMapper optionMapper ; @ Resource private AliOSSUtil aliOSSUtil ; @ Resource private ExerciseRecordMapper exerciseRecordMapper ; @ Resource private CacheClient cacheClient ; @ Resource private StringRedisTemplate stringRedisTemplate ; @ Override @ Transactional public Result < String > addSingleQuestion ( QuestionFrom questionFrom ) { List < Option > options = questionFrom . getOptions ( ) ; if ( questionFrom . getQuType ( ) != <NUM_LIT> && ( Objects . isNull ( options ) || options . size ( ) < <NUM_LIT> ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } Question question = questionConverter . fromToEntity ( questionFrom ) ; questionMapper . insert ( question ) ; if ( question . getQuType ( ) == <NUM_LIT> ) { Option option = questionFrom . getOptions ( ) . get ( <NUM_LIT> ) ; option . setQuId ( question . getId ( ) ) ; optionMapper . insert ( option ) ; } else { options . forEach ( option -> { option . setQuId ( question . getId ( ) ) ; } ) ; optionMapper . insertBatch ( options ) ; } if ( question . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + question . getId ( ) . toString ( ) ) ; } return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ Transactional public Result < String > deleteBatchByIds ( String ids ) { List < Integer > list = Arrays . stream ( ids . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; LambdaUpdateWrapper < ExerciseRecord > updateWrapper = new LambdaUpdateWrapper < ExerciseRecord > ( ) . in ( ExerciseRecord :: getQuestionId , list ) ; int delete = exerciseRecordMapper . delete ( updateWrapper ) ; optionMapper . deleteBatchByQuIds ( list ) ; questionMapper . deleteBatchIdsQu ( list ) ; list . forEach ( id -> { stringRedisTemplate . delete ( \"<STR_LIT>\" + id ) ; } ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override public Result < IPage < QuestionVO > > pagingQuestion ( Integer pageNum , Integer pageSize , String title , Integer type , Integer repoId ) { Integer userId = null ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { userId = SecurityUtil . getUserId ( ) ; } else { userId = <NUM_LIT> ; } int total = questionMapper . countByCondition ( userId , title , type , repoId ) ; int offset = ( pageNum - <NUM_LIT> ) * pageSize ; List < Integer > quIds = questionMapper . selectQuestionIdsPage ( userId , title , type , repoId , offset , pageSize ) ; Map < Integer , QuestionVO > cachedQuestionsMap = cacheClient . batchGet ( \"<STR_LIT>\" , quIds , QuestionVO . class ) ; List < Integer > missIds = new ArrayList < > ( ) ; for ( Integer id : quIds ) { if ( ! cachedQuestionsMap . containsKey ( id ) ) { missIds . add ( id ) ;", "output": "} } if ( ! missIds . isEmpty ( ) ) { List < QuestionVO > missedGrades = questionMapper . batchSelectByIds ( missIds ) ; Map < Integer , QuestionVO > missedGradesMap = missedGrades . stream ( ) . collect ( Collectors . toMap ( QuestionVO :: getId , Function . identity ( ) ) ) ; cacheClient . batchPut ( \"<STR_LIT>\" , missedGradesMap , <NUM_LIT> , TimeUnit . MINUTES ) ; cachedQuestionsMap . putAll ( missedGradesMap ) ; } List < QuestionVO > finalResult = new ArrayList < > ( quIds . size ( ) ) ; for ( Integer id : quIds ) { finalResult . add ( cachedQuestionsMap . get ( id ) ) ; } IPage < QuestionVO > resultPage = new Page < > ( pageNum , pageSize , Long . valueOf ( total ) ) ; resultPage . setRecords ( finalResult ) ; return Result . success ( null , resultPage ) ; } @ Override public Result < QuestionVO > querySingle ( Integer id ) { return Result . success ( null , questionMapper . selectSingle ( id ) ) ; } @ Override @ Transactional public Result < String > updateQuestion ( QuestionFrom questionFrom ) { Question question = questionConverter . fromToEntity ( questionFrom ) ; questionMapper . updateById ( question ) ; List < Option > options = questionFrom . getOptions ( ) ; for ( Option option : options ) { optionMapper . updateById ( option ) ; } if ( question . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + question . getId ( ) . toString ( ) ) ; } return Result . success ( \"<STR_LIT>\" ) ; } @ SneakyThrows ( Exception . class ) @ Override @ Transactional public Result < String > importQuestion ( Integer id , MultipartFile file ) { if ( ! ExcelUtils . isExcel ( Objects . requireNonNull ( file . getOriginalFilename ( ) ) ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } List < QuestionExcelFrom > questionExcelFroms = ExcelUtils . readMultipartFile ( file , QuestionExcelFrom . class ) ; List < QuestionFrom > list = QuestionExcelFrom . converterQuestionFrom ( questionExcelFroms ) ; for ( QuestionFrom questionFrom : list ) { Question question = questionConverter . fromToEntity ( questionFrom ) ; question . setRepoId ( id ) ; questionMapper . insert ( question ) ; List < Option > options = questionFrom . getOptions ( ) ; final int [ ] count = { <NUM_LIT> } ; options . forEach ( option -> { if ( question . getQuType ( ) == <NUM_LIT> ) { option . setIsRight ( <NUM_LIT> ) ; } option . setSort ( ++ count [ <NUM_LIT> ] ) ; option . setQuId ( question . getId ( ) ) ; } ) ; if ( ! options . isEmpty ( ) ) { optionMapper . insertBatch ( options ) ; } if ( question . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + question . getId ( ) . toString ( ) ) ; } } return Result . success ( \"<STR_LIT>\" ) ; } @ SneakyThrows ( IOException . class ) @ Override public Result < String > uploadImage ( MultipartFile file ) { if ( ! aliOSSUtil . isImage ( Objects . requireNonNull ( file . getOriginalFilename ( ) ) ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } if ( aliOSSUtil . isOverSize ( file ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } String url = aliOSSUtil . upload ( file ) ; if ( StringUtils . isBlank ( url ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } return Result . success ( \"<STR_LIT>\" , url ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . factory . BeanCreationException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . context . EnvironmentAware ; import org . springframework . core . env . Environment ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . String . format ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public abstract class AbstractNacosServiceBeanBuilder < S > implements BeanFactoryAware , EnvironmentAware { private final Class < ? > type ; private final GlobalNacosPropertiesSource source ; private BeanFactory beanFactory ; private Environment environment ; protected AbstractNacosServiceBeanBuilder ( GlobalNacosPropertiesSource source ) { type = resolveGenericType ( getClass ( ) ) ; this . source = source ; }", "output": "public S build ( NacosProperties nacosProperties ) { return build ( getAnnotationAttributes ( nacosProperties ) ) ; } public S build ( Map < String , Object > nacosPropertiesAttributes ) { NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; Properties properties = resolveProperties ( nacosPropertiesAttributes ) ; if ( properties . isEmpty ( ) ) { throw new BeanCreationException ( format ( \"<STR_LIT>\" , NacosProperties . class . getSimpleName ( ) ) ) ; } try { return createService ( nacosServiceFactory , properties ) ; } catch ( NacosException e ) { throw new BeanCreationException ( e . getErrMsg ( ) , e ) ; } } protected abstract S createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException ; public final Properties resolveProperties ( NacosProperties nacosProperties ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ; return NacosUtils . resolveProperties ( nacosProperties , environment , globalNacosProperties ) ; } public final Properties resolveProperties ( Map < String , Object > nacosPropertiesAttributes ) { Properties globalNacosProperties = resolveGlobalNacosProperties ( ) ; return NacosUtils . resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; } private Properties resolveGlobalNacosProperties ( ) { return source . getMergedGlobalProperties ( beanFactory ) ; } final Class < ? > getType ( ) { return type ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } }"}, {"input": "package me . zhengjie . config ; import lombok . Data ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Component ; @ Data @ Component public class RsaProperties { public static String privateKey ; @ Value ( \"<STR_LIT>\" ) public void setPrivateKey ( String privateKey ) { RsaProperties . privateKey = privateKey ;", "output": "} }"}, {"input": "package com . yf . base . api . annon ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface Dict { String dicCode ( ) ; String dicText ( ) default \"<STR_LIT>\" ;", "output": "String dictTable ( ) default \"<STR_LIT>\" ; }"}, {"input": "package top . kangert . kspider . vo ; import java . util . List ; import lombok . Getter ; import lombok . Setter ; import top . kangert . kspider . model . ConfigItem ; @ Getter @ Setter public class SpiderNodeVo { private String nodeId ; private String name ; private String sourceId ; private String targetId ; private String condition ; private String exceptionFlow ; private String transmitVariable ; private List < ConfigItem > form ;", "output": "}"}, {"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . infrastructure . common . constants . BizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class SecurityRepositoryImpl implements SecurityRepository { @ Override public Long findLoginUser ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { throw new BizException ( BizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long findLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { return null ; } } private static HttpServletRequest getRequest ( ) { ServletRequestAttributes servletRequestAttributes = ( ServletRequestAttributes ) RequestContextHolder . getRequestAttributes ( ) ; if ( servletRequestAttributes == null ) { return null ; } return servletRequestAttributes . getRequest ( ) ; }", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class ChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String chatId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String contentType ;", "output": "}"}, {"input": "package ginyi . common . constant ; public class CacheConstants { public static final String SYS_CONFIG_KEY = \"<STR_LIT>\" ; public static final String CAPTCHA_CODE_KEY = \"<STR_LIT>\" ; public static final String LOGIN_TOKEN_KEY = \"<STR_LIT>\" ; public static final String PWD_ERR_CNT_KEY = \"<STR_LIT>\" ; public static final String REPEAT_SUBMIT_KEY = \"<STR_LIT>\" ; public static final String API_REQUEST = \"<STR_LIT>\" ; public static final String MENU_KEY_PREFIX = \"<STR_LIT>\" ; public static final String MENU_LIST_KEY = \"<STR_LIT>\" ; public static final String MENU_USER_LIST_KEY = \"<STR_LIT>\" ; public static final String MENU_NOT_EXIST_KEY = \"<STR_LIT>\" ; public static final String MENU_DETAILS_BY_ID_KEY = \"<STR_LIT>\" ; public static final String USER_KEY_PREFIX = \"<STR_LIT>\" ; public static final String USER_LIST_KEY = \"<STR_LIT>\" ; public static final String USER_NOT_EXIST_KEY = \"<STR_LIT>\" ; public static final String USER_DETAILS_BY_USERID_KEY = \"<STR_LIT>\" ; public static final String DEPT_KEY_PREFIX = \"<STR_LIT>\" ; public static final String DEPT_LIST_KEY = \"<STR_LIT>\" ; public static final String DEPT_NOT_EXIST_KEY = \"<STR_LIT>\" ; public static final String DEPT_DETAILS_BY_DEPTID_KEY = \"<STR_LIT>\" ; public static final String DEPT_NAME_USED_KEY = \"<STR_LIT>\" ; public static final String POST_KEY_PREFIX = \"<STR_LIT>\" ; public static final String POST_LIST_KEY = \"<STR_LIT>\" ; public static final String POST_NOT_EXIST_KEY = \"<STR_LIT>\" ; public static final String POST_DETAILS_BY_POSTID_KEY = \"<STR_LIT>\" ; public static final String ROLE_KEY_PREFIX = \"<STR_LIT>\" ; public static final String ROLE_LIST_KEY = \"<STR_LIT>\" ; public static final String ROLE_NOT_EXIST_KEY = \"<STR_LIT>\" ; public static final String ROLE_NAME_USED_KEY = \"<STR_LIT>\" ; public static final String ROLE_CODE_USED_KEY = \"<STR_LIT>\" ; public static final String ROLE_DETAILS_BY_ROLEID_KEY = \"<STR_LIT>\" ; public static final String NOTICE_NOT_EXIST_KEY = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package com . yf . system . modules . user . controller ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . user . dto . SysUserBindDTO ; import com . yf . system . modules . user . service . SysUserBindService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysUserBindController extends BaseController { @ Autowired private SysUserBindService baseService ; @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = {", "output": "RequestMethod . POST } ) public ApiRest < IPage < SysUserBindDTO > > paging ( @ RequestBody PagingReqDTO < SysUserBindDTO > reqDTO ) { IPage < SysUserBindDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < IPage < SysUserBindDTO > > bindList ( @ RequestBody PagingReqDTO < SysUserBindDTO > reqDTO ) { IPage < SysUserBindDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } }"}, {"input": "package top . kangert . kspider . service ; import top . kangert . kspider . domain . SpiderTask ; import top . kangert . kspider . util . PageInfo ; import java . util . Date ; import java . util . List ; import java . util . Map ; import javax . servlet . http . HttpServletResponse ; public interface SpiderTaskService { void deleteItem ( Map < String , Object > params ) ; SpiderTask add ( Map < String , Object > params ) ; Long getMaxTaskIdByFlowId ( Long flowId ) ; Integer getRunningCountByFlowId ( Map < String , Object > params ) ; PageInfo < SpiderTask > queryItems ( Map < String , Object > params ) ; SpiderTask queryItem ( Long taskId ) ; void edit ( Map < String , Object > params ) ; void executeCountIncrement ( Long id , Date lastExecuteTime , Date nextExecuteTime ) ; List < SpiderTask > findByJobEnabled ( Boolean jobEnabled ) ; void updateNextExecuteTime ( SpiderTask task ) ; void updateCronAndNextExecuteTime ( Long taskId , String cron ) ; void clearNextExecuteTime ( ) ; void run ( Map < String , Object > params ) ; void stop ( Map < String , Object > params ) ; void download ( Map < String , Object > params , HttpServletResponse response ) ;", "output": "}"}, {"input": "package ginyi . system . domain ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . annotation . JsonInclude ; import ginyi . common . annotation . CreateBy ; import ginyi . common . annotation . CreateTime ; import ginyi . common . annotation . UpdateBy ; import ginyi . common . annotation . UpdateTime ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Data public class BaseEntity implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonIgnore @ TableField ( exist = false , select = false ) private String searchValue ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ CreateBy @ TableField ( fill = FieldFill . INSERT ) private String createBy ; @ JsonFormat @ ApiModelProperty ( \"<STR_LIT>\" ) @ CreateTime @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ UpdateBy @ TableField ( fill = FieldFill . INSERT_UPDATE ) private String updateBy ; @ JsonFormat @ ApiModelProperty ( \"<STR_LIT>\" ) @ UpdateTime @ TableField ( fill = FieldFill . INSERT_UPDATE ) private Date updateTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String remark ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) @ TableField ( exist = false , select = false ) private Map < String , Object > params ; public Map < String , Object > getParams ( ) { if ( params == null ) {", "output": "params = new HashMap < > ( ) ; } return params ; } public void setParams ( Map < String , Object > params ) { this . params = params ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . RequiredArgsConstructor ; @ Data @ RequiredArgsConstructor @ AllArgsConstructor public class WeChatConfigVO { private Integer pid ; private Long baseAddress ; private String version ; private String nickname ; private String account ; private String mobile ; private String basePath ; private String wxId ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . ObjectArrays ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Random ; public class ArrayUtil { @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] newArray ( Class < T > type , int length ) { return ( T [ ] ) Array . newInstance ( type , length ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T [ ] toArray ( Collection < T > col , Class < T > type ) { return col . toArray ( ( T [ ] ) Array . newInstance ( type , <NUM_LIT> ) ) ; } private static void swap ( Object [ ] arr , int i , int j ) { Object tmp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = tmp ; } public static < T > T [ ] shuffle ( T [ ] array ) { if ( array != null && array . length > <NUM_LIT> ) { Random rand = new Random ( ) ; return shuffle ( array , rand ) ; } else { return array ; } } public static < T > T [ ] shuffle ( T [ ] array , Random random ) { if ( array != null && array . length > <NUM_LIT> && random != null ) { for ( int i = array . length ; i > <NUM_LIT> ; i -- ) { swap ( array , i - <NUM_LIT> , random . nextInt ( i ) ) ; } } return array ; } public static < T > T [ ] concat ( @ Nullable T element , T [ ] array ) { return ObjectArrays . concat ( element , array ) ; } public static < T > T [ ] concat ( T [ ] array , @ Nullable T element ) { return ObjectArrays . concat ( array , element ) ; } public static < T > List < T > asList ( T ... a ) { return Arrays . asList ( a ) ; } public static List < Integer > intAsList ( int ... backingArray ) { return Ints . asList ( backingArray ) ; } public static List < Long > longAsList ( long ... backingArray ) { return Longs . asList ( backingArray ) ; }", "output": "public static List < Double > doubleAsList ( double ... backingArray ) { return Doubles . asList ( backingArray ) ; } }"}, {"input": "package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DeployHistoryService extends IService < DeployHistory > {", "output": "PageResult < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria , Page < Object > page ) ; List < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria ) ; void create ( DeployHistory resources ) ; void delete ( Set < String > ids ) ; void download ( List < DeployHistory > queryAll , HttpServletResponse response ) throws IOException ; }"}, {"input": "package me . zhengjie . modules . quartz . utils ; import cn . hutool . extra . template . Template ; import cn . hutool . extra . template . TemplateConfig ; import cn . hutool . extra . template . TemplateEngine ; import cn . hutool . extra . template . TemplateUtil ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . mapper . QuartzLogMapper ; import me . zhengjie . modules . quartz . service . QuartzJobService ; import me . zhengjie . service . EmailService ; import me . zhengjie . utils . RedisUtils ; import me . zhengjie . utils . SpringContextHolder ; import me . zhengjie . utils . StringUtils ; import me . zhengjie . utils . ThrowableUtil ; import org . quartz . JobExecutionContext ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . scheduling . annotation . Async ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import org . springframework . scheduling . quartz . QuartzJobBean ; import java . util . * ; import java . util . concurrent . * ; @ Async public class ExecutionJob extends QuartzJobBean { private final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final ThreadPoolTaskExecutor executor = SpringContextHolder . getBean ( \"<STR_LIT>\" ) ; @ Override public void executeInternal ( JobExecutionContext context ) { QuartzJob quartzJob = ( QuartzJob ) context . getMergedJobDataMap ( ) . get ( QuartzJob . JOB_KEY ) ; QuartzLogMapper quartzLogMapper = SpringContextHolder . getBean ( QuartzLogMapper . class ) ; QuartzJobService quartzJobService = SpringContextHolder . getBean ( QuartzJobService . class ) ; RedisUtils redisUtils = SpringContextHolder . getBean ( RedisUtils . class ) ; String uuid = quartzJob . getUuid ( ) ; QuartzLog log = new QuartzLog ( ) ; log . setJobName ( quartzJob . getJobName ( ) ) ; log . setBeanName ( quartzJob . getBeanName ( ) ) ; log . setMethodName ( quartzJob . getMethodName ( ) ) ; log . setParams ( quartzJob . getParams ( ) ) ; long startTime = System . currentTimeMillis ( ) ; log . setCronExpression ( quartzJob . getCronExpression ( ) ) ; try { QuartzRunnable task = new QuartzRunnable ( quartzJob . getBeanName ( ) , quartzJob . getMethodName ( ) , quartzJob . getParams ( ) ) ; Future < ? > future = executor . submit ( task ) ; future . get ( ) ; long times = System . currentTimeMillis ( ) - startTime ; log . setTime ( times ) ; if ( StringUtils . isNotBlank ( uuid ) ) { redisUtils . set ( uuid , true ) ; } log . setIsSuccess ( true ) ; logger . info ( \"<STR_LIT>\" + quartzJob . getJobName ( ) + \"<STR_LIT>\" + times + \"<STR_LIT>\" ) ; if ( StringUtils . isNotBlank ( quartzJob . getSubTask ( ) ) ) { String [ ] tasks = quartzJob . getSubTask ( ) . split ( \"<STR_LIT>\" ) ; quartzJobService . executionSubJob ( tasks ) ; } } catch ( Exception e ) { if ( StringUtils . isNotBlank ( uuid ) ) { redisUtils . set ( uuid , false ) ; } logger . error ( \"<STR_LIT>\" + quartzJob . getJobName ( ) ) ; long times = System . currentTimeMillis ( ) - startTime ; log . setTime ( times ) ; log . setIsSuccess ( false ) ; log . setExceptionDetail ( ThrowableUtil . getStackTrace ( e ) ) ; if ( quartzJob . getPauseAfterFailure ( ) != null && quartzJob . getPauseAfterFailure ( ) ) { quartzJob . setIsPause ( false ) ; quartzJobService . updateIsPause ( quartzJob ) ; } if ( quartzJob . getEmail ( ) != null ) { EmailService emailService = SpringContextHolder . getBean ( EmailService . class ) ; if ( StringUtils . isNoneBlank ( quartzJob . getEmail ( ) ) ) { EmailVo emailVo = taskAlarm ( quartzJob , ThrowableUtil . getStackTrace ( e ) ) ; emailService . send ( emailVo , emailService . find ( ) ) ; } } } finally { quartzLogMapper . insert ( log ) ; } } private EmailVo taskAlarm ( QuartzJob quartzJob , String msg ) { EmailVo emailVo = new EmailVo ( ) ; emailVo . setSubject ( \"<STR_LIT>\" + quartzJob . getJobName ( ) + \"<STR_LIT>\" ) ; Map < String , Object > data = new HashMap < > ( <NUM_LIT> ) ; data . put ( \"<STR_LIT>\" , quartzJob ) ; data . put ( \"<STR_LIT>\" , msg ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( \"<STR_LIT>\" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; Template template = engine . getTemplate ( \"<STR_LIT>\" ) ;", "output": "emailVo . setContent ( template . render ( data ) ) ; List < String > emails = Arrays . asList ( quartzJob . getEmail ( ) . split ( \"<STR_LIT>\" ) ) ; emailVo . setTos ( emails ) ; return emailVo ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . vo . stat . AllStatsVO ; import cn . org . alan . exam . model . vo . stat . GradeExamVO ; import cn . org . alan . exam . model . vo . stat . GradeStudentVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . apache . ibatis . annotations . Param ; import org . springframework . stereotype . Repository ; import java . util . List ; @ Repository public interface StatMapper extends BaseMapper < Grade > {", "output": "List < GradeStudentVO > StudentGradeCount ( @ Param ( \"<STR_LIT>\" ) Integer roleId , Integer id ) ; List < GradeExamVO > ExamGradeCount ( @ Param ( \"<STR_LIT>\" ) Integer roleId , Integer id ) ; }"}, {"input": "package top . kangert . kspider . executor . node ; import org . springframework . stereotype . Component ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . websocket . WebSocketEvent ; import java . util . HashMap ; import java . util . Map ; @ Component public class JoinExecutor implements NodeExecutor { private Map < String , Map < String , Object > > cachedVariables = new HashMap < > ( ) ; @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override public boolean allowExecuteNext ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { String key = context . getId ( ) + \"<STR_LIT>\" + node . getNodeId ( ) ; synchronized ( cachedVariables ) {", "output": "boolean isDone = node . isDone ( ) ; Map < String , Object > cached = cachedVariables . get ( key ) ; if ( ! isDone ) { if ( cached == null ) { cached = new HashMap < > ( ) ; cachedVariables . put ( key , cached ) ; } cached . putAll ( variables ) ; } else if ( cached != null ) { variables . putAll ( cached ) ; cachedVariables . remove ( key ) ; } return isDone ; } } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { return new Shape ( supportType ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . Exam ; import cn . org . alan . exam . model . entity . ExamQuAnswer ; import cn . org . alan . exam . model . form . exam . ExamAddForm ; import cn . org . alan . exam . model . form . exam . ExamQuAnswerFrom ; import cn . org . alan . exam . model . form . exam . ExamUpdateForm ; import cn . org . alan . exam . model . form . examquanswer . ExamQuAnswerAddForm ; import cn . org . alan . exam . model . vo . exam . * ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import java . util . List ; public interface IExamService extends IService < Exam > { Result < String > createExam ( ExamAddForm examAddForm ) ; Result < String > updateExam ( ExamUpdateForm examUpdateForm , Integer examId ) ; Result < String > deleteExam ( String ids ) ; Result < IPage < ExamVO > > getPagingExam ( Integer pageNum , Integer pageSize , String title ) ; Result < ExamQuestionListVO > getQuestionList ( Integer examId ) ; Result < ExamQuDetailVO > getQuestionSingle ( Integer examId , Integer questionId ) ; Result < List < ExamQuCollectVO > > getCollect ( Integer examId ) ; Result < ExamDetailVO > getDetail ( Integer examId ) ; Result < Integer > addCheat ( Integer examId ) ; Result < String > addAnswer ( ExamQuAnswerAddForm examQuAnswerForm ) ; Result < IPage < ExamGradeListVO > > getGradeExamList ( Integer pageNum , Integer pageSize , String title ) ; Result < ExamQuDetailVO > handExam ( Integer examId ) ;", "output": "Result < String > startExam ( Integer examId ) ; Result < String > insertNewAnswer ( ExamQuAnswerAddForm examQuAnswerForm , Integer quType ) ; Result < String > updateAnswerIfExists ( ExamQuAnswerAddForm examQuAnswerForm , Integer quType ) ; ExamQuAnswer prepareExamQuAnswer ( ExamQuAnswerAddForm form , Integer quType ) ; boolean isUserTakingExam ( Integer examId ) ; }"}, {"input": "package com . xcs . wx . repository . impl ; import cn . hutool . core . util . ObjUtil ; import cn . hutool . core . util . StrUtil ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . Feeds ; import com . xcs . wx . domain . dto . FeedsDTO ; import com . xcs . wx . mapper . FeedsMapper ; import com . xcs . wx . repository . FeedsRepository ; import org . springframework . stereotype . Repository ; @ Repository @ DS ( value = DataSourceType . SNS_DB ) public class FeedsRepositoryImpl extends ServiceImpl < FeedsMapper , Feeds > implements FeedsRepository { @ Override public Page < Feeds > queryFeeds ( FeedsDTO feedsDTO ) { boolean conditionUserName = StrUtil . isNotBlank ( feedsDTO . getUserName ( ) ) ; boolean conditionCreateTime = ObjUtil . isNotEmpty ( feedsDTO . getStartTime ( ) ) && ObjUtil . isNotEmpty ( feedsDTO . getEndTime ( ) ) ;", "output": "LambdaQueryWrapper < Feeds > wrapper = Wrappers . < Feeds > lambdaQuery ( ) . eq ( conditionUserName , Feeds :: getUserName , feedsDTO . getUserName ( ) ) . between ( conditionCreateTime , Feeds :: getCreateTime , feedsDTO . getStartTime ( ) , feedsDTO . getEndTime ( ) ) . orderByDesc ( Feeds :: getCreateTime ) ; return super . page ( new Page < > ( feedsDTO . getCurrent ( ) , feedsDTO . getPageSize ( ) ) , wrapper ) ; } }"}, {"input": "package org . springblade . config . autopoi . util ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class ApplicationContextUtil implements ApplicationContextAware { private static ApplicationContext context ; public void setApplicationContext ( ApplicationContext context ) throws BeansException { ApplicationContextUtil . context = context ; } public static ApplicationContext getContext ( ) { return context ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . utils ; import cn . hutool . core . convert . Convert ; import com . oddfar . campus . common . constant . Constants ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class ServletUtils { public static String getParameter ( String name ) { return getRequest ( ) . getParameter ( name ) ; } public static String getParameter ( String name , String defaultValue ) { return Convert . toStr ( getRequest ( ) . getParameter ( name ) , defaultValue ) ; } public static Integer getParameterToInt ( String name ) { return Convert . toInt ( getRequest ( ) . getParameter ( name ) ) ; } public static Integer getParameterToInt ( String name , Integer defaultValue ) { return Convert . toInt ( getRequest ( ) . getParameter ( name ) , defaultValue ) ; } public static Boolean getParameterToBool ( String name ) { return Convert . toBool ( getRequest ( ) . getParameter ( name ) ) ; } public static Boolean getParameterToBool ( String name , Boolean defaultValue ) { return Convert . toBool ( getRequest ( ) . getParameter ( name ) , defaultValue ) ; } public static HttpServletRequest getRequest ( ) { RequestAttributes requestAttributes = RequestContextHolder . getRequestAttributes ( ) ; if ( ! ( requestAttributes instanceof ServletRequestAttributes ) ) {", "output": "return null ; } ServletRequestAttributes servletRequestAttributes = ( ServletRequestAttributes ) requestAttributes ; return servletRequestAttributes . getRequest ( ) ; } public static HttpServletRequest getRequest2 ( ) { try { return getRequestAttributes ( ) . getRequest ( ) ; } catch ( Exception e ) { return null ; } } public static HttpServletResponse getResponse ( ) { return getRequestAttributes ( ) . getResponse ( ) ; } public static HttpSession getSession ( ) { return getRequest ( ) . getSession ( ) ; } public static ServletRequestAttributes getRequestAttributes ( ) { RequestAttributes attributes = RequestContextHolder . getRequestAttributes ( ) ; return ( ServletRequestAttributes ) attributes ; } public static void renderString ( HttpServletResponse response , String string ) { try { response . setStatus ( <NUM_LIT> ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . getWriter ( ) . print ( string ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static boolean isAjaxRequest ( HttpServletRequest request ) { String accept = request . getHeader ( \"<STR_LIT>\" ) ; if ( accept != null && accept . contains ( \"<STR_LIT>\" ) ) { return true ; } String xRequestedWith = request . getHeader ( \"<STR_LIT>\" ) ; if ( xRequestedWith != null && xRequestedWith . contains ( \"<STR_LIT>\" ) ) { return true ; } String uri = request . getRequestURI ( ) ; if ( StringUtils . inStringIgnoreCase ( uri , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) { return true ; } String ajax = request . getParameter ( \"<STR_LIT>\" ) ; return StringUtils . inStringIgnoreCase ( ajax , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static String urlEncode ( String str ) { try { return URLEncoder . encode ( str , Constants . UTF8 ) ; } catch ( UnsupportedEncodingException e ) { return StringUtils . EMPTY ; } } public static String urlDecode ( String str ) { try { return URLDecoder . decode ( str , Constants . UTF8 ) ; } catch ( UnsupportedEncodingException e ) { return StringUtils . EMPTY ; } } }"}, {"input": "package org . example . ddduser . infrastructure . repository . database . condition ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . Data ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageCondition extends Page < UserProfile > { private String username ; private UserStatus status ; private Gender gender ; private String nickNameLike ; private Integer ageFrom ; private Integer ageTo ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . form . exam ; import jakarta . validation . constraints . NotBlank ; import lombok . Data ; @ Data public class ExamQuAnswerFrom { private Integer examId ; private Integer quId ; @ NotBlank private String answer ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . certificate ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class MyCertificateVO { private String code ; private Integer id ; private String certificateName ; private String image ; private String certificationNuit ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private String examName ; private Integer examId ;", "output": "}"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . SessionUserVo ; import java . util . Set ; public interface ISysOnlineService { public BaseVo < SessionUserVo > getOnlineUserList ( Long page , Long pageSize ) ; public void removeUser ( String sessionId ) ; public void removeUser ( Set < String > ids ) ;", "output": "}"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . common . model . Option ; import com . youlai . system . model . entity . SysDept ; import com . youlai . system . model . form . DeptForm ; import com . youlai . system . model . query . DeptQuery ; import com . youlai . system . model . vo . DeptVO ; import java . util . List ; public interface SysDeptService extends IService < SysDept > { List < DeptVO > getDeptList ( DeptQuery queryParams ) ; List < Option > listDeptOptions ( ) ;", "output": "Long saveDept ( DeptForm formData ) ; Long updateDept ( Long deptId , DeptForm formData ) ; boolean deleteByIds ( String ids ) ; DeptForm getDeptForm ( Long deptId ) ; }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class LongConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Long . class == fieldType || long . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Long . parseLong ( cellContent ) ; } catch ( NumberFormatException e ) { return Long . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Long value = ( Long ) cellValue ;", "output": "cell . setCellType ( CellType . NUMERIC ) ; cell . setCellValue ( value ) ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class FixedBorrowParam { private String symbolName ; private String symbol ; private BigDecimal depositAmount ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import io . github . chensheng . dddboot . tools . concurrent . ThreadDumpper ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadPoolExecutor ; public class AbortPolicyWithReport extends ThreadPoolExecutor . AbortPolicy { protected static final Logger logger = LoggerFactory . getLogger ( AbortPolicyWithReport . class ) ; private final String threadName ; private ThreadDumpper dummper = new ThreadDumpper ( ) ; public AbortPolicyWithReport ( String threadName ) { this . threadName = threadName ; } @ Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { String msg = String . format ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" , threadName , e . getPoolSize ( ) , e . getActiveCount ( ) , e . getCorePoolSize ( ) , e . getMaximumPoolSize ( ) , e . getLargestPoolSize ( ) , e . getTaskCount ( ) , e . getCompletedTaskCount ( ) , e . isShutdown ( ) , e . isTerminated ( ) , e . isTerminating ( ) ) ; logger . warn ( msg ) ;", "output": "dummper . tryThreadDump ( null ) ; throw new RejectedExecutionException ( msg ) ; } }"}, {"input": "package me . zhengjie . modules . system . rest ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . config . RsaProperties ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . service . DataService ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . vo . UserPassVo ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import me . zhengjie . modules . system . service . VerifyService ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . service . UserService ; import me . zhengjie . utils . enums . CodeEnum ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . stream . Collectors ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class UserController { private final PasswordEncoder passwordEncoder ; private final UserService userService ; private final DataService dataService ; private final DeptService deptService ; private final RoleService roleService ; private final VerifyService verificationCodeService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportUser ( HttpServletResponse response , UserQueryCriteria criteria ) throws IOException { userService . download ( userService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < User > > queryUser ( UserQueryCriteria criteria , Page < Object > page ) { if ( ! ObjectUtils . isEmpty ( criteria . getDeptId ( ) ) ) { criteria . getDeptIds ( ) . add ( criteria . getDeptId ( ) ) ; List < Dept > data = deptService . findByPid ( criteria . getDeptId ( ) ) ; criteria . getDeptIds ( ) . addAll ( deptService . getDeptChildren ( data ) ) ; } List < Long > dataScopes = dataService . getDeptIds ( userService . findByName ( SecurityUtils . getCurrentUsername ( ) ) ) ; if ( ! CollectionUtils . isEmpty ( criteria . getDeptIds ( ) ) && ! CollectionUtils . isEmpty ( dataScopes ) ) { criteria . getDeptIds ( ) . retainAll ( dataScopes ) ; if ( ! CollectionUtil . isEmpty ( criteria . getDeptIds ( ) ) ) { return new ResponseEntity < > ( userService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } } else { criteria . getDeptIds ( ) . addAll ( dataScopes ) ; return new ResponseEntity < > ( userService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } return new ResponseEntity < > ( PageUtil . noData ( ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createUser ( @ Validated @ RequestBody User resources ) { checkLevel ( resources ) ; resources . setPassword ( passwordEncoder . encode ( \"<STR_LIT>\" ) ) ; userService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateUser ( @ Validated ( User . Update . class ) @ RequestBody User resources ) throws Exception { checkLevel ( resources ) ; userService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > centerUser ( @ Validated ( User . Update . class ) @ RequestBody User resources ) {", "output": "if ( ! resources . getId ( ) . equals ( SecurityUtils . getCurrentUserId ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } userService . updateCenter ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteUser ( @ RequestBody Set < Long > ids ) { for ( Long id : ids ) { Integer currentLevel = Collections . min ( roleService . findByUsersId ( SecurityUtils . getCurrentUserId ( ) ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; Integer optLevel = Collections . min ( roleService . findByUsersId ( id ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; if ( currentLevel > optLevel ) { throw new BadRequestException ( \"<STR_LIT>\" + userService . findById ( id ) . getUsername ( ) ) ; } } userService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > updateUserPass ( @ RequestBody UserPassVo passVo ) throws Exception { String oldPass = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , passVo . getOldPass ( ) ) ; String newPass = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , passVo . getNewPass ( ) ) ; User user = userService . findByName ( SecurityUtils . getCurrentUsername ( ) ) ; if ( ! passwordEncoder . matches ( oldPass , user . getPassword ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } if ( passwordEncoder . matches ( newPass , user . getPassword ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } userService . updatePass ( user . getUsername ( ) , passwordEncoder . encode ( newPass ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > resetPwd ( @ RequestBody Set < Long > ids ) { String pwd = passwordEncoder . encode ( \"<STR_LIT>\" ) ; userService . resetPwd ( ids , pwd ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > updateUserAvatar ( @ RequestParam MultipartFile avatar ) { return new ResponseEntity < > ( userService . updateAvatar ( avatar ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > updateUserEmail ( @ PathVariable String code , @ RequestBody User resources ) throws Exception { String password = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , resources . getPassword ( ) ) ; User user = userService . findByName ( SecurityUtils . getCurrentUsername ( ) ) ; if ( ! passwordEncoder . matches ( password , user . getPassword ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } verificationCodeService . validated ( CodeEnum . EMAIL_RESET_EMAIL_CODE . getKey ( ) + user . getEmail ( ) , code ) ; userService . updateEmail ( user . getUsername ( ) , user . getEmail ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } private void checkLevel ( User resources ) { Integer currentLevel = Collections . min ( roleService . findByUsersId ( SecurityUtils . getCurrentUserId ( ) ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; Integer optLevel = roleService . findByRoles ( resources . getRoles ( ) ) ; if ( currentLevel > optLevel ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package com . youlai . system . config . property ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import java . util . List ; @ Data @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class SecurityProperties { private List < String > ignoreUrls ; private JwtProperty jwt ; @ Data public static class JwtProperty { private String key ; private Long ttl ; }", "output": "}"}, {"input": "package me . zhengjie . config ; import lombok . Data ; import me . zhengjie . utils . ElConstant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . context . annotation . Configuration ; @ Data @ Configuration @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class FileProperties { private Long maxSize ; private Long avatarMaxSize ; private ElPath mac ; private ElPath linux ; private ElPath windows ; public ElPath getPath ( ) { String os = System . getProperty ( \"<STR_LIT>\" ) ; if ( os . toLowerCase ( ) . startsWith ( ElConstant . WIN ) ) {", "output": "return windows ; } else if ( os . toLowerCase ( ) . startsWith ( ElConstant . MAC ) ) { return mac ; } return linux ; } @ Data public static class ElPath { private String path ; private String avatar ; } }"}, {"input": "package com . youlai . system . plugin . xxljob ; import com . xxl . job . core . handler . annotation . XxlJob ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Component ; @ Component @ Slf4j public class XxlJobSampleHandler { @ XxlJob ( \"<STR_LIT>\" ) public void demoJobHandler ( ) { log . info ( \"<STR_LIT>\" ) ; }", "output": "}"}, {"input": "package me . zhengjie . config . thread ; import lombok . Data ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component public class AsyncTaskProperties { public static int corePoolSize ; public static int maxPoolSize ; public static int keepAliveSeconds ; public static int queueCapacity ; @ Value ( \"<STR_LIT>\" ) public void setCorePoolSize ( int corePoolSize ) { AsyncTaskProperties . corePoolSize = corePoolSize ;", "output": "} @ Value ( \"<STR_LIT>\" ) public void setMaxPoolSize ( int maxPoolSize ) { AsyncTaskProperties . maxPoolSize = maxPoolSize ; } @ Value ( \"<STR_LIT>\" ) public void setKeepAliveSeconds ( int keepAliveSeconds ) { AsyncTaskProperties . keepAliveSeconds = keepAliveSeconds ; } @ Value ( \"<STR_LIT>\" ) public void setQueueCapacity ( int queueCapacity ) { AsyncTaskProperties . queueCapacity = queueCapacity ; } }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . ContactHeadImg ; import com . xcs . wx . mapper . ContactHeadImgMapper ; import com . xcs . wx . repository . ContactHeadImgRepository ; import org . springframework . stereotype . Repository ; @ Repository @ DS ( value = DataSourceType . MISC_DB ) public class ContactHeadImgRepositoryImpl extends ServiceImpl < ContactHeadImgMapper , ContactHeadImg > implements ContactHeadImgRepository { @ Override public byte [ ] getContactHeadImg ( String usrName ) { ContactHeadImg contactHeadImg = super . getBaseMapper ( ) . getContactHeadImg ( usrName ) ; if ( contactHeadImg != null ) { return contactHeadImg . getSmallHeadBuf ( ) ; } return new byte [ ] {", "output": "} ; } }"}, {"input": "package top . kangert . kspider . context ; import lombok . Getter ; import lombok . extern . slf4j . Slf4j ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . model . SpiderOutput ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . OutputStream ; import java . util . ArrayList ; import java . util . List ; import cn . hutool . core . io . IoUtil ; @ Slf4j public class SpiderJobContext extends SpiderContext { @ Getter private OutputStream outputStream ; private List < SpiderOutput > outputs = new ArrayList < > ( ) ; private boolean allowOutput ; public SpiderJobContext ( OutputStream outputStream , boolean allowOutput ) {", "output": "this . outputStream = outputStream ; this . allowOutput = allowOutput ; } @ Override public void addOutput ( SpiderOutput output ) { if ( this . allowOutput ) { synchronized ( this . outputs ) { this . outputs . add ( output ) ; } } } @ Override public List < SpiderOutput > getOutputs ( ) { return outputs ; } public void close ( ) { IoUtil . close ( this . outputStream ) ; } public static SpiderJobContext create ( String workspace , Long flowId , Long taskId , boolean allowOutput ) throws FileNotFoundException { String flowFolder = Constants . KSPIDER_FLOW_LOG_DIR_PREFIX + flowId ; String taskFolder = Constants . KSPIDER_TASK_LOG_DIR_PREFIX + taskId ; File file = new File ( new File ( workspace ) , \"<STR_LIT>\" + File . separator + flowFolder + File . separator + \"<STR_LIT>\" + File . separator + taskFolder + \"<STR_LIT>\" ) ; File dirFile = file . getParentFile ( ) ; if ( ! dirFile . exists ( ) ) { dirFile . mkdirs ( ) ; } OutputStream os = new FileOutputStream ( file , true ) ; SpiderJobContext context = new SpiderJobContext ( os , allowOutput ) ; context . setFlowId ( flowId ) ; return context ; } }"}, {"input": "package ginyi . common . utils ; import ginyi . common . utils . text . Convert ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . ServletRequest ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . servlet . http . HttpSession ; import java . io . IOException ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; public class ServletUtils { public static String getParameter ( String name ) { return getRequest ( ) . getParameter ( name ) ; } public static String getParameter ( String name , String defaultValue ) { return Convert . toStr ( getRequest ( ) . getParameter ( name ) , defaultValue ) ; } public static Integer getParameterToInt ( String name ) { return Convert . toInt ( getRequest ( ) . getParameter ( name ) ) ; } public static Integer getParameterToInt ( String name , Integer defaultValue ) { return Convert . toInt ( getRequest ( ) . getParameter ( name ) , defaultValue ) ; } public static Boolean getParameterToBool ( String name ) { return Convert . toBool ( getRequest ( ) . getParameter ( name ) ) ; } public static Boolean getParameterToBool ( String name , Boolean defaultValue ) { return Convert . toBool ( getRequest ( ) . getParameter ( name ) , defaultValue ) ; } public static Map < String , String [ ] > getParams ( ServletRequest request ) { final Map < String , String [ ] > map = request . getParameterMap ( ) ; return Collections . unmodifiableMap ( map ) ; } public static Map < String , String > getParamMap ( ServletRequest request ) { Map < String , String > params = new HashMap < > ( ) ; for ( Map . Entry < String , String [ ] > entry : getParams ( request ) . entrySet ( ) ) { params . put ( entry . getKey ( ) , StringUtils . join ( entry . getValue ( ) , \"<STR_LIT>\" ) ) ; } return params ; } public static HttpServletRequest getRequest ( ) { return getRequestAttributes ( ) . getRequest ( ) ; } public static HttpServletResponse getResponse ( ) { return getRequestAttributes ( ) . getResponse ( ) ; } public static HttpSession getSession ( ) { return getRequest ( ) . getSession ( ) ; } public static ServletRequestAttributes getRequestAttributes ( ) { RequestAttributes attributes = RequestContextHolder . getRequestAttributes ( ) ; return ( ServletRequestAttributes ) attributes ; } public static void renderString ( HttpServletResponse response , String string ) { try { response . setStatus ( <NUM_LIT> ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . getWriter ( ) . print ( string ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } public static boolean isAjaxRequest ( HttpServletRequest request ) { String accept = request . getHeader ( \"<STR_LIT>\" ) ; if ( accept != null && accept . contains ( \"<STR_LIT>\" ) ) { return true ; } String xRequestedWith = request . getHeader ( \"<STR_LIT>\" ) ; if ( xRequestedWith != null && xRequestedWith . contains ( \"<STR_LIT>\" ) ) { return true ; } String uri = request . getRequestURI ( ) ; if ( StringUtils . inStringIgnoreCase ( uri , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) { return true ; } String ajax = request . getParameter ( \"<STR_LIT>\" ) ; return StringUtils . inStringIgnoreCase ( ajax , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; }", "output": "public static String urlEncode ( String str ) { try { return URLEncoder . encode ( str , Constants . UTF8 ) ; } catch ( UnsupportedEncodingException e ) { return StringUtils . EMPTY ; } } public static String urlDecode ( String str ) { try { return URLDecoder . decode ( str , Constants . UTF8 ) ; } catch ( UnsupportedEncodingException e ) { return StringUtils . EMPTY ; } } }"}, {"input": "package top . kangert . kspider . model ; import lombok . AllArgsConstructor ; import lombok . Getter ; import lombok . NoArgsConstructor ; import lombok . Setter ; @ Getter @ Setter @ NoArgsConstructor @ AllArgsConstructor public class Shape { private String name ; private String label ; private String title ; private String icon ; private String desc ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . api . mail . Impl ; import cn . hutool . extra . mail . MailAccount ; import cn . hutool . extra . mail . MailUtil ; import com . oddfar . campus . framework . api . mail . MailConfigRead ; import com . oddfar . campus . framework . api . mail . MailSendApi ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class MailServiceImpl implements MailSendApi { @ Async @ Override public void sendQQMail ( List < String > tos , String subject , String content , Boolean isHtml ) { String host = MailConfigRead . getSmtpHost ( ) ; String port = MailConfigRead . getSmtpPort ( ) ;", "output": "String account = MailConfigRead . getSendAccount ( ) ; String password = MailConfigRead . getPassword ( ) ; MailAccount mailAccount = new MailAccount ( ) ; mailAccount . setHost ( host ) ; mailAccount . setPort ( Integer . parseInt ( port ) ) ; mailAccount . setAuth ( true ) ; mailAccount . setFrom ( account ) ; mailAccount . setPass ( password ) ; mailAccount . setSslEnable ( true ) ; MailUtil . send ( mailAccount , tos , subject , content , isHtml ) ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . UserDailyLoginDuration ; import cn . org . alan . exam . model . entity . UserExerciseRecord ; import cn . org . alan . exam . model . vo . stat . DailyVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface UserDailyLoginDurationMapper extends BaseMapper < UserDailyLoginDuration > { List < DailyVO > getDaily ( Integer userId ) ;", "output": "}"}, {"input": "package com . oddfar . campus . common . validator ; import com . oddfar . campus . common . utils . StringUtils ; import javax . validation . ConstraintValidator ; import javax . validation . ConstraintValidatorContext ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class XssValidator implements ConstraintValidator < Xss , String > { private static final String HTML_PATTERN = \"<STR_LIT>\" ; @ Override public boolean isValid ( String value , ConstraintValidatorContext constraintValidatorContext ) { if ( StringUtils . isBlank ( value ) ) { return true ; } return ! containsHtml ( value ) ; }", "output": "public static boolean containsHtml ( String value ) { Pattern pattern = Pattern . compile ( HTML_PATTERN ) ; Matcher matcher = pattern . matcher ( value ) ; return matcher . matches ( ) ; } }"}, {"input": "package org . example . dddworkspace . domain . workspace ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import java . util . UUID ; @ Getter @ Builder public class WorkspaceEntity { private String name ; private Long owner ; public static WorkspaceEntity create ( Long owner ) { if ( owner == null || owner <= <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } String workspaceName = String . format ( \"<STR_LIT>\" , UUID . randomUUID ( ) . toString ( ) ) ; WorkspaceEntity workspace = WorkspaceEntity . builder ( ) . name ( workspaceName ) . owner ( owner ) . build ( ) ;", "output": "return workspace ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . UserBook ; import cn . org . alan . exam . model . entity . UserDailyLoginDuration ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IUserDailyLoginDurationService extends IService < UserDailyLoginDuration > {", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . service . DeployHistoryService ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class DeployHistoryController { private final DeployHistoryService deployhistoryService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportDeployHistory ( HttpServletResponse response , DeployHistoryQueryCriteria criteria ) throws IOException { deployhistoryService . download ( deployhistoryService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < DeployHistory > > queryDeployHistory ( DeployHistoryQueryCriteria criteria , Page < Object > page ) {", "output": "return new ResponseEntity < > ( deployhistoryService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteDeployHistory ( @ RequestBody Set < String > ids ) { deployhistoryService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package ginyi . system . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import lombok . Data ; import java . util . Date ; import java . util . List ; @ Data public class SysUser extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId private Long userId ; private Long deptId ; private String userName ; private String nickName ; private String email ; private String phoneNumber ; private String sex ; private String avatar ; private String password ; private String status ; @ TableLogic private String deleted ; private String loginIp ; private Date loginDate ; private String remark ; @ TableField ( exist = false , select = false ) private SysDept dept ; @ TableField ( exist = false , select = false ) private List < SysRole > roles ; @ TableField ( exist = false , select = false ) private Long [ ] roleIds ; @ TableField ( exist = false , select = false ) private List < SysPost > posts ; @ TableField ( exist = false , select = false ) private Long [ ] postIds ; @ TableField ( exist = false , select = false ) private Long roleId ; public boolean isAdmin ( ) { return isAdmin ( this . userId ) ; } public static boolean isAdmin ( Long userId ) { return userId != null && <NUM_LIT> == userId ;", "output": "} }"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserPassReqDTO implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String oldPassword ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String password ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; @ Data @ AllArgsConstructor public class RecentUsedKeyWordVO { private String text ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; public interface RowReadingListener { void onFinish ( SheetConfig sheetConfig , Object rowData , int rowIndex ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . config . properties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . context . properties . NestedConfigurationProperty ; import org . springframework . util . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; @ ConfigurationProperties ( NacosConfigConstants . PREFIX ) public class NacosConfigProperties { private String serverAddr = \"<STR_LIT>\" ; private String contextPath ; private String encode ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private boolean autoRefresh = false ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type = ConfigType . PROPERTIES ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; private boolean remoteFirst = false ; @ JsonIgnore private List < Config > extConfig = new ArrayList < > ( ) ; @ NestedConfigurationProperty private Bootstrap bootstrap = new Bootstrap ( ) ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { Assert . notNull ( serverAddr , \"<STR_LIT>\" ) ; this . serverAddr = serverAddr ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public String getEncode ( ) { return encode ; } public void setEncode ( String encode ) { this . encode = encode ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; }", "output": "public boolean isRemoteFirst ( ) { return remoteFirst ; } public void setRemoteFirst ( boolean remoteFirst ) { this . remoteFirst = remoteFirst ; } public List < Config > getExtConfig ( ) { return extConfig ; } public void setExtConfig ( List < Config > extConfig ) { this . extConfig = extConfig ; } public Bootstrap getBootstrap ( ) { return bootstrap ; } public void setBootstrap ( Bootstrap bootstrap ) { this . bootstrap = bootstrap ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( contextPath ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( encode ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( extConfig ) ; sb . append ( \"<STR_LIT>\" ) . append ( bootstrap ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public static class Bootstrap { private boolean enable ; private boolean logEnable ; public boolean isEnable ( ) { return enable ; } public void setEnable ( boolean enable ) { this . enable = enable ; } public boolean isLogEnable ( ) { return logEnable ; } public void setLogEnable ( boolean logEnable ) { this . logEnable = logEnable ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( enable ) ; sb . append ( \"<STR_LIT>\" ) . append ( logEnable ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } public static class Config { private String serverAddr ; private String endpoint ; private String namespace ; private String accessKey ; private String secretKey ; private String ramRoleName ; private String dataId ; private String dataIds ; private String group = Constants . DEFAULT_GROUP ; private ConfigType type ; private String maxRetry ; private String configLongPollTimeout ; private String configRetryTime ; private boolean autoRefresh = false ; private boolean enableRemoteSyncConfig = false ; private String username ; private String password ; public String getUsername ( ) { return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getServerAddr ( ) { return serverAddr ; } public void setServerAddr ( String serverAddr ) { this . serverAddr = serverAddr ; } public String getEndpoint ( ) { return endpoint ; } public void setEndpoint ( String endpoint ) { this . endpoint = endpoint ; } public String getNamespace ( ) { return namespace ; } public void setNamespace ( String namespace ) { this . namespace = namespace ; } public String getAccessKey ( ) { return accessKey ; } public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; } public String getSecretKey ( ) { return secretKey ; } public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; } public String getRamRoleName ( ) { return ramRoleName ; } public void setRamRoleName ( String ramRoleName ) { this . ramRoleName = ramRoleName ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getDataIds ( ) { return dataIds ; } public void setDataIds ( String dataIds ) { this . dataIds = dataIds ; } public String getGroup ( ) { return group ; } public void setGroup ( String group ) { this . group = group ; } public ConfigType getType ( ) { return type ; } public void setType ( ConfigType type ) { this . type = type ; } public String getMaxRetry ( ) { return maxRetry ; } public void setMaxRetry ( String maxRetry ) { this . maxRetry = maxRetry ; } public String getConfigLongPollTimeout ( ) { return configLongPollTimeout ; } public void setConfigLongPollTimeout ( String configLongPollTimeout ) { this . configLongPollTimeout = configLongPollTimeout ; } public String getConfigRetryTime ( ) { return configRetryTime ; } public void setConfigRetryTime ( String configRetryTime ) { this . configRetryTime = configRetryTime ; } public boolean isAutoRefresh ( ) { return autoRefresh ; } public void setAutoRefresh ( boolean autoRefresh ) { this . autoRefresh = autoRefresh ; } public boolean isEnableRemoteSyncConfig ( ) { return enableRemoteSyncConfig ; } public void setEnableRemoteSyncConfig ( boolean enableRemoteSyncConfig ) { this . enableRemoteSyncConfig = enableRemoteSyncConfig ; } @ Override public String toString ( ) { final StringBuffer sb = new StringBuffer ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) . append ( serverAddr ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( endpoint ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( namespace ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( accessKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( Objects . isNull ( secretKey ) ? null : \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( ramRoleName ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataId ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( dataIds ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( group ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( type ) ; sb . append ( \"<STR_LIT>\" ) . append ( maxRetry ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configLongPollTimeout ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( configRetryTime ) . append ( '<STR_LIT>' ) ; sb . append ( \"<STR_LIT>\" ) . append ( autoRefresh ) ; sb . append ( \"<STR_LIT>\" ) . append ( enableRemoteSyncConfig ) ; sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } } }"}, {"input": "package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Role ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface UserRoleMapper {", "output": "void insertData ( @ Param ( \"<STR_LIT>\" ) Long userId , @ Param ( \"<STR_LIT>\" ) Set < Role > roles ) ; void deleteByUserId ( @ Param ( \"<STR_LIT>\" ) Long userId ) ; void deleteByUserIds ( @ Param ( \"<STR_LIT>\" ) Set < Long > userIds ) ; }"}, {"input": "package ginyi . common . utils . spring ; import ginyi . common . utils . StringUtils ; import org . springframework . aop . framework . AopContext ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public final class SpringUtils implements BeanFactoryPostProcessor , ApplicationContextAware { private static ConfigurableListableBeanFactory beanFactory ; private static ApplicationContext applicationContext ; @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException { SpringUtils . beanFactory = beanFactory ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { SpringUtils . applicationContext = applicationContext ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T getBean ( String name ) throws BeansException { return ( T ) beanFactory . getBean ( name ) ; } public static < T > T getBean ( Class < T > clz ) throws BeansException { T result = ( T ) beanFactory . getBean ( clz ) ; return result ; } public static boolean containsBean ( String name ) { return beanFactory . containsBean ( name ) ; } public static boolean isSingleton ( String name ) throws NoSuchBeanDefinitionException { return beanFactory . isSingleton ( name ) ;", "output": "} public static Class < ? > getType ( String name ) throws NoSuchBeanDefinitionException { return beanFactory . getType ( name ) ; } public static String [ ] getAliases ( String name ) throws NoSuchBeanDefinitionException { return beanFactory . getAliases ( name ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T getAopProxy ( T invoker ) { return ( T ) AopContext . currentProxy ( ) ; } public static String [ ] getActiveProfiles ( ) { return applicationContext . getEnvironment ( ) . getActiveProfiles ( ) ; } public static String getActiveProfile ( ) { final String [ ] activeProfiles = getActiveProfiles ( ) ; return StringUtils . isNotEmpty ( activeProfiles ) ? activeProfiles [ <NUM_LIT> ] : null ; } public static String getRequiredProperty ( String key ) { return applicationContext . getEnvironment ( ) . getRequiredProperty ( key ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . logging ; import org . slf4j . Logger ; import java . util . HashMap ; import java . util . Map ; public class PerformanceUtil { private PerformanceUtil ( ) { } private static ThreadLocal < Timer > localTimer = new ThreadLocal < Timer > ( ) { @ Override protected Timer initialValue ( ) { return new Timer ( ) ; } } ; private static ThreadLocal < Map < String , Timer > > localTimerMap = new ThreadLocal < Map < String , Timer > > ( ) { @ Override protected Map < String , Timer > initialValue ( ) { return new HashMap < String , Timer > ( ) ; } } ; public static void start ( ) {", "output": "localTimer . get ( ) . start ( ) ; } public static long duration ( ) { return localTimer . get ( ) . duration ( ) ; } public static long end ( ) { long duration = localTimer . get ( ) . duration ( ) ; localTimer . remove ( ) ; return duration ; } public static void start ( String key ) { getTimer ( key ) . start ( ) ; } public static long duration ( String key ) { return getTimer ( key ) . duration ( ) ; } public static long end ( String key ) { long duration = getTimer ( key ) . duration ( ) ; localTimerMap . get ( ) . remove ( key ) ; return duration ; } public static void removeAll ( ) { localTimer . remove ( ) ; localTimerMap . remove ( ) ; } public static void slowLog ( Logger logger , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold ) ; } } public static void slowLog ( Logger logger , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , duration , threshold , context ) ; } } public static void slowLog ( Logger logger , String key , long duration , long threshold , String context ) { if ( duration > threshold ) { logger . warn ( \"<STR_LIT>\" , key , duration , threshold , context ) ; } } public static void endWithSlowLog ( Logger logger , long threshold ) { slowLog ( logger , end ( ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold ) { slowLog ( logger , key , end ( key ) , threshold ) ; } public static void endWithSlowLog ( Logger logger , long threshold , String context ) { slowLog ( logger , end ( ) , threshold , context ) ; } public static void endWithSlowLog ( Logger logger , String key , long threshold , String context ) { slowLog ( logger , key , end ( key ) , threshold , context ) ; } private static Timer getTimer ( String key ) { Map < String , Timer > map = localTimerMap . get ( ) ; Timer timer = map . get ( key ) ; if ( timer == null ) { timer = new Timer ( ) ; map . put ( key , timer ) ; } return timer ; } static class Timer { private long start ; public void start ( ) { start = System . currentTimeMillis ( ) ; } public long duration ( ) { return System . currentTimeMillis ( ) - start ; } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import java . util . Map ; import java . util . Properties ; public interface ConfigParse { Map < String , Object > parse ( String configText ) ; String processType ( ) ;", "output": "String dataId ( ) ; String group ( ) ; }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . form . GradeForm ; import cn . org . alan . exam . model . vo . GradeVO ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface GradeConverter {", "output": "Page < GradeVO > pageEntityToVo ( Page < Grade > page ) ; Grade formToEntity ( GradeForm gradeForm ) ; List < GradeVO > listEntityToVo ( List < Grade > page ) ; GradeVO GradeToGradeVO ( Grade grade ) ; }"}, {"input": "package com . oddfar . campus . business . controller ; import com . oddfar . campus . common . annotation . Anonymous ; import com . oddfar . campus . common . annotation . Sensitive ; import com . oddfar . campus . common . enums . SensitiveStrategy ; import com . oddfar . campus . common . domain . R ; import io . swagger . v3 . oas . annotations . Operation ; import lombok . Data ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class TestSensitiveController { @ GetMapping ( \"<STR_LIT>\" ) @ Anonymous @ Operation ( description = \"<STR_LIT>\" ) public R test ( ) { TestSensitive testSensitive = new TestSensitive ( ) ; testSensitive . setIdCard ( \"<STR_LIT>\" ) ; testSensitive . setPhone ( \"<STR_LIT>\" ) ; testSensitive . setAddress ( \"<STR_LIT>\" ) ; testSensitive . setEmail ( \"<STR_LIT>\" ) ; testSensitive . setBankCard ( \"<STR_LIT>\" ) ; return R . ok ( testSensitive ) ; } @ Data static class TestSensitive { @ Sensitive ( strategy = SensitiveStrategy . ID_CARD ) private String idCard ; @ Sensitive ( strategy = SensitiveStrategy . PHONE ) private String phone ; @ Sensitive ( strategy = SensitiveStrategy . ADDRESS ) private String address ;", "output": "@ Sensitive ( strategy = SensitiveStrategy . EMAIL ) private String email ; @ Sensitive ( strategy = SensitiveStrategy . BANK_CARD ) private String bankCard ; } }"}, {"input": "package ginyi . common . utils . ip ; import ginyi . common . utils . StringUtils ; import javax . servlet . http . HttpServletRequest ; import java . net . InetAddress ; import java . net . UnknownHostException ; public class IpUtils { public static String getIpAddr ( HttpServletRequest request ) { if ( request == null ) { return \"<STR_LIT>\" ; } String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : getMultistageReverseProxyIp ( ip ) ; } public static boolean internalIp ( String ip ) { byte [ ] addr = textToNumericFormatV4 ( ip ) ; return internalIp ( addr ) || \"<STR_LIT>\" . equals ( ip ) ; } private static boolean internalIp ( byte [ ] addr ) { if ( StringUtils . isNull ( addr ) || addr . length < <NUM_LIT> ) { return true ; } final byte b0 = addr [ <NUM_LIT> ] ; final byte b1 = addr [ <NUM_LIT> ] ; final byte SECTION_1 = <NUM_LIT> ; final byte SECTION_2 = ( byte ) <NUM_LIT> ; final byte SECTION_3 = ( byte ) <NUM_LIT> ; final byte SECTION_4 = ( byte ) <NUM_LIT> ; final byte SECTION_5 = ( byte ) <NUM_LIT> ; final byte SECTION_6 = ( byte ) <NUM_LIT> ; switch ( b0 ) { case SECTION_1 : return true ; case SECTION_2 : if ( b1 >= SECTION_3 && b1 <= SECTION_4 ) { return true ; } case SECTION_5 : switch ( b1 ) { case SECTION_6 : return true ; } default : return false ; } } public static byte [ ] textToNumericFormatV4 ( String text ) { if ( text . length ( ) == <NUM_LIT> ) { return null ; } byte [ ] bytes = new byte [ <NUM_LIT> ] ; String [ ] elements = text . split ( \"<STR_LIT>\" , - <NUM_LIT> ) ; try { long l ; int i ; switch ( elements . length ) { case <NUM_LIT> : l = Long . parseLong ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( ( l & <NUM_LIT> ) > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( ( l & <NUM_LIT> ) > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; break ; case <NUM_LIT> : l = Integer . parseInt ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; l = Integer . parseInt ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( ( l & <NUM_LIT> ) > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; break ; case <NUM_LIT> : for ( i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { l = Integer . parseInt ( elements [ i ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ i ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; } l = Integer . parseInt ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; break ; case <NUM_LIT> : for ( i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { l = Integer . parseInt ( elements [ i ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) {", "output": "return null ; } bytes [ i ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; } break ; default : return null ; } } catch ( NumberFormatException e ) { return null ; } return bytes ; } public static String getHostIp ( ) { try { return InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { } return \"<STR_LIT>\" ; } public static String getHostName ( ) { try { return InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { } return \"<STR_LIT>\" ; } public static String getMultistageReverseProxyIp ( String ip ) { if ( ip != null && ip . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) { final String [ ] ips = ip . trim ( ) . split ( \"<STR_LIT>\" ) ; for ( String subIp : ips ) { if ( false == isUnknown ( subIp ) ) { ip = subIp ; break ; } } } return ip ; } public static boolean isUnknown ( String checkString ) { return StringUtils . isBlank ( checkString ) || \"<STR_LIT>\" . equalsIgnoreCase ( checkString ) ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . GradeExercise ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface GradeExerciseMapper extends BaseMapper < GradeExercise > { Integer deleteByUserIds ( List < Integer > userIds ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Exam ; import cn . org . alan . exam . model . vo . answer . AnswerExamVO ; import cn . org . alan . exam . model . vo . record . ExamRecordVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springframework . stereotype . Repository ; import java . util . List ; public interface ExamMapper extends BaseMapper < Exam > { int deleteExams ( List < Integer > examIds ) ; int deleteExamGrades ( List < Integer > examIds ) ;", "output": "int deleteExamRepos ( List < Integer > examIds ) ; int deleteExamQuestions ( List < Integer > examIds ) ; Integer deleteByUserIds ( List < Integer > userIds ) ; IPage < AnswerExamVO > selectMarkedList ( @ Param ( \"<STR_LIT>\" ) IPage < AnswerExamVO > page , @ Param ( \"<STR_LIT>\" ) Integer userId , String role , String examName ) ; Page < ExamRecordVO > getExamRecordPage ( Page < ExamRecordVO > examPage , Integer userId , String examName ) ; }"}, {"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . List ; public class ClassUtil { private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ClassUtil . class ) ; public static String getShortClassName ( final Class < ? > cls ) { return ClassUtils . getShortClassName ( cls ) ; } public static String getShortClassName ( final String className ) { return ClassUtils . getShortClassName ( className ) ; } public static String getPackageName ( final Class < ? > cls ) {", "output": "return ClassUtils . getPackageName ( cls ) ; } public static String getPackageName ( final String className ) { return ClassUtils . getPackageName ( className ) ; } public static List < Class < ? > > getAllSuperclasses ( final Class < ? > cls ) { return ClassUtils . getAllSuperclasses ( cls ) ; } public static List < Class < ? > > getAllInterfaces ( final Class < ? > cls ) { return ClassUtils . getAllInterfaces ( cls ) ; } public static boolean isSubClassOrInterfaceOf ( Class subclass , Class superclass ) { return superclass . isAssignableFrom ( subclass ) ; } public static Class < ? > unwrapCglib ( Object instance ) { Validate . notNull ( instance , \"<STR_LIT>\" ) ; Class < ? > clazz = instance . getClass ( ) ; if ( ( clazz != null ) && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( ( superClass != null ) && ! Object . class . equals ( superClass ) ) { return superClass ; } } return clazz ; } public static < T > Class < T > getClassGenericType ( final Class clazz ) { return getClassGenericType ( clazz , <NUM_LIT> ) ; } public static Class getClassGenericType ( final Class clazz , final int index ) { Type genType = clazz . getGenericSuperclass ( ) ; if ( ! ( genType instanceof ParameterizedType ) ) { logger . warn ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } Type [ ] params = ( ( ParameterizedType ) genType ) . getActualTypeArguments ( ) ; if ( ( index >= params . length ) || ( index < <NUM_LIT> ) ) { logger . warn ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + clazz . getSimpleName ( ) + \"<STR_LIT>\" + params . length ) ; return Object . class ; } if ( ! ( params [ index ] instanceof Class ) ) { logger . warn ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } return ( Class ) params [ index ] ; } }"}, {"input": "package com . youlai . system . config . property ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) @ Data public class CaptchaProperties { private String type ; private int width ; private int height ; private int interfereCount ; private Float textAlpha ; private Long expireSeconds ; private CodeProperties code ; private FontProperties font ; @ Data public static class CodeProperties { private String type ; private int length ; } @ Data public static class FontProperties { private String name ; private int weight ; private int size ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . exception . file ; import com . oddfar . campus . common . exception . base . BaseException ; public class FileException extends BaseException { private static final long serialVersionUID = <NUM_LIT> ; public FileException ( String code , Object [ ] args ) {", "output": "super ( \"<STR_LIT>\" , code , args , null ) ; } }"}, {"input": "package com . yf . base . utils . jackson ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . DeserializationContext ; import com . fasterxml . jackson . databind . JsonDeserializer ; import java . io . IOException ; public class NumericBooleanDeserializer extends JsonDeserializer < Boolean > { private static final String TRUE_TEXT = \"<STR_LIT>\" ; @ Override public Boolean deserialize ( JsonParser jp , DeserializationContext ctx ) throws IOException , JsonProcessingException { return jp . getText ( ) . equals ( TRUE_TEXT ) ; }", "output": "}"}, {"input": "package com . yf . base . utils . download . thread ; import com . yf . base . utils . download . temp . DownloadTempThread ; import org . apache . http . client . methods . CloseableHttpResponse ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClients ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . io . RandomAccessFile ; public class DownloadThread extends Thread { private Logger logger = LoggerFactory . getLogger ( \"<STR_LIT>\" ) ; private long skip ; private long pos ; private long loaded ; private String url ; private String dist ; public DownloadThread ( ) { } public DownloadThread ( String url , String dist , long skip , long pos ) { this . skip = skip ; this . pos = pos ; this . url = url ; this . dist = dist ; } @ Override public void run ( ) { String threadName = Thread . currentThread ( ) . getName ( ) ; logger . info ( \"<STR_LIT>\" , threadName ) ; RandomAccessFile raf ; CloseableHttpClient client = HttpClients . createDefault ( ) ; HttpGet get = new HttpGet ( this . url ) ; get . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + this . skip + \"<STR_LIT>\" + this . pos ) ; try { raf = new RandomAccessFile ( this . dist , \"<STR_LIT>\" ) ; raf . seek ( this . skip ) ; CloseableHttpResponse response = client . execute ( get ) ; InputStream is = response . getEntity ( ) . getContent ( ) ; int len ; byte [ ] b = new byte [ <NUM_LIT> ] ; while ( ( len = is . read ( b ) ) != - <NUM_LIT> ) { raf . write ( b , <NUM_LIT> , len ) ; loaded += len ; } is . close ( ) ; raf . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ;", "output": "} } public DownloadTempThread toTemp ( ) { DownloadTempThread t = new DownloadTempThread ( ) ; t . setLoaded ( this . loaded ) ; t . setPos ( this . pos ) ; t . setSkip ( this . skip ) ; t . setThreadName ( this . getName ( ) ) ; return t ; } public void fromTemp ( String url , String dist , DownloadTempThread t ) { this . url = url ; this . dist = dist ; this . skip = t . getSkip ( ) + t . getLoaded ( ) ; this . pos = t . getPos ( ) ; this . loaded = t . getLoaded ( ) ; this . setName ( t . getThreadName ( ) ) ; } public long getSkip ( ) { return skip ; } public void setSkip ( long skip ) { this . skip = skip ; } public long getPos ( ) { return pos ; } public void setPos ( long pos ) { this . pos = pos ; } public long getLoaded ( ) { return loaded ; } public void setLoaded ( long loaded ) { this . loaded = loaded ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } }"}, {"input": "package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Job ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface UserJobMapper {", "output": "void insertData ( @ Param ( \"<STR_LIT>\" ) Long userId , @ Param ( \"<STR_LIT>\" ) Set < Job > jobs ) ; void deleteByUserId ( @ Param ( \"<STR_LIT>\" ) Long userId ) ; void deleteByUserIds ( @ Param ( \"<STR_LIT>\" ) Set < Long > userIds ) ; }"}, {"input": "package top . kangert . kspider . enums ; public enum TaskStateEnum { TASK_CREATED ( <NUM_LIT> , \"<STR_LIT>\" ) , TASK_RUNNING ( <NUM_LIT> , \"<STR_LIT>\" ) , TASK_ERROR ( <NUM_LIT> , \"<STR_LIT>\" ) , TASK_FINISHED ( <NUM_LIT> , \"<STR_LIT>\" ) ;", "output": "private int typeCode = - <NUM_LIT> ; private String remark = \"<STR_LIT>\" ; TaskStateEnum ( int typeCode , String remark ) { this . typeCode = typeCode ; this . remark = remark ; } public int getTypeCode ( ) { return typeCode ; } public String getRemark ( ) { return remark ; } public static TaskStateEnum getEnumObj ( int typeCode ) { for ( TaskStateEnum item : values ( ) ) { if ( item . getTypeCode ( ) == typeCode ) { return item ; } } return null ; } }"}, {"input": "package com . oddfar . campus . common . domain . model ; public class LoginBody { private String username ; private String password ; private String code ; private String uuid ; public String getUsername ( ) {", "output": "return username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getUuid ( ) { return uuid ; } public void setUuid ( String uuid ) { this . uuid = uuid ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustXhZyzsParam { String type ; String memberId ; String exchangeCoinId ; String entrustCode ;", "output": "String orderCode ; String direction ; BigDecimal triggerPrice ; BigDecimal price ; BigDecimal amount ; }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . web . utils . GeneratorUtil ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtParam { String type ; String concatCoinId ; String memberId ; Integer pattern ; Integer patternType ; Integer contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal takeProfitPrice ; BigDecimal stopLossPrice ;", "output": "BigDecimal amount ; String walletId ; BigDecimal totalFrozenBalance ; Boolean refreshFactoryFlag = true ; }"}, {"input": "package me . zhengjie . modules . mnt . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . mapper . AppMapper ; import me . zhengjie . modules . mnt . mapper . DeployMapper ; import me . zhengjie . modules . mnt . mapper . DeployServerMapper ; import me . zhengjie . modules . mnt . service . AppService ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor public class AppServiceImpl extends ServiceImpl < AppMapper , App > implements AppService { private final AppMapper appMapper ; private final DeployMapper deployMapper ; private final DeployServerMapper deployServerMapper ; @ Override public PageResult < App > queryAll ( AppQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( appMapper . queryAll ( criteria , page ) ) ; } @ Override public List < App > queryAll ( AppQueryCriteria criteria ) { return appMapper . queryAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( App resources ) { verification ( resources ) ; save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( App resources ) { verification ( resources ) ; App app = getById ( resources . getId ( ) ) ; app . copy ( resources ) ; saveOrUpdate ( app ) ; } private void verification ( App resources ) { String opt = \"<STR_LIT>\" ; String home = \"<STR_LIT>\" ; if ( ! ( resources . getUploadPath ( ) . startsWith ( opt ) || resources . getUploadPath ( ) . startsWith ( home ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } if ( ! ( resources . getDeployPath ( ) . startsWith ( opt ) || resources . getDeployPath ( ) . startsWith ( home ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } if ( ! ( resources . getBackupPath ( ) . startsWith ( opt ) || resources . getBackupPath ( ) . startsWith ( home ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; Set < Long > deployIds = deployMapper . getIdByAppIds ( ids ) ; if ( deployIds != null && deployIds . size ( ) > <NUM_LIT> ) { deployServerMapper . deleteByDeployIds ( deployIds ) ; deployMapper . deleteBatchIds ( deployIds ) ; } } @ Override public void download ( List < App > apps , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( App app : apps ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , app . getName ( ) ) ; map . put ( \"<STR_LIT>\" , app . getPort ( ) ) ; map . put ( \"<STR_LIT>\" , app . getUploadPath ( ) ) ; map . put ( \"<STR_LIT>\" , app . getDeployPath ( ) ) ; map . put ( \"<STR_LIT>\" , app . getBackupPath ( ) ) ; map . put ( \"<STR_LIT>\" , app . getStartScript ( ) ) ; map . put ( \"<STR_LIT>\" , app . getDeployScript ( ) ) ; map . put ( \"<STR_LIT>\" , app . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ;", "output": "} }"}, {"input": "package com . yf . system . modules . config . controller ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . system . modules . config . service . CfgSwitchService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import java . util . Map ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class CfgSwitchController extends BaseController { @ Autowired private CfgSwitchService baseService ; @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody Map < String , Object > map ) { baseService . save ( map ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest detail ( ) { Map < String , Object > map = baseService . allMap ( ) ; return super . success ( map ) ; }", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class NumberProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer multipleOf ; private Integer maximum ; private Integer exclusiveMaximum ; private Integer minimum ; private Integer exclusiveMinimum ; private String pattern ; private String errorInfo ; public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) { this . errorInfo = errorInfo ; } public Integer getMultipleOf ( ) { return multipleOf ; } public void setMultipleOf ( Integer multipleOf ) { this . multipleOf = multipleOf ; } public Integer getMaximum ( ) { return maximum ; } public void setMaximum ( Integer maximum ) { this . maximum = maximum ; } public Integer getExclusiveMaximum ( ) { return exclusiveMaximum ; } public void setExclusiveMaximum ( Integer exclusiveMaximum ) { this . exclusiveMaximum = exclusiveMaximum ; } public Integer getMinimum ( ) { return minimum ; } public void setMinimum ( Integer minimum ) { this . minimum = minimum ; } public Integer getExclusiveMinimum ( ) { return exclusiveMinimum ; } public void setExclusiveMinimum ( Integer exclusiveMinimum ) { this . exclusiveMinimum = exclusiveMinimum ; } public String getPattern ( ) { return pattern ;", "output": "} public void setPattern ( String pattern ) { this . pattern = pattern ; } public NumberProperty ( ) { } public NumberProperty ( String key , String title , String type ) { this . key = key ; this . type = type ; this . title = title ; this . view = \"<STR_LIT>\" ; } public NumberProperty ( String key , String title , String view , List < DictModel > include ) { this . type = \"<STR_LIT>\" ; this . key = key ; this . view = view ; this . title = title ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( multipleOf != null ) { prop . put ( \"<STR_LIT>\" , multipleOf ) ; } if ( maximum != null ) { prop . put ( \"<STR_LIT>\" , maximum ) ; } if ( exclusiveMaximum != null ) { prop . put ( \"<STR_LIT>\" , exclusiveMaximum ) ; } if ( minimum != null ) { prop . put ( \"<STR_LIT>\" , minimum ) ; } if ( exclusiveMinimum != null ) { prop . put ( \"<STR_LIT>\" , exclusiveMinimum ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; } if ( errorInfo != null ) { prop . put ( \"<STR_LIT>\" , errorInfo ) ; } map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package com . oddfar . campus . common . core . text ; import com . oddfar . campus . common . utils . StringUtils ; import org . apache . commons . lang3 . ArrayUtils ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . text . NumberFormat ; import java . util . Set ; public class Convert { public static String toStr ( Object value , String defaultValue ) { if ( null == value ) { return defaultValue ; } if ( value instanceof String ) { return ( String ) value ; } return value . toString ( ) ; } public static String toStr ( Object value ) { return toStr ( value , null ) ; } public static Character toChar ( Object value , Character defaultValue ) { if ( null == value ) { return defaultValue ; } if ( value instanceof Character ) { return ( Character ) value ; } final String valueStr = toStr ( value , null ) ; return StringUtils . isEmpty ( valueStr ) ? defaultValue : valueStr . charAt ( <NUM_LIT> ) ; } public static Character toChar ( Object value ) { return toChar ( value , null ) ; } public static Byte toByte ( Object value , Byte defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Byte ) { return ( Byte ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . byteValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return Byte . parseByte ( valueStr ) ; } catch ( Exception e ) { return defaultValue ; } } public static Byte toByte ( Object value ) { return toByte ( value , null ) ; } public static Short toShort ( Object value , Short defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Short ) { return ( Short ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . shortValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return Short . parseShort ( valueStr . trim ( ) ) ; } catch ( Exception e ) { return defaultValue ; } } public static Short toShort ( Object value ) { return toShort ( value , null ) ; } public static Number toNumber ( Object value , Number defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Number ) { return ( Number ) value ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return NumberFormat . getInstance ( ) . parse ( valueStr ) ; } catch ( Exception e ) { return defaultValue ; } } public static Number toNumber ( Object value ) { return toNumber ( value , null ) ; } public static Integer toInt ( Object value , Integer defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Integer ) { return ( Integer ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . intValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return Integer . parseInt ( valueStr . trim ( ) ) ; } catch ( Exception e ) { return defaultValue ; } }", "output": "public static Integer toInt ( Object value ) { return toInt ( value , null ) ; } public static Integer [ ] toIntArray ( String str ) { return toIntArray ( \"<STR_LIT>\" , str ) ; } public static Long [ ] toLongArray ( String str ) { return toLongArray ( \"<STR_LIT>\" , str ) ; } public static Integer [ ] toIntArray ( String split , String str ) { if ( StringUtils . isEmpty ( str ) ) { return new Integer [ ] { } ; } String [ ] arr = str . split ( split ) ; final Integer [ ] ints = new Integer [ arr . length ] ; for ( int i = <NUM_LIT> ; i < arr . length ; i ++ ) { final Integer v = toInt ( arr [ i ] , <NUM_LIT> ) ; ints [ i ] = v ; } return ints ; } public static Long [ ] toLongArray ( String split , String str ) { if ( StringUtils . isEmpty ( str ) ) { return new Long [ ] { } ; } String [ ] arr = str . split ( split ) ; final Long [ ] longs = new Long [ arr . length ] ; for ( int i = <NUM_LIT> ; i < arr . length ; i ++ ) { final Long v = toLong ( arr [ i ] , null ) ; longs [ i ] = v ; } return longs ; } public static String [ ] toStrArray ( String str ) { return toStrArray ( \"<STR_LIT>\" , str ) ; } public static String [ ] toStrArray ( String split , String str ) { return str . split ( split ) ; } public static Long toLong ( Object value , Long defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Long ) { return ( Long ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . longValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return new BigDecimal ( valueStr . trim ( ) ) . longValue ( ) ; } catch ( Exception e ) { return defaultValue ; } } public static Long toLong ( Object value ) { return toLong ( value , null ) ; } public static Double toDouble ( Object value , Double defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Double ) { return ( Double ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . doubleValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return new BigDecimal ( valueStr . trim ( ) ) . doubleValue ( ) ; } catch ( Exception e ) { return defaultValue ; } } public static Double toDouble ( Object value ) { return toDouble ( value , null ) ; } public static Float toFloat ( Object value , Float defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Float ) { return ( Float ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . floatValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return Float . parseFloat ( valueStr . trim ( ) ) ; } catch ( Exception e ) { return defaultValue ; } } public static Float toFloat ( Object value ) { return toFloat ( value , null ) ; } public static Boolean toBool ( Object value , Boolean defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Boolean ) { return ( Boolean ) value ; } String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } valueStr = valueStr . trim ( ) . toLowerCase ( ) ; switch ( valueStr ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : case \"<STR_LIT>\" : case \"<STR_LIT>\" : return true ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : case \"<STR_LIT>\" : return false ; default : return defaultValue ; } } public static Boolean toBool ( Object value ) { return toBool ( value , null ) ; } public static < E extends Enum < E > > E toEnum ( Class < E > clazz , Object value , E defaultValue ) { if ( value == null ) { return defaultValue ; } if ( clazz . isAssignableFrom ( value . getClass ( ) ) ) { @ SuppressWarnings ( \"<STR_LIT>\" ) E myE = ( E ) value ; return myE ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return Enum . valueOf ( clazz , valueStr ) ; } catch ( Exception e ) { return defaultValue ; } } public static < E extends Enum < E > > E toEnum ( Class < E > clazz , Object value ) { return toEnum ( clazz , value , null ) ; } public static BigInteger toBigInteger ( Object value , BigInteger defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof BigInteger ) { return ( BigInteger ) value ; } if ( value instanceof Long ) { return BigInteger . valueOf ( ( Long ) value ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return new BigInteger ( valueStr ) ; } catch ( Exception e ) { return defaultValue ; } } public static BigInteger toBigInteger ( Object value ) { return toBigInteger ( value , null ) ; } public static BigDecimal toBigDecimal ( Object value , BigDecimal defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof BigDecimal ) { return ( BigDecimal ) value ; } if ( value instanceof Long ) { return new BigDecimal ( ( Long ) value ) ; } if ( value instanceof Double ) { return new BigDecimal ( ( Double ) value ) ; } if ( value instanceof Integer ) { return new BigDecimal ( ( Integer ) value ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return new BigDecimal ( valueStr ) ; } catch ( Exception e ) { return defaultValue ; } } public static BigDecimal toBigDecimal ( Object value ) { return toBigDecimal ( value , null ) ; } public static String utf8Str ( Object obj ) { return str ( obj , CharsetKit . CHARSET_UTF_8 ) ; } public static String str ( Object obj , String charsetName ) { return str ( obj , Charset . forName ( charsetName ) ) ; } public static String str ( Object obj , Charset charset ) { if ( null == obj ) { return null ; } if ( obj instanceof String ) { return ( String ) obj ; } else if ( obj instanceof byte [ ] ) { return str ( ( byte [ ] ) obj , charset ) ; } else if ( obj instanceof Byte [ ] ) { byte [ ] bytes = ArrayUtils . toPrimitive ( ( Byte [ ] ) obj ) ; return str ( bytes , charset ) ; } else if ( obj instanceof ByteBuffer ) { return str ( ( ByteBuffer ) obj , charset ) ; } return obj . toString ( ) ; } public static String str ( byte [ ] bytes , String charset ) { return str ( bytes , StringUtils . isEmpty ( charset ) ? Charset . defaultCharset ( ) : Charset . forName ( charset ) ) ; } public static String str ( byte [ ] data , Charset charset ) { if ( data == null ) { return null ; } if ( null == charset ) { return new String ( data ) ; } return new String ( data , charset ) ; } public static String str ( ByteBuffer data , String charset ) { if ( data == null ) { return null ; } return str ( data , Charset . forName ( charset ) ) ; } public static String str ( ByteBuffer data , Charset charset ) { if ( null == charset ) { charset = Charset . defaultCharset ( ) ; } return charset . decode ( data ) . toString ( ) ; } public static String toSBC ( String input ) { return toSBC ( input , null ) ; } public static String toSBC ( String input , Set < Character > notConvertSet ) { char [ ] c = input . toCharArray ( ) ; for ( int i = <NUM_LIT> ; i < c . length ; i ++ ) { if ( null != notConvertSet && notConvertSet . contains ( c [ i ] ) ) { continue ; } if ( c [ i ] == '<STR_LIT>' ) { c [ i ] = '<STR_LIT>' ; } else if ( c [ i ] < '<STR_LIT>' ) { c [ i ] = ( char ) ( c [ i ] + <NUM_LIT> ) ; } } return new String ( c ) ; } public static String toDBC ( String input ) { return toDBC ( input , null ) ; } public static String toDBC ( String text , Set < Character > notConvertSet ) { char [ ] c = text . toCharArray ( ) ; for ( int i = <NUM_LIT> ; i < c . length ; i ++ ) { if ( null != notConvertSet && notConvertSet . contains ( c [ i ] ) ) { continue ; } if ( c [ i ] == '<STR_LIT>' ) { c [ i ] = '<STR_LIT>' ; } else if ( c [ i ] > '<STR_LIT>' && c [ i ] < '<STR_LIT>' ) { c [ i ] = ( char ) ( c [ i ] - <NUM_LIT> ) ; } } String returnString = new String ( c ) ; return returnString ; } public static String digitUppercase ( double n ) { String [ ] fraction = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; String [ ] digit = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String [ ] [ ] unit = { { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } , { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } } ; String head = n < <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ; n = Math . abs ( n ) ; String s = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < fraction . length ; i ++ ) { s += ( digit [ ( int ) ( Math . floor ( n * <NUM_LIT> * Math . pow ( <NUM_LIT> , i ) ) % <NUM_LIT> ) ] + fraction [ i ] ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } if ( s . length ( ) < <NUM_LIT> ) { s = \"<STR_LIT>\" ; } int integerPart = ( int ) Math . floor ( n ) ; for ( int i = <NUM_LIT> ; i < unit [ <NUM_LIT> ] . length && integerPart > <NUM_LIT> ; i ++ ) { String p = \"<STR_LIT>\" ; for ( int j = <NUM_LIT> ; j < unit [ <NUM_LIT> ] . length && n > <NUM_LIT> ; j ++ ) { p = digit [ integerPart % <NUM_LIT> ] + unit [ <NUM_LIT> ] [ j ] + p ; integerPart = integerPart / <NUM_LIT> ; } s = p . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + unit [ <NUM_LIT> ] [ i ] + s ; } return head + s . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceFirst ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import com . alibaba . excel . annotation . ExcelIgnore ; import com . alibaba . excel . annotation . ExcelProperty ; import com . alibaba . excel . annotation . write . style . ColumnWidth ; import com . alibaba . excel . annotation . write . style . ContentStyle ; import com . alibaba . excel . enums . poi . HorizontalAlignmentEnum ; import lombok . Data ; @ Data @ ContentStyle ( horizontalAlignment = HorizontalAlignmentEnum . CENTER ) public class ExportChatRoomVO { @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String chatRoomName ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String chatRoomTitle ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String selfDisplayName ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String createBy ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private Boolean dissolution ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private Boolean enterprise ; @ ExcelIgnore private byte [ ] roomData ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private Integer memberCount ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; public class PageQuery extends SortableQuery { @ QueryCondition ( ignore = true ) private long size = <NUM_LIT> ; @ QueryCondition ( ignore = true ) private long current = <NUM_LIT> ; protected Long getMaxSize ( ) { return null ; } public long getSize ( ) { Long maxSize = getMaxSize ( ) ; if ( maxSize == null || size <= maxSize ) { return size ; } return maxSize ; }", "output": "public void setSize ( long size ) { this . size = size ; } public long getCurrent ( ) { return current ; } public void setCurrent ( long current ) { this . current = current ; } }"}, {"input": "package top . kangert . kspider . util ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . support . UserAgentManager ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . net . HttpURLConnection ; import java . net . InetSocketAddress ; import java . net . MalformedURLException ; import java . net . Proxy ; import java . net . SocketTimeoutException ; import java . net . URL ; import java . util . List ; @ Slf4j @ Component public class FileUtils { @ Autowired private static UserAgentManager userAgentManager ; public static String FILENAME_PATTERN = \"<STR_LIT>\" ; public static void writeBytes ( String filePath , OutputStream os ) throws IOException { FileInputStream fis = null ; try { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { throw new FileNotFoundException ( filePath ) ; } fis = new FileInputStream ( file ) ; byte [ ] b = new byte [ <NUM_LIT> ] ; int length ; while ( ( length = fis . read ( b ) ) > <NUM_LIT> ) { os . write ( b , <NUM_LIT> , length ) ; } } catch ( IOException e ) { throw e ; } finally { if ( os != null ) { try { os . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } } public static boolean deleteFile ( String filePath ) { boolean flag = false ; File file = new File ( filePath ) ; if ( file . isFile ( ) && file . exists ( ) ) { file . delete ( ) ; flag = true ; } return flag ; } public static boolean isValidFilename ( String filename ) { return filename . matches ( FILENAME_PATTERN ) ; } public enum DownloadStatus { URL_ERROR ( <NUM_LIT> , \"<STR_LIT>\" ) , FILE_EXIST ( <NUM_LIT> , \"<STR_LIT>\" ) , TIME_OUT ( <NUM_LIT> , \"<STR_LIT>\" ) , DOWNLOAD_FAIL ( <NUM_LIT> , \"<STR_LIT>\" ) , DOWNLOAD_SUCCESS ( <NUM_LIT> , \"<STR_LIT>\" ) ; private int code ; private String name ; DownloadStatus ( int code , String name ) { this . code = code ; this . name = name ; } public int getCode ( ) { return code ; } public void setCode ( int code ) { this . code = code ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } } public static DownloadStatus downloadFile ( String savePath , String url , String proxy , boolean downNew , boolean saveOriginPath ) { URL fileUrl = null ; HttpURLConnection httpUrl = null ; BufferedInputStream bis = null ; BufferedOutputStream bos = null ; if ( url . startsWith ( \"<STR_LIT>\" ) ) { url = \"<STR_LIT>\" + url ; } String fileName ; try { fileUrl = new URL ( url ) ; String urlPath = fileUrl . getPath ( ) ; if ( saveOriginPath ) { fileName = urlPath ; } else { fileName = urlPath . substring ( urlPath . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; }", "output": "} catch ( MalformedURLException e ) { log . error ( \"<STR_LIT>\" , e ) ; return DownloadStatus . URL_ERROR ; } File path = new File ( savePath ) ; if ( ! path . exists ( ) ) { path . mkdirs ( ) ; } File file = new File ( savePath + File . separator + fileName ) ; if ( file . exists ( ) ) { if ( downNew ) { file . delete ( ) ; } else { log . info ( \"<STR_LIT>\" ) ; return DownloadStatus . FILE_EXIST ; } } else if ( ! file . getParentFile ( ) . exists ( ) && saveOriginPath ) { file . getParentFile ( ) . mkdirs ( ) ; } try { if ( StrUtil . isNotBlank ( proxy ) ) { List < String > proxyArr = StrUtil . split ( Constants . PROXY_HOST_PORT_SEPARATOR , proxy ) ; if ( proxyArr . size ( ) == <NUM_LIT> ) { InetSocketAddress socketAddress = new InetSocketAddress ( proxyArr . get ( <NUM_LIT> ) , Integer . parseInt ( proxyArr . get ( <NUM_LIT> ) ) ) ; Proxy p = new Proxy ( Proxy . Type . HTTP , socketAddress ) ; httpUrl = ( HttpURLConnection ) fileUrl . openConnection ( p ) ; log . info ( \"<STR_LIT>\" , proxyArr . get ( <NUM_LIT> ) , proxyArr . get ( <NUM_LIT> ) ) ; } } else { httpUrl = ( HttpURLConnection ) fileUrl . openConnection ( ) ; } httpUrl . setRequestProperty ( \"<STR_LIT>\" , userAgentManager . getChromeNewest ( ) ) ; httpUrl . setReadTimeout ( <NUM_LIT> ) ; httpUrl . setConnectTimeout ( <NUM_LIT> ) ; httpUrl . connect ( ) ; bis = new BufferedInputStream ( httpUrl . getInputStream ( ) ) ; bos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; final int len = <NUM_LIT> ; byte [ ] buf = new byte [ len ] ; int readLen ; while ( ( readLen = bis . read ( buf ) ) != - <NUM_LIT> ) { bos . write ( buf , <NUM_LIT> , readLen ) ; } log . info ( \"<STR_LIT>\" + url ) ; bos . flush ( ) ; bis . close ( ) ; httpUrl . disconnect ( ) ; return DownloadStatus . DOWNLOAD_SUCCESS ; } catch ( SocketTimeoutException e ) { log . error ( \"<STR_LIT>\" , e ) ; return DownloadStatus . TIME_OUT ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; return DownloadStatus . DOWNLOAD_FAIL ; } finally { try { if ( bis != null ) { bis . close ( ) ; } if ( bos != null ) { bos . close ( ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } } } }"}, {"input": "package org . example . ddduser . domain . repository ; import org . example . ddduser . domain . user . valueobject . Address ; public interface LocationRepository {", "output": "Address find ( Double longitude , Double latitude ) ; }"}, {"input": "package org . example . domain . example . valueobject ; import com . baomidou . mybatisplus . annotation . EnumValue ; public enum ExampleStatus { ENABLE ( <NUM_LIT> ) , DISABLE ( <NUM_LIT> ) ;", "output": "@ EnumValue private int value ; ExampleStatus ( int value ) { this . value = value ; } }"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . youlai . system . model . bo . RolePermsBO ; import com . youlai . system . model . entity . SysRoleMenu ; import org . apache . ibatis . annotations . Mapper ; import java . util . List ; import java . util . Set ; @ Mapper public interface SysRoleMenuMapper extends BaseMapper < SysRoleMenu > {", "output": "List < Long > listMenuIdsByRoleId ( Long roleId ) ; List < RolePermsBO > getRolePermsList ( String roleCode ) ; Set < String > listRolePerms ( Set < String > roles ) ; }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SqliteMaster { @ TableField ( \"<STR_LIT>\" ) private String type ; @ TableField ( \"<STR_LIT>\" ) private String tblName ; @ TableField ( \"<STR_LIT>\" ) private String rootPage ; @ TableField ( \"<STR_LIT>\" ) private String sql ;", "output": "}"}, {"input": "package com . yf . system . modules . menu . eums ; public interface MenuType { Integer DIR = <NUM_LIT> ; Integer MENU = <NUM_LIT> ;", "output": "Integer FUNCTION = <NUM_LIT> ; }"}, {"input": "package ginyi . common . utils ; import java . util . Date ; import java . util . GregorianCalendar ; public class LunarCalendarUtil { public static final int MIN_YEAR = <NUM_LIT> ; public static final int MAX_YEAR = <NUM_LIT> ; private static final int [ ] DAYS_BEFORE_MONTH = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> }", "output": "; private static final int [ ] LUNAR_INFO = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static final int [ ] lunarToSolar ( int year , int month , int monthDay , boolean isLeapMonth ) { int dayOffset ; int leapMonth ; int i ; if ( year < MIN_YEAR || year > MAX_YEAR || month < <NUM_LIT> || month > <NUM_LIT> || monthDay < <NUM_LIT> || monthDay > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } dayOffset = ( LUNAR_INFO [ year - MIN_YEAR ] & <NUM_LIT> ) - <NUM_LIT> ; if ( ( ( LUNAR_INFO [ year - MIN_YEAR ] & <NUM_LIT> ) > > <NUM_LIT> ) == <NUM_LIT> ) { dayOffset += <NUM_LIT> ; } for ( i = <NUM_LIT> ; i < month ; i ++ ) { if ( ( LUNAR_INFO [ year - MIN_YEAR ] & ( <NUM_LIT> > > ( i - <NUM_LIT> ) ) ) == <NUM_LIT> ) { dayOffset += <NUM_LIT> ; } else { dayOffset += <NUM_LIT> ; } } dayOffset += monthDay ; leapMonth = ( LUNAR_INFO [ year - MIN_YEAR ] & <NUM_LIT> ) > > <NUM_LIT> ; if ( leapMonth != <NUM_LIT> ) { if ( month > leapMonth || ( month == leapMonth && isLeapMonth ) ) { if ( ( LUNAR_INFO [ year - MIN_YEAR ] & ( <NUM_LIT> > > ( month - <NUM_LIT> ) ) ) == <NUM_LIT> ) { dayOffset += <NUM_LIT> ; } else { dayOffset += <NUM_LIT> ; } } } if ( dayOffset > <NUM_LIT> || ( year % <NUM_LIT> != <NUM_LIT> && dayOffset > <NUM_LIT> ) ) { year += <NUM_LIT> ; if ( year % <NUM_LIT> == <NUM_LIT> ) { dayOffset -= <NUM_LIT> ; } else { dayOffset -= <NUM_LIT> ; } } int [ ] solarInfo = new int [ <NUM_LIT> ] ; for ( i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int iPos = DAYS_BEFORE_MONTH [ i ] ; if ( year % <NUM_LIT> == <NUM_LIT> && i > <NUM_LIT> ) { iPos += <NUM_LIT> ; } if ( year % <NUM_LIT> == <NUM_LIT> && i == <NUM_LIT> && iPos + <NUM_LIT> == dayOffset ) { solarInfo [ <NUM_LIT> ] = i ; solarInfo [ <NUM_LIT> ] = dayOffset - <NUM_LIT> ; break ; } if ( iPos >= dayOffset ) { solarInfo [ <NUM_LIT> ] = i ; iPos = DAYS_BEFORE_MONTH [ i - <NUM_LIT> ] ; if ( year % <NUM_LIT> == <NUM_LIT> && i > <NUM_LIT> ) { iPos += <NUM_LIT> ; } if ( dayOffset > iPos ) { solarInfo [ <NUM_LIT> ] = dayOffset - iPos ; } else if ( dayOffset == iPos ) { if ( year % <NUM_LIT> == <NUM_LIT> && i == <NUM_LIT> ) { solarInfo [ <NUM_LIT> ] = DAYS_BEFORE_MONTH [ i ] - DAYS_BEFORE_MONTH [ i - <NUM_LIT> ] + <NUM_LIT> ; } else { solarInfo [ <NUM_LIT> ] = DAYS_BEFORE_MONTH [ i ] - DAYS_BEFORE_MONTH [ i - <NUM_LIT> ] ; } } else { solarInfo [ <NUM_LIT> ] = dayOffset ; } break ; } } solarInfo [ <NUM_LIT> ] = year ; return solarInfo ; } public static final int [ ] solarToLunar ( int year , int month , int monthDay ) { int [ ] lunarDate = new int [ <NUM_LIT> ] ; Date baseDate = new GregorianCalendar ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) . getTime ( ) ; Date objDate = new GregorianCalendar ( year , month - <NUM_LIT> , monthDay ) . getTime ( ) ; int offset = ( int ) ( ( objDate . getTime ( ) - baseDate . getTime ( ) ) / <NUM_LIT> ) ; int iYear , daysOfYear = <NUM_LIT> ; for ( iYear = MIN_YEAR ; iYear <= MAX_YEAR && offset > <NUM_LIT> ; iYear ++ ) { daysOfYear = daysInLunarYear ( iYear ) ; offset -= daysOfYear ; } if ( offset < <NUM_LIT> ) { offset += daysOfYear ; iYear -- ; } lunarDate [ <NUM_LIT> ] = iYear ; int leapMonth = leapMonth ( iYear ) ; boolean isLeap = false ; int iMonth , daysOfMonth = <NUM_LIT> ; for ( iMonth = <NUM_LIT> ; iMonth <= <NUM_LIT> && offset > <NUM_LIT> ; iMonth ++ ) { daysOfMonth = daysInLunarMonth ( iYear , iMonth ) ; offset -= daysOfMonth ; } if ( leapMonth != <NUM_LIT> && iMonth > leapMonth ) { -- iMonth ; if ( iMonth == leapMonth ) { isLeap = true ; } } if ( offset < <NUM_LIT> ) { offset += daysOfMonth ; -- iMonth ; } lunarDate [ <NUM_LIT> ] = iMonth ; lunarDate [ <NUM_LIT> ] = offset + <NUM_LIT> ; lunarDate [ <NUM_LIT> ] = isLeap ? <NUM_LIT> : <NUM_LIT> ; return lunarDate ; } final public static int daysInMonth ( int year , int month ) { return daysInMonth ( year , month , false ) ; } public static final int daysInMonth ( int year , int month , boolean leap ) { int leapMonth = leapMonth ( year ) ; int offset = <NUM_LIT> ; if ( leapMonth != <NUM_LIT> && month > leapMonth ) { offset = <NUM_LIT> ; } if ( ! leap ) { return daysInLunarMonth ( year , month + offset ) ; } else { if ( leapMonth != <NUM_LIT> && leapMonth == month ) { return daysInLunarMonth ( year , month + <NUM_LIT> ) ; } } return <NUM_LIT> ; } private static int daysInLunarYear ( int year ) { int i , sum = <NUM_LIT> ; if ( leapMonth ( year ) != <NUM_LIT> ) { sum = <NUM_LIT> ; } int monthInfo = LUNAR_INFO [ year - MIN_YEAR ] & <NUM_LIT> ; for ( i = <NUM_LIT> ; i > <NUM_LIT> ; i >>= <NUM_LIT> ) { if ( ( monthInfo & i ) != <NUM_LIT> ) { sum += <NUM_LIT> ; } } return sum ; } public static int daysInLunarMonth ( int year , int month ) { if ( ( LUNAR_INFO [ year - MIN_YEAR ] & ( <NUM_LIT> > > month ) ) == <NUM_LIT> ) { return <NUM_LIT> ; } else { return <NUM_LIT> ; } } public static int leapMonth ( int year ) { return ( ( LUNAR_INFO [ year - MIN_YEAR ] & <NUM_LIT> ) ) > > <NUM_LIT> ; } }"}, {"input": "package com . youlai . system . model . vo ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; import lombok . Setter ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public class VisitTrendVO { @ Schema ( description = \"<STR_LIT>\" ) private List < String > dates ; @ Schema ( description = \"<STR_LIT>\" ) private List < Integer > pvList ; @ Schema ( description = \"<STR_LIT>\" ) private List < Integer > uvList ; @ Schema ( description = \"<STR_LIT>\" ) private List < Integer > ipList ;", "output": "}"}, {"input": "package ginyi . common . mysql . handler ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import ginyi . common . constant . UserConstants ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . reflection . MetaObject ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . Date ; @ Slf4j @ Component public class MyMetaObjectHandler implements MetaObjectHandler { @ Resource private HttpServletRequest request ; @ Override public void insertFill ( MetaObject metaObject ) { this . setFieldValByName ( \"<STR_LIT>\" , request . getAttribute ( UserConstants . CURRENT_USER ) , metaObject ) ; this . setFieldValByName ( \"<STR_LIT>\" , new Date ( ) , metaObject ) ; this . setFieldValByName ( \"<STR_LIT>\" , request . getAttribute ( UserConstants . CURRENT_USER ) , metaObject ) ; this . setFieldValByName ( \"<STR_LIT>\" , new Date ( ) , metaObject ) ; } @ Override public void updateFill ( MetaObject metaObject ) { this . setFieldValByName ( \"<STR_LIT>\" , request . getAttribute ( UserConstants . CURRENT_USER ) , metaObject ) ;", "output": "this . setFieldValByName ( \"<STR_LIT>\" , new Date ( ) , metaObject ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import com . google . common . util . concurrent . MoreExecutors ; import com . google . common . util . concurrent . ThreadFactoryBuilder ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; public class ThreadPoolUtil { public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeoutMills ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeoutMills , TimeUnit . MILLISECONDS ) ; } public static boolean gracefulShutdown ( @ Nullable ExecutorService threadPool , int shutdownTimeout , TimeUnit timeUnit ) { return threadPool == null || MoreExecutors . shutdownAndAwaitTermination ( threadPool , shutdownTimeout , timeUnit ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . build ( ) ; } public static ThreadFactory buildThreadFactory ( @ NotNull String threadNamePrefix , @ NotNull boolean daemon ) { return new ThreadFactoryBuilder ( ) . setNameFormat ( threadNamePrefix + \"<STR_LIT>\" ) . setDaemon ( daemon ) . build ( ) ; } public static Runnable safeRunnable ( @ NotNull Runnable runnable ) { return new SafeRunnable ( runnable ) ; } private static class SafeRunnable implements Runnable { private static Logger logger = LoggerFactory . getLogger ( SafeRunnable . class ) ; private Runnable runnable ;", "output": "public SafeRunnable ( Runnable runnable ) { Validate . notNull ( runnable ) ; this . runnable = runnable ; } @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Throwable e ) { logger . error ( \"<STR_LIT>\" , e ) ; } } } }"}, {"input": "package com . youlai . system . plugin . mybatis . handler ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . springframework . stereotype . Component ; import java . time . LocalDateTime ; @ Component public class MyMetaObjectHandler implements MetaObjectHandler { @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , LocalDateTime :: now , LocalDateTime . class ) ; this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , LocalDateTime :: now , LocalDateTime . class ) ;", "output": "} @ Override public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , LocalDateTime :: now , LocalDateTime . class ) ; } }"}, {"input": "package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) public class EmailConfig implements Serializable { @ TableId ( \"<STR_LIT>\" ) private Long id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String host ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String port ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String user ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pass ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fromUser ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . node ; import lombok . extern . slf4j . Slf4j ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . support . ExpressionEngine ; import top . kangert . kspider . websocket . WebSocketEvent ; import org . springframework . stereotype . Component ; import cn . hutool . core . exceptions . ExceptionUtil ; import cn . hutool . core . lang . TypeReference ; import cn . hutool . json . JSONUtil ; import javax . annotation . Resource ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Component @ Slf4j public class VariableExecutor implements NodeExecutor { private final String VARIABLE = \"<STR_LIT>\" ; @ Resource private ExpressionEngine expressionEngine ; @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { List < Map < String , String > > variableList = node . getJsonArrayProperty ( VARIABLE ) ; for ( Map < String , String > nameValue : variableList ) { String variableStr = nameValue . get ( VARIABLE ) ; Map < String , String > variableMap = JSONUtil . toBean ( variableStr , new TypeReference < Map < String , String > > ( ) { } , false ) ; String variableKey = variableMap . get ( \"<STR_LIT>\" ) ;", "output": "String variableValue = variableMap . get ( \"<STR_LIT>\" ) ; Object value = null ; try { value = expressionEngine . execute ( variableValue , variables ) ; log . debug ( \"<STR_LIT>\" , variableKey , value ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , variableKey , value ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , variableKey , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } variables . put ( variableKey , value ) ; } } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public boolean isAsync ( ) { return false ; } @ Override public List < ConfigItem > configItems ( ) { List < ConfigItem > configItemList = new ArrayList < > ( ) ; ConfigItem configItemName = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . CUSTOM_MULT_KEY_VALUE , ConfigItem . DataType . LIST_MAP , VARIABLE , null , new ArrayList < > ( ) , null , null ) ; configItemList . add ( configItemName ) ; return configItemList ; } @ Override public Shape shape ( ) { return new Shape ( supportType ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . util . List ; @ Data public class ContractDetailParam { String type ; List < String > symbolNameList ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class CsvUtil { protected static final char FIELD_SEPARATOR = '<STR_LIT>' ; protected static final char FIELD_QUOTE = '<STR_LIT>' ; protected static final String DOUBLE_QUOTE = \"<STR_LIT>\" ; protected static final String SPECIAL_CHARS = \"<STR_LIT>\" ; protected static final String SPACE = \"<STR_LIT>\" ; protected static final String QUOTE = \"<STR_LIT>\" ; public static String toCsvString ( Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ;", "output": "} continue ; } String field = elements [ i ] . toString ( ) ; int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - <NUM_LIT> ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - <NUM_LIT> && ( field . startsWith ( SPACE ) || field . endsWith ( SPACE ) ) ) { ndx = <NUM_LIT> ; } if ( ndx == - <NUM_LIT> ) { ndx = StringUtils . indexOf ( field , SPECIAL_CHARS ) ; } if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } field = StringUtils . replace ( field , QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - <NUM_LIT> ) { line . append ( FIELD_QUOTE ) ; } if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; } public static String [ ] fromCsvString ( String line ) { List < String > row = new ArrayList < String > ( ) ; boolean inQuotedField = false ; int fieldStart = <NUM_LIT> ; final int len = line . length ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { char c = line . charAt ( i ) ; if ( c == FIELD_SEPARATOR ) { if ( ! inQuotedField ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; } } else if ( c == FIELD_QUOTE ) { if ( inQuotedField ) { if ( i + <NUM_LIT> == len || line . charAt ( i + <NUM_LIT> ) == FIELD_SEPARATOR ) { addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + <NUM_LIT> ; i ++ ; inQuotedField = false ; } } else if ( fieldStart == i ) { inQuotedField = true ; fieldStart ++ ; } } } if ( len > <NUM_LIT> && fieldStart <= len ) { addField ( row , line , fieldStart , len , inQuotedField ) ; } return row . toArray ( new String [ row . size ( ) ] ) ; } private static void addField ( List < String > row , String line , int startIndex , int endIndex , boolean inQuoted ) { String field = line . substring ( startIndex , endIndex ) ; if ( inQuoted ) { field = StringUtils . replace ( field , DOUBLE_QUOTE , \"<STR_LIT>\" ) ; } row . add ( field ) ; } }"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import java . io . Serializable ; import lombok . Data ; @ Data public class SysDictItem implements Serializable { @ TableId ( type = IdType . AUTO ) private Long id ; private Long dictId ; private String name ; private String value ; private Integer sort ; private Integer status ; private String remark ;", "output": "}"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . ChatRoomInfo ; public interface ChatRoomInfoMapper extends BaseMapper < ChatRoomInfo > {", "output": "}"}, {"input": "package me . zhengjie . utils ; import java . io . Closeable ; public class CloseUtil { public static void close ( Closeable closeable ) { if ( null != closeable ) { try { closeable . close ( ) ; } catch ( Exception e ) { } } } public static void close ( AutoCloseable closeable ) { if ( null != closeable ) { try { closeable . close ( ) ; }", "output": "catch ( Exception e ) { } } } }"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import java . util . List ; @ Data public class OnLineUserInfo { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String oauthId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BladeUser bladeUser ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Kv detail ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > permissions ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > roles ; private String errorMsg ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . boot . autoconfigure . web . servlet . error . BasicErrorController ; import org . springframework . core . MethodParameter ; import org . springframework . http . MediaType ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . http . converter . StringHttpMessageConverter ; import org . springframework . http . server . ServerHttpRequest ; import org . springframework . http . server . ServerHttpResponse ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . ResponseBodyAdvice ; @ ControllerAdvice public class CustomResponseBodyAdvice implements ResponseBodyAdvice < Object > { private ResponseBodyDecorateCenter responseBodyDecorateCenter ; public CustomResponseBodyAdvice ( ResponseBodyDecorateCenter responseBodyDecorateCenter ) { this . responseBodyDecorateCenter = responseBodyDecorateCenter ;", "output": "} @ Override public boolean supports ( MethodParameter returnType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return true ; } @ Override public Object beforeBodyWrite ( Object body , MethodParameter returnType , MediaType selectedContentType , Class < ? extends HttpMessageConverter < ? > > selectedConverterType , ServerHttpRequest request , ServerHttpResponse response ) { Class < ? > containingClass = returnType . getContainingClass ( ) ; if ( containingClass != null && containingClass == BasicErrorController . class ) { return body ; } IgnoreResponseWrapper ignoreResponseWrapper = returnType . getMethodAnnotation ( IgnoreResponseWrapper . class ) ; if ( ignoreResponseWrapper != null ) { return body ; } if ( selectedConverterType . isAssignableFrom ( StringHttpMessageConverter . class ) ) { return body ; } body = responseBodyDecorateCenter . doDecorate ( body ) ; if ( body != null && Response . class . isAssignableFrom ( body . getClass ( ) ) ) { return body ; } CommonResponse bodyWrapper = CommonResponse . bizSuccess ( body ) ; return bodyWrapper ; } }"}, {"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileIndexModel implements Serializable { @ Data public static class TopModel { private Long cou ; private Long jrscl ; private List < Xy > xyList ; } @ Data public static class kv { private String k ; private String v ; } @ Data public static class Fwl { private String tian ;", "output": "private String type ; private String userCou ; private String viewCou ; } @ Data public static class Xy { private String x ; private String y ; public Xy ( String x , String y ) { this . x = x ; this . y = y ; } } }"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . toolkit . Constants ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import org . apache . ibatis . annotations . Param ; public interface SysUserMapper extends BaseMapperX < SysUserEntity > { default PageResult < SysUserEntity > selectPage ( SysUserEntity user ) { LambdaQueryWrapperX < SysUserEntity > lqw = new LambdaQueryWrapperX < > ( ) ; lqw . select ( SysUserEntity . class , i -> ! i . getProperty ( ) . equals ( \"<STR_LIT>\" ) ) ; lqw . likeIfPresent ( SysUserEntity :: getUserName , user . getUserName ( ) ) ; lqw . likeIfPresent ( SysUserEntity :: getPhonenumber , user . getPhonenumber ( ) ) ; lqw . eqIfPresent ( SysUserEntity :: getStatus , user . getStatus ( ) ) ; lqw . betweenIfPresent ( SysUserEntity :: getCreateTime , user . getParams ( ) ) ; return selectPage ( lqw ) ; } SysUserEntity selectUserByUserName ( String userName ) ; SysUserEntity selectUserById ( Long userId ) ; Page < SysUserEntity > selectAllocatedList ( @ Param ( \"<STR_LIT>\" ) Page < SysUserEntity > page , @ Param ( Constants . WRAPPER ) Wrapper < SysUserEntity > queryWrapper ) ; Page < SysUserEntity > selectUnallocatedList ( @ Param ( \"<STR_LIT>\" ) Page < SysUserEntity > page , @ Param ( \"<STR_LIT>\" ) SysUserEntity user ) ;", "output": "int updateUserAvatar ( @ Param ( \"<STR_LIT>\" ) String userName , @ Param ( \"<STR_LIT>\" ) String avatar ) ; default SysUserEntity checkEmailUnique ( String email ) { return selectOne ( new LambdaQueryWrapperX < SysUserEntity > ( ) . eq ( SysUserEntity :: getEmail , email ) ) ; } default SysUserEntity checkPhoneUnique ( String phonenumber ) { return selectOne ( new LambdaQueryWrapperX < SysUserEntity > ( ) . eq ( SysUserEntity :: getPhonenumber , phonenumber ) ) ; } int resetUserPwd ( @ Param ( \"<STR_LIT>\" ) String userName , @ Param ( \"<STR_LIT>\" ) String password ) ; default SysUserEntity checkUserNameUnique ( String userName ) { return selectOne ( new LambdaQueryWrapperX < SysUserEntity > ( ) . eq ( SysUserEntity :: getUserName , userName ) ) ; } }"}, {"input": "package com . oddfar . campus . common . utils . http ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . servlet . ServletRequest ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; public class HttpHelper { private static final Logger LOGGER = LoggerFactory . getLogger ( HttpHelper . class ) ; public static String getBodyString ( ServletRequest request ) { StringBuilder sb = new StringBuilder ( ) ; BufferedReader reader = null ; try ( InputStream inputStream = request . getInputStream ( ) ) { reader = new BufferedReader ( new InputStreamReader ( inputStream , StandardCharsets . UTF_8 ) ) ; String line = \"<STR_LIT>\" ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) ; } } catch ( IOException e ) { LOGGER . warn ( \"<STR_LIT>\" ) ; }", "output": "finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { LOGGER . error ( ExceptionUtils . getMessage ( e ) ) ; } } } return sb . toString ( ) ; } }"}, {"input": "package top . kangert . kspider . entity ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . GenerationType ; import javax . persistence . Id ; import javax . persistence . Table ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; @ Table ( name = \"<STR_LIT>\" ) @ Entity @ Getter @ Setter @ ToString public class Application extends BaseEntity { @ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) @ Column ( updatable = false ) private Long appId ; @ Column ( unique = true ) private String appName ; @ Column ( unique = true ) private String appSecretKey ; private String whiteList ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . service ; import java . util . Map ; public interface MonitorService {", "output": "Map < String , Object > getServers ( ) ; }"}, {"input": "package me . zhengjie . modules . security . security ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . web . AuthenticationEntryPoint ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Component public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint { @ Override public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) throws IOException {", "output": "response . sendError ( HttpServletResponse . SC_UNAUTHORIZED , authException == null ? \"<STR_LIT>\" : authException . getMessage ( ) ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import lombok . Data ; @ Data public class ExamGradeVO { private Integer id ; private Integer examId ; private Integer gradeId ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . utils . enums . DataScopeEnum ; import org . springframework . http . HttpStatus ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . core . userdetails . UserDetails ; import org . springframework . security . core . userdetails . UserDetailsService ; import java . util . List ; @ Slf4j public class SecurityUtils { public static UserDetails getCurrentUser ( ) { UserDetailsService userDetailsService = SpringContextHolder . getBean ( UserDetailsService . class ) ; return userDetailsService . loadUserByUsername ( getCurrentUsername ( ) ) ; } public static String getCurrentUsername ( ) { final Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { throw new BadRequestException ( HttpStatus . UNAUTHORIZED , \"<STR_LIT>\" ) ; } if ( authentication . getPrincipal ( ) instanceof UserDetails ) { UserDetails userDetails = ( UserDetails ) authentication . getPrincipal ( ) ; return userDetails . getUsername ( ) ; } throw new BadRequestException ( HttpStatus . UNAUTHORIZED , \"<STR_LIT>\" ) ; } public static Long getCurrentUserId ( ) { UserDetails userDetails = getCurrentUser ( ) ; JSONObject jsonObject = ( JSONObject ) JSON . toJSON ( userDetails ) ; return jsonObject . getJSONObject ( \"<STR_LIT>\" ) . getLong ( \"<STR_LIT>\" ) ; } public static List < Long > getCurrentUserDataScope ( ) { UserDetails userDetails = getCurrentUser ( ) ; JSONObject jsonObject = ( JSONObject ) JSON . toJSON ( userDetails ) ; JSONArray jsonArray = jsonObject . getJSONArray ( \"<STR_LIT>\" ) ; return JSON . parseArray ( jsonArray . toJSONString ( ) , Long . class ) ; } public static String getDataScopeType ( ) { List < Long > dataScopes = getCurrentUserDataScope ( ) ; if ( dataScopes . size ( ) != <NUM_LIT> ) { return \"<STR_LIT>\" ; } return DataScopeEnum . ALL . getValue ( ) ; }", "output": "}"}, {"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . entity . DesformRoute ; import org . springblade . cgform . enums . MjkjAeskey ; import org . springblade . cgform . model . DesformUpdateTimeModel ; import org . springblade . cgform . model . param . FormDataSaveModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . DateUtils ; import org . springblade . core . api . crypto . annotation . decrypt . ApiDecryptAes ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import javax . validation . Valid ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class DesformApiController {", "output": "}"}, {"input": "package org . springblade . web . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . github . houbb . opencc4j . util . ZhConverterUtil ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . * ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . market . MarketConstant ; import org . springblade . config . market . MarketKlineUtils ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . * ; import org . springblade . feign . IMjkjMarketClient ; import org . springblade . web . model . KLine ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . MongoDetail ; import org . springblade . web . model . param . * ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Criteria ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . Assert ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . math . BigDecimal ; import java . time . Duration ; import java . util . * ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class OpenController { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IMarketService marketService ; @ Autowired private IWebService webService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getMarketInitData ( String type ) { Object o = marketService . messageInitdata ( type ) ; return R . data ( o ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R getDownloadUrl ( String type ) { QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , type ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . orderByDesc ( \"<STR_LIT>\" ) ; List < Map < String , Object > > dataMapList = mjkjBaseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMapList ) ) { return R . data ( \"<STR_LIT>\" ) ; } Map < String , Object > map = dataMapList . get ( <NUM_LIT> ) ; return R . data ( MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ) ; }", "output": "@ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R updateLang ( @ PathVariable ( \"<STR_LIT>\" ) String yy ) { if ( Func . isEmpty ( yy ) ) { return R . data ( webService . getLanguage ( \"<STR_LIT>\" ) ) ; } Long userId = AuthUtil . getUserId ( ) ; if ( Func . isEmpty ( userId ) ) { return R . data ( webService . getLanguage ( \"<STR_LIT>\" ) ) ; } return R . data ( webService . getLanguage ( \"<STR_LIT>\" ) ) ; } }"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class SysRoleMenu { private Long roleId ; private Long menuId ; @ TableField ( exist = false ) private static final long serialVersionUID = <NUM_LIT> ;", "output": "}"}, {"input": "package org . springblade . web . utils ; import org . apache . commons . collections4 . queue . CircularFifoQueue ; import org . springblade . model . DeptHModel ; import org . springblade . web . model . ContractTrade ; import org . springblade . web . model . DetailModel ; import java . math . BigDecimal ; import java . util . HashMap ; import java . util . Map ; public class MarketUtils { public static Long indexTime = <NUM_LIT> ; public static Map < String , Boolean > subKlineFlagMap = new HashMap < > ( ) ; public static Map < String , Boolean > subFlagMap = new HashMap < > ( ) ; public static Map < String , Object > indexDataMap = new HashMap < > ( ) ; public static Map < String , DeptHModel > dhcpHDataMap = new HashMap < > ( ) ; public static Map < String , CircularFifoQueue < ContractTrade > > tradeHDataMap = new HashMap < > ( ) ; public static BigDecimal getZdf ( DetailModel detailModel ) { try { BigDecimal zdf = detailModel . getClose ( ) . subtract ( detailModel . getOpen ( ) ) . divide ( detailModel . getOpen ( ) , <NUM_LIT> , BigDecimal . ROUND_HALF_UP ) . multiply ( BigDecimal . valueOf ( <NUM_LIT> ) ) ; return zdf ; } catch ( Exception e ) { } return BigDecimal . ZERO ;", "output": "} }"}, {"input": "package com . oddfar . campus . common . utils ; public class MetaVo { private String title ; private String icon ; private boolean noCache ; private String link ; public MetaVo ( ) { } public MetaVo ( String title , String icon ) { this . title = title ; this . icon = icon ; } public MetaVo ( String title , String icon , boolean noCache ) { this . title = title ;", "output": "this . icon = icon ; this . noCache = noCache ; } public MetaVo ( String title , String icon , String link ) { this . title = title ; this . icon = icon ; this . link = link ; } public MetaVo ( String title , String icon , boolean noCache , String link ) { this . title = title ; this . icon = icon ; this . noCache = noCache ; if ( StringUtils . ishttp ( link ) ) { this . link = link ; } } public boolean isNoCache ( ) { return noCache ; } public void setNoCache ( boolean noCache ) { this . noCache = noCache ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getIcon ( ) { return icon ; } public void setIcon ( String icon ) { this . icon = icon ; } public String getLink ( ) { return link ; } public void setLink ( String link ) { this . link = link ; } }"}, {"input": "package org . springblade . cgform . model . file ; import lombok . Data ; @ Data public class FileCreateResultModel { private String date ; private Long size ; private Long id ; private String type ; private String value ; private Long fileId ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . form ; import cn . org . alan . exam . common . result . Result ; import jakarta . validation . constraints . NotBlank ; import lombok . Data ; @ Data public class NoticeForm { private Integer id ; @ NotBlank private String title ; private String image ; @ NotBlank private String content ; private Integer userId ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import java . util . Collections ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; public class NacosPropertySource extends MapPropertySource { private String groupId ; private String dataId ; private boolean autoRefreshed ; private boolean first ; private String before ; private String after ; private String type ; private Map < Object , Object > properties ; private Map < String , Object > attributesMetadata ; private Object origin ; private String beanName ; private Class < ? > beanType ; public NacosPropertySource ( String dataId , String groupId , String name , String nacosConfig , String type ) { super ( name , NacosUtils . toProperties ( dataId , groupId , nacosConfig , type ) ) ; this . type = type ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getDataId ( ) { return dataId ; } public void setDataId ( String dataId ) { this . dataId = dataId ; } public boolean isAutoRefreshed ( ) { return autoRefreshed ; } public void setAutoRefreshed ( boolean autoRefreshed ) { this . autoRefreshed = autoRefreshed ; } public boolean isFirst ( ) { return first ; } public void setFirst ( boolean first ) { this . first = first ; } public String getBefore ( ) { return before ; } public void setBefore ( String before ) { this . before = before ; } public String getAfter ( ) { return after ; } public void setAfter ( String after ) { this . after = after ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public Map < Object , Object > getProperties ( ) { return properties ; } public void setProperties ( Map < Object , Object > properties ) { this . properties = properties ; } public Map < String , Object > getAttributesMetadata ( ) { return attributesMetadata != null ? attributesMetadata : Collections . < String , Object > emptyMap ( ) ; } public void setAttributesMetadata ( Map < String , Object > attributesMetadata ) { this . attributesMetadata = attributesMetadata ; } public Object getOrigin ( ) { return origin ;", "output": "} public void setOrigin ( Object origin ) { this . origin = origin ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } protected void copy ( NacosPropertySource original ) { this . groupId = original . groupId ; this . dataId = original . dataId ; this . autoRefreshed = original . autoRefreshed ; this . first = original . first ; this . before = original . before ; this . after = original . after ; this . type = original . type ; this . properties = original . properties ; this . attributesMetadata = original . attributesMetadata ; this . origin = original . origin ; this . beanName = original . beanName ; this . beanType = original . beanType ; } }"}, {"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class MysqlTableHandle implements DbTableHandleI { public MysqlTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + this . b ( columnMeta ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String classType = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) {", "output": "classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { classType = \"<STR_LIT>\" ; } return classType ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta meta , ColumnMeta meta2 ) { String var3 = \"<STR_LIT>\" ; if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + meta . getColumnSize ( ) + \"<STR_LIT>\" + meta . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( meta . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = meta . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( meta . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } var3 = var3 + ( StringUtils . isNotEmpty ( meta . getComment ( ) ) ? \"<STR_LIT>\" + meta . getComment ( ) + \"<STR_LIT>\" : \"<STR_LIT>\" ) ; var3 = var3 + ( StringUtils . isNotEmpty ( meta . getFieldDefault ( ) ) ? \"<STR_LIT>\" + meta . getFieldDefault ( ) : \"<STR_LIT>\" ) ; String var4 = meta . getPkType ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( meta . getColumnName ( ) ) && var4 != null && ( \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) || \"<STR_LIT>\" . equalsIgnoreCase ( var4 ) ) ) { var3 = var3 + \"<STR_LIT>\" ; } return var3 ; } private String b ( ColumnMeta meta1 , ColumnMeta meta2 ) { String var3 = this . a ( meta1 , meta2 ) ; return var3 ; } private String a ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ; return var2 ; } private String b ( ColumnMeta meta ) { String var2 = this . a ( meta , ( ColumnMeta ) null ) ; return var2 ; } public String getCommentSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return null ; } public String dropIndexs ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName + \"<STR_LIT>\" + tableName ; } public String countIndex ( String indexName , String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + indexName + \"<STR_LIT>\" ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . * ; import java . util . concurrent . ExecutorService ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosConfigListenerExecutorIfPresent ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . identify ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class CacheableEventPublishingNacosServiceFactory implements NacosServiceFactory { private static volatile CacheableEventPublishingNacosServiceFactory SINGLETON = new CacheableEventPublishingNacosServiceFactory ( ) ; private final Map < String , ConfigService > configServicesCache = new LinkedHashMap < String , ConfigService > ( <NUM_LIT> ) ; private final Map < String , NamingService > namingServicesCache = new LinkedHashMap < String , NamingService > ( <NUM_LIT> ) ; private final Map < String , NamingMaintainService > maintainServiceCache = new LinkedHashMap < String , NamingMaintainService > ( <NUM_LIT> ) ; private final LinkedList < DeferServiceHolder > deferServiceCache = new LinkedList < DeferServiceHolder > ( ) ; private ConfigurableApplicationContext context ; private ExecutorService nacosConfigListenerExecutor ; private Map < ServiceType , AbstractCreateWorker > createWorkerManager = new HashMap < ServiceType , AbstractCreateWorker > ( <NUM_LIT> ) ; public CacheableEventPublishingNacosServiceFactory ( ) { createWorkerManager . put ( ServiceType . CONFIG , new ConfigCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . NAMING , new NamingCreateWorker ( ) ) ; createWorkerManager . put ( ServiceType . MAINTAIN , new MaintainCreateWorker ( ) ) ; createWorkerManager = Collections . unmodifiableMap ( createWorkerManager ) ; } public static CacheableEventPublishingNacosServiceFactory getSingleton ( ) { return SINGLETON ; } @ Override public ConfigService createConfigService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( ConfigService ) createWorkerManager . get ( ServiceType . CONFIG ) . run ( copy , null ) ; } @ Override public NamingService createNamingService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingService ) createWorkerManager . get ( ServiceType . NAMING ) . run ( copy , null ) ; } @ Override public NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException { Properties copy = new Properties ( ) ; copy . putAll ( properties ) ; return ( NamingMaintainService ) createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( copy , null ) ; } public < T > T deferCreateService ( T service , Properties properties ) { DeferServiceHolder serviceHolder = new DeferServiceHolder ( ) ; serviceHolder . setHolder ( service ) ; serviceHolder . setProperties ( properties ) ; deferServiceCache . add ( serviceHolder ) ; return service ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public void publishDeferService ( ApplicationContext context ) throws NacosException { setApplicationContext ( context ) ; for ( DeferServiceHolder holder : deferServiceCache ) { final Object o = holder . getHolder ( ) ; final Properties properties = holder . getProperties ( ) ; if ( o instanceof ConfigService ) { ConfigService configService = ( ConfigService ) o ; createWorkerManager . get ( ServiceType . CONFIG ) . run ( properties , configService ) ; } else if ( o instanceof NamingService ) { NamingService namingService = ( NamingService ) o ; createWorkerManager . get ( ServiceType . NAMING ) . run ( properties , namingService ) ; } else if ( o instanceof NamingMaintainService ) { NamingMaintainService maintainService = ( NamingMaintainService ) o ; createWorkerManager . get ( ServiceType . MAINTAIN ) . run ( properties , maintainService ) ; } } deferServiceCache . clear ( ) ; } public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . context = ( ConfigurableApplicationContext ) applicationContext ; this . nacosConfigListenerExecutor = getSingleton ( ) . nacosConfigListenerExecutor == null ? getNacosConfigListenerExecutorIfPresent ( applicationContext ) : getSingleton ( ) . nacosConfigListenerExecutor ; } @ Override public Collection < ConfigService > getConfigServices ( ) { return configServicesCache . values ( ) ; } @ Override public Collection < NamingService > getNamingServices ( ) { return namingServicesCache . values ( ) ; } @ Override public Collection < NamingMaintainService > getNamingMaintainService ( ) { return maintainServiceCache . values ( ) ; } private static enum ServiceType { CONFIG , NAMING , MAINTAIN } static class DeferServiceHolder { private Properties properties ; private Object holder ; private ServiceType type ; public Properties getProperties ( ) { return properties ; } public void setProperties ( Properties properties ) { this . properties = properties ; } Object getHolder ( ) { return holder ; } void setHolder ( Object holder ) { this . holder = holder ; } public ServiceType getType ( ) { return type ; } public void setType ( ServiceType type ) { this . type = type ; } } abstract static class AbstractCreateWorker < T > { AbstractCreateWorker ( ) { } public abstract T run ( Properties properties , T service ) throws NacosException ; } class ConfigCreateWorker extends AbstractCreateWorker < ConfigService > { ConfigCreateWorker ( ) { } @ Override public ConfigService run ( Properties properties , ConfigService service ) throws NacosException { String cacheKey = identify ( properties ) ;", "output": "ConfigService configService = configServicesCache . get ( cacheKey ) ; if ( configService == null ) { if ( service == null ) { service = NacosFactory . createConfigService ( properties ) ; } configService = new EventPublishingConfigService ( service , properties , getSingleton ( ) . context , getSingleton ( ) . nacosConfigListenerExecutor ) ; configServicesCache . put ( cacheKey , configService ) ; } return configService ; } } class NamingCreateWorker extends AbstractCreateWorker < NamingService > { NamingCreateWorker ( ) { } @ Override public NamingService run ( Properties properties , NamingService service ) throws NacosException { String cacheKey = identify ( properties ) ; NamingService namingService = namingServicesCache . get ( cacheKey ) ; if ( namingService == null ) { if ( service == null ) { service = NacosFactory . createNamingService ( properties ) ; } namingService = new DelegatingNamingService ( service , properties ) ; namingServicesCache . put ( cacheKey , namingService ) ; } return namingService ; } } class MaintainCreateWorker extends AbstractCreateWorker < NamingMaintainService > { MaintainCreateWorker ( ) { } @ Override public NamingMaintainService run ( Properties properties , NamingMaintainService service ) throws NacosException { String cacheKey = identify ( properties ) ; NamingMaintainService namingMaintainService = maintainServiceCache . get ( cacheKey ) ; if ( namingMaintainService == null ) { if ( service == null ) { service = NacosFactory . createMaintainService ( properties ) ; } namingMaintainService = new DelegatingNamingMaintainService ( service , properties ) ; maintainServiceCache . put ( cacheKey , namingMaintainService ) ; } return namingMaintainService ; } } }"}, {"input": "package com . yf . system . aspect . mybatis ; import com . baomidou . mybatisplus . extension . handlers . AbstractSqlParserHandler ; import com . yf . system . modules . user . UserUtils ; import lombok . extern . log4j . Log4j2 ; import org . apache . ibatis . binding . MapperMethod . ParamMap ; import org . apache . ibatis . executor . Executor ; import org . apache . ibatis . mapping . MappedStatement ; import org . apache . ibatis . mapping . SqlCommandType ; import org . apache . ibatis . plugin . * ; import java . lang . reflect . Field ; import java . sql . Timestamp ; import java . util . * ; @ Log4j2 @ Intercepts ( value = { @ Signature ( type = Executor . class , method = \"<STR_LIT>\" , args = { MappedStatement . class , Object . class } ) } ) public class UpdateInterceptor extends AbstractSqlParserHandler implements Interceptor { private static final String CREATE_TIME = \"<STR_LIT>\" ; private static final String UPDATE_TIME = \"<STR_LIT>\" ; private static final String CREATE_BY = \"<STR_LIT>\" ; private static final String UPDATE_BY = \"<STR_LIT>\" ; private static final String DEPT_CODE = \"<STR_LIT>\" ; private static final String [ ] EXCLUDE_MAPPERS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Override public Object intercept ( Invocation invocation ) throws Throwable { MappedStatement mappedStatement = ( MappedStatement ) invocation . getArgs ( ) [ <NUM_LIT> ] ; String id = mappedStatement . getId ( ) ; if ( this . isExclude ( id ) ) {", "output": "return invocation . proceed ( ) ; } SqlCommandType sqlCommandType = mappedStatement . getSqlCommandType ( ) ; Object parameter = invocation . getArgs ( ) [ <NUM_LIT> ] ; if ( parameter != null ) { if ( SqlCommandType . INSERT . equals ( sqlCommandType ) ) { this . processInsert ( parameter ) ; } if ( SqlCommandType . UPDATE . equals ( sqlCommandType ) ) { this . processUpdate ( parameter ) ; } } return invocation . proceed ( ) ; } @ Override public Object plugin ( Object target ) { if ( target instanceof Executor ) { return Plugin . wrap ( target , this ) ; } return target ; } @ Override public void setProperties ( Properties properties ) { } private void processInsert ( Object parameter ) throws IllegalAccessException { Field [ ] fields = getAllFields ( parameter ) ; for ( Field field : fields ) { if ( Objects . equals ( CREATE_TIME , field . getName ( ) ) ) { field . setAccessible ( true ) ; field . set ( parameter , new Timestamp ( System . currentTimeMillis ( ) ) ) ; } if ( Objects . equals ( CREATE_BY , field . getName ( ) ) ) { field . setAccessible ( true ) ; field . set ( parameter , UserUtils . getUserId ( false ) ) ; } if ( Objects . equals ( UPDATE_TIME , field . getName ( ) ) ) { field . setAccessible ( true ) ; field . set ( parameter , new Timestamp ( System . currentTimeMillis ( ) ) ) ; } if ( Objects . equals ( UPDATE_BY , field . getName ( ) ) ) { field . setAccessible ( true ) ; field . set ( parameter , UserUtils . getUserId ( false ) ) ; } if ( Objects . equals ( DEPT_CODE , field . getName ( ) ) ) { field . setAccessible ( true ) ; Object value = field . get ( parameter ) ; if ( value == null ) { field . set ( parameter , UserUtils . departCode ( ) ) ; } } } } private void processUpdate ( Object parameter ) throws IllegalAccessException { if ( parameter instanceof ParamMap ) { ParamMap < ? > p = ( ParamMap < ? > ) parameter ; if ( p . containsKey ( \"<STR_LIT>\" ) ) { parameter = p . get ( \"<STR_LIT>\" ) ; } else { parameter = p . get ( \"<STR_LIT>\" ) ; } if ( parameter == null ) { return ; } } Field [ ] fields = getAllFields ( parameter ) ; for ( Field field : fields ) { String fieldName = field . getName ( ) ; if ( Objects . equals ( UPDATE_TIME , fieldName ) ) { field . setAccessible ( true ) ; field . set ( parameter , new Timestamp ( System . currentTimeMillis ( ) ) ) ; } if ( Objects . equals ( UPDATE_BY , fieldName ) ) { field . setAccessible ( true ) ; field . set ( parameter , UserUtils . getUserId ( false ) ) ; } if ( Objects . equals ( DEPT_CODE , field . getName ( ) ) ) { field . setAccessible ( true ) ; Object value = field . get ( parameter ) ; if ( value == null ) { field . set ( parameter , UserUtils . departCode ( ) ) ; } } } } public static Field [ ] getAllFields ( Object object ) { Class < ? > clazz = object . getClass ( ) ; List < Field > fieldList = new ArrayList < > ( ) ; while ( clazz != null ) { fieldList . addAll ( new ArrayList < > ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ) ; clazz = clazz . getSuperclass ( ) ; } Field [ ] fields = new Field [ fieldList . size ( ) ] ; fieldList . toArray ( fields ) ; return fields ; } private boolean isExclude ( String id ) { for ( String item : EXCLUDE_MAPPERS ) { if ( id . contains ( item ) ) { return true ; } } return false ; } }"}, {"input": "package com . oddfar . campus . common . constant ; public class Constants { public static final String UTF8 = \"<STR_LIT>\" ; public static final String GBK = \"<STR_LIT>\" ; public static final String WWW = \"<STR_LIT>\" ; public static final String HTTP = \"<STR_LIT>\" ; public static final String HTTPS = \"<STR_LIT>\" ; public static final String SUCCESS = \"<STR_LIT>\" ; public static final String FAIL = \"<STR_LIT>\" ; public static final String YES = \"<STR_LIT>\" ; public static final String NO = \"<STR_LIT>\" ; public static final String LOGIN_SUCCESS = \"<STR_LIT>\" ; public static final String LOGOUT = \"<STR_LIT>\" ; public static final String REGISTER = \"<STR_LIT>\" ; public static final String LOGIN_FAIL = \"<STR_LIT>\" ; public static final Integer CAPTCHA_EXPIRATION = <NUM_LIT> ; public static final String TOKEN = \"<STR_LIT>\" ; public static final String USER_ID = \"<STR_LIT>\" ; public static final String TOKEN_PREFIX = \"<STR_LIT>\" ; public static final String LOGIN_USER_KEY = \"<STR_LIT>\" ; public static final String JWT_USERID = \"<STR_LIT>\" ; public static final String JWT_USERNAME = \"<STR_LIT>\" ; public static final String JWT_AVATAR = \"<STR_LIT>\" ; public static final String JWT_CREATED = \"<STR_LIT>\" ; public static final String JWT_AUTHORITIES = \"<STR_LIT>\" ; public static final String RESOURCE_PREFIX = \"<STR_LIT>\" ; public static final String LOOKUP_RMI = \"<STR_LIT>\" ; public static final String LOOKUP_LDAP = \"<STR_LIT>\" ; public static final String LOOKUP_LDAPS = \"<STR_LIT>\" ; public static final String [ ] JOB_WHITELIST_STR = { \"<STR_LIT>\" } ; public static final String [ ] JOB_ERROR_STR = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" }", "output": "; }"}, {"input": "package ginyi . framework . security . service ; import ginyi . system . domain . SysRole ; import ginyi . system . domain . SysUser ; import ginyi . system . service . ISysMenuService ; import ginyi . system . service . ISysPermissionService ; import ginyi . system . service . ISysRoleService ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @ Service public class SysPermissionServiceImpl implements ISysPermissionService { @ Resource private ISysRoleService roleService ; @ Resource private ISysMenuService menuService ; @ Override public Set < String > getRolePermission ( SysUser user ) { Set < String > roles = new HashSet < String > ( ) ; if ( user . isAdmin ( ) ) { roles . add ( \"<STR_LIT>\" ) ; } else { roles . addAll ( roleService . selectRolePermissionByUserId ( user . getUserId ( ) ) ) ; } return roles ; } @ Override public Set < String > getMenuPermission ( SysUser user ) { Set < String > perms = new HashSet < String > ( ) ; if ( user . isAdmin ( ) ) { perms . add ( \"<STR_LIT>\" ) ; } else { List < SysRole > roles = user . getRoles ( ) ;", "output": "if ( ! roles . isEmpty ( ) && roles . size ( ) > <NUM_LIT> ) { for ( SysRole role : roles ) { Set < String > rolePerms = menuService . selectMenuPermsByRoleId ( role . getRoleId ( ) ) ; role . setPermissions ( rolePerms ) ; perms . addAll ( rolePerms ) ; } } else { perms . addAll ( menuService . selectMenuPermsByUserId ( user . getUserId ( ) ) ) ; } } return perms ; } }"}, {"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . LinkedHashMap ; import java . util . Map ; @ Data public class GatewayFilter { private String name ; private Map < String , String > args = new LinkedHashMap < > ( ) ;", "output": "}"}, {"input": "package com . oddfar . campus . common . utils ; import org . apache . commons . lang3 . time . DateFormatUtils ; import java . lang . management . ManagementFactory ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . time . * ; import java . util . Date ; public class DateUtils extends org . apache . commons . lang3 . time . DateUtils { public static String YYYY = \"<STR_LIT>\" ; public static String YYYY_MM = \"<STR_LIT>\" ; public static String YYYY_MM_DD = \"<STR_LIT>\" ; public static String YYYYMMDDHHMMSS = \"<STR_LIT>\" ; public static String YYYY_MM_DD_HH_MM_SS = \"<STR_LIT>\" ; private static String [ ] parsePatterns = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static Date getNowDate ( ) { return new Date ( ) ; } public static String getDate ( ) { return dateTimeNow ( YYYY_MM_DD ) ; } public static final String getTime ( ) { return dateTimeNow ( YYYY_MM_DD_HH_MM_SS ) ; } public static final String dateTimeNow ( ) { return dateTimeNow ( YYYYMMDDHHMMSS ) ; } public static final String dateTimeNow ( final String format ) { return parseDateToStr ( format , new Date ( ) ) ; } public static final String dateTime ( final Date date ) { return parseDateToStr ( YYYY_MM_DD , date ) ; } public static final String parseDateToStr ( final String format , final Date date ) { return new SimpleDateFormat ( format ) . format ( date ) ; } public static final Date dateTime ( final String format , final String ts ) { try { return new SimpleDateFormat ( format ) . parse ( ts ) ; } catch ( ParseException e ) { throw new RuntimeException ( e ) ; } } public static final String datePath ( ) { Date now = new Date ( ) ; return DateFormatUtils . format ( now , \"<STR_LIT>\" ) ; } public static final String dateTime ( ) { Date now = new Date ( ) ; return DateFormatUtils . format ( now , \"<STR_LIT>\" ) ; } public static Date parseDate ( Object str ) { if ( str == null ) { return null ; } try { return parseDate ( str . toString ( ) , parsePatterns ) ; } catch ( ParseException e ) { return null ; } } public static Date getServerStartDate ( ) { long time = ManagementFactory . getRuntimeMXBean ( ) . getStartTime ( ) ; return new Date ( time ) ; } public static int differentDaysByMillisecond ( Date date1 , Date date2 ) { return Math . abs ( ( int ) ( ( date2 . getTime ( ) - date1 . getTime ( ) ) / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) ) ; } public static String getDatePoor ( Date endDate , Date nowDate ) { long nd = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; long nh = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ;", "output": "long nm = <NUM_LIT> * <NUM_LIT> ; long diff = endDate . getTime ( ) - nowDate . getTime ( ) ; long day = diff / nd ; long hour = diff % nd / nh ; long min = diff % nd % nh / nm ; return day + \"<STR_LIT>\" + hour + \"<STR_LIT>\" + min + \"<STR_LIT>\" ; } public static Date toDate ( LocalDateTime temporalAccessor ) { ZonedDateTime zdt = temporalAccessor . atZone ( ZoneId . systemDefault ( ) ) ; return Date . from ( zdt . toInstant ( ) ) ; } public static Date toDate ( LocalDate temporalAccessor ) { LocalDateTime localDateTime = LocalDateTime . of ( temporalAccessor , LocalTime . of ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ) ; ZonedDateTime zdt = localDateTime . atZone ( ZoneId . systemDefault ( ) ) ; return Date . from ( zdt . toInstant ( ) ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class FeedsLocationVO { private String poiClassifyId ; private String poiName ; private String poiAddress ; private Integer poiClassifyType ; private String city ;", "output": "}"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class TradePlateItem { private BigDecimal price ; private BigDecimal amount ; @ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( price ) . append ( \"<STR_LIT>\" ) . append ( amount ) ;", "output": "return sb . toString ( ) ; } }"}, {"input": "package com . oddfar . campus . common . exception . base ; import com . oddfar . campus . common . utils . MessageUtils ; import com . oddfar . campus . common . utils . StringUtils ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class BaseException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String module ; private String code ; private Object [ ] args ; private String defaultMessage ; @ Override public String getMessage ( ) { String message = null ; if ( ! StringUtils . isEmpty ( code ) ) { message = MessageUtils . message ( code , args ) ; } if ( message == null ) { message = defaultMessage ;", "output": "} return message ; } }"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . mysql . MyPage ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . SessionUserVo ; import ginyi . system . service . ISysOnlineService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; @ Slf4j @ Service public class MonitorServiceImpl implements ISysOnlineService { @ Resource private RedisCache redisCache ; @ Override public BaseVo < SessionUserVo > getOnlineUserList ( Long page , Long pageSize ) { MyPage IPage = new MyPage ( page , pageSize ) ; long skipCount = IPage . getPageSize ( ) * ( IPage . getPageNum ( ) - <NUM_LIT> ) ; BaseVo < SessionUserVo > baseVo = new BaseVo < > ( ) ; List < SessionUserVo > list = new LinkedList < > ( ) ; Set < String > keys = redisCache . getKeys ( CacheConstants . LOGIN_TOKEN_KEY + \"<STR_LIT>\" ) ; LoginUser loginUser ; for ( String key : keys ) { SessionUserVo sessionUserVo = new SessionUserVo ( ) ; loginUser = redisCache . getCacheObject ( key , LoginUser . class ) ; BeanUtils . copyProperties ( loginUser , sessionUserVo ) ; list . add ( sessionUserVo ) ; } long toIndex = Math . min ( skipCount + IPage . getPageSize ( ) , list . size ( ) ) ; if ( skipCount > list . size ( ) ) { list = new LinkedList < > ( ) ; } else { list = list . subList ( ( int ) skipCount , ( int ) toIndex ) ; } baseVo . setList ( list ) ; baseVo . setCount ( keys . size ( ) ) ; return baseVo ; } @ Override public void removeUser ( String sessionId ) { if ( ! redisCache . hasKey ( CacheConstants . LOGIN_TOKEN_KEY + sessionId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , sessionId + CommonMessageConstants . USER_NOT_EXIST ) ; } redisCache . removeCacheObject ( CacheConstants . LOGIN_TOKEN_KEY + sessionId ) ; } @ Override public void removeUser ( Set < String > ids ) { for ( String sessionId : ids ) { if ( ! redisCache . hasKey ( CacheConstants . LOGIN_TOKEN_KEY + sessionId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , sessionId + CommonMessageConstants . USER_NOT_EXIST ) ; }", "output": "} for ( String sessionId : ids ) { redisCache . removeCacheObject ( CacheConstants . LOGIN_TOKEN_KEY + sessionId ) ; } } }"}, {"input": "package com . oddfar . campus . framework . web . service ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . framework . service . SysMenuService ; import com . oddfar . campus . framework . service . SysResourceService ; import com . oddfar . campus . framework . service . SysRoleService ; import com . oddfar . campus . framework . service . SysUserService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @ Component public class SysPermissionService { @ Autowired private SysRoleService roleService ; @ Autowired private SysMenuService menuService ; @ Autowired private SysResourceService resourceService ; @ Autowired private SysUserService userService ; @ Autowired private TokenService tokenService ; @ Autowired private RedisCache redisCache ; public Set < String > getRolePermission ( SysUserEntity user ) { Set < String > roles = new HashSet < String > ( ) ; if ( user . isAdmin ( ) ) { roles . add ( \"<STR_LIT>\" ) ; } else { roles . addAll ( roleService . selectRolePermissionByUserId ( user . getUserId ( ) ) ) ; } return roles ; } public Set < String > getMenuPermission ( SysUserEntity user ) { Set < String > perms = new HashSet < String > ( ) ; if ( user . isAdmin ( ) ) { perms . add ( \"<STR_LIT>\" ) ; } else { List < SysRoleEntity > roles = user . getRoles ( ) ; if ( ! roles . isEmpty ( ) && roles . size ( ) > <NUM_LIT> ) { for ( SysRoleEntity role : roles ) { Set < String > rolePerms = menuService . selectMenuPermsByRoleId ( role . getRoleId ( ) ) ; role . setPermissions ( rolePerms ) ; perms . addAll ( rolePerms ) ; } } else { perms . addAll ( menuService . selectMenuPermsByUserId ( user . getUserId ( ) ) ) ; } } return perms ; } public Set < String > getMenuPermissionByRoleId ( Long roleID ) { Set < String > perms = new HashSet < String > ( ) ; if ( roleID == <NUM_LIT> ) { perms . add ( \"<STR_LIT>\" ) ; } else { perms = menuService . selectMenuPermsByRoleId ( roleID ) ; } return perms ; } public Set < String > getResources ( SysUserEntity user ) { Set < String > res = new HashSet < String > ( ) ; if ( user . isAdmin ( ) ) { res . add ( \"<STR_LIT>\" ) ; } else { List < SysRoleEntity > roles = user . getRoles ( ) ; if ( roles != null && ! roles . isEmpty ( ) ) { for ( SysRoleEntity role : roles ) { Set < String > code = resourceService . selectResourceCodeByRoleId ( role . getRoleId ( ) ) ; res . addAll ( code ) ; } } } return res ; } public void resetLoginUserRoleCache ( long roleId ) { SysUserEntity user = new SysUserEntity ( ) ; user . setRoleId ( roleId ) ; List < SysUserEntity > sysUserEntities = userService . selectAllocatedList ( user ) . getRecords ( ) ; sysUserEntities . forEach ( u -> resetUserRoleAuthCache ( u . getUserId ( ) ) ) ; } public void resetUserRoleAuthCache ( long userId ) { LoginUser loginUser = tokenService . getLoginUserByUserId ( userId ) ; if ( loginUser != null ) { loginUser . setPermissions ( getMenuPermission ( loginUser . getUser ( ) ) ) ; loginUser . setUser ( userService . selectUserByUserName ( loginUser . getUser ( ) . getUserName ( ) ) ) ; loginUser . setResources ( getResources ( loginUser . getUser ( ) ) ) ;", "output": "tokenService . setLoginUser ( loginUser ) ; } } }"}, {"input": "package top . kangert . kspider . executor ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; public interface NodeExecutor { void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) ; default boolean allowExecuteNext ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { return true ; } default Shape shape ( ) { return null ;", "output": "} default List < ConfigItem > configItems ( ) { return Collections . emptyList ( ) ; } default boolean isAsync ( ) { return true ; } String supportType ( ) ; }"}, {"input": "package top . kangert . kspider . support ; import com . zaxxer . hikari . HikariDataSource ; import top . kangert . kspider . domain . dto . DataSourceDTO ; import top . kangert . kspider . service . DataSourceService ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import javax . sql . DataSource ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class DataSourceManager { private Map < Long , DataSource > datasourceMap = new ConcurrentHashMap < > ( ) ; @ Resource private DataSourceService dataSourceService ; public DataSource createDataSource ( String className , String url , String username , String password ) { HikariDataSource datasource = new HikariDataSource ( ) ;", "output": "datasource . setDriverClassName ( className ) ; datasource . setJdbcUrl ( url ) ; datasource . setUsername ( username ) ; datasource . setPassword ( password ) ; datasource . setAutoCommit ( true ) ; datasource . setMinimumIdle ( <NUM_LIT> ) ; return datasource ; } public void remove ( Long dataSourceId ) { DataSource dataSource = datasourceMap . get ( dataSourceId ) ; if ( dataSource != null ) { HikariDataSource ds = ( HikariDataSource ) dataSource ; ds . close ( ) ; datasourceMap . remove ( dataSourceId ) ; } } public DataSource getDataSource ( Long dataSourceId ) { DataSource dataSource = datasourceMap . get ( dataSourceId ) ; if ( dataSource == null ) { DataSourceDTO ds = dataSourceService . getById ( dataSourceId ) ; if ( ds != null ) { dataSource = createDataSource ( ds . getDriverClassName ( ) , ds . getJdbcUrl ( ) , ds . getUsername ( ) , ds . getPassword ( ) ) ; datasourceMap . put ( dataSourceId , dataSource ) ; } } return dataSource ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . Contact ; import com . xcs . wx . domain . vo . ContactVO ; import org . mapstruct . Mapper ; import java . util . List ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface ContactMapping { List < ContactVO > convert ( List < Contact > entities ) ;", "output": "}"}, {"input": "package org . example . domain . example ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class ExampleDomainService { @ Autowired private ExampleRepository exampleRepository ; public void validateUsername ( String username ) { ExampleEntity existingUser = exampleRepository . getByUsername ( username ) ; if ( existingUser != null ) { throw new BizException ( \"<STR_LIT>\" ) ; }", "output": "} }"}, {"input": "package top . kangert . kspider . executor . node ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . Grammar ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . support . DataSourceManager ; import top . kangert . kspider . support . ExpressionEngine ; import top . kangert . kspider . support . Grammarly ; import top . kangert . kspider . util . ExtractUtils ; import top . kangert . kspider . websocket . WebSocketEvent ; import lombok . extern . slf4j . Slf4j ; import org . springframework . jdbc . core . ArgumentPreparedStatementSetter ; import org . springframework . jdbc . core . JdbcTemplate ; import org . springframework . jdbc . support . GeneratedKeyHolder ; import org . springframework . jdbc . support . KeyHolder ; import org . springframework . stereotype . Component ; import cn . hutool . core . exceptions . ExceptionUtil ; import cn . hutool . core . util . StrUtil ; import javax . annotation . Resource ; import java . lang . reflect . Array ; import java . sql . PreparedStatement ; import java . sql . Statement ; import java . util . * ; @ Component @ Slf4j public class SQLExecutor implements NodeExecutor , Grammarly { String SQL = \"<STR_LIT>\" ; String STATEMENT_TYPE = \"<STR_LIT>\" ; String SELECT_RESULT_SQL_ROW_SET = \"<STR_LIT>\" ; public static final String STATEMENT_SELECT = \"<STR_LIT>\" ; public static final String STATEMENT_SELECT_ONE = \"<STR_LIT>\" ; public static final String STATEMENT_SELECT_INT = \"<STR_LIT>\" ; public static final String STATEMENT_INSERT = \"<STR_LIT>\" ; public static final String STATEMENT_UPDATE = \"<STR_LIT>\" ; public static final String STATEMENT_DELETE = \"<STR_LIT>\" ; public static final String STATEMENT_INSERT_PK = \"<STR_LIT>\" ; @ Resource private ExpressionEngine expressionEngine ; @ Resource private DataSourceManager dataSourceManager ; @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { String dsId = node . getJsonProperty ( Constants . DATASOURCE_ID ) ; String sql = node . getJsonProperty ( SQL ) ; if ( StrUtil . isBlank ( dsId ) ) { log . warn ( \"<STR_LIT>\" ) ; } else if ( StrUtil . isBlank ( sql ) ) { log . warn ( \"<STR_LIT>\" ) ; } else { JdbcTemplate template = new JdbcTemplate ( dataSourceManager . getDataSource ( Long . parseLong ( dsId ) ) ) ; List < String > parameters = ExtractUtils . getMatchers ( sql , \"<STR_LIT>\" , true ) ; sql = sql . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { Object sqlObject = expressionEngine . execute ( sql , variables ) ; if ( sqlObject == null ) { log . warn ( \"<STR_LIT>\" ) ; return ; } sql = sqlObject . toString ( ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , SQL , sql ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } int size = parameters . size ( ) ; Object [ ] params = new Object [ size ] ; boolean hasList = false ; int parameterSize = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Object parameter = expressionEngine . execute ( parameters . get ( i ) , variables ) ; if ( parameter != null ) { if ( parameter instanceof List ) { hasList = true ; parameterSize = Math . max ( parameterSize , ( ( List < ? > ) parameter ) . size ( ) ) ; } else if ( parameter . getClass ( ) . isArray ( ) ) { hasList = true ; parameterSize = Math . max ( parameterSize , Array . getLength ( parameter ) ) ; } } params [ i ] = parameter ; } String statementType = node . getJsonProperty ( STATEMENT_TYPE ) ; log . debug ( \"<STR_LIT>\" , sql ) ; if ( STATEMENT_SELECT . equals ( statementType ) ) { boolean isSqlRowSet = Constants . YES . equals ( node . getJsonProperty ( SELECT_RESULT_SQL_ROW_SET ) ) ; try { if ( isSqlRowSet ) { variables . put ( Constants . SQL_RESULT , template . queryForRowSet ( sql , params ) ) ; } else { variables . put ( Constants . SQL_RESULT , template . queryForList ( sql , params ) ) ; } } catch ( Exception e ) { variables . put ( Constants . SQL_RESULT , null ) ; log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } } else if ( STATEMENT_SELECT_ONE . equals ( statementType ) ) { Map < String , Object > rs ; try { rs = template . queryForMap ( sql , params ) ; variables . put ( Constants . SQL_RESULT , rs ) ; } catch ( Exception e ) { variables . put ( Constants . SQL_RESULT , null ) ; log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; }", "output": "} else if ( STATEMENT_SELECT_INT . equals ( statementType ) ) { Integer rs ; try { rs = template . queryForObject ( sql , Integer . class , params ) ; rs = rs == null ? <NUM_LIT> : rs ; variables . put ( Constants . SQL_RESULT , rs ) ; } catch ( Exception e ) { variables . put ( Constants . SQL_RESULT , <NUM_LIT> ) ; log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } } else if ( STATEMENT_UPDATE . equals ( statementType ) || STATEMENT_INSERT . equals ( statementType ) || STATEMENT_DELETE . equals ( statementType ) ) { try { int updateCount = <NUM_LIT> ; if ( hasList ) { int [ ] rs = template . batchUpdate ( sql , convertParameters ( params , parameterSize ) ) ; if ( rs . length > <NUM_LIT> ) { updateCount = Arrays . stream ( rs ) . sum ( ) ; } } else { updateCount = template . update ( sql , params ) ; } variables . put ( Constants . SQL_RESULT , updateCount ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; variables . put ( Constants . SQL_RESULT , - <NUM_LIT> ) ; ExceptionUtil . wrapAndThrow ( e ) ; } } else if ( STATEMENT_INSERT_PK . equals ( statementType ) ) { try { KeyHolder keyHolder = new GeneratedKeyHolder ( ) ; final String insertSQL = sql ; template . update ( con -> { PreparedStatement ps = con . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; new ArgumentPreparedStatementSetter ( params ) . setValues ( ps ) ; return ps ; } , keyHolder ) ; variables . put ( Constants . SQL_RESULT , keyHolder . getKey ( ) . intValue ( ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; variables . put ( Constants . SQL_RESULT , - <NUM_LIT> ) ; ExceptionUtil . wrapAndThrow ( e ) ; } } } } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { return new Shape ( supportType ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } private List < Object [ ] > convertParameters ( Object [ ] params , int length ) { List < Object [ ] > result = new ArrayList < > ( length ) ; int size = params . length ; for ( int i = <NUM_LIT> ; i < length ; i ++ ) { Object [ ] parameters = new Object [ size ] ; for ( int j = <NUM_LIT> ; j < size ; j ++ ) { parameters [ j ] = getValue ( params [ j ] , i ) ; } result . add ( parameters ) ; } return result ; } private Object getValue ( Object object , int index ) { if ( object == null ) { return null ; } else if ( object instanceof List ) { List < ? > list = ( List < ? > ) object ; int size = list . size ( ) ; if ( size > <NUM_LIT> ) { return list . get ( Math . min ( list . size ( ) - <NUM_LIT> , index ) ) ; } } else if ( object . getClass ( ) . isArray ( ) ) { int size = Array . getLength ( object ) ; if ( size > <NUM_LIT> ) { Array . get ( object , Math . min ( - <NUM_LIT> , index ) ) ; } } else { return object ; } return null ; } @ Override public List < Grammar > grammars ( ) { Grammar grammar = new Grammar ( ) ; grammar . setComment ( \"<STR_LIT>\" ) ; grammar . setFunction ( Constants . SQL_RESULT ) ; grammar . setReturns ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; return Collections . singletonList ( grammar ) ; } }"}, {"input": "package org . springblade . plugin . message . model ; import lombok . Data ; import java . util . List ; @ Data public class SocketMsgModel { private String topic ; private String content ;", "output": "}"}, {"input": "package org . springblade . cgform . model . generate . pojo ; import java . util . Map ; public class TableVo { private String tableName ; private String ftlDescription ; private String primaryKeyPolicy ; private String sequenceCode ; private String entityPackage ; private String entityName ; private Integer fieldRowNum ; private Integer searchFieldNum ; private Integer fieldRequiredNum ; private Map < ? , ? > extendParams ; public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public Integer getFieldRowNum ( ) { return this . fieldRowNum ; } public void setFieldRowNum ( Integer fieldRowNum ) { this . fieldRowNum = fieldRowNum ; } public Integer getSearchFieldNum ( ) {", "output": "return this . searchFieldNum ; } public void setSearchFieldNum ( Integer searchFieldNum ) { this . searchFieldNum = searchFieldNum ; } public Integer getFieldRequiredNum ( ) { return this . fieldRequiredNum ; } public void setFieldRequiredNum ( Integer fieldRequiredNum ) { this . fieldRequiredNum = fieldRequiredNum ; } public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + this . tableName + \"<STR_LIT>\" + this . ftlDescription + \"<STR_LIT>\" + this . primaryKeyPolicy + \"<STR_LIT>\" + this . sequenceCode + \"<STR_LIT>\" + this . entityPackage + \"<STR_LIT>\" + this . entityName + \"<STR_LIT>\" + this . fieldRowNum + \"<STR_LIT>\" + this . searchFieldNum + \"<STR_LIT>\" + this . fieldRequiredNum + \"<STR_LIT>\" ; } }"}, {"input": "package com . youlai . system . config ; import com . xxl . job . core . executor . impl . XxlJobSpringExecutor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ ConditionalOnProperty ( name = \"<STR_LIT>\" ) @ Slf4j public class XxlJobConfig { @ Value ( \"<STR_LIT>\" ) private String adminAddresses ; @ Value ( \"<STR_LIT>\" ) private String accessToken ; @ Value ( \"<STR_LIT>\" ) private String appname ; @ Value ( \"<STR_LIT>\" ) private String address ; @ Value ( \"<STR_LIT>\" ) private String ip ; @ Value ( \"<STR_LIT>\" ) private int port ; @ Value ( \"<STR_LIT>\" ) private String logPath ; @ Value ( \"<STR_LIT>\" ) private int logRetentionDays ; @ Bean public XxlJobSpringExecutor xxlJobExecutor ( ) { log . info ( \"<STR_LIT>\" ) ; XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor ( ) ; xxlJobSpringExecutor . setAdminAddresses ( adminAddresses ) ;", "output": "xxlJobSpringExecutor . setAppname ( appname ) ; xxlJobSpringExecutor . setAddress ( address ) ; xxlJobSpringExecutor . setIp ( ip ) ; xxlJobSpringExecutor . setPort ( port ) ; xxlJobSpringExecutor . setAccessToken ( accessToken ) ; xxlJobSpringExecutor . setLogPath ( logPath ) ; xxlJobSpringExecutor . setLogRetentionDays ( logRetentionDays ) ; return xxlJobSpringExecutor ; } }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . model . dto . RoleDto ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . RoleVo ; import java . util . Set ; public interface ISysRoleService { public Set < String > selectRolePermissionByUserId ( Long userId ) ;", "output": "BaseVo < RoleVo > list ( RoleDto roleDto , Long page , Long pageSize ) ; public RoleVo getRoleByRoleId ( Long roleId ) ; public void addRole ( RoleDto roleDto ) ; public void updateRole ( RoleDto roleDto ) ; public void removeByRoleId ( Long roleId ) ; public void removeByRoleIds ( Set < Long > ids ) ; public void updateStatus ( RoleDto roleDto ) ; }"}, {"input": "package cn . org . alan . exam . config ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . GenericJackson2JsonRedisSerializer ; import org . springframework . data . redis . serializer . StringRedisSerializer ; @ Configuration public class RedisConfig { @ Bean public RedisTemplate redisTemplateInit ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < String , Object > redisTemplate = new RedisTemplate < > ( ) ; redisTemplate . setConnectionFactory ( redisConnectionFactory ) ; redisTemplate . setKeySerializer ( new StringRedisSerializer ( ) ) ; redisTemplate . setValueSerializer ( new GenericJackson2JsonRedisSerializer ( ) ) ; redisTemplate . setHashKeySerializer ( new StringRedisSerializer ( ) ) ; redisTemplate . setHashValueSerializer ( new GenericJackson2JsonRedisSerializer ( ) ) ; return redisTemplate ; }", "output": "}"}, {"input": "package ginyi . common . utils . http ; import ginyi . common . utils . Constants ; import ginyi . common . utils . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ssl . * ; import java . io . * ; import java . net . ConnectException ; import java . net . SocketTimeoutException ; import java . net . URL ; import java . net . URLConnection ; import java . nio . charset . StandardCharsets ; import java . security . cert . X509Certificate ; public class HttpUtils { private static final Logger log = LoggerFactory . getLogger ( HttpUtils . class ) ; public static String sendGet ( String url ) { return sendGet ( url , StringUtils . EMPTY ) ; } public static String sendGet ( String url , String param ) { return sendGet ( url , param , Constants . UTF8 ) ; } public static String sendGet ( String url , String param , String contentType ) { StringBuilder result = new StringBuilder ( ) ; BufferedReader in = null ; try { String urlNameString = StringUtils . isNotBlank ( param ) ? url + \"<STR_LIT>\" + param : url ; log . info ( \"<STR_LIT>\" , urlNameString ) ; URL realUrl = new URL ( urlNameString ) ; URLConnection connection = realUrl . openConnection ( ) ; connection . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; connection . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; connection . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; connection . connect ( ) ; in = new BufferedReader ( new InputStreamReader ( connection . getInputStream ( ) , contentType ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { result . append ( line ) ; } log . info ( \"<STR_LIT>\" , result ) ; } catch ( ConnectException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( SocketTimeoutException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } finally { try { if ( in != null ) { in . close ( ) ;", "output": "} } catch ( Exception ex ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , ex ) ; } } return result . toString ( ) ; } public static String sendPost ( String url , String param ) { PrintWriter out = null ; BufferedReader in = null ; StringBuilder result = new StringBuilder ( ) ; try { log . info ( \"<STR_LIT>\" , url ) ; URL realUrl = new URL ( url ) ; URLConnection conn = realUrl . openConnection ( ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setDoOutput ( true ) ; conn . setDoInput ( true ) ; out = new PrintWriter ( conn . getOutputStream ( ) ) ; out . print ( param ) ; out . flush ( ) ; in = new BufferedReader ( new InputStreamReader ( conn . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { result . append ( line ) ; } log . info ( \"<STR_LIT>\" , result ) ; } catch ( ConnectException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( SocketTimeoutException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } finally { try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( IOException ex ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , ex ) ; } } return result . toString ( ) ; } public static String sendSSLPost ( String url , String param ) { StringBuilder result = new StringBuilder ( ) ; String urlNameString = url + \"<STR_LIT>\" + param ; try { log . info ( \"<STR_LIT>\" , urlNameString ) ; SSLContext sc = SSLContext . getInstance ( \"<STR_LIT>\" ) ; sc . init ( null , new TrustManager [ ] { new TrustAnyTrustManager ( ) } , new java . security . SecureRandom ( ) ) ; URL console = new URL ( urlNameString ) ; HttpsURLConnection conn = ( HttpsURLConnection ) console . openConnection ( ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setRequestProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; conn . setDoOutput ( true ) ; conn . setDoInput ( true ) ; conn . setSSLSocketFactory ( sc . getSocketFactory ( ) ) ; conn . setHostnameVerifier ( new TrustAnyHostnameVerifier ( ) ) ; conn . connect ( ) ; InputStream is = conn . getInputStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ; String ret = \"<STR_LIT>\" ; while ( ( ret = br . readLine ( ) ) != null ) { if ( ret != null && ! \"<STR_LIT>\" . equals ( ret . trim ( ) ) ) { result . append ( new String ( ret . getBytes ( StandardCharsets . ISO_8859_1 ) , StandardCharsets . UTF_8 ) ) ; } } log . info ( \"<STR_LIT>\" , result ) ; conn . disconnect ( ) ; br . close ( ) ; } catch ( ConnectException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( SocketTimeoutException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + url + \"<STR_LIT>\" + param , e ) ; } return result . toString ( ) ; } private static class TrustAnyTrustManager implements X509TrustManager { @ Override public void checkClientTrusted ( X509Certificate [ ] chain , String authType ) { } @ Override public void checkServerTrusted ( X509Certificate [ ] chain , String authType ) { } @ Override public X509Certificate [ ] getAcceptedIssuers ( ) { return new X509Certificate [ ] { } ; } } private static class TrustAnyHostnameVerifier implements HostnameVerifier { @ Override public boolean verify ( String hostname , SSLSession session ) { return true ; } } }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import org . apache . poi . hssf . usermodel . HSSFDateUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . text . ParseException ; import java . util . Date ; import java . util . regex . Pattern ; public class DateConverter implements Converter { private static final Logger logger = LoggerFactory . getLogger ( DateConverter . class ) ; private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; private static final String [ ] DATE_FORMATS = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Date . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { if ( ! isNumeric ( cellContent ) ) { Date simpleDate = getSimpleDate ( cellContent , format ) ; if ( simpleDate != null ) { return simpleDate ; } } try { Double time = Double . parseDouble ( cellContent ) ; return HSSFDateUtil . getJavaDate ( time , use1904DateWindowing ) ;", "output": "} catch ( NumberFormatException e ) { } return null ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Date value = ( Date ) cellValue ; String cellContent = null ; if ( TextUtil . isNotEmpty ( format ) ) { try { cellContent = DateFormatUtil . formatDate ( format , value ) ; } catch ( Exception e ) { } } if ( cellContent == null ) { cellContent = DateFormatUtil . formatDate ( DATE_FORMATS [ <NUM_LIT> ] , value ) ; } if ( cellContent != null ) { cell . setCellValue ( cellContent ) ; } } private Date getSimpleDate ( String value , String format ) { if ( TextUtil . isNotEmpty ( format ) ) { try { return DateFormatUtil . parseDate ( format , value ) ; } catch ( ParseException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } } for ( String dateFormat : DATE_FORMATS ) { try { return DateFormatUtil . parseDate ( dateFormat , value ) ; } catch ( ParseException e ) { } } return null ; } private static boolean isNumeric ( String str ) { return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . number ; import io . github . chensheng . dddboot . tools . base . MoreValidate ; import org . apache . commons . lang3 . RandomStringUtils ; import org . apache . commons . lang3 . Validate ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . ThreadLocalRandom ; public class RandomUtil { public static Random threadLocalRandom ( ) { return ThreadLocalRandom . current ( ) ; } public static SecureRandom secureRandom ( ) { try { return SecureRandom . getInstance ( \"<STR_LIT>\" ) ; } catch ( NoSuchAlgorithmException e ) { return new SecureRandom ( ) ; } } public static int nextInt ( ) { return nextInt ( ThreadLocalRandom . current ( ) ) ; } public static int nextInt ( Random random ) { int n = random . nextInt ( ) ; if ( n == Integer . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static int nextInt ( int max ) { return nextInt ( ThreadLocalRandom . current ( ) , max ) ; } public static int nextInt ( Random random , int max ) { return random . nextInt ( max ) ; } public static int nextInt ( int min , int max ) { return nextInt ( ThreadLocalRandom . current ( ) , min , max ) ; } public static int nextInt ( Random random , int min , int max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return min + random . nextInt ( max - min ) ; } public static long nextLong ( ) { return nextLong ( ThreadLocalRandom . current ( ) ) ; } public static long nextLong ( Random random ) { long n = random . nextLong ( ) ; if ( n == Long . MIN_VALUE ) { n = <NUM_LIT> ; } else { n = Math . abs ( n ) ; } return n ; } public static long nextLong ( long max ) { return nextLong ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static long nextLong ( Random random , long max ) { return nextLong ( random , <NUM_LIT> , max ) ; } public static long nextLong ( long min , long max ) { return nextLong ( ThreadLocalRandom . current ( ) , min , max ) ; } public static long nextLong ( Random random , long min , long max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( min == max ) { return min ; } return ( long ) ( min + ( ( max - min ) * random . nextDouble ( ) ) ) ; }", "output": "public static double nextDouble ( ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( Random random ) { return nextDouble ( random , <NUM_LIT> , Double . MAX_VALUE ) ; } public static double nextDouble ( double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , <NUM_LIT> , max ) ; } public static double nextDouble ( Random random , double max ) { return nextDouble ( random , <NUM_LIT> , max ) ; } public static double nextDouble ( final double min , final double max ) { return nextDouble ( ThreadLocalRandom . current ( ) , min , max ) ; } public static double nextDouble ( Random random , final double min , final double max ) { Validate . isTrue ( max >= min , \"<STR_LIT>\" ) ; MoreValidate . nonNegative ( \"<STR_LIT>\" , min ) ; if ( Double . compare ( min , max ) == <NUM_LIT> ) { return min ; } return min + ( ( max - min ) * random . nextDouble ( ) ) ; } public static String randomStringFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , true , null , threadLocalRandom ( ) ) ; } public static String randomStringFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , true , null , random ) ; } public static String randomStringRandomLength ( int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , true , null , threadLocalRandom ( ) ) ; } public static String randomStringRandomLength ( Random random , int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( random , minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , true , null , random ) ; } public static String randomLetterFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , false , null , threadLocalRandom ( ) ) ; } public static String randomLetterFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , true , false , null , random ) ; } public static String randomLetterRandomLength ( int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , false , null , threadLocalRandom ( ) ) ; } public static String randomLetterRandomLength ( Random random , int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( random , minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , true , false , null , random ) ; } public static String randomAsciiFixLength ( int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , false , false , null , threadLocalRandom ( ) ) ; } public static String randomAsciiFixLength ( Random random , int length ) { return RandomStringUtils . random ( length , <NUM_LIT> , <NUM_LIT> , false , false , null , random ) ; } public static String randomAsciiRandomLength ( int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , false , false , null , threadLocalRandom ( ) ) ; } public static String randomAsciiRandomLength ( Random random , int minLength , int maxLength ) { return RandomStringUtils . random ( nextInt ( random , minLength , maxLength ) , <NUM_LIT> , <NUM_LIT> , false , false , null , random ) ; } }"}, {"input": "package org . springblade . gateway . config ; import com . fasterxml . jackson . databind . ObjectMapper ; import org . springblade . gateway . handler . ErrorExceptionHandler ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . web . ResourceProperties ; import org . springframework . boot . autoconfigure . web . ServerProperties ; import org . springframework . boot . autoconfigure . web . reactive . error . ErrorWebFluxAutoConfiguration ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ AutoConfigureBefore ( ErrorWebFluxAutoConfiguration . class ) @ EnableConfigurationProperties ( { ServerProperties . class , ResourceProperties . class } ) public class ErrorHandlerConfiguration {", "output": "@ Bean public ErrorExceptionHandler globalExceptionHandler ( ObjectMapper objectMapper ) { return new ErrorExceptionHandler ( objectMapper ) ; } }"}, {"input": "package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . List ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Dict extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Long id ; @ TableField ( exist = false ) private List < DictDetail > dictDetails ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ;", "output": "}"}, {"input": "package com . youlai . system . enums ; import com . baomidou . mybatisplus . annotation . EnumValue ; import com . youlai . system . common . base . IBaseEnum ; import lombok . Getter ; @ Getter public enum MenuTypeEnum implements IBaseEnum < Integer > { NULL ( <NUM_LIT> , null ) , MENU ( <NUM_LIT> , \"<STR_LIT>\" ) , CATALOG ( <NUM_LIT> , \"<STR_LIT>\" ) , EXTLINK ( <NUM_LIT> , \"<STR_LIT>\" ) , BUTTON ( <NUM_LIT> , \"<STR_LIT>\" ) ; @ EnumValue private final Integer value ; private final String label ; MenuTypeEnum ( Integer value , String label ) {", "output": "this . value = value ; this . label = label ; } }"}, {"input": "package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Menu ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface RoleMenuMapper { void insertData ( @ Param ( \"<STR_LIT>\" ) Long roleId , @ Param ( \"<STR_LIT>\" ) Set < Menu > menus ) ;", "output": "void deleteByRoleId ( @ Param ( \"<STR_LIT>\" ) Long roleId ) ; void deleteByRoleIds ( @ Param ( \"<STR_LIT>\" ) Set < Long > roleIds ) ; void deleteByMenuId ( @ Param ( \"<STR_LIT>\" ) Long menuId ) ; }"}, {"input": "package org . example . ddduser . infrastructure . convertor ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . MappingConstants ; import org . mapstruct . MappingTarget ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface UserConvertor { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserEntity toEntity ( User user , UserDetail detail ) ; User toUserPo ( UserEntity entity ) ; void toUserPo ( UserEntity entity , @ MappingTarget User user ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) UserDetail toDetailPo ( UserEntity entity , Long userId ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) void toDetailPo ( UserEntity entity , @ MappingTarget UserDetail detail ) ; @ Mapping ( target = \"<STR_LIT>\" , expression = \"<STR_LIT>\" ) UserProfile toDto ( UserEntity entity ) ;", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import org . springblade . cgform . model . DictModel ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class StringProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private Integer maxLength ; private Integer minLength ; private String pattern ; private String errorInfo ; public Integer getMaxLength ( ) { return maxLength ; } public void setMaxLength ( Integer maxLength ) { this . maxLength = maxLength ; } public Integer getMinLength ( ) { return minLength ; } public void setMinLength ( Integer minLength ) { this . minLength = minLength ; } public String getPattern ( ) { return pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getErrorInfo ( ) { return errorInfo ; } public void setErrorInfo ( String errorInfo ) {", "output": "this . errorInfo = errorInfo ; } public StringProperty ( ) { } public StringProperty ( String key , String title , String view , Integer maxLength ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; } public StringProperty ( String key , String title , String view , Integer maxLength , List < DictModel > include ) { this . maxLength = maxLength ; this . key = key ; this . view = view ; this . title = title ; this . type = \"<STR_LIT>\" ; this . include = include ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( maxLength != null ) { prop . put ( \"<STR_LIT>\" , maxLength ) ; } if ( minLength != null ) { prop . put ( \"<STR_LIT>\" , minLength ) ; } if ( pattern != null ) { prop . put ( \"<STR_LIT>\" , pattern ) ; } if ( errorInfo != null ) { prop . put ( \"<STR_LIT>\" , errorInfo ) ; } map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package com . yf . system . modules . plugin . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . plugin . entity . PluginSchema ; public interface PluginSchemaMapper extends BaseMapper < PluginSchema > {", "output": "}"}, {"input": "package ginyi . system . domain . model . dto ; import com . baomidou . mybatisplus . annotation . TableLogic ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . * ; import java . util . Date ; import java . util . List ; import java . util . Set ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class UserDto extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = UpdateGroup . class , message = \"<STR_LIT>\" ) private Long userId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { UpdateGroup . class , AddGroup . class } , message = \"<STR_LIT>\" ) private String userName ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = { UpdateGroup . class , AddGroup . class } , message = \"<STR_LIT>\" ) private Long deptId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String nickName ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Email ( message = \"<STR_LIT>\" ) private String email ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String phoneNumber ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String sex ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String avatar ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String password ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String status ; private String loginIp ; private Date loginDate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date beginTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date endTime ; @ TableLogic private String deleted ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > postIds ;", "output": "@ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > roleIds ; }"}, {"input": "package top . kangert . kspider . executor . function ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; import top . kangert . kspider . util . ExtractUtils ; import org . jsoup . Jsoup ; import org . jsoup . nodes . Element ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Comment ( \"<STR_LIT>\" ) public class ExtractFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object jsonpath ( Object root , String jsonpath ) { return ExtractUtils . getValueByJsonPath ( root , jsonpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( String content , String pattern ) { return ExtractUtils . getFirstMatcher ( content , pattern , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( String content , String pattern , int groupIndex ) { return ExtractUtils . getFirstMatcher ( content , pattern , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regx ( String content , String pattern , List < Integer > groups ) { return ExtractUtils . getFirstMatcher ( content , pattern , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( String content , String pattern ) { return ExtractUtils . getMatchers ( content , pattern , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( String content , String pattern , int groupIndex ) { return ExtractUtils . getMatchers ( content , pattern , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < List < String > > regxs ( String content , String pattern , List < Integer > groups ) { return ExtractUtils . getMatchers ( content , pattern , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String xpath ( Element element , String xpath ) { return ExtractUtils . getValueByXPath ( element , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String xpath ( String content , String xpath ) { return xpath ( Jsoup . parse ( content ) , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > xpaths ( Element element , String xpath ) { return ExtractUtils . getValuesByXPath ( element , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > xpaths ( String content , String xpath ) { return xpaths ( Jsoup . parse ( content ) , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > selectors ( Object object , String selector ) { return ExtractUtils . getHTMLBySelector ( getElement ( object ) , selector ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object selector ( Object object , String selector , String type ) { if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getFirstElement ( getElement ( object ) , selector ) ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getFirstTextBySelector ( getElement ( object ) , selector ) ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getFirstOuterHTMLBySelector ( getElement ( object ) , selector ) ; } return null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String selector ( Object object , String selector , String type , String attrValue ) { if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getFirstAttrBySelector ( getElement ( object ) , selector , attrValue ) ;", "output": "} return null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String selector ( Object object , String selector ) { return ExtractUtils . getFirstHTMLBySelector ( getElement ( object ) , selector ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object selectors ( Object object , String selector , String type ) { if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getElements ( getElement ( object ) , selector ) ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getTextBySelector ( getElement ( object ) , selector ) ; } else if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getOuterHTMLBySelector ( getElement ( object ) , selector ) ; } return null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object selectors ( Object object , String selector , String type , String attrValue ) { if ( \"<STR_LIT>\" . equals ( type ) ) { return ExtractUtils . getAttrBySelector ( getElement ( object ) , selector , attrValue ) ; } return null ; } private static Element getElement ( Object object ) { if ( object != null ) { return object instanceof Element ? ( Element ) object : Jsoup . parse ( ( String ) object ) ; } return null ; } }"}, {"input": "package com . youlai . system . model . query ; import com . youlai . system . common . base . BasePageQuery ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; import lombok . Setter ; import org . springframework . format . annotation . DateTimeFormat ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public class LogPageQuery extends BasePageQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ; @ Schema ( description = \"<STR_LIT>\" ) @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private String startDate ; @ Schema ( description = \"<STR_LIT>\" ) @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private String endDate ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . BeanMapper ; import com . yf . base . utils . jackson . JsonHelper ; import com . yf . system . modules . plugin . dto . PluginDataDTO ; import com . yf . system . modules . plugin . entity . PluginData ; import com . yf . system . modules . plugin . mapper . PluginDataMapper ; import com . yf . system . modules . plugin . service . PluginDataService ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class PluginDataServiceImpl extends ServiceImpl < PluginDataMapper , PluginData > implements PluginDataService { @ Override public IPage < PluginDataDTO > paging ( PagingReqDTO < PluginDataDTO > reqDTO ) { QueryWrapper < PluginData > wrapper = new QueryWrapper < > ( ) ; PluginDataDTO params = reqDTO . getParams ( ) ; IPage < PluginData > page = this . page ( reqDTO . toPage ( ) , wrapper ) ; System . out . println ( \"<STR_LIT>\" ) ; IPage < PluginDataDTO > pageData = JsonHelper . parseObject ( page , new TypeReference < Page < PluginDataDTO > > ( ) { } ) ; return pageData ; } @ Override public void save ( PluginDataDTO reqDTO ) { PluginData entity = new PluginData ( ) ; BeanMapper . copy ( reqDTO , entity ) ; this . saveOrUpdate ( entity ) ; } @ Override public void delete ( List < String > ids ) { this . removeByIds ( ids ) ; } @ Override public PluginDataDTO detail ( String id ) {", "output": "PluginData entity = this . getById ( id ) ; PluginDataDTO dto = new PluginDataDTO ( ) ; BeanMapper . copy ( entity , dto ) ; return dto ; } @ Override public List < PluginDataDTO > list ( PluginDataDTO reqDTO ) { QueryWrapper < PluginData > wrapper = new QueryWrapper < > ( ) ; List < PluginData > list = this . list ( wrapper ) ; List < PluginDataDTO > dtoList = BeanMapper . mapList ( list , PluginDataDTO . class ) ; return dtoList ; } @ Override public String findConfig ( String code ) { QueryWrapper < PluginData > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( PluginData :: getCode , code ) ; PluginData data = this . getOne ( wrapper , false ) ; if ( data == null ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } return data . getConfigData ( ) ; } @ Override public String findServiceClazz ( String groupId ) { QueryWrapper < PluginData > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( PluginData :: getGroupId , groupId ) . orderByDesc ( PluginData :: getInUse ) ; PluginData data = this . getOne ( wrapper , false ) ; if ( data == null ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } return data . getServiceClazz ( ) ; } }"}, {"input": "package org . example . ddduser . infrastructure . repository ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . stereotype . Component ; @ Component public class LocationRepositoryImpl implements LocationRepository { @ Override public Address find ( Double longitude , Double latitude ) { Address address = Address . builder ( ) . country ( \"<STR_LIT>\" ) . province ( \"<STR_LIT>\" ) . city ( \"<STR_LIT>\" ) . county ( \"<STR_LIT>\" ) . detail ( String . format ( \"<STR_LIT>\" , longitude , latitude ) ) . build ( ) ; return address ;", "output": "} }"}, {"input": "package ginyi . common . exception ; import ginyi . common . result . StateCode ; import lombok . Data ; @ Data public class CommonException extends RuntimeException { private StateCode state ; private Object data ; public CommonException ( StateCode state , Object data ) {", "output": "this . state = state ; this . data = data ; } public CommonException ( StateCode state ) { this . state = state ; this . data = data ; } }"}, {"input": "package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . service . DeployService ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; @ RestController @ Api ( tags = \"<STR_LIT>\" ) @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class DeployController { private final String fileSavePath = FileUtil . getTmpDirPath ( ) + \"<STR_LIT>\" ; private final DeployService deployService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportDeployData ( HttpServletResponse response , DeployQueryCriteria criteria ) throws IOException { deployService . download ( deployService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Deploy > > queryDeployData ( DeployQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( deployService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createDeploy ( @ Validated @ RequestBody Deploy resources ) { deployService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateDeploy ( @ Validated @ RequestBody Deploy resources ) { deployService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteDeploy ( @ RequestBody Set < Long > ids ) { deployService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > uploadDeploy ( @ RequestBody MultipartFile file , HttpServletRequest request ) throws Exception { Long id = Long . valueOf ( request . getParameter ( \"<STR_LIT>\" ) ) ; String fileName = \"<STR_LIT>\" ; if ( file != null ) { fileName = file . getOriginalFilename ( ) ; File deployFile = new File ( fileSavePath + fileName ) ; FileUtil . del ( deployFile ) ; file . transferTo ( deployFile ) ; deployService . deploy ( fileSavePath + fileName , id ) ; } else { System . out . println ( \"<STR_LIT>\" ) ;", "output": "} System . out . println ( \"<STR_LIT>\" + Objects . requireNonNull ( file ) . getOriginalFilename ( ) ) ; Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; map . put ( \"<STR_LIT>\" , fileName ) ; return new ResponseEntity < > ( map , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < String > serverReduction ( @ Validated @ RequestBody DeployHistory resources ) { String result = deployService . serverReduction ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < String > serverStatus ( @ Validated @ RequestBody Deploy resources ) { String result = deployService . serverStatus ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < String > startServer ( @ Validated @ RequestBody Deploy resources ) { String result = deployService . startServer ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < String > stopServer ( @ Validated @ RequestBody Deploy resources ) { String result = deployService . stopServer ( resources ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } }"}, {"input": "package org . springblade . web . config . rabbitmq ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Component ; @ Slf4j @ Component public class DetailUbwQueueHandler {", "output": "}"}, {"input": "package org . springblade . cgform . model . param ; import lombok . Data ; import java . io . Serializable ; @ Data public class InvitationCodeParam implements Serializable { private Long activity_id ; private Long blade_user_id ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . config . xml . NacosPropertySourceXmlBeanDefinition ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . io . Resource ; import org . springframework . util . StringUtils ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; public class XmlNacosPropertySourceBuilder extends AbstractNacosPropertySourceBuilder < NacosPropertySourceXmlBeanDefinition > { public static final String BEAN_NAME = \"<STR_LIT>\" ; @ Override protected Map < String , Object > [ ] resolveRuntimeAttributesArray ( NacosPropertySourceXmlBeanDefinition beanDefinition , Properties globalNacosProperties ) { Element element = beanDefinition . getElement ( ) ; Map < String , Object > runtimeAttributes = new HashMap < String , Object > ( <NUM_LIT> ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME , getAttribute ( element , \"<STR_LIT>\" , DEFAULT_GROUP ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AUTO_REFRESHED_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ) ; String type = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , DEFAULT_CONFIG_TYPE_VALUE ) ; try { runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME , ConfigType . valueOf ( type . toUpperCase ( ) ) ) ; runtimeAttributes . put ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME , new Properties ( ) ) ; return new Map [ ] { runtimeAttributes } ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } @ Override protected void initNacosPropertySource ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , Map < String , Object > attributes ) { Element element = beanDefinition . getElement ( ) ; initAttributesMetadata ( nacosPropertySource , element ) ; initOrigin ( nacosPropertySource , beanDefinition . getXmlReaderContext ( ) ) ; initAutoRefreshed ( nacosPropertySource , element ) ; initOrder ( nacosPropertySource , element ) ; } private void initOrigin ( NacosPropertySource nacosPropertySource , XmlReaderContext xmlReaderContext ) { Resource resource = xmlReaderContext . getResource ( ) ; nacosPropertySource . setOrigin ( resource ) ; } private void initAutoRefreshed ( NacosPropertySource nacosPropertySource , Element element ) { boolean autoRefreshed = getAttribute ( element , \"<STR_LIT>\" , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; nacosPropertySource . setAutoRefreshed ( autoRefreshed ) ; } private void initAttributesMetadata ( NacosPropertySource nacosPropertySource , Element element ) { NamedNodeMap elementAttributes = element . getAttributes ( ) ; int length = elementAttributes . getLength ( ) ; } private void initOrder ( NacosPropertySource nacosPropertySource , Element element ) { boolean first = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . FIRST_ATTRIBUTE_NAME , DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ) ; String before = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . BEFORE_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; String after = getAttribute ( element , io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . AFTER_ATTRIBUTE_NAME , DEFAULT_STRING_ATTRIBUTE_VALUE ) ; nacosPropertySource . setFirst ( first ) ; nacosPropertySource . setBefore ( before ) ; nacosPropertySource . setAfter ( after ) ; } private < T > T getAttribute ( Element element , String name , T defaultValue ) { ConversionService conversionService = environment . getConversionService ( ) ; String value = element . getAttribute ( name ) ; String resolvedValue = environment . resolvePlaceholders ( value ) ; T attributeValue = StringUtils . hasText ( resolvedValue ) ? ( T ) conversionService . convert ( resolvedValue , defaultValue . getClass ( ) ) : defaultValue ; return attributeValue ; } @ Override protected NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition ) { return new NacosConfigMetadataEvent ( beanDefinition . getElement ( ) ) ; }", "output": "@ Override protected void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , NacosPropertySourceXmlBeanDefinition beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setXmlResource ( beanDefinition . getXmlReaderContext ( ) . getResource ( ) ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class UserInfoVO { private String basePath ; private String wxId ; private String nickname ; private String version ; private String account ; private String mobile ;", "output": "}"}, {"input": "package com . yf . system . modules . config . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CfgSwitchDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String val ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . util . regex . Pattern ; public class NumericUtil { private static final Pattern NUMERIC_PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; public static boolean isNumeric ( String str ) { if ( TextUtil . isEmpty ( str ) ) { return false ; } return NUMERIC_PATTERN . matcher ( str ) . matches ( ) ; } public static Integer calculateScale ( String format ) { if ( TextUtil . isEmpty ( format ) ) { return null ; } String scaleStr ; int dotIndex = format . indexOf ( \"<STR_LIT>\" ) ; if ( dotIndex < <NUM_LIT> ) { scaleStr = format ; } else if ( dotIndex + <NUM_LIT> >= format . length ( ) ) {", "output": "scaleStr = \"<STR_LIT>\" ; } else { scaleStr = format . substring ( dotIndex + <NUM_LIT> ) ; } return scaleStr . length ( ) ; } public static int countChar ( String value , char targetChar ) { int count = <NUM_LIT> ; if ( value == null ) { return count ; } char [ ] chars = value . toCharArray ( ) ; for ( char cc : chars ) { if ( cc == targetChar ) { count ++ ; } } return count ; } public static String formatNumericInNeed ( String value , Integer scale ) { if ( value == null ) { return null ; } if ( ! value . contains ( \"<STR_LIT>\" ) || ! isNumeric ( value ) ) { return value ; } try { BigDecimal bigDecimal = new BigDecimal ( value ) ; if ( scale == null ) { return bigDecimal . setScale ( <NUM_LIT> , RoundingMode . HALF_UP ) . toPlainString ( ) ; } else { return bigDecimal . setScale ( scale , RoundingMode . HALF_UP ) . toPlainString ( ) ; } } catch ( NumberFormatException e ) { return null ; } } }"}, {"input": "package me . zhengjie . modules . security . config . bean ; import lombok . Data ; @ Data public class LoginCode { private LoginCodeEnum codeType ; private Long expiration = <NUM_LIT> ; private int length = <NUM_LIT> ; private int width = <NUM_LIT> ; private int height = <NUM_LIT> ; private String fontName ; private int fontSize = <NUM_LIT> ; public LoginCodeEnum getCodeType ( ) { return codeType ; }", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class DictProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dictCode ; private String dictTable ; private String dictText ; public String getDictCode ( ) { return dictCode ; } public void setDictCode ( String dictCode ) { this . dictCode = dictCode ; } public String getDictTable ( ) {", "output": "return dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public DictProperty ( ) { } public DictProperty ( String key , String title , String dictTable , String dictCode , String dictText ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictCode = dictCode ; this . dictTable = dictTable ; this . dictText = dictText ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dictCode != null ) { prop . put ( \"<STR_LIT>\" , dictCode ) ; } if ( dictTable != null ) { prop . put ( \"<STR_LIT>\" , dictTable ) ; } if ( dictText != null ) { prop . put ( \"<STR_LIT>\" , dictText ) ; } map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; public class NacosConfigListenerRegisteredEvent extends NacosConfigEvent { private final Listener listener ; private final boolean registered ; public NacosConfigListenerRegisteredEvent ( ConfigService configService , String dataId , String groupId , Listener listener , boolean registered ) { super ( configService , dataId , groupId ) ; this . listener = listener ; this . registered = registered ;", "output": "} public Listener getListener ( ) { return listener ; } public boolean isRegistered ( ) { return registered ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . id ; import java . util . UUID ; import java . util . concurrent . ThreadLocalRandom ; public class IdUtil { public static UUID fastUUID ( ) { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; return new UUID ( random . nextLong ( ) , random . nextLong ( ) ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . form . NoticeForm ; import cn . org . alan . exam . model . vo . NoticeVO ; import cn . org . alan . exam . service . INoticeService ; import cn . org . alan . exam . util . JwtUtil ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . validation . constraints . NotBlank ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class NoticeController { @ Resource private INoticeService noticeService ; @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > addNotice ( @ Validated @ RequestBody NoticeForm noticeForm ) { return noticeService . addNotice ( noticeForm ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > deleteNotice ( @ PathVariable ( \"<STR_LIT>\" ) @ NotBlank String ids ) { return noticeService . deleteNotice ( ids ) ;", "output": "} @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > updateNotice ( @ PathVariable ( \"<STR_LIT>\" ) @ NotBlank String id , @ Validated @ RequestBody NoticeForm noticeForm ) { return noticeService . updateNotice ( id , noticeForm ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < NoticeVO > > getNotice ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String title ) { return noticeService . getNotice ( pageNum , pageSize , title ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < NoticeVO > > getNewNotice ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize ) { return noticeService . getNewNotice ( pageNum , pageSize ) ; } }"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . youlai . system . model . entity . SysMenu ; import com . youlai . system . model . bo . RouteBO ; import org . apache . ibatis . annotations . Mapper ; import java . util . List ; import java . util . Set ; @ Mapper public interface SysMenuMapper extends BaseMapper < SysMenu > { List < RouteBO > listRoutes ( Set < String > roles ) ;", "output": "}"}, {"input": "package org . example . ddduser . application . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; public interface UserMngQueryService {", "output": "Page < UserProfile > profilePage ( UserProfilePageQuery query ) ; }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . TreeSelect ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import com . oddfar . campus . common . domain . entity . SysRoleResourceEntity ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import com . oddfar . campus . framework . mapper . SysResourceMapper ; import com . oddfar . campus . framework . mapper . SysRoleResourceMapper ; import com . oddfar . campus . framework . service . SysResourceService ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . * ; import java . util . stream . Collectors ; @ Service public class SysResourceServiceImpl extends ServiceImpl < SysResourceMapper , SysResourceEntity > implements SysResourceService { @ Resource private SysResourceMapper resourceMapper ; @ Resource private SysRoleResourceMapper roleResourceMapper ; @ Override public PageResult < SysResourceEntity > page ( SysResourceEntity sysResourceEntity ) { return resourceMapper . selectPage ( sysResourceEntity ) ; } @ Override public int insertResource ( SysResourceEntity resource ) { int row = resourceMapper . insert ( resource ) ; return row ; } @ Override public void truncateResource ( ) { resourceMapper . truncateResource ( ) ; }", "output": "@ Override public Set < String > selectResourceCodeByRoleId ( Long roleId ) { return resourceMapper . selectResourceCodeByRoleId ( roleId ) ; } @ Override public List < SysResourceEntity > selectApiResourceList ( Long userId ) { SysResourceEntity resourceEntity = new SysResourceEntity ( ) ; resourceEntity . setRequiredPermissionFlag ( Constants . YES ) ; return selectApiResourceList ( resourceEntity , userId ) ; } @ Override public List < SysRoleAuth > selectSysRoleAuthAll ( ) { return roleResourceMapper . selectList ( ) . stream ( ) . map ( SysRoleAuth :: new ) . collect ( Collectors . toList ( ) ) ; } @ Override public List < SysResourceEntity > selectApiResourceList ( SysResourceEntity resource , Long userId ) { List < SysResourceEntity > resourceList = null ; if ( SysUserEntity . isAdmin ( userId ) ) { resourceList = resourceMapper . selectResourceList ( resource ) ; } else { resource . getParams ( ) . put ( \"<STR_LIT>\" , userId ) ; resourceList = resourceMapper . selectResourceListByUserId ( resource ) ; } return resourceList ; } @ Override public List < Long > selectResourceListByRoleId ( Long roleId ) { return resourceMapper . selectResourceListByRoleId ( roleId ) ; } @ Override public List < TreeSelect > buildResourceTreeSelect ( List < SysResourceEntity > resources ) { List < TreeSelect > treeSelects = new ArrayList < > ( ) ; Map < String , List < SysResourceEntity > > map = resources . stream ( ) . collect ( Collectors . groupingBy ( SysResourceEntity :: getClassName ) ) ; long size = <NUM_LIT> ; for ( String key : map . keySet ( ) ) { String modularName = map . get ( key ) . get ( <NUM_LIT> ) . getModularName ( ) ; TreeSelect treeSelect = new TreeSelect ( ++ size , modularName , map . get ( key ) ) ; treeSelects . add ( treeSelect ) ; } return treeSelects ; } @ Override public void editRoleResource ( Long roleId , Long [ ] resourceIds ) { roleResourceMapper . deleteRoleResourceByRoleId ( roleId ) ; if ( resourceIds . length > <NUM_LIT> ) { List < SysResourceEntity > resourceEntities = resourceMapper . selectBatchIds ( Arrays . asList ( resourceIds ) ) ; insertRoleMenu ( roleId , resourceEntities ) ; } } public int insertRoleMenu ( Long roleId , List < SysResourceEntity > resourceEntities ) { List < SysRoleResourceEntity > rrList = new ArrayList < > ( ) ; for ( SysResourceEntity resourceEntity : resourceEntities ) { SysRoleResourceEntity rr = new SysRoleResourceEntity ( ) ; rr . setRoleId ( roleId ) ; rr . setResourceCode ( resourceEntity . getResourceCode ( ) ) ; rrList . add ( rr ) ; } return roleResourceMapper . saveBatch ( rrList ) ; } }"}, {"input": "package org . example . ddduser . application . dto . result ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserProfile { private Long id ; private String username ; private String nickName ; private String avatar ; private Integer age ; private Gender gender ; private String address ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; public interface IDataObject { Long getId ( ) ; void beforeUpdate ( IDataObject original ) ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . web . service ; import cn . hutool . core . util . StrUtil ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . security . context . PermissionContextHolder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Service ; import org . springframework . util . CollectionUtils ; import org . springframework . web . context . WebApplicationContext ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . HandlerExecutionChain ; import org . springframework . web . servlet . mvc . method . annotation . RequestMappingHandlerMapping ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Method ; import java . util . Set ; @ Service ( \"<STR_LIT>\" ) public class PermissionService { private static final Logger log = LoggerFactory . getLogger ( PermissionService . class ) ; @ Value ( \"<STR_LIT>\" ) private String springApplicationName ; @ Autowired WebApplicationContext applicationContext ; private static final String ALL_PERMISSION = \"<STR_LIT>\" ; private static final String SUPER_ADMIN = \"<STR_LIT>\" ; private static final String ROLE_DELIMETER = \"<STR_LIT>\" ; private static final String PERMISSION_DELIMETER = \"<STR_LIT>\" ; public boolean hasPermi ( String permission ) { if ( StringUtils . isEmpty ( permission ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getPermissions ( ) ) ) { return false ; } PermissionContextHolder . setContext ( permission ) ; return hasPermissions ( loginUser . getPermissions ( ) , permission ) ; } public boolean resourceAuth ( ) { LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) ) { return false ; } HttpServletRequest request = ServletUtils . getRequest ( ) ; RequestMappingHandlerMapping mapping = applicationContext . getBean ( RequestMappingHandlerMapping . class ) ; HandlerExecutionChain handlerChain = null ; try { handlerChain = mapping . getHandler ( request ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } HandlerMethod handler = ( HandlerMethod ) handlerChain . getHandler ( ) ; String resourceCode = getResourceCode ( handler ) ; return hasResources ( loginUser . getResources ( ) , resourceCode ) ; } private String getResourceCode ( HandlerMethod handler ) { Object bean = handler . getBean ( ) ; Class < ? > aClass = bean . getClass ( ) ; Method method = handler . getMethod ( ) ; ApiResource apiResource = method . getDeclaringClass ( ) . getAnnotation ( ApiResource . class ) ; StringBuffer resourceCode = new StringBuffer ( ) ; String appCode = springApplicationName ; if ( apiResource != null ) { if ( StringUtils . isNotEmpty ( apiResource . appCode ( ) ) ) { appCode = apiResource . appCode ( ) ; } } String className = StrUtil . toUnderlineCase ( StringUtils . substringBefore ( aClass . getSimpleName ( ) , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; String methodName = StrUtil . toUnderlineCase ( method . getName ( ) ) ; return resourceCode . append ( appCode ) . append ( \"<STR_LIT>\" ) . append ( className ) . append ( \"<STR_LIT>\" ) . append ( methodName ) . toString ( ) ; } private boolean hasResources ( Set < String > resources , String resource ) { return resources . contains ( ALL_PERMISSION ) || resources . contains ( StringUtils . trim ( resource ) ) ; } public boolean lacksPermi ( String permission ) { return hasPermi ( permission ) != true ; } public boolean hasAnyPermi ( String permissions ) { if ( StringUtils . isEmpty ( permissions ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getPermissions ( ) ) ) { return false ; } PermissionContextHolder . setContext ( permissions ) ; Set < String > authorities = loginUser . getPermissions ( ) ; for ( String permission : permissions . split ( PERMISSION_DELIMETER ) ) { if ( permission != null && hasPermissions ( authorities , permission ) ) { return true ; } } return false ; } public boolean hasRole ( String role ) { if ( StringUtils . isEmpty ( role ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getUser ( ) . getRoles ( ) ) ) { return false ;", "output": "} for ( SysRoleEntity sysRole : loginUser . getUser ( ) . getRoles ( ) ) { String roleKey = sysRole . getRoleKey ( ) ; if ( SUPER_ADMIN . equals ( roleKey ) || roleKey . equals ( StringUtils . trim ( role ) ) ) { return true ; } } return false ; } public boolean lacksRole ( String role ) { return hasRole ( role ) != true ; } public boolean hasAnyRoles ( String roles ) { if ( StringUtils . isEmpty ( roles ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getUser ( ) . getRoles ( ) ) ) { return false ; } for ( String role : roles . split ( ROLE_DELIMETER ) ) { if ( hasRole ( role ) ) { return true ; } } return false ; } private boolean hasPermissions ( Set < String > permissions , String permission ) { return permissions . contains ( ALL_PERMISSION ) || permissions . contains ( StringUtils . trim ( permission ) ) ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . Msg ; import com . xcs . wx . domain . vo . ExportMsgVO ; import com . xcs . wx . domain . vo . MsgVO ; import org . mapstruct . Mapper ; import java . util . List ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface MsgMapping { List < MsgVO > convert ( List < Msg > msgs ) ;", "output": "List < ExportMsgVO > convertToExportMsgVO ( List < MsgVO > msgVOList ) ; }"}, {"input": "package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . MenuMetaVo ; import me . zhengjie . modules . system . domain . vo . MenuVo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . modules . system . mapper . MenuMapper ; import me . zhengjie . modules . system . mapper . RoleMenuMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . service . MenuService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import me . zhengjie . utils . * ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class MenuServiceImpl extends ServiceImpl < MenuMapper , Menu > implements MenuService { private final MenuMapper menuMapper ; private final RoleMenuMapper roleMenuMapper ; private final UserMapper userMapper ; private final RoleService roleService ; private final RedisUtils redisUtils ; private static final String HTTP_PRE = \"<STR_LIT>\" ; private static final String HTTPS_PRE = \"<STR_LIT>\" ; private static final String YES_STR = \"<STR_LIT>\" ; private static final String NO_STR = \"<STR_LIT>\" ; private static final String BAD_REQUEST = \"<STR_LIT>\" ; @ Override public List < Menu > queryAll ( MenuQueryCriteria criteria , Boolean isQuery ) throws Exception { if ( Boolean . TRUE . equals ( isQuery ) ) { criteria . setPidIsNull ( true ) ; List < Field > fields = StringUtils . getAllFields ( criteria . getClass ( ) , new ArrayList < > ( ) ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object val = field . get ( criteria ) ; if ( \"<STR_LIT>\" . equals ( field . getName ( ) ) ) { continue ; } if ( ObjectUtil . isNotNull ( val ) ) { criteria . setPidIsNull ( null ) ; break ; } } } return menuMapper . findAll ( criteria ) ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public Menu findById ( long id ) { return getById ( id ) ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public List < Menu > findByUser ( Long currentUserId ) { List < Role > roles = roleService . findByUsersId ( currentUserId ) ; Set < Long > roleIds = roles . stream ( ) . map ( Role :: getId ) . collect ( Collectors . toSet ( ) ) ; LinkedHashSet < Menu > menus = menuMapper . findByRoleIdsAndTypeNot ( roleIds , <NUM_LIT> ) ; return new ArrayList < > ( menus ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Menu resources ) { if ( menuMapper . findByTitle ( resources . getTitle ( ) ) != null ) { throw new EntityExistException ( Menu . class , \"<STR_LIT>\" , resources . getTitle ( ) ) ; } if ( StringUtils . isNotBlank ( resources . getComponentName ( ) ) ) { if ( menuMapper . findByComponentName ( resources . getComponentName ( ) ) != null ) { throw new EntityExistException ( Menu . class , \"<STR_LIT>\" , resources . getComponentName ( ) ) ; } } if ( Long . valueOf ( <NUM_LIT> ) . equals ( resources . getPid ( ) ) ) { resources . setPid ( null ) ; } if ( resources . getIFrame ( ) ) { if ( ! ( resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTP_PRE ) || resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTPS_PRE ) ) ) { throw new BadRequestException ( BAD_REQUEST ) ; } } save ( resources ) ; resources . setSubCount ( <NUM_LIT> ) ; updateSubCnt ( resources . getPid ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Menu resources ) { if ( resources . getId ( ) . equals ( resources . getPid ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } Menu menu = getById ( resources . getId ( ) ) ; if ( resources . getIFrame ( ) ) { if ( ! ( resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTP_PRE ) || resources . getPath ( ) . toLowerCase ( ) . startsWith ( HTTPS_PRE ) ) ) { throw new BadRequestException ( BAD_REQUEST ) ; } } Menu menu1 = menuMapper . findByTitle ( resources . getTitle ( ) ) ; if ( menu1 != null && ! menu1 . getId ( ) . equals ( menu . getId ( ) ) ) { throw new EntityExistException ( Menu . class , \"<STR_LIT>\" , resources . getTitle ( ) ) ; } if ( resources . getPid ( ) . equals ( <NUM_LIT> ) ) { resources . setPid ( null ) ; } Long oldPid = menu . getPid ( ) ; Long newPid = resources . getPid ( ) ; if ( StringUtils . isNotBlank ( resources . getComponentName ( ) ) ) { menu1 = menuMapper . findByComponentName ( resources . getComponentName ( ) ) ; if ( menu1 != null && ! menu1 . getId ( ) . equals ( menu . getId ( ) ) ) { throw new EntityExistException ( Menu . class , \"<STR_LIT>\" , resources . getComponentName ( ) ) ; } } menu . setTitle ( resources . getTitle ( ) ) ; menu . setComponent ( resources . getComponent ( ) ) ; menu . setPath ( resources . getPath ( ) ) ; menu . setIcon ( resources . getIcon ( ) ) ; menu . setIFrame ( resources . getIFrame ( ) ) ; menu . setPid ( resources . getPid ( ) ) ; menu . setMenuSort ( resources . getMenuSort ( ) ) ; menu . setCache ( resources . getCache ( ) ) ; menu . setHidden ( resources . getHidden ( ) ) ; menu . setComponentName ( resources . getComponentName ( ) ) ; menu . setPermission ( resources . getPermission ( ) ) ; menu . setType ( resources . getType ( ) ) ; saveOrUpdate ( menu ) ; updateSubCnt ( oldPid ) ; updateSubCnt ( newPid ) ; delCaches ( resources . getId ( ) ) ; } @ Override public Set < Menu > getChildMenus ( List < Menu > menuList , Set < Menu > menuSet ) { for ( Menu menu : menuList ) { menuSet . add ( menu ) ; List < Menu > menus = menuMapper . findByPidOrderByMenuSort ( menu . getId ( ) ) ; if ( menus != null && menus . size ( ) != <NUM_LIT> ) { getChildMenus ( menus , menuSet ) ; } } return menuSet ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Menu > menuSet ) { for ( Menu menu : menuSet ) { delCaches ( menu . getId ( ) ) ; roleMenuMapper . deleteByMenuId ( menu . getId ( ) ) ; menuMapper . deleteById ( menu . getId ( ) ) ; updateSubCnt ( menu . getPid ( ) ) ; } } @ Override public List < Menu > getMenus ( Long pid ) { List < Menu > menus ; if ( pid != null && ! pid . equals ( <NUM_LIT> ) ) { menus = menuMapper . findByPidOrderByMenuSort ( pid ) ; } else { menus = menuMapper . findByPidIsNullOrderByMenuSort ( ) ; } return menus ; } @ Override public List < Menu > getSuperior ( Menu menu , List < Menu > menus ) { if ( menu . getPid ( ) == null ) { menus . addAll ( menuMapper . findByPidIsNullOrderByMenuSort ( ) ) ; return menus ; } menus . addAll ( menuMapper . findByPidOrderByMenuSort ( menu . getPid ( ) ) ) ; return getSuperior ( findById ( menu . getPid ( ) ) , menus ) ; } @ Override public List < Menu > buildTree ( List < Menu > menus ) { List < Menu > trees = new ArrayList < > ( ) ; Set < Long > ids = new HashSet < > ( ) ; for ( Menu menu : menus ) { if ( menu . getPid ( ) == null ) { trees . add ( menu ) ; } for ( Menu it : menus ) { if ( menu . getId ( ) . equals ( it . getPid ( ) ) ) { if ( menu . getChildren ( ) == null ) { menu . setChildren ( new ArrayList < > ( ) ) ; } menu . getChildren ( ) . add ( it ) ; ids . add ( it . getId ( ) ) ; } } } if ( trees . size ( ) == <NUM_LIT> ) { trees = menus . stream ( ) . filter ( s -> ! ids . contains ( s . getId ( ) ) ) . collect ( Collectors . toList ( ) ) ; } return trees ;", "output": "} @ Override public List < MenuVo > buildMenus ( List < Menu > menus ) { List < MenuVo > list = new LinkedList < > ( ) ; menus . forEach ( menu -> { if ( menu != null ) { List < Menu > menuList = menu . getChildren ( ) ; MenuVo menuVo = new MenuVo ( ) ; menuVo . setName ( ObjectUtil . isNotEmpty ( menu . getComponentName ( ) ) ? menu . getComponentName ( ) : menu . getTitle ( ) ) ; menuVo . setPath ( menu . getPid ( ) == null ? \"<STR_LIT>\" + menu . getPath ( ) : menu . getPath ( ) ) ; menuVo . setHidden ( menu . getHidden ( ) ) ; if ( ! menu . getIFrame ( ) ) { if ( menu . getPid ( ) == null ) { menuVo . setComponent ( StringUtils . isEmpty ( menu . getComponent ( ) ) ? \"<STR_LIT>\" : menu . getComponent ( ) ) ; } else if ( menu . getType ( ) == <NUM_LIT> ) { menuVo . setComponent ( StringUtils . isEmpty ( menu . getComponent ( ) ) ? \"<STR_LIT>\" : menu . getComponent ( ) ) ; } else if ( StringUtils . isNoneBlank ( menu . getComponent ( ) ) ) { menuVo . setComponent ( menu . getComponent ( ) ) ; } } menuVo . setMeta ( new MenuMetaVo ( menu . getTitle ( ) , menu . getIcon ( ) , ! menu . getCache ( ) ) ) ; if ( CollectionUtil . isNotEmpty ( menuList ) ) { menuVo . setAlwaysShow ( true ) ; menuVo . setRedirect ( \"<STR_LIT>\" ) ; menuVo . setChildren ( buildMenus ( menuList ) ) ; } else if ( menu . getPid ( ) == null ) { MenuVo menuVo1 = new MenuVo ( ) ; menuVo1 . setMeta ( menuVo . getMeta ( ) ) ; if ( ! menu . getIFrame ( ) ) { menuVo1 . setPath ( \"<STR_LIT>\" ) ; menuVo1 . setName ( menuVo . getName ( ) ) ; menuVo1 . setComponent ( menuVo . getComponent ( ) ) ; } else { menuVo1 . setPath ( menu . getPath ( ) ) ; } menuVo . setName ( null ) ; menuVo . setMeta ( null ) ; menuVo . setComponent ( \"<STR_LIT>\" ) ; List < MenuVo > list1 = new ArrayList < > ( ) ; list1 . add ( menuVo1 ) ; menuVo . setChildren ( list1 ) ; } list . add ( menuVo ) ; } } ) ; return list ; } @ Override public void download ( List < Menu > menus , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Menu menu : menus ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , menu . getTitle ( ) ) ; map . put ( \"<STR_LIT>\" , menu . getType ( ) == null ? \"<STR_LIT>\" : menu . getType ( ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , menu . getPermission ( ) ) ; map . put ( \"<STR_LIT>\" , menu . getIFrame ( ) ? YES_STR : NO_STR ) ; map . put ( \"<STR_LIT>\" , menu . getHidden ( ) ? NO_STR : YES_STR ) ; map . put ( \"<STR_LIT>\" , menu . getCache ( ) ? YES_STR : NO_STR ) ; map . put ( \"<STR_LIT>\" , menu . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } private void updateSubCnt ( Long menuId ) { if ( menuId != null ) { int count = menuMapper . countByPid ( menuId ) ; menuMapper . updateSubCntById ( count , menuId ) ; } } public void delCaches ( Long id ) { List < User > users = userMapper . findByMenuId ( id ) ; redisUtils . del ( CacheKey . MENU_ID + id ) ; redisUtils . delByKeys ( CacheKey . MENU_USER , users . stream ( ) . map ( User :: getId ) . collect ( Collectors . toSet ( ) ) ) ; List < Role > roles = roleService . findByMenuId ( id ) ; redisUtils . delByKeys ( CacheKey . ROLE_ID , roles . stream ( ) . map ( Role :: getId ) . collect ( Collectors . toSet ( ) ) ) ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . * ; import java . math . BigDecimal ; @ Data public class AdvertiseParam { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer direction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank private String countryId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal coinCou ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer rateType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private String rate ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String supportMethodList ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal minTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ DecimalMin ( value = \"<STR_LIT>\" ) private BigDecimal maxTransaction ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer isDeleted ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String remarks ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . service ; import me . zhengjie . modules . system . domain . User ; import java . util . List ; public interface DataService { List < Long > getDeptIds ( User user ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import jakarta . validation . constraints . * ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class Option implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer quId ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Max ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) private Integer isRight ; private String image ; @ NotBlank ( message = \"<STR_LIT>\" ) private String content ; private Integer sort ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) { this . isDeleted = isDeleted ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getQuId ( ) { return quId ; } public void setQuId ( Integer quId ) { this . quId = quId ; } public Integer getIsRight ( ) { return isRight ; } public void setIsRight ( Integer isRight ) { this . isRight = isRight ; } public String getImage ( ) { return image ; } public void setImage ( String image ) { this . image = image ;", "output": "} public String getContent ( ) { return content ; } public void setContent ( String content ) { this . content = content ; } public Integer getSort ( ) { return sort ; } public void setSort ( Integer sort ) { this . sort = sort ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + quId + \"<STR_LIT>\" + isRight + \"<STR_LIT>\" + image + '<STR_LIT>' + \"<STR_LIT>\" + content + '<STR_LIT>' + \"<STR_LIT>\" + sort + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package com . yf . base . utils . http ; import org . apache . commons . lang3 . StringUtils ; import org . apache . http . HttpEntity ; import org . apache . http . NameValuePair ; import org . apache . http . client . entity . UrlEncodedFormEntity ; import org . apache . http . client . methods . CloseableHttpResponse ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . client . methods . HttpPost ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . message . BasicNameValuePair ; import org . apache . http . util . EntityUtils ; import java . io . UnsupportedEncodingException ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLEncoder ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class HttpClientUtil { private static final String PARAM_STARTER = \"<STR_LIT>\" ; private static final String PARAM_CONCAT = \"<STR_LIT>\" ; private static final String ENCODING = \"<STR_LIT>\" ; public static String postRestJson ( String url , Map < String , String > params ) { CloseableHttpClient client = HttpClients . createDefault ( ) ; try { HttpPost httpPost = new HttpPost ( url ) ; List < NameValuePair > list = new ArrayList < > ( ) ; for ( String key : params . keySet ( ) ) { BasicNameValuePair vp = new BasicNameValuePair ( key , params . get ( key ) ) ; list . add ( vp ) ; } UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity ( list ) ; httpPost . setEntity ( formEntity ) ; CloseableHttpResponse response = client . execute ( httpPost ) ; HttpEntity entity = response . getEntity ( ) ; String str = EntityUtils . toString ( entity , \"<STR_LIT>\" ) ; response . close ( ) ; return str ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public static String getJson ( String url , Map < String , String > headers , Map < String , String > params ) { CloseableHttpClient client = HttpClients . createDefault ( ) ; try { String fullUrl = buildParamsUrl ( url , params ) ; HttpGet httpGet = new HttpGet ( fullUrl ) ; if ( headers != null && ! headers . isEmpty ( ) ) { for ( String key : headers . keySet ( ) ) { httpGet . addHeader ( key , headers . get ( key ) ) ; } } CloseableHttpResponse response = client . execute ( httpGet ) ; HttpEntity entity = response . getEntity ( ) ; String body = EntityUtils . toString ( entity , ENCODING ) ; return body ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public static String buildParamsUrl ( String url , Map < String , String > params ) { if ( params != null && ! params . isEmpty ( ) ) { StringBuffer sb = new StringBuffer ( url ) ; if ( url . indexOf ( PARAM_STARTER ) == - <NUM_LIT> ) { sb . append ( PARAM_STARTER ) ; } for ( String key : params . keySet ( ) ) { if ( ! sb . toString ( ) . endsWith ( PARAM_STARTER ) ) { sb . append ( PARAM_CONCAT ) ; } String value = params . get ( key ) ; if ( StringUtils . isBlank ( value ) ) { value = \"<STR_LIT>\" ; } else { try { value = URLEncoder . encode ( value , ENCODING ) ; }", "output": "catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; continue ; } } sb . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value ) ; } return sb . toString ( ) ; } return url ; } public static boolean exist ( String input , String type ) { try { URL url = new URL ( input ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; int code = conn . getResponseCode ( ) ; System . out . println ( \"<STR_LIT>\" + input + \"<STR_LIT>\" + code ) ; if ( code == <NUM_LIT> ) { String contentType = conn . getContentType ( ) ; System . out . println ( \"<STR_LIT>\" + contentType ) ; return contentType . contains ( type ) ; } return code == <NUM_LIT> ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } public static void main ( String [ ] args ) { boolean sss = exist ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; System . out . println ( sss ) ; } }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . Feeds ; public interface FeedsMapper extends BaseMapper < Feeds > {", "output": "}"}, {"input": "package ginyi . common . utils ; import cn . hutool . extra . mail . MailUtil ; public class EmailUtils { public static boolean sendToOne ( String to , String subject , String message , Boolean isHtml ) { String result = MailUtil . send ( to , subject , message , isHtml ) ; return result != null ; }", "output": "}"}, {"input": "package com . yf . ability . task . service ; public interface JobService { String TASK_DATA = \"<STR_LIT>\" ; void addCronJob ( Class jobClass , String jobName , String jobGroup , String cron , String data ) ;", "output": "void addCronJob ( Class jobClass , String jobName , String jobGroup , String data ) ; void pauseJob ( String jobName , String jobGroup ) ; void resumeJob ( String triggerName , String triggerGroup ) ; void deleteJob ( String jobName , String jobGroup ) ; }"}, {"input": "package org . example . infrastructure . repository . example ; import org . example . domain . example . valueobject . ExampleAddress ; import org . example . domain . example . repository . ExampleLocationRepository ; import org . springframework . stereotype . Component ; @ Component public class ExampleLocationRepositoryImpl implements ExampleLocationRepository { @ Override public ExampleAddress find ( Double longitude , Double latitude ) { ExampleAddress address = ExampleAddress . builder ( ) . country ( \"<STR_LIT>\" ) . province ( \"<STR_LIT>\" ) . city ( \"<STR_LIT>\" ) . county ( \"<STR_LIT>\" ) . detail ( String . format ( \"<STR_LIT>\" , longitude , latitude ) ) . build ( ) ; return address ; }", "output": "}"}, {"input": "package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . PATCH ) public @ interface AnonymousPatchMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default \"<STR_LIT>\" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default {", "output": "} ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; }"}, {"input": "package com . yf . base . utils . download ; import com . yf . base . utils . download . temp . DownloadTemp ; import com . yf . base . utils . download . temp . DownloadTempThread ; import com . yf . base . utils . download . thread . DownloadThread ; import com . yf . base . utils . file . MD5Util ; import com . yf . base . utils . file . TextFileUtils ; import com . yf . base . utils . jackson . JsonHelper ; import org . apache . commons . lang3 . concurrent . BasicThreadFactory ; import org . apache . http . client . methods . CloseableHttpResponse ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClients ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; public class Downloader { private static final int RESPONSE_OK = <NUM_LIT> ; private static final String TEMP_FILE_SUFFIX = \"<STR_LIT>\" ; private int threadCount = <NUM_LIT> ; private Logger logger = LoggerFactory . getLogger ( \"<STR_LIT>\" ) ; private long fileLength ; private long downloaded ; private String url ; private String dist ; private DownloadThread [ ] threads = new DownloadThread [ threadCount ] ; private ScheduledExecutorService executorService ; public Downloader ( String url , String dist ) { this . url = url ; this . dist = dist ; } public void download ( ) throws Exception { if ( checkNeedContinue ( ) ) { this . continueDownload ( ) ; } else { this . newDownload ( ) ; } executorService = new ScheduledThreadPoolExecutor ( <NUM_LIT> , new BasicThreadFactory . Builder ( ) . namingPattern ( \"<STR_LIT>\" ) . daemon ( true ) . build ( ) ) ; executorService . scheduleAtFixedRate ( ( ) -> saveProcess ( ) , <NUM_LIT> , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } private void newDownload ( ) throws Exception { CloseableHttpClient client = HttpClients . createDefault ( ) ; HttpGet get = new HttpGet ( url ) ; CloseableHttpResponse response = client . execute ( get ) ; int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode != RESPONSE_OK ) { throw new Exception ( \"<STR_LIT>\" + statusCode ) ; } fileLength = response . getEntity ( ) . getContentLength ( ) ; long pie = fileLength / threadCount ; long left = fileLength % threadCount ; for ( int i = <NUM_LIT> ; i < threadCount ; i ++ ) { long start = i * pie ; long end = ( i + <NUM_LIT> ) * pie ; if ( ( i + <NUM_LIT> ) == threadCount ) { end += left ; } if ( i > <NUM_LIT> ) { start += <NUM_LIT> ; } logger . info ( \"<STR_LIT>\" , start , end ) ; String threadName = MD5Util . MD5 ( url ) + \"<STR_LIT>\" + i ; DownloadThread thread = new DownloadThread ( url , dist , start , end ) ; thread . setName ( threadName ) ; threads [ i ] = thread ; threads [ i ] . start ( ) ; } } public boolean isDownloading ( ) { for ( DownloadThread thread : threads ) { if ( thread . isAlive ( ) ) { return true ; } } return false ; } public boolean checkNeedContinue ( ) { File tempFile = new File ( dist + TEMP_FILE_SUFFIX ) ; return tempFile . exists ( ) ; } private void continueDownload ( ) { String json = TextFileUtils . readText ( dist + TEMP_FILE_SUFFIX ) ; DownloadTemp info = JsonHelper . parseObject ( json , DownloadTemp . class ) ; this . fileLength = info . getFileLength ( ) ; if ( info == null || info . getThreads ( ) != null || info . getThreads ( ) . size ( ) == <NUM_LIT> ) { return ; } this . threadCount = info . getThreads ( ) . size ( ) ; this . threads = new DownloadThread [ this . threadCount ] ; int i = <NUM_LIT> ; for ( DownloadTempThread t : info . getThreads ( ) ) { DownloadThread thread = new DownloadThread ( ) ; thread . fromTemp ( this . url , this . dist , t ) ; threads [ i ] = thread ; threads [ i ] . start ( ) ; i ++ ; } } public void saveProcess ( ) { List < DownloadTempThread > records = new ArrayList < > ( ) ; long downloaded = <NUM_LIT> ; for ( DownloadThread thread : this . threads ) { records . add ( thread . toTemp ( ) ) ;", "output": "downloaded += thread . getLoaded ( ) ; } DownloadTemp info = new DownloadTemp ( ) ; info . setFileLength ( fileLength ) ; info . setUrl ( url ) ; info . setThreads ( records ) ; TextFileUtils . write ( dist + TEMP_FILE_SUFFIX , JsonHelper . toJson ( info ) ) ; this . downloaded = downloaded ; } public long getFileLength ( ) { return fileLength ; } public long getDownloaded ( ) { return downloaded ; } public static void main ( String [ ] args ) throws Exception { String url = \"<STR_LIT>\" ; String dist = \"<STR_LIT>\" ; Downloader downloader = new Downloader ( url , dist ) ; downloader . download ( ) ; while ( downloader . isDownloading ( ) ) { Thread . sleep ( <NUM_LIT> ) ; float percent = downloader . getDownloaded ( ) * <NUM_LIT> / downloader . getFileLength ( ) ; System . out . println ( \"<STR_LIT>\" + percent + \"<STR_LIT>\" ) ; } String md5 = MD5Util . getFileMD5 ( new File ( dist ) ) ; System . out . println ( \"<STR_LIT>\" + md5 ) ; String example = \"<STR_LIT>\" ; String exMD5 = MD5Util . getFileMD5 ( new File ( example ) ) ; System . out . println ( \"<STR_LIT>\" + exMD5 ) ; } }"}, {"input": "package com . yf . system . modules . menu . dto . response ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . apache . commons . lang3 . StringUtils ; import java . io . Serializable ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class RouteRespDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonIgnore @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ JsonIgnore @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer menuType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String component ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String redirect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaActiveMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean metaNoCache ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean hidden ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < RouteRespDTO > children ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Map < String , Object > meta ; public Map < String , Object > getMeta ( ) { Map < String , Object > meta = new HashMap < > ( <NUM_LIT> ) ; if ( ! StringUtils . isBlank ( this . getMetaTitle ( ) ) ) { meta . put ( \"<STR_LIT>\" , this . getMetaTitle ( ) ) ; } if ( ! StringUtils . isBlank ( this . getMetaIcon ( ) ) ) { meta . put ( \"<STR_LIT>\" , this . getMetaIcon ( ) ) ; } if ( ( hidden == null || ! hidden ) && menuType . equals ( <NUM_LIT> ) ) {", "output": "meta . put ( \"<STR_LIT>\" , true ) ; } return meta ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class RedisData { private LocalDateTime expireTime ; private Object data ;", "output": "}"}, {"input": "package com . yf . system . modules . role . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . yf . ability . shiro . MyShiroRealm ; import com . yf . base . utils . CacheKey ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . system . modules . role . entity . SysRoleMenu ; import com . yf . system . modules . role . mapper . SysRoleMenuMapper ; import com . yf . system . modules . role . service . SysRoleMenuService ; import com . yf . system . modules . role . service . SysRoleService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . List ; @ Service public class SysRoleMenuServiceImpl extends ServiceImpl < SysRoleMenuMapper , SysRoleMenu > implements SysRoleMenuService { @ Autowired private MyShiroRealm myShiroRealm ; @ Autowired private SysRoleService roleService ; private static final String [ ] DASH_MENUS = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Override public List < String > findRoleMenus ( String roleId ) { QueryWrapper < SysRoleMenu > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysRoleMenu :: getRoleId , roleId ) ; List < SysRoleMenu > list = this . list ( wrapper ) ; List < String > ids = new ArrayList < > ( ) ; if ( ! CollectionUtils . isEmpty ( list ) ) { for ( SysRoleMenu item : list ) { ids . add ( item . getMenuId ( ) ) ; } }", "output": "return ids ; } @ CacheEvict ( value = CacheKey . MENU , allEntries = true ) @ Transactional ( rollbackFor = Exception . class ) @ Override public void saveRoleIds ( String roleId , List < String > ids ) { SysRole role = roleService . getById ( roleId ) ; QueryWrapper < SysRoleMenu > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysRoleMenu :: getRoleId , roleId ) ; this . remove ( wrapper ) ; if ( ! CollectionUtils . isEmpty ( ids ) ) { List < SysRoleMenu > list = new ArrayList < > ( ) ; for ( String id : ids ) { SysRoleMenu item = new SysRoleMenu ( ) ; item . setMenuId ( id ) ; item . setRoleId ( roleId ) ; list . add ( item ) ; } this . saveBatch ( list ) ; } myShiroRealm . getAuthorizationCache ( ) . clear ( ) ; } }"}, {"input": "package cn . org . alan . exam . util ; import cn . hutool . extra . spring . SpringUtil ; import cn . org . alan . exam . model . entity . User ; import com . auth0 . jwt . JWT ; import com . auth0 . jwt . algorithms . Algorithm ; import com . auth0 . jwt . exceptions . JWTVerificationException ; import com . auth0 . jwt . interfaces . Claim ; import com . auth0 . jwt . interfaces . DecodedJWT ; import com . auth0 . jwt . interfaces . JWTVerifier ; import com . fasterxml . jackson . databind . ObjectMapper ; import jakarta . annotation . Resource ; import jakarta . servlet . http . HttpServletRequest ; import lombok . SneakyThrows ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . ValueOperations ; import org . springframework . stereotype . Component ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ Component @ Slf4j public class JwtUtil { @ Resource private ObjectMapper objectMapper ; @ Value ( \"<STR_LIT>\" ) private String secret ; public String createJwt ( String userInfo , List < String > authList ) { Date issDate = new Date ( ) ; Date expireDate = new Date ( issDate . getTime ( ) + <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ; Map < String , Object > headerClaims = new HashMap < > ( ) ; headerClaims . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; headerClaims . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return JWT . create ( ) . withHeader ( headerClaims ) . withIssuer ( \"<STR_LIT>\" ) . withIssuedAt ( issDate ) . withExpiresAt ( expireDate ) . withClaim ( \"<STR_LIT>\" , userInfo ) . withClaim ( \"<STR_LIT>\" , authList ) . sign ( Algorithm . HMAC256 ( secret ) ) ; } public boolean verifyToken ( String token ) { JWTVerifier verifier = JWT . require ( Algorithm . HMAC256 ( secret ) ) . build ( ) ; try { verifier . verify ( token ) ; return true ; } catch ( JWTVerificationException e ) { log . error ( \"<STR_LIT>\" ) ; return false ; } } public String getUser ( String token ) { JWTVerifier verifier = JWT . require ( Algorithm . HMAC256 ( secret ) ) . build ( ) ; try { DecodedJWT jwt = verifier . verify ( token ) ; return jwt . getClaim ( \"<STR_LIT>\" ) . asString ( ) ; } catch ( JWTVerificationException e ) { log . error ( \"<STR_LIT>\" ) ; return null ; } } public List < String > getAuthList ( String token ) { JWTVerifier verifier = JWT . require ( Algorithm . HMAC256 ( secret ) ) . build ( ) ; try { DecodedJWT jwt = verifier . verify ( token ) ; return jwt . getClaim ( \"<STR_LIT>\" ) . asList ( String . class ) ; } catch ( JWTVerificationException e ) { log . error ( \"<STR_LIT>\" ) ; return null ;", "output": "} } }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . springframework . jdbc . support . rowset . SqlRowSet ; import org . springframework . stereotype . Component ; import cn . hutool . core . exceptions . ExceptionUtil ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import java . util . HashMap ; import java . util . Map ; @ Component public class SqlRowSetExtension implements FunctionExtension { public static Map < String , String [ ] > tableMetaMap = new HashMap < > ( ) ; @ Override public Class < ? > support ( ) { return SqlRowSet . class ; } @ Example ( \"<STR_LIT>\" ) public static Map < String , Object > nextToMap ( SqlRowSet sqlRowSet ) { try { if ( ! sqlRowSet . next ( ) ) { return null ; } String [ ] columnNames = sqlRowSet . getMetaData ( ) . getColumnNames ( ) ; Map < String , Object > result = new HashMap < > ( ) ; for ( String columnName : columnNames ) {", "output": "result . put ( columnName , sqlRowSet . getObject ( columnName ) ) ; } return result ; } catch ( Exception e ) { ExceptionUtil . wrapAndThrow ( e ) ; } return null ; } }"}, {"input": "package com . yf . ability . upload . factory ; import com . yf . ability . upload . service . UploadService ; import com . yf . base . utils . SpringUtils ; import com . yf . system . modules . plugin . service . PluginDataService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UploadFactory { private static final String GROUP_ID = \"<STR_LIT>\" ; @ Autowired private PluginDataService pluginDataService ; public UploadService getService ( ) { String clazz = pluginDataService . findServiceClazz ( GROUP_ID ) ; System . out . println ( \"<STR_LIT>\" + clazz ) ; try {", "output": "return ( UploadService ) SpringUtils . getBean ( Class . forName ( clazz ) ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } } }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . LoginUser ; import javax . servlet . http . HttpServletRequest ; public interface ITokenService { public String createToken ( LoginUser loginUser ) ; public LoginUser getLoginUser ( HttpServletRequest request ) ; public void delLoginUser ( String token ) ; public void verifyToken ( LoginUser loginUser ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Set ; @ Mapper public interface DeptMapper extends BaseMapper < Dept > { List < Dept > findAll ( @ Param ( \"<STR_LIT>\" ) DeptQueryCriteria criteria ) ; List < Dept > findByPid ( @ Param ( \"<STR_LIT>\" ) Long pid ) ;", "output": "List < Dept > findByPidIsNull ( ) ; Set < Dept > findByRoleId ( @ Param ( \"<STR_LIT>\" ) Long roleId ) ; @ Select ( \"<STR_LIT>\" ) int countByPid ( @ Param ( \"<STR_LIT>\" ) Long pid ) ; @ Select ( \"<STR_LIT>\" ) void updateSubCntById ( @ Param ( \"<STR_LIT>\" ) Integer count , @ Param ( \"<STR_LIT>\" ) Long id ) ; }"}, {"input": "package com . xcs . wx . domain . dto ; import lombok . Data ; @ Data public class PageDTO { private Long current ; private Long pageSize ;", "output": "}"}, {"input": "package org . springblade . plugin . message . model ; import lombok . Data ; @ Data public class IndexHqModel { private String symbol ; private String bzmc ; private String bzicon ; private String jg ; private String zdf ; private String cjl ; private String cje ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import org . apache . commons . configuration . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class ColUtil { private static final Logger log = LoggerFactory . getLogger ( ColUtil . class ) ; static String cloToJava ( String type ) { Configuration config = getConfig ( ) ; assert config != null ; return config . getString ( type , \"<STR_LIT>\" ) ; } public static PropertiesConfiguration getConfig ( ) {", "output": "try { return new PropertiesConfiguration ( \"<STR_LIT>\" ) ; } catch ( ConfigurationException e ) { log . error ( e . getMessage ( ) , e ) ; } return null ; } }"}, {"input": "package org . springblade . config . util ; import cn . hutool . core . io . FileUtil ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . net . URLDecoder ; import java . util . Iterator ; import java . util . List ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtil { public static File compressFiles ( List < String > files , String var1 ) throws RuntimeException { File var2 = FileUtil . touch ( var1 ) ; if ( var2 == null ) { return null ; } else if ( ! var2 . getName ( ) . endsWith ( \"<STR_LIT>\" ) ) { return null ; } else { ZipOutputStream var3 = null ; try { FileOutputStream var4 = new FileOutputStream ( var2 ) ; var3 = new ZipOutputStream ( var4 ) ; Iterator < String > var5 = files . iterator ( ) ; while ( true ) { File var7 ; do { do { if ( ! var5 . hasNext ( ) ) { if ( var3 != null ) { try { var3 . close ( ) ; } catch ( IOException var12 ) { System . out . println ( \"<STR_LIT>\" + var12 ) ; } } var4 . close ( ) ; return var2 ; } String var6 = ( String ) var5 . next ( ) ; var6 = URLDecoder . decode ( var6 , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "var7 = new File ( var6 ) ; } while ( var7 == null ) ; } while ( ! var7 . exists ( ) ) ; byte [ ] var8 = new byte [ <NUM_LIT> ] ; String var9 = null ; if ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } else { var9 = var7 . getAbsolutePath ( ) . substring ( var7 . getAbsolutePath ( ) . indexOf ( \"<STR_LIT>\" ) - <NUM_LIT> ) ; } var3 . putNextEntry ( new ZipEntry ( var9 ) ) ; FileInputStream var11 = new FileInputStream ( var7 ) ; int var10 ; while ( ( var10 = var11 . read ( var8 ) ) != - <NUM_LIT> ) { var3 . write ( var8 , <NUM_LIT> , var10 ) ; } var11 . close ( ) ; var3 . closeEntry ( ) ; } } catch ( Exception var13 ) { throw new RuntimeException ( \"<STR_LIT>\" , var13 ) ; } } } }"}, {"input": "package top . kangert . kspider . service . impl ; import top . kangert . kspider . config . SpiderConfig ; import top . kangert . kspider . dao . SpiderTaskRepository ; import top . kangert . kspider . domain . SpiderTask ; import top . kangert . kspider . enums . TaskStateEnum ; import top . kangert . kspider . exception . BaseException ; import top . kangert . kspider . exception . ExceptionCodes ; import top . kangert . kspider . job . SpiderJobManager ; import top . kangert . kspider . service . BaseService ; import top . kangert . kspider . service . SpiderTaskService ; import top . kangert . kspider . util . PageInfo ; import org . quartz . CronScheduleBuilder ; import org . quartz . CronTrigger ; import org . quartz . TriggerBuilder ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Page ; import org . springframework . data . domain . Pageable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . PlatformTransactionManager ; import org . springframework . transaction . TransactionStatus ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . transaction . support . TransactionCallbackWithoutResult ; import org . springframework . transaction . support . TransactionTemplate ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . io . FileUtil ; import cn . hutool . core . lang . TypeReference ; import cn . hutool . core . util . StrUtil ; import cn . hutool . core . util . ZipUtil ; import cn . hutool . json . JSONUtil ; import lombok . extern . slf4j . Slf4j ; import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . File ; import java . io . IOException ; import java . net . URLEncoder ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . Optional ; import javax . annotation . PostConstruct ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletResponse ; @ Service @ Slf4j public class SpiderTaskServiceImpl extends BaseService implements SpiderTaskService { @ Resource private SpiderTaskRepository spiderTaskRepository ; @ Resource private SpiderJobManager spiderJobManager ; @ Autowired @ SuppressWarnings ( \"<STR_LIT>\" ) private PlatformTransactionManager txManager ; @ Autowired private SpiderConfig spiderConfig ; @ PostConstruct public void initializeJobs ( ) { TransactionTemplate tmpl = new TransactionTemplate ( txManager ) ; tmpl . execute ( new TransactionCallbackWithoutResult ( ) { @ Override protected void doInTransactionWithoutResult ( TransactionStatus status ) { clearNextExecuteTime ( ) ; List < SpiderTask > tasks = findByJobEnabled ( Boolean . TRUE ) ; if ( tasks != null && ! tasks . isEmpty ( ) ) { for ( SpiderTask task : tasks ) { if ( StrUtil . isNotBlank ( task . getCron ( ) ) ) { Date nextTime = spiderJobManager . addJob ( task ) ; log . info ( \"<STR_LIT>\" , task . getTaskName ( ) , DateUtil . format ( nextTime , \"<STR_LIT>\" ) ) ; if ( nextTime != null ) { task . setNextExecuteTime ( nextTime ) ; updateNextExecuteTime ( task ) ; } } } } } } ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public SpiderTask add ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; Map < String , Object > matedata = JSONUtil . toBean ( ( String ) params . get ( \"<STR_LIT>\" ) , new TypeReference < Map < String , Object > > ( ) { } , false ) ; if ( ! matedata . containsKey ( \"<STR_LIT>\" ) ) { checkParams ( matedata , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; } else { checkParams ( matedata , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; } SpiderTask spiderTask = transformEntity ( params , SpiderTask . class ) ; if ( spiderTask . getFlowId ( ) != null ) { if ( spiderTask . getJobEnabled ( ) && StrUtil . isNotBlank ( spiderTask . getCron ( ) ) ) { CronTrigger trigger = TriggerBuilder . newTrigger ( ) . withSchedule ( CronScheduleBuilder . cronSchedule ( spiderTask . getCron ( ) ) ) . build ( ) ; spiderTask . setNextExecuteTime ( trigger . getFireTimeAfter ( null ) ) ; if ( spiderJobManager . removeJob ( spiderTask . getFlowId ( ) ) ) { spiderJobManager . addJob ( spiderTask ) ; } } } return spiderTaskRepository . save ( spiderTask ) ; } @ Override public SpiderTask queryItem ( Long taskId ) { Optional < SpiderTask > optional = spiderTaskRepository . findById ( taskId ) ; return optional . get ( ) ; } @ Override public PageInfo < SpiderTask > queryItems ( Map < String , Object > params ) { Pageable pageable = processPage ( params ) ; Page < SpiderTask > spiderTaskList = spiderTaskRepository . findAll ( multipleConditionsBuilder ( params ) , pageable ) ; return new PageInfo < SpiderTask > ( spiderTaskList ) ; } @ Override public Integer getRunningCountByFlowId ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long flowId = ( Long ) params . get ( \"<STR_LIT>\" ) ; return spiderTaskRepository . countByFlowIdAndupdateTimeIsNull ( flowId ) ; } @ Override public Long getMaxTaskIdByFlowId ( Long flowId ) { return spiderTaskRepository . findTaskIdByFlowIdOrderByupdateTimeDesc ( flowId ) . stream ( ) . findFirst ( ) . orElse ( null ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void deleteItem ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long taskId = ( Long ) params . get ( \"<STR_LIT>\" ) ; if ( spiderJobManager . removeJob ( taskId ) ) { spiderTaskRepository . deleteById ( taskId ) ; } } @ Override public void edit ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long taskId = Convert . toLong ( params . get ( \"<STR_LIT>\" ) ) ; if ( params . containsKey ( \"<STR_LIT>\" ) ) { Map < String , Object > matedata = JSONUtil . toBean ( ( String ) params . get ( \"<STR_LIT>\" ) , new TypeReference < Map < String , Object > > ( ) { } , false ) ; if ( ! matedata . containsKey ( \"<STR_LIT>\" ) ) { checkParams ( matedata , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; } else { checkParams ( matedata , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; } } SpiderTask spiderTask = queryItem ( taskId ) ; if ( spiderTask == null ) { throw new BaseException ( ExceptionCodes . DB_DATA_WRONG ) ; } copyProperties ( params , spiderTask ) ; if ( StrUtil . isNotBlank ( spiderTask . getCron ( ) ) && spiderTask . getJobEnabled ( ) ) { CronTrigger trigger = TriggerBuilder . newTrigger ( ) . withSchedule ( CronScheduleBuilder . cronSchedule ( spiderTask . getCron ( ) ) ) . build ( ) ; spiderTask . setNextExecuteTime ( trigger . getFireTimeAfter ( null ) ) ; if ( spiderJobManager . removeJob ( spiderTask . getFlowId ( ) ) ) { spiderJobManager . addJob ( spiderTask ) ; } } spiderTaskRepository . save ( spiderTask ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void executeCountIncrement ( Long id , Date lastExecuteTime , Date nextExecuteTime ) { if ( nextExecuteTime == null ) { spiderTaskRepository . executeCountIncrement ( lastExecuteTime , id ) ; } else { spiderTaskRepository . executeCountIncrementAndExecuteNextTime ( lastExecuteTime , nextExecuteTime , id ) ; } } @ Override public List < SpiderTask > findByJobEnabled ( Boolean jobEnabled ) { return spiderTaskRepository . findByJobEnabled ( jobEnabled ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateNextExecuteTime ( SpiderTask task ) { spiderTaskRepository . updateNextExecuteTime ( task . getNextExecuteTime ( ) , task . getFlowId ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateCronAndNextExecuteTime ( Long taskId , String cron ) { CronTrigger trigger = TriggerBuilder . newTrigger ( ) . withSchedule ( CronScheduleBuilder . cronSchedule ( cron ) ) . build ( ) ; if ( spiderJobManager . removeJob ( taskId ) ) { spiderTaskRepository . updateCronAndNextExecuteTime ( taskId , cron , trigger . getFireTimeAfter ( null ) ) ; SpiderTask task = queryItem ( taskId ) ; if ( task . getJobEnabled ( ) ) { spiderJobManager . addJob ( task ) ; } else { spiderTaskRepository . updateCronAndNextExecuteTime ( taskId , cron , null ) ; } } else { spiderTaskRepository . updateCronAndNextExecuteTime ( taskId , cron , null ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void clearNextExecuteTime ( ) { spiderTaskRepository . clearNextExecuteTime ( ) ; } @ Override public void run ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long taskId = Convert . toLong ( params . get ( \"<STR_LIT>\" ) ) ; SpiderTask spiderTask = spiderTaskRepository . findById ( taskId ) . get ( ) ; if ( spiderTask . getRunState ( ) == TaskStateEnum . TASK_RUNNING . getTypeCode ( ) ) { throw new BaseException ( ExceptionCodes . CURRENT_TASK_RUN ) ; } if ( spiderTask . getJobEnabled ( ) ) { scheduleStart ( taskId ) ; } spiderJobManager . run ( taskId ) ; } @ Override @ Transactional public void stop ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long taskId = Convert . toLong ( params . get ( \"<STR_LIT>\" ) ) ; spiderTaskRepository . updateJobEnabled ( taskId , Boolean . FALSE ) ; spiderTaskRepository . updateNextExecuteTime ( null , taskId ) ; spiderJobManager . removeJob ( taskId ) ; } private void scheduleStart ( Long taskId ) { if ( spiderJobManager . removeJob ( taskId ) ) { spiderTaskRepository . updateJobEnabled ( taskId , Boolean . TRUE ) ; SpiderTask spiderTask = queryItem ( taskId ) ; if ( spiderTask != null ) { Date nextExecuteTime = spiderJobManager . addJob ( spiderTask ) ; if ( nextExecuteTime != null ) { spiderTask . setNextExecuteTime ( nextExecuteTime ) ; spiderTaskRepository . updateNextExecuteTime ( spiderTask . getNextExecuteTime ( ) , spiderTask . getFlowId ( ) ) ; } } } } @ Override public void download ( Map < String , Object > params , HttpServletResponse response ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long taskId = Convert . toLong ( params . get ( \"<STR_LIT>\" ) ) ; SpiderTask spiderTask = queryItem ( taskId ) ; String matedata = spiderTask . getMatedata ( ) ; Map < String , Object > variables = JSONUtil . toBean ( matedata , new TypeReference < Map < String , Object > > ( ) { } , false ) ; String fileName = null ; String filePath = null ; BufferedInputStream inputStream = null ; BufferedOutputStream outputStream = null ; if ( variables . containsKey ( \"<STR_LIT>\" ) ) { fileName = variables . get ( \"<STR_LIT>\" ) + \"<STR_LIT>\" ; String jsonPath = spiderConfig . getWorkspace ( ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + fileName ; if ( ! FileUtil . exist ( jsonPath ) ) { throw new BaseException ( ExceptionCodes . FILE_NOT_EXIST ) ;", "output": "} inputStream = FileUtil . getInputStream ( jsonPath ) ; } else { String enterpriseName = Convert . toStr ( variables . get ( \"<STR_LIT>\" ) ) ; String className = Convert . toStr ( variables . get ( \"<STR_LIT>\" ) ) ; long currentTime = System . currentTimeMillis ( ) ; String upCatalog = taskId + \"<STR_LIT>\" + enterpriseName ; String srcPath = spiderConfig . getWorkspace ( ) + File . separator + \"<STR_LIT>\" + File . separator + upCatalog ; filePath = spiderConfig . getWorkspace ( ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + enterpriseName + currentTime + \"<STR_LIT>\" ; if ( ! FileUtil . exist ( srcPath ) ) { throw new BaseException ( ExceptionCodes . FILE_NOT_EXIST ) ; } ZipUtil . zip ( srcPath , filePath ) ; fileName = taskId + \"<STR_LIT>\" + enterpriseName + \"<STR_LIT>\" + className + \"<STR_LIT>\" ; inputStream = FileUtil . getInputStream ( filePath ) ; } try { response . reset ( ) ; response . addHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( fileName , \"<STR_LIT>\" ) ) ; response . setContentType ( \"<STR_LIT>\" ) ; outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; byte [ ] readBytes = new byte [ inputStream . available ( ) ] ; inputStream . read ( readBytes ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + readBytes . length ) ; outputStream . write ( readBytes ) ; outputStream . flush ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw new BaseException ( ExceptionCodes . FILE_EXPORT_FAILED ) ; } finally { if ( outputStream != null ) { try { outputStream . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } if ( fileName . lastIndexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) { FileUtil . del ( filePath ) ; } } } }"}, {"input": "package org . springblade . cgform . model . generate . util ; import org . apache . commons . lang . RandomStringUtils ; import java . security . SecureRandom ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . UUID ; public class NonceUtils { private static final SimpleDateFormat sdf ; private static final String [ ] b ; private static Date c ; private static int d ; public static String a ( int n ) { return RandomStringUtils . randomAlphanumeric ( n ) ; } public static int a ( ) { return new SecureRandom ( ) . nextInt ( ) ; } public static String b ( ) { return Integer . toHexString ( a ( ) ) ; } public static long c ( ) { return new SecureRandom ( ) . nextLong ( ) ; } public static String d ( ) { return Long . toHexString ( c ( ) ) ; } public static String e ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String f ( ) { return NonceUtils . sdf . format ( new Date ( ) ) ; } public static long g ( ) { return System . currentTimeMillis ( ) ; } public static String h ( ) { return Long . toHexString ( g ( ) ) ; } public static synchronized String i ( ) { final Date c = new Date ( ) ; if ( c . equals ( NonceUtils . c ) ) { ++ NonceUtils . d ; } else { NonceUtils . c = c ; NonceUtils . d = <NUM_LIT> ; } return Integer . toHexString ( NonceUtils . d ) ; } public static String a ( String s , int n ) { int i = n - s . length ( ) ; StringBuilder sb = new StringBuilder ( ) ; while ( i >= <NUM_LIT> ) { sb . append ( NonceUtils . b [ <NUM_LIT> ] ) ; i -= <NUM_LIT> ; } for ( int j = <NUM_LIT> ; j >= <NUM_LIT> ; -- j ) { if ( ( i & <NUM_LIT> << j ) != <NUM_LIT> ) { sb . append ( NonceUtils . b [ j ] ) ; } } sb . append ( s ) ; return sb . toString ( ) ;", "output": "} static { sdf = new SimpleDateFormat ( \"<STR_LIT>\" ) ; b = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; NonceUtils . d = <NUM_LIT> ; } }"}, {"input": "package ginyi . system . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class SysMenu extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId @ ApiModelProperty ( \"<STR_LIT>\" ) private Long menuId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String menuName ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableField ( exist = false , select = false ) private String parentName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableField ( value = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String component ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String query ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isFrame ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isCache ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String menuType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String visible ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String perms ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String icon ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableField ( exist = false , select = false ) private List < SysMenu > children = new ArrayList < SysMenu > ( ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . util ; import cn . org . alan . exam . mapper . UserMapper ; import cn . org . alan . exam . model . entity . User ; import jakarta . annotation . Resource ; import org . junit . jupiter . api . Test ; import java . time . LocalDate ; import java . util . List ; import static org . junit . jupiter . api . Assertions . * ; class DateTimeUtilTest {", "output": "@ Resource private UserMapper userMapper ; @ Test void getDate ( ) { List < User > users = userMapper . selectList ( null ) ; System . out . println ( users ) ; } @ Test void dateToStr ( ) { System . out . println ( DateTimeUtil . dateToStr ( DateTimeUtil . getDate ( ) ) ) ; } }"}, {"input": "package com . youlai . system . model . query ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class DeptQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ;", "output": "}"}, {"input": "package me . zhengjie . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class TableInfo { private Object tableName ; private Object createTime ; private Object engine ; private Object coding ; private Object remark ;", "output": "}"}, {"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . ddduser . domain . repository . UserRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserDomainService { @ Autowired private UserRepository userRepository ; public void validateUsername ( String username ) { UserEntity existingUser = userRepository . find ( username ) ; if ( existingUser != null ) {", "output": "throw new BizException ( \"<STR_LIT>\" ) ; } } public UserEntity validateUserId ( Long userId ) { if ( userId == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = userRepository . find ( userId ) ; if ( user == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return user ; } }"}, {"input": "package me . zhengjie . aspect ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . domain . SysLog ; import me . zhengjie . service . SysLogService ; import me . zhengjie . utils . RequestHolder ; import me . zhengjie . utils . SecurityUtils ; import me . zhengjie . utils . StringUtils ; import me . zhengjie . utils . ThrowableUtil ; import org . aspectj . lang . JoinPoint ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . AfterThrowing ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; @ Component @ Aspect @ Slf4j public class LogAspect { private final SysLogService sysLogService ; ThreadLocal < Long > currentTime = new ThreadLocal < > ( ) ; public LogAspect ( SysLogService sysLogService ) { this . sysLogService = sysLogService ; } @ Pointcut ( \"<STR_LIT>\" ) public void logPointcut ( ) { } @ Around ( \"<STR_LIT>\" ) public Object logAround ( ProceedingJoinPoint joinPoint ) throws Throwable { Object result ; currentTime . set ( System . currentTimeMillis ( ) ) ; result = joinPoint . proceed ( ) ; SysLog sysLog = new SysLog ( \"<STR_LIT>\" , System . currentTimeMillis ( ) - currentTime . get ( ) ) ; currentTime . remove ( ) ; HttpServletRequest request = RequestHolder . getHttpServletRequest ( ) ;", "output": "sysLogService . save ( getUsername ( ) , StringUtils . getBrowser ( request ) , StringUtils . getIp ( request ) , joinPoint , sysLog ) ; return result ; } @ AfterThrowing ( pointcut = \"<STR_LIT>\" , throwing = \"<STR_LIT>\" ) public void logAfterThrowing ( JoinPoint joinPoint , Throwable e ) { SysLog sysLog = new SysLog ( \"<STR_LIT>\" , System . currentTimeMillis ( ) - currentTime . get ( ) ) ; currentTime . remove ( ) ; sysLog . setExceptionDetail ( new String ( ThrowableUtil . getStackTrace ( e ) . getBytes ( ) ) ) ; HttpServletRequest request = RequestHolder . getHttpServletRequest ( ) ; sysLogService . save ( getUsername ( ) , StringUtils . getBrowser ( request ) , StringUtils . getIp ( request ) , ( ProceedingJoinPoint ) joinPoint , sysLog ) ; } public String getUsername ( ) { try { return SecurityUtils . getCurrentUsername ( ) ; } catch ( Exception e ) { return \"<STR_LIT>\" ; } } }"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . sql . Timestamp ; import java . util . List ; @ Data @ NoArgsConstructor public class JobQueryCriteria { private String name ; private Boolean enabled ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package org . springblade . config . util . sms ; import lombok . Data ; @ Data public class AliSmsConfig { private String accessKey ; private String secretKey ; private String qm ; private String yjdx ; private String sfdx ; private String xzdx ; private String sczddx ; private String qfdx ; private String tyyzm ; private String zhdqdx ; private String gzgzhdx ; private String bytzdx ; private String byhtdqdx ;", "output": "}"}, {"input": "package org . springblade . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class WalletMessageStruct implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String message ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . env ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . * ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . context . * ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . * ; import static java . lang . String . format ; import static org . springframework . util . ClassUtils . resolveClassName ; public abstract class AbstractNacosPropertySourceBuilder < T extends BeanDefinition > implements EnvironmentAware , BeanFactoryAware , BeanClassLoaderAware , ApplicationContextAware , InitializingBean , DisposableBean { protected final Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; private final Class < T > beanDefinitionType ; protected ConfigurableEnvironment environment ; protected BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; private Properties globalNacosProperties ; private ClassLoader classLoader ; private ApplicationEventPublisher applicationEventPublisher ; public AbstractNacosPropertySourceBuilder ( ) { beanDefinitionType = resolveGenericType ( getClass ( ) ) ; } public List < NacosPropertySource > build ( String beanName , T beanDefinition ) { Map < String , Object > [ ] attributesArray = resolveRuntimeAttributesArray ( beanDefinition , globalNacosProperties ) ; int size = attributesArray == null ? <NUM_LIT> : attributesArray . length ; if ( size == <NUM_LIT> ) { return Collections . emptyList ( ) ; } List < NacosPropertySource > nacosPropertySources = new ArrayList < NacosPropertySource > ( size ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , Object > attributes = attributesArray [ i ] ; if ( ! CollectionUtils . isEmpty ( attributes ) ) { NacosPropertySource nacosPropertySource = doBuild ( beanName , beanDefinition , attributesArray [ i ] ) ; NacosConfigMetadataEvent metadataEvent = createMetaEvent ( nacosPropertySource , beanDefinition ) ; initMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; publishMetadataEvent ( metadataEvent ) ; nacosPropertySources . add ( nacosPropertySource ) ; } } return nacosPropertySources ; } protected abstract NacosConfigMetadataEvent createMetaEvent ( NacosPropertySource nacosPropertySource , T beanDefinition ) ; private void initMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) { metadataEvent . setDataId ( nacosPropertySource . getDataId ( ) ) ; metadataEvent . setGroupId ( nacosPropertySource . getGroupId ( ) ) ; metadataEvent . setBeanName ( nacosPropertySource . getBeanName ( ) ) ;", "output": "metadataEvent . setBeanType ( nacosPropertySource . getBeanType ( ) ) ; metadataEvent . setNacosProperties ( nacosPropertySource . getProperties ( ) ) ; Map < String , Object > attributesMetadata = nacosPropertySource . getAttributesMetadata ( ) ; Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) attributesMetadata . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; doInitMetadataEvent ( nacosPropertySource , beanDefinition , metadataEvent ) ; } private void publishMetadataEvent ( NacosConfigMetadataEvent metadataEvent ) { applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected abstract void doInitMetadataEvent ( NacosPropertySource nacosPropertySource , T beanDefinition , NacosConfigMetadataEvent metadataEvent ) ; protected NacosPropertySource doBuild ( String beanName , T beanDefinition , Map < String , Object > runtimeAttributes ) { String name = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . NAME_ATTRIBUTE_NAME ) ; String dataId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . DATA_ID_ATTRIBUTE_NAME ) ; String groupId = ( String ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . GROUP_ID_ATTRIBUTE_NAME ) ; dataId = NacosUtils . readFromEnvironment ( dataId , environment ) ; groupId = NacosUtils . readFromEnvironment ( groupId , environment ) ; final String type ; ConfigType typeEunm = ( ConfigType ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . CONFIG_TYPE_ATTRIBUTE_NAME ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } Map < String , Object > nacosPropertiesAttributes = ( Map < String , Object > ) runtimeAttributes . get ( io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosPropertySource . PROPERTIES_ATTRIBUTE_NAME ) ; Properties nacosProperties = resolveProperties ( nacosPropertiesAttributes , environment , globalNacosProperties ) ; String nacosConfig = nacosConfigLoader . load ( dataId , groupId , nacosProperties ) ; if ( ! StringUtils . hasText ( nacosConfig ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , nacosPropertiesAttributes ) ) ; } } if ( ! StringUtils . hasText ( name ) ) { name = buildDefaultPropertySourceName ( dataId , groupId , nacosProperties ) ; } NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , name , nacosConfig , type ) ; nacosPropertySource . setBeanName ( beanName ) ; String beanClassName = beanDefinition . getBeanClassName ( ) ; if ( StringUtils . hasText ( beanClassName ) ) { nacosPropertySource . setBeanType ( resolveClassName ( beanClassName , classLoader ) ) ; } nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setProperties ( nacosProperties ) ; initNacosPropertySource ( nacosPropertySource , beanDefinition , runtimeAttributes ) ; return nacosPropertySource ; } protected abstract Map < String , Object > [ ] resolveRuntimeAttributesArray ( T beanDefinition , Properties globalNacosProperties ) ; protected abstract void initNacosPropertySource ( NacosPropertySource nacosPropertySource , T beanDefinition , Map < String , Object > attributes ) ; public boolean supports ( BeanDefinition beanDefinition ) { Class < ? > beanDefinitionClass = beanDefinition . getClass ( ) ; return beanDefinitionType . isAssignableFrom ( beanDefinitionClass ) ; } @ Override public void setEnvironment ( Environment environment ) { if ( environment instanceof ConfigurableEnvironment ) { this . environment = ( ConfigurableEnvironment ) environment ; } } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; } @ Override public void setBeanClassLoader ( ClassLoader classLoader ) { this . classLoader = classLoader ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) { ConfigurableApplicationContext context = ( ConfigurableApplicationContext ) applicationContext ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; } @ Override public void afterPropertiesSet ( ) throws Exception { nacosConfigLoader = new NacosConfigLoader ( environment ) ; nacosConfigLoader . setNacosServiceFactory ( NacosBeanUtils . getNacosServiceFactoryBean ( beanFactory ) ) ; globalNacosProperties = GlobalNacosPropertiesSource . CONFIG . getMergedGlobalProperties ( beanFactory ) ; } @ Override public void destroy ( ) throws Exception { if ( nacosConfigLoader == null ) { return ; } ConfigService configService = nacosConfigLoader . getConfigService ( ) ; if ( configService != null ) { configService . shutDown ( ) ; } } public final Class < T > getBeanDefinitionType ( ) { return beanDefinitionType ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Exam ; import cn . org . alan . exam . model . entity . ExamGrade ; import cn . org . alan . exam . model . vo . exam . ExamGradeListVO ; import cn . org . alan . exam . model . vo . score . GradeScoreVO ; import cn . org . alan . exam . model . vo . stat . GradeExamVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface ExamGradeMapper extends BaseMapper < ExamGrade > {", "output": "Integer addExamGrade ( Integer id , List < Integer > gradeIds ) ; Integer delExamGrade ( Integer id ) ; IPage < GradeScoreVO > getExamGrade ( IPage < GradeScoreVO > page , String examTitle , Integer userId , Integer gradeId , Integer roleId ) ; Integer selectClassSize ( Integer id ) ; IPage < ExamGradeListVO > selectClassExam ( IPage < ExamGradeListVO > examPage , Integer userId , String title ) ; IPage < ExamGradeListVO > selectAdminClassExam ( IPage < ExamGradeListVO > examPage , Integer userId , String title ) ; }"}, {"input": "package com . yf . ability . shiro . service ; import com . yf . ability . shiro . dto . SysUserLoginDTO ; import java . util . List ; public interface ShiroUserService {", "output": "List < String > permissions ( String userId ) ; List < String > roles ( String userId ) ; SysUserLoginDTO token ( String token ) ; }"}, {"input": "package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . Set ; public interface AppService extends IService < App > {", "output": "PageResult < App > queryAll ( AppQueryCriteria criteria , Page < Object > page ) ; List < App > queryAll ( AppQueryCriteria criteria ) ; void create ( App resources ) ; void update ( App resources ) ; void delete ( Set < Long > ids ) ; void download ( List < App > apps , HttpServletResponse response ) throws IOException ; }"}, {"input": "package org . springblade . config . autopoi . poi . exception . word . enmus ; public enum WordExportEnum { EXCEL_PARAMS_ERROR ( \"<STR_LIT>\" ) , EXCEL_HEAD_HAVA_NULL ( \"<STR_LIT>\" ) , EXCEL_NO_HEAD ( \"<STR_LIT>\" ) ; private String msg ; WordExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) { return msg ;", "output": "} public void setMsg ( String msg ) { this . msg = msg ; } }"}, {"input": "package org . springblade . cgform . model . generate . util ; import freemarker . cache . FileTemplateLoader ; import freemarker . cache . MultiTemplateLoader ; import freemarker . cache . TemplateLoader ; import freemarker . template . Configuration ; import freemarker . template . Template ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . StringTokenizer ; @ Slf4j public class TemplatePathUtil { public static Configuration templateConfig ( List < File > list , String defaultEncoding , String s ) throws IOException { Configuration configuration = new Configuration ( Configuration . VERSION_2_3_0 ) ; log . debug ( \"<STR_LIT>\" + list . size ( ) ) ; log . debug ( \"<STR_LIT>\" + s ) ; FileTemplateLoader [ ] array = new FileTemplateLoader [ list . size ( ) ] ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; ++ i ) { File file = list . get ( i ) ; log . debug ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; array [ i ] = new FileTemplateLoader ( file ) ; } configuration . setTemplateLoader ( ( TemplateLoader ) new MultiTemplateLoader ( ( TemplateLoader [ ] ) array ) ) ; configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setBooleanFormat ( \"<STR_LIT>\" ) ; configuration . setDefaultEncoding ( defaultEncoding ) ;", "output": "return configuration ; } public static List < String > a ( String s , String s2 ) { String [ ] b = b ( s , \"<STR_LIT>\" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( s2 ) ; list . add ( File . separator + s2 ) ; String string = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < b . length ; ++ i ) { string = string + File . separator + b [ i ] ; list . add ( string + File . separator + s2 ) ; } return list ; } public static String [ ] b ( String s , String s2 ) { if ( s == null ) { return new String [ <NUM_LIT> ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( s , s2 ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( stringTokenizer . hasMoreElements ( ) ) { list . add ( stringTokenizer . nextElement ( ) . toString ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } public static String a ( String s , Map < String , Object > map , Configuration configuration ) { StringWriter stringWriter = new StringWriter ( ) ; try { new Template ( \"<STR_LIT>\" , ( Reader ) new StringReader ( s ) , configuration ) . process ( ( Object ) map , ( Writer ) stringWriter ) ; return stringWriter . toString ( ) ; } catch ( Exception ex ) { throw new IllegalStateException ( \"<STR_LIT>\" + s + \"<STR_LIT>\" + ex , ex ) ; } } public static void templateDraw ( Template template , Map < String , Object > map , File file , String s ) throws IOException , TemplateException { BufferedWriter bufferedWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , s ) ) ; map . put ( \"<STR_LIT>\" , new SimpleFormat ( ) ) ; template . process ( ( Object ) map , ( Writer ) bufferedWriter ) ; bufferedWriter . close ( ) ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . group . UserGroup ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . form . Auth . LoginForm ; import cn . org . alan . exam . model . form . UserForm ; import cn . org . alan . exam . service . IAuthService ; import jakarta . annotation . Resource ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . servlet . http . HttpServletResponse ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . time . Duration ; import java . time . LocalDateTime ; import java . util . Map ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class AuthController { @ Resource private IAuthService iAuthService ; @ PostMapping ( \"<STR_LIT>\" ) public Result < String > login ( HttpServletRequest request , @ Validated @ RequestBody LoginForm loginForm ) { return iAuthService . login ( request , loginForm ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) public Result < String > logout ( HttpServletRequest request ) { return iAuthService . logout ( request ) ; }", "output": "@ PostMapping ( \"<STR_LIT>\" ) public Result < String > register ( HttpServletRequest request , @ RequestBody @ Validated ( UserGroup . RegisterGroup . class ) UserForm userForm ) { return iAuthService . register ( request , userForm ) ; } @ GetMapping ( \"<STR_LIT>\" ) public void getCaptcha ( HttpServletRequest request , HttpServletResponse response ) { iAuthService . getCaptcha ( request , response ) ; } @ PostMapping ( \"<STR_LIT>\" ) public Result < String > verifyCode ( HttpServletRequest request , @ PathVariable ( \"<STR_LIT>\" ) String code ) { return iAuthService . verifyCode ( request , code ) ; } @ PostMapping ( \"<STR_LIT>\" ) public Result < String > trackPresence ( HttpServletRequest request ) { return iAuthService . sendHeartbeat ( request ) ; } }"}, {"input": "package ginyi . common . utils . text ; import ginyi . common . utils . StringUtils ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; public class CharsetKit { public static final String ISO_8859_1 = \"<STR_LIT>\" ; public static final String UTF_8 = \"<STR_LIT>\" ; public static final String GBK = \"<STR_LIT>\" ; public static final Charset CHARSET_ISO_8859_1 = Charset . forName ( ISO_8859_1 ) ; public static final Charset CHARSET_UTF_8 = Charset . forName ( UTF_8 ) ; public static final Charset CHARSET_GBK = Charset . forName ( GBK ) ; public static Charset charset ( String charset ) { return StringUtils . isEmpty ( charset ) ? Charset . defaultCharset ( ) : Charset . forName ( charset ) ; } public static String convert ( String source , String srcCharset , String destCharset ) { return convert ( source , Charset . forName ( srcCharset ) , Charset . forName ( destCharset ) ) ; } public static String convert ( String source , Charset srcCharset , Charset destCharset ) { if ( null == srcCharset ) { srcCharset = StandardCharsets . ISO_8859_1 ; } if ( null == destCharset ) { destCharset = StandardCharsets . UTF_8 ; } if ( StringUtils . isEmpty ( source ) || srcCharset . equals ( destCharset ) ) { return source ; } return new String ( source . getBytes ( srcCharset ) , destCharset ) ;", "output": "} public static String systemCharset ( ) { return Charset . defaultCharset ( ) . name ( ) ; } }"}, {"input": "package org . example . ddduser . infrastructure . repository . database ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . infrastructure . repository . database . condition . UserProfilePageCondition ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; public interface UserMapper extends BaseMapper < User > {", "output": "Page < UserProfile > selectProfilePage ( UserProfilePageCondition condition ) ; }"}, {"input": "package com . youlai . system . model . vo ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . youlai . system . enums . MenuTypeEnum ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class MenuVO { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private Long parentId ; @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private MenuTypeEnum type ; @ Schema ( description = \"<STR_LIT>\" ) private String routeName ; @ Schema ( description = \"<STR_LIT>\" ) private String routePath ; @ Schema ( description = \"<STR_LIT>\" ) private String component ; @ Schema ( description = \"<STR_LIT>\" ) private Integer sort ; @ Schema ( description = \"<STR_LIT>\" ) private Integer visible ; @ Schema ( description = \"<STR_LIT>\" ) private String icon ; @ Schema ( description = \"<STR_LIT>\" ) private String redirect ; @ Schema ( description = \"<STR_LIT>\" ) private String perm ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonInclude ( value = JsonInclude . Include . NON_NULL ) private List < MenuVO > children ;", "output": "}"}, {"input": "package top . kangert . kspider . model ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . util . EscapeUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONArray ; import cn . hutool . json . JSONUtil ; import lombok . Getter ; import lombok . Setter ; import top . kangert . kspider . constant . ConditionType ; import top . kangert . kspider . constant . Constants ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; public class SpiderNode { @ Getter @ Setter private String nodeId ; @ Getter @ Setter private String nodeName ; private AtomicInteger taskCounter = new AtomicInteger ( ) ; @ Setter private Map < String , Object > jsonProperty = new HashMap < > ( ) ; private List < SpiderNode > prevNodes = new ArrayList < > ( ) ; @ Getter private List < SpiderNode > nextNodes = new ArrayList < > ( ) ; private Map < String , String > transmitVariables = new HashMap < > ( ) ; private Map < String , String > conditions = new HashMap < > ( ) ; private Map < String , String > conditionTypes = new HashMap < > ( ) ; public String getJsonProperty ( String key ) { String value = Convert . toStr ( jsonProperty . get ( key ) ) ; if ( value != null ) { value = EscapeUtil . unescapeHtml4 ( value ) ; } return value ; } public String getJsonProperty ( String key , String defaultValue ) { String value = this . getJsonProperty ( key ) ; return StrUtil . isNotBlank ( value ) ? value : defaultValue ; } public void addNextNode ( SpiderNode nextNode ) { nextNode . prevNodes . add ( this ) ; this . nextNodes . add ( nextNode ) ; } public List < Map < String , String > > getJsonArrayProperty ( String ... keys ) { int size = - <NUM_LIT> ; List < JSONArray > arrays = new ArrayList < > ( ) ; List < Map < String , String > > result = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { JSONArray jsonArray = JSONUtil . parseArray ( this . jsonProperty . get ( keys [ i ] ) ) ; if ( jsonArray != null ) {", "output": "if ( size == - <NUM_LIT> ) { size = jsonArray . size ( ) ; } if ( size != jsonArray . size ( ) ) { throw new ArrayIndexOutOfBoundsException ( ) ; } arrays . add ( jsonArray ) ; } } for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Map < String , String > item = new HashMap < > ( ) ; for ( int j = <NUM_LIT> ; j < keys . length ; j ++ ) { String value = arrays . get ( j ) . getStr ( i ) ; if ( value != null ) { value = EscapeUtil . unescapeHtml4 ( value ) ; } item . put ( keys [ j ] , value ) ; } result . add ( item ) ; } return result ; } public boolean needTransmit ( String fromNodeId ) { String value = this . transmitVariables . get ( fromNodeId ) ; return StrUtil . isBlank ( value ) || Constants . YES . equals ( value ) ; } public void increment ( ) { taskCounter . incrementAndGet ( ) ; } public void decrement ( ) { taskCounter . decrementAndGet ( ) ; } public boolean isDone ( ) { return isDone ( new HashSet < > ( ) ) ; } public boolean isDone ( Set < String > visited ) { if ( this . taskCounter . get ( ) == <NUM_LIT> ) { for ( SpiderNode prevNode : prevNodes ) { if ( visited . add ( nodeId ) && ! prevNode . isDone ( visited ) ) { return false ; } } return true ; } return false ; } public String getCondition ( String fromNodeId ) { return this . conditions . get ( fromNodeId ) ; } public String getConditionType ( String fromNodeId ) { return this . conditionTypes . get ( fromNodeId ) ; } public void setTransmitVariable ( String fromNodeId , String value ) { this . transmitVariables . put ( fromNodeId , value ) ; } public void setCondition ( String fromNodeId , String value ) { this . conditions . put ( fromNodeId , value ) ; } public void setConditionType ( String fromNodeId , String value ) { this . conditionTypes . put ( fromNodeId , value ) ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + nodeId + '<STR_LIT>' + \"<STR_LIT>\" + nodeName + '<STR_LIT>' + '<STR_LIT>' ; } }"}, {"input": "package com . xcs . wx . msg . impl ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import org . springframework . stereotype . Service ; @ Service public class VoiceMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ; } @ Override public void process ( MsgVO msgVO ) {", "output": "msgVO . setStrContent ( \"<STR_LIT>\" ) ; } }"}, {"input": "package ginyi . server . admin . controller ; import ginyi . common . result . CommonResult ; import ginyi . system . domain . model . dto . LoginDto ; import ginyi . system . domain . model . dto . RegisterDto ; import ginyi . system . domain . model . vo . LoginVo ; import ginyi . system . service . ISysLoginService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) @ Slf4j public class SysLoginController { @ Autowired private ISysLoginService loginService ; @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public CommonResult < LoginVo > login ( @ RequestBody @ Validated LoginDto loginDto ) { LoginVo loginVo = loginService . login ( loginDto ) ; return CommonResult . success ( loginVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public CommonResult register ( @ RequestBody @ Validated RegisterDto registerDto ) { loginService . register ( registerDto ) ; return CommonResult . success ( ) ; }", "output": "@ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public CommonResult logout ( ) { return CommonResult . success ( ) ; } }"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . BaseColumn ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class LinkDownProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; String dictTable ; List < BaseColumn > otherColumns ; public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public List < BaseColumn > getOtherColumns ( ) { return this . otherColumns ;", "output": "} public void setOtherColumns ( List < BaseColumn > otherColumns ) { this . otherColumns = otherColumns ; } public LinkDownProperty ( ) { } public LinkDownProperty ( String key , String title , String dictTable ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dictTable = dictTable ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONObject temp = JSONObject . parseObject ( this . dictTable ) ; prop . put ( \"<STR_LIT>\" , temp ) ; prop . put ( \"<STR_LIT>\" , otherColumns ) ; map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package com . yf . system . modules . dict . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysDicValue extends Model < SysDicValue > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String dicCode ; @ TableField ( \"<STR_LIT>\" ) private String value ; private String title ; @ TableField ( \"<STR_LIT>\" ) private String parentId ; private String remark ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . Date ; import java . util . List ; import java . util . Set ; @ Mapper public interface UserMapper extends BaseMapper < User > { List < User > findAll ( @ Param ( \"<STR_LIT>\" ) UserQueryCriteria criteria ) ; Long countAll ( @ Param ( \"<STR_LIT>\" ) UserQueryCriteria criteria ) ; User findByUsername ( @ Param ( \"<STR_LIT>\" ) String username ) ; User findByEmail ( @ Param ( \"<STR_LIT>\" ) String email ) ; User findByPhone ( @ Param ( \"<STR_LIT>\" ) String phone ) ; @ Select ( \"<STR_LIT>\" ) void updatePass ( @ Param ( \"<STR_LIT>\" ) String username , @ Param ( \"<STR_LIT>\" ) String password , @ Param ( \"<STR_LIT>\" ) Date lastPasswordResetTime ) ;", "output": "@ Select ( \"<STR_LIT>\" ) void updateEmail ( @ Param ( \"<STR_LIT>\" ) String username , @ Param ( \"<STR_LIT>\" ) String email ) ; List < User > findByRoleId ( @ Param ( \"<STR_LIT>\" ) Long roleId ) ; List < User > findByRoleDeptId ( @ Param ( \"<STR_LIT>\" ) Long deptId ) ; List < User > findByMenuId ( @ Param ( \"<STR_LIT>\" ) Long menuId ) ; int countByJobs ( @ Param ( \"<STR_LIT>\" ) Set < Long > jobIds ) ; int countByDepts ( @ Param ( \"<STR_LIT>\" ) Set < Long > deptIds ) ; int countByRoles ( @ Param ( \"<STR_LIT>\" ) Set < Long > roleIds ) ; void resetPwd ( @ Param ( \"<STR_LIT>\" ) Set < Long > userIds , @ Param ( \"<STR_LIT>\" ) String pwd ) ; }"}, {"input": "package com . yf . system . modules . menu . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysMenuDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer menuType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String permissionTag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String component ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String redirect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaActiveMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean metaNoCache ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean hidden ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date createTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date updateTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String createBy ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String updateBy ;", "output": "}"}, {"input": "package com . yf . config ; import org . springframework . boot . web . servlet . FilterRegistrationBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import java . util . Arrays ; @ Configuration public class CorsConfig { @ Bean public FilterRegistrationBean < CorsFilter > corsFilter ( ) { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ;", "output": "config . addAllowedOrigin ( CorsConfiguration . ALL ) ; config . addAllowedHeader ( CorsConfiguration . ALL ) ; config . setAllowedMethods ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; FilterRegistrationBean < CorsFilter > bean = new FilterRegistrationBean < > ( new CorsFilter ( source ) ) ; bean . setOrder ( Ordered . HIGHEST_PRECEDENCE ) ; return bean ; } }"}, {"input": "package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . system . domain . Job ; import me . zhengjie . modules . system . domain . vo . JobQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; @ Mapper public interface JobMapper extends BaseMapper < Job > { @ Select ( \"<STR_LIT>\" ) Job findByName ( @ Param ( \"<STR_LIT>\" ) String name ) ;", "output": "List < Job > findAll ( @ Param ( \"<STR_LIT>\" ) JobQueryCriteria criteria ) ; IPage < Job > findAll ( @ Param ( \"<STR_LIT>\" ) JobQueryCriteria criteria , Page < Object > page ) ; }"}, {"input": "package com . yf . system . modules . plugin . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . plugin . entity . PluginData ; public interface PluginDataMapper extends BaseMapper < PluginData > {", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . ExerciseConverter ; import cn . org . alan . exam . converter . QuestionConverter ; import cn . org . alan . exam . converter . RecordConverter ; import cn . org . alan . exam . mapper . * ; import cn . org . alan . exam . model . entity . * ; import cn . org . alan . exam . model . form . ExerciseFillAnswerFrom ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . model . vo . exam . ExamQuestionVO ; import cn . org . alan . exam . model . vo . exercise . AnswerInfoVO ; import cn . org . alan . exam . model . vo . exercise . QuestionSheetVO ; import cn . org . alan . exam . model . vo . record . ExamRecordDetailVO ; import cn . org . alan . exam . model . vo . record . ExamRecordVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordDetailVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordVO ; import cn . org . alan . exam . service . IExerciseRecordService ; import cn . org . alan . exam . service . IOptionService ; import cn . org . alan . exam . util . CacheClient ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Function ; import java . util . stream . Collectors ; @ Service public class ExerciseRecordServiceImpl extends ServiceImpl < ExerciseRecordMapper , ExerciseRecord > implements IExerciseRecordService { @ Resource private QuestionMapper questionMapper ; @ Resource private ExamMapper examMapper ; @ Resource private RecordConverter recordConverter ; @ Resource private ExamQuestionMapper examQuestionMapper ; @ Resource private OptionMapper optionMapper ; @ Resource private ExamQuAnswerMapper examQuAnswerMapper ; @ Resource private IOptionService optionService ; @ Resource private UserExerciseRecordMapper userExerciseRecordMapper ; @ Resource private RepoMapper repoMapper ; @ Resource private ExerciseConverter exerciseConverter ; @ Resource private ExerciseRecordMapper exerciseRecordMapper ; @ Resource private CacheClient cacheClient ; @ Override public Result < List < QuestionSheetVO > > getQuestionSheet ( Integer repoId , Integer quType ) { List < QuestionSheetVO > list = questionMapper . selectQuestionSheet ( repoId , quType , SecurityUtil . getUserId ( ) ) ; return Result . success ( null , list ) ; } @ Override public Result < IPage < ExamRecordVO > > getExamRecordPage ( Integer pageNum , Integer pageSize , String examName ) { Page < ExamRecordVO > examPage = new Page < > ( pageNum , pageSize ) ; examPage = examMapper . getExamRecordPage ( examPage , SecurityUtil . getUserId ( ) , examName ) ; return Result . success ( \"<STR_LIT>\" , examPage ) ; } @ Override public Result < List < ExamRecordDetailVO > > getExamRecordDetail ( Integer examId ) { Function < Integer , List > function = new Function < > ( ) { @ Override public List apply ( Integer integer ) { List < ExamRecordDetailVO > examRecordDetailVOS = new ArrayList < > ( ) ; LambdaQueryWrapper < ExamQuestion > examQuestionWrapper = new LambdaQueryWrapper < > ( ) ; examQuestionWrapper . eq ( ExamQuestion :: getExamId , examId ) . orderByAsc ( ExamQuestion :: getSort ) ; List < ExamQuestion > examQuestions = examQuestionMapper . selectList ( examQuestionWrapper ) ; List < Integer > quIds = examQuestions . stream ( ) . map ( ExamQuestion :: getQuestionId ) . collect ( Collectors . toList ( ) ) ; List < Question > questions = questionMapper . selectBatchIds ( quIds ) ; for ( Question temp : questions ) { ExamRecordDetailVO examRecordDetailVO = new ExamRecordDetailVO ( ) ; examRecordDetailVO . setImage ( temp . getImage ( ) ) ; examRecordDetailVO . setTitle ( temp . getContent ( ) ) ; examRecordDetailVO . setQuType ( temp . getQuType ( ) ) ; examRecordDetailVO . setAnalyse ( temp . getAnalysis ( ) ) ; LambdaQueryWrapper < Option > optionWrapper = new LambdaQueryWrapper < > ( ) ; optionWrapper . eq ( Option :: getQuId , temp . getId ( ) ) ; List < Option > options = optionMapper . selectList ( optionWrapper ) ; if ( temp . getQuType ( ) == <NUM_LIT> ) { examRecordDetailVO . setOption ( null ) ; } else { examRecordDetailVO . setOption ( options ) ; } LambdaQueryWrapper < Question > QuWrapper = new LambdaQueryWrapper < > ( ) ; QuWrapper . eq ( Question :: getId , temp . getId ( ) ) ; Question qu = questionMapper . selectOne ( QuWrapper ) ; Integer quType = qu . getQuType ( ) ; LambdaQueryWrapper < Option > opWrapper = new LambdaQueryWrapper < > ( ) ; opWrapper . eq ( Option :: getQuId , temp . getId ( ) ) ; List < Option > opList = optionMapper . selectList ( opWrapper ) ; if ( temp . getQuType ( ) == <NUM_LIT> && opList . size ( ) > <NUM_LIT> ) { examRecordDetailVO . setRightOption ( opList . get ( <NUM_LIT> ) . getContent ( ) ) ; } else { String current = \"<STR_LIT>\" ; ArrayList < Integer > strings = new ArrayList < > ( ) ; for ( Option temp1 : options ) { if ( temp1 . getIsRight ( ) == <NUM_LIT> ) { strings . add ( temp1 . getSort ( ) ) ; } } List < String > stringList = strings . stream ( ) . map ( String :: valueOf ) . collect ( Collectors . toList ( ) ) ; String result = String . join ( \"<STR_LIT>\" , stringList ) ; examRecordDetailVO . setRightOption ( result ) ; } LambdaQueryWrapper < ExamQuAnswer > examQuAnswerWrapper = new LambdaQueryWrapper < > ( ) ; examQuAnswerWrapper . eq ( ExamQuAnswer :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( ExamQuAnswer :: getExamId , examId ) . eq ( ExamQuAnswer :: getQuestionId , temp . getId ( ) ) ; ExamQuAnswer examQuAnswer = examQuAnswerMapper . selectOne ( examQuAnswerWrapper ) ; if ( examQuAnswer == null ) {", "output": "examRecordDetailVO . setMyOption ( null ) ; examRecordDetailVO . setIsRight ( - <NUM_LIT> ) ; examRecordDetailVOS . add ( examRecordDetailVO ) ; continue ; } switch ( quType ) { case <NUM_LIT> -> { LambdaQueryWrapper < Option > optionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; optionLambdaQueryWrapper . eq ( Option :: getId , examQuAnswer . getAnswerId ( ) ) ; Option op1 = optionMapper . selectOne ( optionLambdaQueryWrapper ) ; examRecordDetailVO . setMyOption ( Integer . toString ( op1 . getSort ( ) ) ) ; Option byId = optionService . getById ( examQuAnswer . getAnswerId ( ) ) ; if ( byId . getIsRight ( ) == <NUM_LIT> ) { examRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } else { examRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } } case <NUM_LIT> -> { String answerId = examQuAnswer . getAnswerId ( ) ; List < Integer > opIds = Arrays . stream ( answerId . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; List < Integer > sorts = new ArrayList < > ( ) ; for ( Integer opId : opIds ) { LambdaQueryWrapper < Option > optionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; optionLambdaQueryWrapper . eq ( Option :: getId , opId ) ; Option option = optionMapper . selectOne ( optionLambdaQueryWrapper ) ; sorts . add ( option . getSort ( ) ) ; } List < String > shortList = sorts . stream ( ) . map ( String :: valueOf ) . collect ( Collectors . toList ( ) ) ; String myOption = String . join ( \"<STR_LIT>\" , shortList ) ; examRecordDetailVO . setMyOption ( myOption ) ; LambdaQueryWrapper < Option > optionWrapper1 = new LambdaQueryWrapper < > ( ) ; optionWrapper1 . eq ( Option :: getIsRight , <NUM_LIT> ) . eq ( Option :: getQuId , temp . getId ( ) ) ; List < Option > examQuAnswers = optionMapper . selectList ( optionWrapper ) ; examRecordDetailVO . setIsRight ( <NUM_LIT> ) ; for ( Option temp1 : examQuAnswers ) { boolean containsBanana = opIds . contains ( temp . getId ( ) ) ; if ( containsBanana ) { examRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } } } case <NUM_LIT> -> { LambdaQueryWrapper < Option > optionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; optionLambdaQueryWrapper . eq ( Option :: getId , examQuAnswer . getAnswerId ( ) ) ; Option op1 = optionMapper . selectOne ( optionLambdaQueryWrapper ) ; examRecordDetailVO . setMyOption ( Integer . toString ( op1 . getSort ( ) ) ) ; Option byId = optionService . getById ( examQuAnswer . getAnswerId ( ) ) ; if ( byId . getIsRight ( ) == <NUM_LIT> ) { examRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } else { examRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } } case <NUM_LIT> -> { examRecordDetailVO . setMyOption ( examQuAnswer . getAnswerContent ( ) ) ; examRecordDetailVO . setIsRight ( - <NUM_LIT> ) ; } default -> { } } examRecordDetailVOS . add ( examRecordDetailVO ) ; } return examRecordDetailVOS ; } } ; List < ExamRecordDetailVO > result = cacheClient . queryWithPassThrough ( \"<STR_LIT>\" + SecurityUtil . getUserId ( ) , examId , List . class , function , ExamRecordDetailVO . class , <NUM_LIT> , TimeUnit . MINUTES ) ; if ( result == null ) { return Result . failed ( \"<STR_LIT>\" ) ; } return Result . success ( \"<STR_LIT>\" , result ) ; } @ Override public Result < IPage < ExerciseRecordVO > > getExerciseRecordPage ( Integer pageNum , Integer pageSize , String repoName ) { Page < Repo > repoPage = new Page < > ( pageNum , pageSize ) ; LambdaQueryWrapper < UserExerciseRecord > userExerciseRecordWrapper = new LambdaQueryWrapper < > ( ) ; userExerciseRecordWrapper . eq ( UserExerciseRecord :: getUserId , SecurityUtil . getUserId ( ) ) ; List < UserExerciseRecord > userExerciseRecord = userExerciseRecordMapper . selectList ( userExerciseRecordWrapper ) ; List < Integer > repoIds = userExerciseRecord . stream ( ) . map ( UserExerciseRecord :: getRepoId ) . collect ( Collectors . toList ( ) ) ; LambdaQueryWrapper < Repo > examWrapper = new LambdaQueryWrapper < > ( ) ; examWrapper . in ( Repo :: getId , repoIds ) . like ( StringUtils . isNotBlank ( repoName ) , Repo :: getTitle , repoName ) ; Page < Repo > exercisePageResult = repoMapper . selectPage ( repoPage , examWrapper ) ; Page < ExerciseRecordVO > exerciseRecordVOPage = recordConverter . pageRepoEntityToVo ( exercisePageResult ) ; return Result . success ( \"<STR_LIT>\" , exerciseRecordVOPage ) ; } @ Override public Result < List < ExerciseRecordDetailVO > > getExerciseRecordDetail ( Integer exerciseId ) { List < ExerciseRecordDetailVO > exerciseRecordDetailVOS = new ArrayList < > ( ) ; LambdaQueryWrapper < Question > questionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; questionLambdaQueryWrapper . eq ( Question :: getRepoId , exerciseId ) ; List < Question > questions1 = questionMapper . selectList ( questionLambdaQueryWrapper ) ; for ( Question temp : questions1 ) { ExerciseRecordDetailVO exerciseRecordDetailVO = new ExerciseRecordDetailVO ( ) ; exerciseRecordDetailVO . setImage ( temp . getImage ( ) ) ; exerciseRecordDetailVO . setTitle ( temp . getContent ( ) ) ; exerciseRecordDetailVO . setAnalyse ( temp . getAnalysis ( ) ) ; exerciseRecordDetailVO . setQuType ( temp . getQuType ( ) ) ; LambdaQueryWrapper < Option > optionWrapper = new LambdaQueryWrapper < > ( ) ; optionWrapper . eq ( Option :: getQuId , temp . getId ( ) ) ; List < Option > options = optionMapper . selectList ( optionWrapper ) ; if ( temp . getQuType ( ) == <NUM_LIT> ) { exerciseRecordDetailVO . setOption ( null ) ; } else { exerciseRecordDetailVO . setOption ( options ) ; } if ( temp . getQuType ( ) == <NUM_LIT> && options . size ( ) > <NUM_LIT> ) { exerciseRecordDetailVO . setRightOption ( options . get ( <NUM_LIT> ) . getContent ( ) ) ; } else { String current = \"<STR_LIT>\" ; ArrayList < Integer > strings = new ArrayList < > ( ) ; for ( Option temp1 : options ) { if ( temp1 . getIsRight ( ) == <NUM_LIT> ) { strings . add ( temp1 . getSort ( ) ) ; } } List < String > stringList = strings . stream ( ) . map ( String :: valueOf ) . collect ( Collectors . toList ( ) ) ; String result = String . join ( \"<STR_LIT>\" , stringList ) ; exerciseRecordDetailVO . setRightOption ( result ) ; } LambdaQueryWrapper < ExerciseRecord > exerciseRecordLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; exerciseRecordLambdaQueryWrapper . eq ( ExerciseRecord :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( ExerciseRecord :: getRepoId , exerciseId ) . eq ( ExerciseRecord :: getQuestionId , temp . getId ( ) ) ; ExerciseRecord exerciseRecord = exerciseRecordMapper . selectOne ( exerciseRecordLambdaQueryWrapper ) ; if ( exerciseRecord == null ) { exerciseRecordDetailVO . setMyOption ( null ) ; exerciseRecordDetailVO . setIsRight ( - <NUM_LIT> ) ; exerciseRecordDetailVOS . add ( exerciseRecordDetailVO ) ; continue ; } switch ( temp . getQuType ( ) ) { case <NUM_LIT> -> { LambdaQueryWrapper < Option > optionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; optionLambdaQueryWrapper . eq ( Option :: getId , exerciseRecord . getAnswer ( ) ) ; Option op1 = optionMapper . selectOne ( optionLambdaQueryWrapper ) ; exerciseRecordDetailVO . setMyOption ( Integer . toString ( op1 . getSort ( ) ) ) ; Option byId = optionService . getById ( exerciseRecord . getAnswer ( ) ) ; if ( byId . getIsRight ( ) == <NUM_LIT> ) { exerciseRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } else { exerciseRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } } case <NUM_LIT> -> { String answerId = exerciseRecord . getAnswer ( ) ; List < Integer > opIds = Arrays . stream ( answerId . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; List < Integer > sorts = new ArrayList < > ( ) ; for ( Integer opId : opIds ) { LambdaQueryWrapper < Option > optionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; optionLambdaQueryWrapper . eq ( Option :: getId , opId ) ; Option option = optionMapper . selectOne ( optionLambdaQueryWrapper ) ; sorts . add ( option . getSort ( ) ) ; } List < String > shortList = sorts . stream ( ) . map ( String :: valueOf ) . collect ( Collectors . toList ( ) ) ; String myOption = String . join ( \"<STR_LIT>\" , shortList ) ; exerciseRecordDetailVO . setMyOption ( myOption ) ; LambdaQueryWrapper < Option > optionWrapper1 = new LambdaQueryWrapper < > ( ) ; optionWrapper1 . eq ( Option :: getIsRight , <NUM_LIT> ) . eq ( Option :: getQuId , temp . getId ( ) ) ; List < Option > examQuAnswers = optionMapper . selectList ( optionWrapper ) ; exerciseRecordDetailVO . setIsRight ( <NUM_LIT> ) ; for ( Option temp1 : examQuAnswers ) { boolean containsBanana = opIds . contains ( temp . getId ( ) ) ; if ( containsBanana ) { exerciseRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } } } case <NUM_LIT> -> { LambdaQueryWrapper < Option > optionLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; optionLambdaQueryWrapper . eq ( Option :: getId , exerciseRecord . getAnswer ( ) ) ; Option op1 = optionMapper . selectOne ( optionLambdaQueryWrapper ) ; exerciseRecordDetailVO . setMyOption ( Integer . toString ( op1 . getSort ( ) ) ) ; Option byId = optionService . getById ( exerciseRecord . getAnswer ( ) ) ; if ( byId . getIsRight ( ) == <NUM_LIT> ) { exerciseRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } else { exerciseRecordDetailVO . setIsRight ( <NUM_LIT> ) ; } } case <NUM_LIT> -> { exerciseRecordDetailVO . setMyOption ( null ) ; exerciseRecordDetailVO . setIsRight ( - <NUM_LIT> ) ; } default -> { } } exerciseRecordDetailVOS . add ( exerciseRecordDetailVO ) ; } return Result . success ( \"<STR_LIT>\" , exerciseRecordDetailVOS ) ; } @ Override @ Transactional public Result < QuestionVO > fillAnswer ( ExerciseFillAnswerFrom exerciseFillAnswerFrom ) { ExerciseRecord exerciseRecord = exerciseConverter . fromToEntity ( exerciseFillAnswerFrom ) ; boolean flag = true ; exerciseRecord . setIsRight ( <NUM_LIT> ) ; if ( exerciseFillAnswerFrom . getQuType ( ) != <NUM_LIT> ) { List < Integer > options = Arrays . stream ( exerciseRecord . getAnswer ( ) . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; List < Integer > rightOptions = new ArrayList < > ( ) ; optionMapper . selectAllByQuestionId ( exerciseRecord . getQuestionId ( ) ) . forEach ( option -> { if ( option . getIsRight ( ) == <NUM_LIT> ) { rightOptions . add ( option . getId ( ) ) ; } } ) ; if ( options . size ( ) != rightOptions . size ( ) ) { flag = false ; } else { for ( Integer option : options ) { if ( ! rightOptions . contains ( option ) ) { flag = false ; exerciseRecord . setIsRight ( <NUM_LIT> ) ; break ; } } } } if ( flag ) { exerciseRecord . setIsRight ( <NUM_LIT> ) ; } else { exerciseRecord . setIsRight ( <NUM_LIT> ) ; } LambdaQueryWrapper < ExerciseRecord > exerciseRecordLambdaQueryWrapper = new LambdaQueryWrapper < ExerciseRecord > ( ) . eq ( ExerciseRecord :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( ExerciseRecord :: getRepoId , exerciseRecord . getRepoId ( ) ) . eq ( ExerciseRecord :: getQuestionId , exerciseRecord . getQuestionId ( ) ) ; ExerciseRecord databaseExerciseRecord = exerciseRecordMapper . selectOne ( exerciseRecordLambdaQueryWrapper ) ; boolean exercised = Optional . ofNullable ( databaseExerciseRecord ) . isEmpty ( ) ; if ( exercised ) { exerciseRecordMapper . insert ( exerciseRecord ) ; LambdaQueryWrapper < UserExerciseRecord > exerciseRecordWrapper = new LambdaQueryWrapper < UserExerciseRecord > ( ) . eq ( UserExerciseRecord :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( UserExerciseRecord :: getRepoId , exerciseRecord . getRepoId ( ) ) ; UserExerciseRecord userExerciseRecord = userExerciseRecordMapper . selectOne ( exerciseRecordWrapper ) ; if ( Optional . ofNullable ( userExerciseRecord ) . isEmpty ( ) ) { LambdaQueryWrapper < Question > questionWrapper = new LambdaQueryWrapper < Question > ( ) . eq ( Question :: getRepoId , exerciseRecord . getRepoId ( ) ) ; int totalCount = questionMapper . selectCount ( questionWrapper ) . intValue ( ) ; UserExerciseRecord insertUserExerciseRecord = new UserExerciseRecord ( ) ; insertUserExerciseRecord . setExerciseCount ( <NUM_LIT> ) ; insertUserExerciseRecord . setRepoId ( exerciseRecord . getRepoId ( ) ) ; insertUserExerciseRecord . setTotalCount ( totalCount ) ; userExerciseRecordMapper . insert ( insertUserExerciseRecord ) ; } else { LambdaQueryWrapper < Question > wrapper = new LambdaQueryWrapper < Question > ( ) . eq ( Question :: getId , exerciseRecord . getRepoId ( ) ) ; UserExerciseRecord updateUserExerciseRecord = new UserExerciseRecord ( ) ; updateUserExerciseRecord . setTotalCount ( questionMapper . selectCount ( wrapper ) . intValue ( ) ) ; updateUserExerciseRecord . setId ( userExerciseRecord . getId ( ) ) ; updateUserExerciseRecord . setExerciseCount ( userExerciseRecord . getExerciseCount ( ) + <NUM_LIT> ) ; userExerciseRecordMapper . updateById ( updateUserExerciseRecord ) ; } } else { exerciseRecord . setId ( databaseExerciseRecord . getId ( ) ) ; exerciseRecordMapper . updateById ( exerciseRecord ) ; } QuestionVO questionVO = questionMapper . selectSingle ( exerciseRecord . getQuestionId ( ) ) ; if ( exerciseRecord . getQuestionType ( ) == <NUM_LIT> ) { return Result . success ( null , questionVO ) ; } return flag ? Result . success ( \"<STR_LIT>\" , questionVO ) : Result . success ( \"<STR_LIT>\" , questionVO ) ; } @ Override public Result < QuestionVO > getSingle ( Integer id ) { QuestionVO questionVO = questionMapper . selectDetail ( id ) ; return Result . success ( \"<STR_LIT>\" , questionVO ) ; } @ Override public Result < AnswerInfoVO > getAnswerInfo ( Integer repoId , Integer quId ) { QuestionVO questionVO = questionMapper . selectSingle ( quId ) ; AnswerInfoVO answerInfoVO = exerciseConverter . quVOToAnswerInfoVO ( questionVO ) ; LambdaQueryWrapper < ExerciseRecord > exerciseRecordLambdaQueryWrapper = new LambdaQueryWrapper < ExerciseRecord > ( ) . eq ( ExerciseRecord :: getRepoId , repoId ) . eq ( ExerciseRecord :: getQuestionId , quId ) . eq ( ExerciseRecord :: getUserId , SecurityUtil . getUserId ( ) ) ; ExerciseRecord exerciseRecord = exerciseRecordMapper . selectOne ( exerciseRecordLambdaQueryWrapper ) ; answerInfoVO . setAnswerContent ( exerciseRecord . getAnswer ( ) ) ; return exerciseRecord . getIsRight ( ) == <NUM_LIT> ? Result . success ( \"<STR_LIT>\" , answerInfoVO ) : Result . success ( \"<STR_LIT>\" , answerInfoVO ) ; } }"}, {"input": "package org . springblade . feign ; import org . springblade . model . MatchExchangeAddParam ; import org . springblade . model . MatchExchangeDelParam ; import org . springblade . model . MatchExchangeRefreshParam ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjMatchClient { String API_PREFIX = \"<STR_LIT>\" ; String MATCH_ADD_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_DEL_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String MATCH_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; String JOB_RESET_REDIS = API_PREFIX + \"<STR_LIT>\" ; String JOB_REFRESH_EXCHANGE = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( MATCH_ADD_EXCHANGE ) void addExchange ( @ RequestBody MatchExchangeAddParam param ) ; @ PostMapping ( MATCH_DEL_EXCHANGE ) void delExchange ( @ RequestBody MatchExchangeDelParam param ) ; @ PostMapping ( MATCH_REFRESH_EXCHANGE ) void refreshExchange ( @ RequestBody MatchExchangeRefreshParam param ) ; @ PostMapping ( JOB_RESET_REDIS ) void resetRedis ( ) ;", "output": "@ PostMapping ( JOB_REFRESH_EXCHANGE ) void jobRefreshExchange ( ) ; }"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentHashSet < E > extends AbstractSet < E > implements Set < E > , java . io . Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final Map < E , Boolean > m ; private transient Set < E > s ; public ConcurrentHashSet ( ) { m = new ConcurrentHashMap < E , Boolean > ( ) ; s = m . keySet ( ) ; } public void clear ( ) { m . clear ( ) ; } public int size ( ) { return m . size ( ) ; } public boolean isEmpty ( ) { return m . isEmpty ( ) ; } public boolean contains ( Object o ) { return m . containsKey ( o ) ; } public boolean remove ( Object o ) { return m . remove ( o ) != null ; } public boolean add ( E e ) { return m . put ( e , Boolean . TRUE ) == null ; } public Iterator < E > iterator ( ) { return s . iterator ( ) ; } public Object [ ] toArray ( ) { return s . toArray ( ) ; } public < T > T [ ] toArray ( T [ ] a ) { return s . toArray ( a ) ; } @ Override public String toString ( ) { return s . toString ( ) ; } public int hashCode ( ) { return s . hashCode ( ) ; } public boolean equals ( Object o ) { return o == this || s . equals ( o ) ; } public boolean containsAll ( Collection < ? > c ) { return s . containsAll ( c ) ; } public boolean removeAll ( Collection < ? > c ) { return s . removeAll ( c ) ; }", "output": "public boolean retainAll ( Collection < ? > c ) { return s . retainAll ( c ) ; } }"}, {"input": "package com . oddfar . campus . common . utils . ip ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import javax . servlet . http . HttpServletRequest ; import java . net . InetAddress ; import java . net . UnknownHostException ; public class IpUtils { public final static String REGX_0_255 = \"<STR_LIT>\" ; public final static String REGX_IP = \"<STR_LIT>\" + REGX_0_255 + \"<STR_LIT>\" + REGX_0_255 + \"<STR_LIT>\" ; public final static String REGX_IP_WILDCARD = \"<STR_LIT>\" + REGX_0_255 + \"<STR_LIT>\" + REGX_0_255 + \"<STR_LIT>\" + REGX_0_255 + \"<STR_LIT>\" + \"<STR_LIT>\" + REGX_0_255 + \"<STR_LIT>\" ; public final static String REGX_IP_SEG = \"<STR_LIT>\" + REGX_IP + \"<STR_LIT>\" + REGX_IP + \"<STR_LIT>\" ; public static String getIpAddr ( ) { return getIpAddr ( ServletUtils . getRequest ( ) ) ; } public static String getIpAddr ( HttpServletRequest request ) { if ( request == null ) { return \"<STR_LIT>\" ; } String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : getMultistageReverseProxyIp ( ip ) ; } public static boolean internalIp ( String ip ) { byte [ ] addr = textToNumericFormatV4 ( ip ) ; return internalIp ( addr ) || \"<STR_LIT>\" . equals ( ip ) ; } private static boolean internalIp ( byte [ ] addr ) { if ( StringUtils . isNull ( addr ) || addr . length < <NUM_LIT> ) { return true ; } final byte b0 = addr [ <NUM_LIT> ] ; final byte b1 = addr [ <NUM_LIT> ] ; final byte SECTION_1 = <NUM_LIT> ; final byte SECTION_2 = ( byte ) <NUM_LIT> ; final byte SECTION_3 = ( byte ) <NUM_LIT> ; final byte SECTION_4 = ( byte ) <NUM_LIT> ; final byte SECTION_5 = ( byte ) <NUM_LIT> ; final byte SECTION_6 = ( byte ) <NUM_LIT> ; switch ( b0 ) { case SECTION_1 : return true ; case SECTION_2 : if ( b1 >= SECTION_3 && b1 <= SECTION_4 ) { return true ; } case SECTION_5 : switch ( b1 ) { case SECTION_6 : return true ; } default : return false ; } } public static byte [ ] textToNumericFormatV4 ( String text ) { if ( text . length ( ) == <NUM_LIT> ) { return null ; } byte [ ] bytes = new byte [ <NUM_LIT> ] ; String [ ] elements = text . split ( \"<STR_LIT>\" , - <NUM_LIT> ) ; try { long l ; int i ; switch ( elements . length ) { case <NUM_LIT> : l = Long . parseLong ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( ( l & <NUM_LIT> ) > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( ( l & <NUM_LIT> ) > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; break ; case <NUM_LIT> : l = Integer . parseInt ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; l = Integer . parseInt ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( ( l & <NUM_LIT> ) > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; break ; case <NUM_LIT> : for ( i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { l = Integer . parseInt ( elements [ i ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ i ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; } l = Integer . parseInt ( elements [ <NUM_LIT> ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l > > <NUM_LIT> & <NUM_LIT> ) ; bytes [ <NUM_LIT> ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; break ; case <NUM_LIT> : for ( i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { l = Integer . parseInt ( elements [ i ] ) ; if ( ( l < <NUM_LIT> ) || ( l > <NUM_LIT> ) ) { return null ; } bytes [ i ] = ( byte ) ( int ) ( l & <NUM_LIT> ) ; } break ; default : return null ; } } catch ( NumberFormatException e ) { return null ; } return bytes ; } public static String getHostIp ( ) { try { return InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { } return \"<STR_LIT>\" ; } public static String getHostName ( ) { try { return InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { } return \"<STR_LIT>\" ; } public static String getMultistageReverseProxyIp ( String ip ) { if ( ip != null && ip . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) { final String [ ] ips = ip . trim ( ) . split ( \"<STR_LIT>\" ) ; for ( String subIp : ips ) { if ( false == isUnknown ( subIp ) ) { ip = subIp ; break ; } } } return StringUtils . substring ( ip , <NUM_LIT> , <NUM_LIT> ) ; } public static boolean isUnknown ( String checkString ) { return StringUtils . isBlank ( checkString ) || \"<STR_LIT>\" . equalsIgnoreCase ( checkString ) ; } public static boolean isIP ( String ip ) { return StringUtils . isNotBlank ( ip ) && ip . matches ( REGX_IP ) ; } public static boolean isIpWildCard ( String ip ) { return StringUtils . isNotBlank ( ip ) && ip . matches ( REGX_IP_WILDCARD ) ; } public static boolean ipIsInWildCardNoCheck ( String ipWildCard , String ip ) { String [ ] s1 = ipWildCard . split ( \"<STR_LIT>\" ) ; String [ ] s2 = ip . split ( \"<STR_LIT>\" ) ; boolean isMatchedSeg = true ; for ( int i = <NUM_LIT> ; i < s1 . length && ! s1 [ i ] . equals ( \"<STR_LIT>\" ) ; i ++ ) { if ( ! s1 [ i ] . equals ( s2 [ i ] ) ) { isMatchedSeg = false ; break ; } } return isMatchedSeg ; } public static boolean isIPSegment ( String ipSeg ) { return StringUtils . isNotBlank ( ipSeg ) && ipSeg . matches ( REGX_IP_SEG ) ; } public static boolean ipIsInNetNoCheck ( String iparea , String ip ) { int idx = iparea . indexOf ( '<STR_LIT>' ) ; String [ ] sips = iparea . substring ( <NUM_LIT> , idx ) . split ( \"<STR_LIT>\" ) ; String [ ] sipe = iparea . substring ( idx + <NUM_LIT> ) . split ( \"<STR_LIT>\" ) ; String [ ] sipt = ip . split ( \"<STR_LIT>\" ) ; long ips = <NUM_LIT> , ipe = <NUM_LIT> , ipt = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { ips = ips << <NUM_LIT> | Integer . parseInt ( sips [ i ] ) ; ipe = ipe << <NUM_LIT> | Integer . parseInt ( sipe [ i ] ) ;", "output": "ipt = ipt << <NUM_LIT> | Integer . parseInt ( sipt [ i ] ) ; } if ( ips > ipe ) { long t = ips ; ips = ipe ; ipe = t ; } return ips <= ipt && ipt <= ipe ; } public static boolean isMatchedIp ( String filter , String ip ) { if ( StringUtils . isEmpty ( filter ) || StringUtils . isEmpty ( ip ) ) { return false ; } String [ ] ips = filter . split ( \"<STR_LIT>\" ) ; for ( String iStr : ips ) { if ( isIP ( iStr ) && iStr . equals ( ip ) ) { return true ; } else if ( isIpWildCard ( iStr ) && ipIsInWildCardNoCheck ( iStr , ip ) ) { return true ; } else if ( isIPSegment ( iStr ) && ipIsInNetNoCheck ( iStr , ip ) ) { return true ; } } return false ; } }"}, {"input": "package org . springblade . config . util ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . CgformEnhanceJs ; import org . springblade . cgform . entity . CgformField ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import java . util . Iterator ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class EnhanceJsUtil { private static final String actions = \"<STR_LIT>\" ; private static final String interval = \"<STR_LIT>\" ; private static final String separator = \"<STR_LIT>\" ; public static String getCgJs ( String cgJs , String buttonCode ) { String buttonCodeStr = \"<STR_LIT>\" + buttonCode + \"<STR_LIT>\" ; String functionStr = buttonCode + \"<STR_LIT>\" ; String jsFunctionStr = getJsFunction ( cgJs , interval + buttonCodeStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunctionStr == null ) { cgJs = getRegexCgJs ( cgJs , buttonCodeStr , functionStr ) ; } else { cgJs = jsFunctionStr ; } cgJs = getCgJs ( cgJs , buttonCode , null ) ; return cgJs ; } public static String getCgJs ( String cgJs , String buttonCode , String s ) { String s1 = \"<STR_LIT>\" + ConvertUtils . getString ( s ) + buttonCode + \"<STR_LIT>\" ; String s2 = buttonCode + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + s1 , \"<STR_LIT>\" + s2 ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , s1 , s2 ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getJsFunction ( String cgJs , String regex , String s2 ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { cgJs = cgJs . replace ( matcher . group ( <NUM_LIT> ) , s2 ) ; return cgJs ; } else { return null ; } } public static String getRegexCgJs ( String cgJs , String regex , String s1 ) { String jsFunction = getJsFunction ( cgJs , regex , s1 ) ; return jsFunction != null ? jsFunction : cgJs ; } public static String getJsFunction ( String cgJs , String dbFieldName ) { String dbFieldNameStr = \"<STR_LIT>\" + dbFieldName + \"<STR_LIT>\" ; String functionStr = dbFieldName + \"<STR_LIT>\" ; String jsFunction = getJsFunction ( cgJs , interval + dbFieldNameStr , \"<STR_LIT>\" + functionStr ) ; if ( jsFunction == null ) { cgJs = getRegexCgJs ( cgJs , dbFieldNameStr , functionStr ) ; } else { cgJs = jsFunction ; } return cgJs ; } public static String getCgJs ( String cgJs ) { String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getJsFunction ( String cgJs , List < CgformButton > onlCgformButtonList ) { cgJs = getCgJs ( cgJs , onlCgformButtonList ) ; String js = \"<STR_LIT>\" + cgJs + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , js ) ; return js ; } public static String getCgJs ( String cgJs , List < CgformButton > buttons ) { if ( buttons != null ) { Iterator < CgformButton > iterator = buttons . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformButton button = iterator . next ( ) ; String code = button . getButtonCode ( ) ; if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code ) ; } else if ( \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) || \"<STR_LIT>\" . equals ( button . getButtonStyle ( ) ) ) { cgJs = getCgJs ( cgJs , code , null ) ; } } } String [ ] actionArr = actions . split ( separator ) ; int length = actionArr . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String action = actionArr [ i ] ; if ( \"<STR_LIT>\" . indexOf ( action ) >= <NUM_LIT> ) { cgJs = getCgJs ( cgJs , action , null ) ; } else { cgJs = getCgJs ( cgJs , action ) ; } }", "output": "return cgJs ; } public static void enhanceJs ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } String cgJs = \"<STR_LIT>\" + onlCgformEnhanceJs . getCgJs ( ) ; log . info ( \"<STR_LIT>\" + cgJs ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" ) ; cgJs = getCgJs ( cgJs , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } } log . info ( \"<STR_LIT>\" + cgJs ) ; onlCgformEnhanceJs . setCgJs ( cgJs ) ; } public static void getJsFunction ( CgformEnhanceJs onlCgformEnhanceJs , String var1 , List < CgformField > fields ) { if ( Func . isEmpty ( onlCgformEnhanceJs ) || Func . isEmpty ( onlCgformEnhanceJs . getCgJs ( ) ) ) { return ; } log . info ( \"<STR_LIT>\" + onlCgformEnhanceJs ) ; String cgJs = onlCgformEnhanceJs . getCgJs ( ) ; String onlChangeStr = var1 + \"<STR_LIT>\" + \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" + onlChangeStr + \"<STR_LIT>\" ) ; Matcher matcher = pattern . matcher ( cgJs ) ; if ( matcher . find ( ) ) { log . info ( \"<STR_LIT>\" + onlChangeStr ) ; cgJs = getCgJs ( cgJs , onlChangeStr , null ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField formField = iterator . next ( ) ; cgJs = getJsFunction ( cgJs , formField . getDbFieldName ( ) ) ; } } log . info ( \"<STR_LIT>\" + cgJs ) ; onlCgformEnhanceJs . setCgJs ( cgJs ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import io . github . chensheng . dddboot . nacos . spring . annotation . AnnotationNacosInjectedBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingMaintainServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . annotation . NamingServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosConfigListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . NacosValueAnnotationBeanPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . LoggingNacosConfigMetadataEventListener ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBindingPostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . AnnotationNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . env . XmlNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . factory . ApplicationContextHolder ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . context . constants . NacosConstants ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . config . SingletonBeanRegistry ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . support . AbstractApplicationContext ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import java . lang . reflect . Constructor ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . atomic . AtomicInteger ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveProperties ; public abstract class NacosBeanUtils { public static final String PLACEHOLDER_CONFIGURER_BEAN_NAME = \"<STR_LIT>\" ; public static final String GLOBAL_NACOS_PROPERTIES_BEAN_NAME = \"<STR_LIT>\" ; public static final String CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME = GLOBAL_NACOS_PROPERTIES_BEAN_NAME + \"<STR_LIT>\" ; public static final String NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME = \"<STR_LIT>\" ; public static final String IGNORE_RESOURCE_NOT_FOUND = \"<STR_LIT>\" ; public static final String IGNORE_UNRESOLVABLE_PLACEHOLDERS = \"<STR_LIT>\" ; public static void registerSingleton ( BeanDefinitionRegistry registry , String beanName , Object singletonObject ) { SingletonBeanRegistry beanRegistry = null ; if ( registry instanceof SingletonBeanRegistry ) { beanRegistry = ( SingletonBeanRegistry ) registry ; } else if ( registry instanceof AbstractApplicationContext ) { beanRegistry = ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } if ( beanRegistry != null ) { if ( ! beanRegistry . containsSingleton ( beanName ) ) { beanRegistry . registerSingleton ( beanName , singletonObject ) ; } } } public static void registerInfrastructureBean ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder . rootBeanDefinition ( beanClass ) ; for ( Object constructorArg : constructorArgs ) { beanDefinitionBuilder . addConstructorArgValue ( constructorArg ) ; } beanDefinitionBuilder . setRole ( BeanDefinition . ROLE_INFRASTRUCTURE ) ; registry . registerBeanDefinition ( beanName , beanDefinitionBuilder . getBeanDefinition ( ) ) ; } public static void registerInfrastructureBeanIfAbsent ( BeanDefinitionRegistry registry , String beanName , Class < ? > beanClass , Object ... constructorArgs ) { if ( ! isBeanDefinitionPresent ( registry , beanName , beanClass ) && ! registry . containsBeanDefinition ( beanName ) ) { registerInfrastructureBean ( registry , beanName , beanClass , constructorArgs ) ; } } public static BeanFactory resolveBeanFactory ( BeanDefinitionRegistry registry ) { if ( registry instanceof BeanFactory ) { return ( BeanFactory ) registry ; } if ( registry instanceof AbstractApplicationContext ) { return ( ( AbstractApplicationContext ) registry ) . getBeanFactory ( ) ; } return null ; } public static boolean isBeanDefinitionPresent ( BeanDefinitionRegistry registry , String beanName , Class < ? > targetBeanClass ) { String [ ] beanNames = BeanUtils . getBeanNames ( ( ListableBeanFactory ) registry , targetBeanClass ) ; return ArrayUtils . contains ( beanNames , beanName ) ; } public static void registerPropertySourcesPlaceholderConfigurer ( BeanDefinitionRegistry registry , BeanFactory beanFactory ) { registerInfrastructureBeanIfAbsent ( registry , PLACEHOLDER_CONFIGURER_BEAN_NAME , PropertySourcesPlaceholderConfigurer . class ) ; boolean ignoreResourceNotFound = Boolean . parseBoolean ( System . getProperty ( IGNORE_RESOURCE_NOT_FOUND ) ) ; boolean ignoreUnresolvablePlaceholders = Boolean . parseBoolean ( System . getProperty ( IGNORE_UNRESOLVABLE_PLACEHOLDERS ) ) ; if ( ignoreResourceNotFound || ignoreUnresolvablePlaceholders ) { PropertySourcesPlaceholderConfigurer configurer = ( PropertySourcesPlaceholderConfigurer ) beanFactory . getBean ( NacosBeanUtils . PLACEHOLDER_CONFIGURER_BEAN_NAME ) ; if ( configurer != null ) { configurer . setIgnoreResourceNotFound ( ignoreResourceNotFound ) ; configurer . setIgnoreUnresolvablePlaceholders ( ignoreUnresolvablePlaceholders ) ; } } } public static void registerGlobalNacosProperties ( AnnotationAttributes attributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { if ( attributes == null ) { return ; } AnnotationAttributes globalPropertiesAttributes = attributes . getAnnotation ( \"<STR_LIT>\" ) ; registerGlobalNacosProperties ( ( Map < ? , ? > ) globalPropertiesAttributes , registry , propertyResolver , beanName ) ; } public static void registerGlobalNacosProperties ( Map < ? , ? > globalPropertiesAttributes , BeanDefinitionRegistry registry , PropertyResolver propertyResolver , String beanName ) { Properties globalProperties = resolveProperties ( globalPropertiesAttributes , propertyResolver ) ; registerSingleton ( registry , beanName , globalProperties ) ; } public static void registerNacosApplicationContextHolder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static void registerNacosConfigPropertiesBindingPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigurationPropertiesBindingPostProcessor . BEAN_NAME , NacosConfigurationPropertiesBindingPostProcessor . class ) ; } public static void registerNacosConfigListenerMethodProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosConfigListenerMethodProcessor . BEAN_NAME , NacosConfigListenerMethodProcessor . class ) ; } public static void registerNacosPropertySourcePostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; } public static void registerAnnotationNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosPropertySourceBuilder . BEAN_NAME , AnnotationNacosPropertySourceBuilder . class ) ; } public static void registerXmlNacosPropertySourceBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , XmlNacosPropertySourceBuilder . BEAN_NAME , XmlNacosPropertySourceBuilder . class ) ; } public static void registerNacosConfigListenerExecutor ( BeanDefinitionRegistry registry , Environment environment ) { final String beanName = NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ; if ( registry instanceof BeanFactory && ( ( BeanFactory ) registry ) . containsBean ( beanName ) ) { return ; } ExecutorService nacosConfigListenerExecutor = buildNacosConfigListenerExecutor ( environment ) ; registerSingleton ( registry , beanName , nacosConfigListenerExecutor ) ; } private static ExecutorService buildNacosConfigListenerExecutor ( Environment environment ) { int parallelism = getParallelism ( environment ) ; return Executors . newFixedThreadPool ( parallelism , new ThreadFactory ( ) { private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; @ Override public Thread newThread ( Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( \"<STR_LIT>\" + threadNumber . getAndIncrement ( ) ) ; return thread ; } } ) ; } private static int getParallelism ( Environment environment ) { int parallelism = environment . getProperty ( NacosConstants . NACOS_CONFIG_LISTENER_PARALLELISM , int . class , NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM ) ; return parallelism < <NUM_LIT> ? NacosConstants . DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM : parallelism ; } public static void registerNacosValueAnnotationBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NacosValueAnnotationBeanPostProcessor . BEAN_NAME , NacosValueAnnotationBeanPostProcessor . class ) ; } public static void registerNacosCommonBeans ( BeanDefinitionRegistry registry ) { registerNacosApplicationContextHolder ( registry ) ; registerAnnotationNacosInjectedBeanPostProcessor ( registry ) ; } public static void registerNacosConfigBeans ( BeanDefinitionRegistry registry , Environment environment , BeanFactory beanFactory ) { registerPropertySourcesPlaceholderConfigurer ( registry , beanFactory ) ; registerNacosConfigPropertiesBindingPostProcessor ( registry ) ; registerNacosConfigListenerMethodProcessor ( registry ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerAnnotationNacosPropertySourceBuilder ( registry ) ; registerNacosConfigListenerExecutor ( registry , environment ) ; registerNacosValueAnnotationBeanPostProcessor ( registry ) ; registerConfigServiceBeanBuilder ( registry ) ; registerLoggingNacosConfigMetadataEventListener ( registry ) ; } public static void invokeNacosPropertySourcePostProcessor ( BeanFactory beanFactory ) { NacosPropertySourcePostProcessor postProcessor = beanFactory . getBean ( NacosPropertySourcePostProcessor . BEAN_NAME , NacosPropertySourcePostProcessor . class ) ; postProcessor . postProcessBeanFactory ( ( ConfigurableListableBeanFactory ) beanFactory ) ; } private static void registerLoggingNacosConfigMetadataEventListener ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , LoggingNacosConfigMetadataEventListener . BEAN_NAME , LoggingNacosConfigMetadataEventListener . class ) ; } public static void registerNacosDiscoveryBeans ( BeanDefinitionRegistry registry ) { registerNamingServiceBeanBuilder ( registry ) ; registerNamingMaintainServiceBeanBuilder ( registry ) ; } private static void registerAnnotationNacosInjectedBeanPostProcessor ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , AnnotationNacosInjectedBeanPostProcessor . BEAN_NAME , AnnotationNacosInjectedBeanPostProcessor . class ) ; } private static void registerConfigServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ;", "output": "} private static void registerNamingServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } private static void registerNamingMaintainServiceBeanBuilder ( BeanDefinitionRegistry registry ) { registerInfrastructureBeanIfAbsent ( registry , NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ; } public static Properties getGlobalPropertiesBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME , Properties . class ) ; } public static NacosServiceFactory getNacosServiceFactoryBean ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { if ( null == beanFactory ) { return getNacosServiceFactoryBean ( ) ; } ApplicationContextHolder applicationContextHolder = getApplicationContextHolder ( beanFactory ) ; CacheableEventPublishingNacosServiceFactory nacosServiceFactory = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; nacosServiceFactory . setApplicationContext ( applicationContextHolder . getApplicationContext ( ) ) ; return nacosServiceFactory ; } public static NacosServiceFactory getNacosServiceFactoryBean ( ) throws NoSuchBeanDefinitionException { return CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; } public static ApplicationContextHolder getApplicationContextHolder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( ApplicationContextHolder . BEAN_NAME , ApplicationContextHolder . class ) ; } public static ExecutorService getNacosConfigListenerExecutorIfPresent ( BeanFactory beanFactory ) { if ( ! beanFactory . containsBean ( NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME ) ) { return null ; } return beanFactory . getBean ( NACOS_CONFIG_LISTENER_EXECUTOR_BEAN_NAME , ExecutorService . class ) ; } public static ConfigServiceBeanBuilder getConfigServiceBeanBuilder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( ConfigServiceBeanBuilder . BEAN_NAME , ConfigServiceBeanBuilder . class ) ; } public static NamingServiceBeanBuilder getNamingServiceBeanBuilder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( NamingServiceBeanBuilder . BEAN_NAME , NamingServiceBeanBuilder . class ) ; } public static NamingMaintainServiceBeanBuilder getNamingMaintainServiceBeanBuilder ( BeanFactory beanFactory ) throws NoSuchBeanDefinitionException { return beanFactory . getBean ( NamingMaintainServiceBeanBuilder . BEAN_NAME , NamingMaintainServiceBeanBuilder . class ) ; } }"}, {"input": "package com . yf . system . modules . menu . dto . response ; import com . yf . base . api . annon . Dict ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MenuTreeRespDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String parentId ; @ Dict ( dicCode = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer menuType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String permissionTag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String component ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String redirect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String metaActiveMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean metaNoCache ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean hidden ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < MenuTreeRespDTO > children ;", "output": "}"}, {"input": "package org . springblade . common . aspect ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . ActionLogEvent ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class ActionAspect { @ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) {", "output": "} @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable { for ( Object arg : point . getArgs ( ) ) { if ( arg instanceof Map ) { SpringUtil . publishEvent ( new ActionLogEvent ( arg ) ) ; } } return point . proceed ( ) ; } }"}, {"input": "package com . oddfar . campus . framework . security . filter ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . web . WebFrameworkUtils ; import com . oddfar . campus . framework . web . service . TokenService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . web . authentication . WebAuthenticationDetailsSource ; import org . springframework . stereotype . Component ; import org . springframework . web . filter . OncePerRequestFilter ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Component public class JwtAuthenticationTokenFilter extends OncePerRequestFilter { @ Autowired private TokenService tokenService ; @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain chain ) throws ServletException , IOException { LoginUser loginUser = tokenService . getLoginUser ( request ) ; if ( StringUtils . isNotNull ( loginUser ) && StringUtils . isNull ( SecurityUtils . getAuthentication ( ) ) ) { setLoginUser ( loginUser , request ) ; tokenService . verifyToken ( loginUser ) ; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( loginUser , null , loginUser . getAuthorities ( ) ) ; authenticationToken . setDetails ( new WebAuthenticationDetailsSource ( ) . buildDetails ( request ) ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authenticationToken ) ; } chain . doFilter ( request , response ) ; }", "output": "public static void setLoginUser ( LoginUser loginUser , HttpServletRequest request ) { WebFrameworkUtils . setLoginUserId ( request , loginUser . getUserId ( ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ConfigurableApplicationContext ; public class ApplicationContextHolder implements ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private ConfigurableApplicationContext context ; public ConfigurableApplicationContext getApplicationContext ( ) { return context ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { context = ( ConfigurableApplicationContext ) applicationContext ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosDiscoveryBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware { private Environment environment ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacosDiscovery . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerGlobalNacosProperties ( attributes , registry , environment , MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosDiscoveryBeans ( registry ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ;", "output": "} }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . form . Auth . LoginForm ; import cn . org . alan . exam . model . form . UserForm ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . servlet . http . HttpServletResponse ; public interface IAuthService { Result < String > login ( HttpServletRequest request , LoginForm loginForm ) ; Result < String > logout ( HttpServletRequest request ) ;", "output": "void getCaptcha ( HttpServletRequest request , HttpServletResponse response ) ; Result < String > verifyCode ( HttpServletRequest request , String code ) ; Result < String > register ( HttpServletRequest request , UserForm userForm ) ; Result < String > sendHeartbeat ( HttpServletRequest request ) ; }"}, {"input": "package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollUtil ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . security . service . dto . AuthorityDto ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . mapper . RoleDeptMapper ; import me . zhengjie . modules . system . mapper . RoleMapper ; import me . zhengjie . modules . system . mapper . RoleMenuMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import me . zhengjie . utils . * ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class RoleServiceImpl extends ServiceImpl < RoleMapper , Role > implements RoleService { private final RoleMapper roleMapper ; private final RoleDeptMapper roleDeptMapper ; private final RoleMenuMapper roleMenuMapper ; private final RedisUtils redisUtils ; private final UserMapper userMapper ; private final UserCacheManager userCacheManager ; @ Override public List < Role > queryAll ( ) { return roleMapper . queryAll ( ) ; } @ Override public List < Role > queryAll ( RoleQueryCriteria criteria ) { return roleMapper . findAll ( criteria ) ; } @ Override public PageResult < Role > queryAll ( RoleQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < Role > roles = roleMapper . findAll ( criteria ) ; Long total = roleMapper . countAll ( criteria ) ; return PageUtil . toPage ( roles , total ) ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public Role findById ( long id ) { return roleMapper . findById ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Role resources ) { if ( roleMapper . findByName ( resources . getName ( ) ) != null ) { throw new EntityExistException ( Role . class , \"<STR_LIT>\" , resources . getName ( ) ) ; } save ( resources ) ; if ( CollectionUtil . isNotEmpty ( resources . getDepts ( ) ) ) { roleDeptMapper . insertData ( resources . getId ( ) , resources . getDepts ( ) ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Role resources ) { Role role = getById ( resources . getId ( ) ) ; Role role1 = roleMapper . findByName ( resources . getName ( ) ) ; if ( role1 != null && ! role1 . getId ( ) . equals ( role . getId ( ) ) ) { throw new EntityExistException ( Role . class , \"<STR_LIT>\" , resources . getName ( ) ) ; } role . setName ( resources . getName ( ) ) ; role . setDescription ( resources . getDescription ( ) ) ; role . setDataScope ( resources . getDataScope ( ) ) ; role . setDepts ( resources . getDepts ( ) ) ; role . setLevel ( resources . getLevel ( ) ) ; saveOrUpdate ( role ) ; roleDeptMapper . deleteByRoleId ( resources . getId ( ) ) ; if ( CollectionUtil . isNotEmpty ( resources . getDepts ( ) ) ) { roleDeptMapper . insertData ( resources . getId ( ) , resources . getDepts ( ) ) ; } delCaches ( role . getId ( ) , null ) ; } @ Override public void updateMenu ( Role role ) { List < User > users = userMapper . findByRoleId ( role . getId ( ) ) ; roleMenuMapper . deleteByRoleId ( role . getId ( ) ) ; if ( CollUtil . isNotEmpty ( role . getMenus ( ) ) ) { roleMenuMapper . insertData ( role . getId ( ) , role . getMenus ( ) ) ; } delCaches ( role . getId ( ) , users ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { for ( Long id : ids ) { delCaches ( id , null ) ; } removeBatchByIds ( ids ) ; roleDeptMapper . deleteByRoleIds ( ids ) ; roleMenuMapper . deleteByRoleIds ( ids ) ; } @ Override public List < Role > findByUsersId ( Long userId ) { return roleMapper . findByUserId ( userId ) ;", "output": "} @ Override public Integer findByRoles ( Set < Role > roles ) { if ( roles . size ( ) == <NUM_LIT> ) { return Integer . MAX_VALUE ; } Set < Role > roleSet = new HashSet < > ( ) ; for ( Role role : roles ) { roleSet . add ( findById ( role . getId ( ) ) ) ; } return Collections . min ( roleSet . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ) ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public List < AuthorityDto > mapToGrantedAuthorities ( User user ) { Set < String > permissions = new HashSet < > ( ) ; if ( user . getIsAdmin ( ) ) { permissions . add ( \"<STR_LIT>\" ) ; return permissions . stream ( ) . map ( AuthorityDto :: new ) . collect ( Collectors . toList ( ) ) ; } List < Role > roles = roleMapper . findByUserId ( user . getId ( ) ) ; permissions = roles . stream ( ) . flatMap ( role -> role . getMenus ( ) . stream ( ) ) . map ( Menu :: getPermission ) . filter ( StringUtils :: isNotBlank ) . collect ( Collectors . toSet ( ) ) ; return permissions . stream ( ) . map ( AuthorityDto :: new ) . collect ( Collectors . toList ( ) ) ; } @ Override public void download ( List < Role > roles , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Role role : roles ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , role . getName ( ) ) ; map . put ( \"<STR_LIT>\" , role . getLevel ( ) ) ; map . put ( \"<STR_LIT>\" , role . getDescription ( ) ) ; map . put ( \"<STR_LIT>\" , role . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public void verification ( Set < Long > ids ) { if ( userMapper . countByRoles ( ids ) > <NUM_LIT> ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } @ Override public List < Role > findByMenuId ( Long menuId ) { return roleMapper . findByMenuId ( menuId ) ; } public void delCaches ( Long id , List < User > users ) { users = CollectionUtil . isEmpty ( users ) ? userMapper . findByRoleId ( id ) : users ; if ( CollectionUtil . isNotEmpty ( users ) ) { users . forEach ( item -> userCacheManager . cleanUserCache ( item . getUsername ( ) ) ) ; Set < Long > userIds = users . stream ( ) . map ( User :: getId ) . collect ( Collectors . toSet ( ) ) ; redisUtils . delByKeys ( CacheKey . DATA_USER , userIds ) ; redisUtils . delByKeys ( CacheKey . MENU_USER , userIds ) ; redisUtils . delByKeys ( CacheKey . ROLE_AUTH , userIds ) ; } redisUtils . del ( CacheKey . ROLE_ID + id ) ; } }"}, {"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class OracleTableHandle implements DbTableHandleI { public OracleTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; }", "output": "else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits == <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && digits != <NUM_LIT> ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName . toLowerCase ( ) + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName . toUpperCase ( ) + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) || var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var2 = var2 + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; return var2 ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; String var4 = \"<STR_LIT>\" ; if ( ! var2 . getIsNullable ( ) . equals ( var1 . getIsNullable ( ) ) ) { var4 = var1 . getIsNullable ( ) . equals ( \"<STR_LIT>\" ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ; } if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var4 ; } var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; var3 = var3 + var4 ; return var3 ; } public String getCommentSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getTableName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" + columnMeta . getComment ( ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return null ; } public String dropIndexs ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName ; } public String countIndex ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName + \"<STR_LIT>\" ; } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; @ Data @ TableName ( value = \"<STR_LIT>\" , autoResultMap = true ) public class Feeds { @ TableId ( \"<STR_LIT>\" ) private Long feedId ; @ TableField ( \"<STR_LIT>\" ) private Integer createTime ; @ TableField ( \"<STR_LIT>\" ) private Integer faultId ; @ TableField ( \"<STR_LIT>\" ) private Integer type ; @ TableField ( \"<STR_LIT>\" ) private String userName ; @ TableField ( \"<STR_LIT>\" ) private Integer status ; @ TableField ( \"<STR_LIT>\" ) private Integer extFlag ; @ TableField ( \"<STR_LIT>\" ) private Integer privFlag ; @ TableField ( \"<STR_LIT>\" ) private String stringId ; @ TableField ( \"<STR_LIT>\" ) private String content ;", "output": "}"}, {"input": "package com . yf . base . utils ; import java . io . File ; public class FileUtils { public static boolean checkDelete ( String path ) { if ( path . contains ( \"<STR_LIT>\" ) || path . contains ( \"<STR_LIT>\" ) || path . contains ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static void deleteDir ( File file ) { if ( ! file . exists ( ) || ! file . isDirectory ( ) ) { return ; } File [ ] files = file . listFiles ( ) ; if ( files == null || files . length == <NUM_LIT> ) { return ; } for ( File item : files ) { if ( file . isDirectory ( ) ) { deleteDir ( item ) ; continue ; } if ( checkDelete ( item . getAbsolutePath ( ) ) ) { System . out . println ( \"<STR_LIT>\" + item . getAbsolutePath ( ) ) ; item . delete ( ) ; } } if ( checkDelete ( file . getAbsolutePath ( ) ) ) { System . out . println ( \"<STR_LIT>\" + file . getAbsolutePath ( ) ) ; file . delete ( ) ; }", "output": "} }"}, {"input": "package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface DictMapper extends BaseMapper < Dict > {", "output": "List < Dict > findAll ( @ Param ( \"<STR_LIT>\" ) DictQueryCriteria criteria ) ; Long countAll ( @ Param ( \"<STR_LIT>\" ) DictQueryCriteria criteria ) ; }"}, {"input": "package org . springblade . config . util ; public class DbType { public static final String BIG_DECIMAL = \"<STR_LIT>\" ; public static final String BLOB = \"<STR_LIT>\" ; public static final String DATE = \"<STR_LIT>\" ; public static final String DATE_TIME = \"<STR_LIT>\" ; public static final String TIME = \"<STR_LIT>\" ; public static final String DOUBLE = \"<STR_LIT>\" ; public static final String INT = \"<STR_LIT>\" ; public static final String STRING = \"<STR_LIT>\" ; public static final String TEXT = \"<STR_LIT>\" ; public static final String TEXT_AREA = \"<STR_LIT>\" ; public static final String BIG_INT = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package top . kangert . kspider . service ; import java . util . Map ; import top . kangert . kspider . entity . Application ; import top . kangert . kspider . util . PageInfo ; public interface ApplicationService { void addItem ( Map < String , Object > params ) ; PageInfo < Application > queryItem ( Map < String , Object > params ) ; void editItem ( Map < String , Object > params ) ; void delete ( Map < String , Object > param ) ;", "output": "}"}, {"input": "package com . yf . ability . task . service . impl ; import com . yf . base . utils . CronUtils ; import com . yf . ability . task . service . JobService ; import lombok . extern . log4j . Log4j2 ; import org . quartz . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . scheduling . quartz . SchedulerFactoryBean ; import org . springframework . stereotype . Service ; import java . util . Calendar ; import java . util . Random ; @ Log4j2 @ Service public class JobServiceImpl implements JobService { private Scheduler scheduler ; public JobServiceImpl ( @ Autowired SchedulerFactoryBean schedulerFactoryBean ) { scheduler = schedulerFactoryBean . getScheduler ( ) ; } @ Override public void addCronJob ( Class jobClass , String jobName , String jobGroup , String cron , String data ) { try { JobKey jobKey = JobKey . jobKey ( jobName , jobGroup ) ; JobDetail jobDetail = scheduler . getJobDetail ( jobKey ) ; if ( jobDetail != null ) { log . info ( \"<STR_LIT>\" , jobName ) ; this . deleteJob ( jobName , jobGroup ) ; }", "output": "log . info ( \"<STR_LIT>\" , jobClass . toString ( ) , jobName , jobGroup , cron , data ) ; jobDetail = JobBuilder . newJob ( jobClass ) . withIdentity ( jobName , jobGroup ) . build ( ) ; jobDetail . getJobDataMap ( ) . put ( TASK_DATA , data ) ; CronScheduleBuilder scheduleBuilder = CronScheduleBuilder . cronSchedule ( cron ) ; CronTrigger trigger = TriggerBuilder . newTrigger ( ) . withIdentity ( jobName , jobGroup ) . withSchedule ( scheduleBuilder ) . build ( ) ; scheduler . scheduleJob ( jobDetail , trigger ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Override public void addCronJob ( Class jobClass , String jobName , String jobGroup , String data ) { java . util . Calendar cl = java . util . Calendar . getInstance ( ) ; cl . setTimeInMillis ( System . currentTimeMillis ( ) ) ; cl . add ( Calendar . SECOND , <NUM_LIT> + new Random ( ) . nextInt ( <NUM_LIT> ) ) ; this . addCronJob ( jobClass , jobName , jobGroup , CronUtils . dateToCron ( cl . getTime ( ) ) , data ) ; } @ Override public void pauseJob ( String jobName , String jobGroup ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( jobName , jobGroup ) ; scheduler . pauseTrigger ( triggerKey ) ; log . info ( \"<STR_LIT>\" , jobName ) ; } catch ( SchedulerException e ) { e . printStackTrace ( ) ; } } @ Override public void resumeJob ( String jobName , String jobGroup ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( jobName , jobGroup ) ; scheduler . resumeTrigger ( triggerKey ) ; log . info ( \"<STR_LIT>\" , jobName ) ; } catch ( SchedulerException e ) { e . printStackTrace ( ) ; } } @ Override public void deleteJob ( String jobName , String jobGroup ) { try { JobKey jobKey = JobKey . jobKey ( jobName , jobGroup ) ; scheduler . deleteJob ( jobKey ) ; log . info ( \"<STR_LIT>\" , jobKey ) ; } catch ( SchedulerException e ) { e . printStackTrace ( ) ; } } }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Repo ; import cn . org . alan . exam . model . vo . repo . RepoVO ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface RepoConverter {", "output": "List < RepoVO > listEntityToVo ( List < Repo > list ) ; }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractJhwtParam { String type ; String memberId ; String contractCoinId ; String entrustCode ; String orderCode ; String direction ; String pattern ; String patternType ; String contractType ; BigDecimal triggerPrice ; BigDecimal price ; BigDecimal amount ;", "output": "Boolean refreshFactoryFlag = true ; String serviceType ; String rule ; String zyzsType ; }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class ChatRoomMemberVO { private String wxId ; private String remark ; private Integer state ; private String headImgUrl ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . support . AbstractBeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . AbstractBeanDefinitionParser ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . w3c . dom . Element ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerNacosPropertySourcePostProcessor ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerXmlNacosPropertySourceBuilder ; public class NacosPropertySourceBeanDefinitionParser extends AbstractBeanDefinitionParser { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override protected AbstractBeanDefinition parseInternal ( Element element , ParserContext parserContext ) {", "output": "BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerNacosPropertySourcePostProcessor ( registry ) ; registerXmlNacosPropertySourceBuilder ( registry ) ; NacosPropertySourceXmlBeanDefinition beanDefinition = new NacosPropertySourceXmlBeanDefinition ( ) ; beanDefinition . setElement ( element ) ; beanDefinition . setXmlReaderContext ( parserContext . getReaderContext ( ) ) ; return beanDefinition ; } @ Override protected boolean shouldGenerateId ( ) { return true ; } }"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class HiddenProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; public HiddenProperty ( ) { } public HiddenProperty ( String key , String title ) { this . type = \"<STR_LIT>\" ;", "output": "this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; prop . put ( \"<STR_LIT>\" , true ) ; map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package com . oddfar . campus . common . config ; import org . springframework . boot . autoconfigure . AutoConfiguration ; import org . springframework . context . annotation . EnableAspectJAutoProxy ; @ AutoConfiguration @ EnableAspectJAutoProxy ( exposeProxy = true ) public class ApplicationConfig {", "output": "}"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Mapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Map ; @ Mapper public interface SqlMapper { List < Map < String , Object > > queryListBySqlList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; IPage < Map < String , Object > > selectPageBySqlList ( Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void executeInsertSQL ( Map < String , Object > map ) ;", "output": "void executeInsertBatchSQL ( String fieldStrList , List < Map < String , Object > > mapList ) ; void executeUpdatetSQL ( Map < String , Object > map ) ; void saveFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void editFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteAutoList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; void deleteList ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Map < String , Object > queryFormData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Integer queryCountBySql ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; List < Map < String , Object > > queryListData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; List < TreeModel > queryDataListByLinkDown ( @ Param ( \"<STR_LIT>\" ) CommonEntity entity ) ; }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . User ; import cn . org . alan . exam . model . form . UserForm ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface UserConverter {", "output": "User fromToEntity ( UserForm userForm ) ; List < User > listFromToEntity ( List < UserForm > list ) ; }"}, {"input": "package ginyi . common . utils ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class NumberUtils { public static double round ( double number , int decimalPlaces ) { BigDecimal bigDecimal = new BigDecimal ( Double . toString ( number ) ) ; bigDecimal = bigDecimal . setScale ( decimalPlaces , RoundingMode . HALF_UP ) ; return bigDecimal . doubleValue ( ) ;", "output": "} }"}, {"input": "package com . yf . system . modules . user . enums ; public interface UserState { Integer NORMAL = <NUM_LIT> ; Integer DISABLED = <NUM_LIT> ; Integer AUDIT = <NUM_LIT> ;", "output": "}"}, {"input": "package com . oddfar . campus . common . config ; import com . oddfar . campus . common . config . properties . ThreadPoolProperties ; import com . oddfar . campus . common . utils . Threads ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang3 . concurrent . BasicThreadFactory ; import org . springframework . boot . autoconfigure . AutoConfiguration ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import javax . annotation . PreDestroy ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ AutoConfiguration @ EnableConfigurationProperties ( ThreadPoolProperties . class ) public class ThreadPoolConfig { private final int core = Runtime . getRuntime ( ) . availableProcessors ( ) + <NUM_LIT> ; private ScheduledExecutorService scheduledExecutorService ; @ Bean ( name = \"<STR_LIT>\" ) @ ConditionalOnProperty ( prefix = \"<STR_LIT>\" , name = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor threadPoolTaskExecutor ( ThreadPoolProperties threadPoolProperties ) { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor ( ) ; executor . setCorePoolSize ( core ) ; executor . setMaxPoolSize ( core * <NUM_LIT> ) ; executor . setQueueCapacity ( threadPoolProperties . getQueueCapacity ( ) ) ; executor . setKeepAliveSeconds ( threadPoolProperties . getKeepAliveSeconds ( ) ) ; executor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; return executor ; } @ Bean ( name = \"<STR_LIT>\" ) protected ScheduledExecutorService scheduledExecutorService ( ) { ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor ( core , new BasicThreadFactory . Builder ( ) . namingPattern ( \"<STR_LIT>\" ) . daemon ( true ) . build ( ) , new ThreadPoolExecutor . CallerRunsPolicy ( ) ) { @ Override protected void afterExecute ( Runnable r , Throwable t ) { super . afterExecute ( r , t ) ; Threads . printException ( r , t ) ; } } ;", "output": "this . scheduledExecutorService = scheduledThreadPoolExecutor ; return scheduledThreadPoolExecutor ; } @ PreDestroy public void destroy ( ) { try { log . info ( \"<STR_LIT>\" ) ; Threads . shutdownAndAwaitTermination ( scheduledExecutorService ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } }"}, {"input": "package org . example . test ; import io . github . chensheng . dddboot . test . ArchitectureTest ; import org . junit . Test ; public class DDDArchitectureTest { @ Test public void testDDDArchitecture ( ) {", "output": "ArchitectureTest . validateDDD ( \"<STR_LIT>\" ) ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . UserBook ; import cn . org . alan . exam . model . vo . userbook . UserPageBookVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import java . util . List ; public interface UserBookMapper extends BaseMapper < UserBook > { Integer deleteByUserIds ( List < Integer > userIds ) ; int addUserBookList ( List < UserBook > userBookArrayList ) ;", "output": "Page < UserPageBookVO > selectPageVo ( Page < UserPageBookVO > page , String examName , Integer userId , Integer role ) ; }"}, {"input": "package top . kangert . kspider . annotation ; import java . lang . annotation . * ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface Return {", "output": "Class < ? > [ ] value ( ) ; }"}, {"input": "package ginyi . system . domain . model . dto ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; import java . util . Date ; import java . util . List ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class PostDto extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = UpdateGroup . class , message = \"<STR_LIT>\" ) private Long postId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > postIds ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { UpdateGroup . class , AddGroup . class }", "output": ", message = \"<STR_LIT>\" ) private String postCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { UpdateGroup . class , AddGroup . class } , message = \"<STR_LIT>\" ) private String postName ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = { UpdateGroup . class , AddGroup . class } , message = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) @ NotBlank ( groups = { UpdateGroup . class , AddGroup . class } , message = \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date beginTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date endTime ; }"}, {"input": "package org . springblade . gateway . handler ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import lombok . RequiredArgsConstructor ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . boot . web . reactive . error . ErrorWebExceptionHandler ; import org . springframework . core . annotation . Order ; import org . springframework . core . io . buffer . DataBufferFactory ; import org . springframework . http . MediaType ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . server . ResponseStatusException ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Map ; @ Order ( - <NUM_LIT> ) @ RequiredArgsConstructor public class ErrorExceptionHandler implements ErrorWebExceptionHandler { private final ObjectMapper objectMapper ; @ Override public Mono < Void > handle ( ServerWebExchange exchange , Throwable ex ) { ServerHttpRequest request = exchange . getRequest ( ) ; ServerHttpResponse response = exchange . getResponse ( ) ; if ( response . isCommitted ( ) ) { return Mono . error ( ex ) ; } response . getHeaders ( ) . setContentType ( MediaType . APPLICATION_JSON ) ; if ( ex instanceof ResponseStatusException ) { response . setStatusCode ( ( ( ResponseStatusException ) ex ) . getStatus ( ) ) ;", "output": "} return response . writeWith ( Mono . fromSupplier ( ( ) -> { DataBufferFactory bufferFactory = response . bufferFactory ( ) ; try { int status = <NUM_LIT> ; if ( response . getStatusCode ( ) != null ) { status = response . getStatusCode ( ) . value ( ) ; } Map < String , Object > result = ResponseProvider . response ( status , this . buildMessage ( request , ex ) ) ; return bufferFactory . wrap ( objectMapper . writeValueAsBytes ( result ) ) ; } catch ( JsonProcessingException e ) { return bufferFactory . wrap ( new byte [ <NUM_LIT> ] ) ; } } ) ) ; } private String buildMessage ( ServerHttpRequest request , Throwable ex ) { String uri = request . getURI ( ) . toString ( ) ; if ( uri . endsWith ( \"<STR_LIT>\" ) ) { return \"<STR_LIT>\" ; } StringBuilder message = new StringBuilder ( \"<STR_LIT>\" ) ; message . append ( request . getMethodValue ( ) ) ; message . append ( \"<STR_LIT>\" ) ; message . append ( request . getURI ( ) ) ; message . append ( \"<STR_LIT>\" ) ; if ( ex != null ) { message . append ( \"<STR_LIT>\" ) ; message . append ( ex . getMessage ( ) ) ; } return message . toString ( ) ; } }"}, {"input": "package com . youlai . system . controller ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . common . result . PageResult ; import com . youlai . system . common . result . Result ; import com . youlai . system . model . query . TablePageQuery ; import com . youlai . system . model . vo . TableColumnVO ; import com . youlai . system . model . vo . TableGeneratePreviewVO ; import com . youlai . system . model . vo . TablePageVO ; import com . youlai . system . service . GeneratorService ; import io . swagger . v3 . oas . annotations . Operation ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PathVariable ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class GeneratorController { private final GeneratorService generatorService ; @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public PageResult < TablePageVO > getTablePage ( TablePageQuery queryParams ) { Page < TablePageVO > result = generatorService . getTablePage ( queryParams ) ;", "output": "return PageResult . success ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < TableColumnVO > > getTableColumns ( @ Parameter ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ PathVariable String tableName ) { List < TableColumnVO > list = generatorService . getTableColumns ( tableName ) ; return Result . success ( list ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < TableGeneratePreviewVO > > getTablePreviewData ( @ PathVariable String tableName ) { List < TableGeneratePreviewVO > list = generatorService . getTablePreviewData ( tableName ) ; return Result . success ( list ) ; } }"}, {"input": "package org . springblade . web . service ; import org . springblade . entity . BuySellWalletParam ; import org . springblade . entity . OperateWalletParam ; import org . springblade . web . model . param . TransParam ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWalletService {", "output": "Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) ; }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class OrderChatRecordParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String contentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String userType ;", "output": "}"}, {"input": "package com . xcs . wx . msg ; import com . xcs . wx . domain . vo . MsgVO ; public interface MsgStrategy { boolean support ( Integer type , Integer subType ) ; void process ( MsgVO msgVO ) ;", "output": "}"}, {"input": "package com . xcs . wx . service ; import org . springframework . core . io . Resource ; import org . springframework . http . ResponseEntity ; public interface ImageService { ResponseEntity < Resource > downloadImgMd5 ( String md5 ) ; ResponseEntity < Resource > downloadImg ( String path ) ; ResponseEntity < Resource > downloadImgFormLocal ( String localPath ) ;", "output": "}"}, {"input": "package ginyi . common . mysql ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . Data ; @ Data public class MyPage { private Long pageNum ; private Long pageSize ; private boolean isPage ; public MyPage ( ) { } public MyPage ( Long page , Long pageSize ) { if ( ( page != null && page > <NUM_LIT> ) && ( pageSize != null && pageSize > <NUM_LIT> ) ) { this . pageNum = page ; this . pageSize = pageSize ; this . isPage = true ; } else { this . pageNum = <NUM_LIT> ; this . pageSize = <NUM_LIT> ; this . isPage = false ; } } public Page getPage ( ) {", "output": "return this . isPage ? new Page ( this . pageNum , this . pageSize ) : new Page ( ) . setSize ( <NUM_LIT> ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySourcePostProcessor ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MutablePropertySources ; import org . springframework . core . env . StandardEnvironment ; import org . springframework . util . StringUtils ; import java . util . * ; import java . util . function . Function ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; public class NacosConfigLoader { private final Logger logger = LoggerFactory . getLogger ( NacosConfigLoader . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final Properties globalProperties ; private final ConfigurableEnvironment environment ; private Function < Properties , ConfigService > builder ; private List < DeferNacosPropertySource > nacosPropertySources = new LinkedList < > ( ) ; public NacosConfigLoader ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . builder = builder ; globalProperties = buildGlobalNacosProperties ( ) ; } public void loadConfig ( ) { MutablePropertySources mutablePropertySources = environment . getPropertySources ( ) ; List < NacosPropertySource > sources = reqGlobalNacosConfig ( globalProperties , nacosConfigProperties . getType ( ) ) ; for ( NacosConfigProperties . Config config : nacosConfigProperties . getExtConfig ( ) ) { List < NacosPropertySource > elements = reqSubNacosConfig ( config , globalProperties , config . getType ( ) ) ; sources . addAll ( elements ) ; } if ( nacosConfigProperties . isRemoteFirst ( ) ) { for ( ListIterator < NacosPropertySource > itr = sources . listIterator ( sources . size ( ) ) ; itr . hasPrevious ( ) ; ) { mutablePropertySources . addAfter ( StandardEnvironment . SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME , itr . previous ( ) ) ; } } else { for ( NacosPropertySource propertySource : sources ) { mutablePropertySources . addLast ( propertySource ) ; } } } public Properties buildGlobalNacosProperties ( ) { return NacosPropertiesBuilder . buildNacosProperties ( environment , nacosConfigProperties . getServerAddr ( ) , nacosConfigProperties . getNamespace ( ) , nacosConfigProperties . getEndpoint ( ) , nacosConfigProperties . getSecretKey ( ) , nacosConfigProperties . getAccessKey ( ) , nacosConfigProperties . getRamRoleName ( ) , nacosConfigProperties . getConfigLongPollTimeout ( ) , nacosConfigProperties . getConfigRetryTime ( ) , nacosConfigProperties . getMaxRetry ( ) , nacosConfigProperties . isEnableRemoteSyncConfig ( ) , nacosConfigProperties . getUsername ( ) , nacosConfigProperties . getPassword ( ) ) ; } private Properties buildSubNacosProperties ( Properties globalProperties , NacosConfigProperties . Config config ) { Properties sub = NacosPropertiesBuilder . buildNacosProperties ( environment , config . getServerAddr ( ) , config . getNamespace ( ) , config . getEndpoint ( ) , config . getSecretKey ( ) , config . getAccessKey ( ) , config . getRamRoleName ( ) , config . getConfigLongPollTimeout ( ) , config . getConfigRetryTime ( ) , config . getMaxRetry ( ) , config . isEnableRemoteSyncConfig ( ) , config . getUsername ( ) , config . getPassword ( ) ) ; NacosPropertiesBuilder . merge ( sub , globalProperties ) ; return sub ; } private List < NacosPropertySource > reqGlobalNacosConfig ( Properties globalProperties , ConfigType type ) { List < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( nacosConfigProperties . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( nacosConfigProperties . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( nacosConfigProperties . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; final boolean isAutoRefresh = nacosConfigProperties . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( globalProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private List < NacosPropertySource > reqSubNacosConfig ( NacosConfigProperties . Config config , Properties globalProperties , ConfigType type ) { Properties subConfigProperties = buildSubNacosProperties ( globalProperties , config ) ; ArrayList < String > dataIds = new ArrayList < > ( ) ; if ( ! StringUtils . hasLength ( config . getDataId ( ) ) ) { final String ids = environment . resolvePlaceholders ( config . getDataIds ( ) ) ; dataIds . addAll ( Arrays . asList ( ids . split ( \"<STR_LIT>\" ) ) ) ; } else { dataIds . add ( config . getDataId ( ) ) ; } final String groupName = environment . resolvePlaceholders ( config . getGroup ( ) ) ; final boolean isAutoRefresh = config . isAutoRefresh ( ) ; return new ArrayList < > ( Arrays . asList ( reqNacosConfig ( subConfigProperties , dataIds . toArray ( new String [ <NUM_LIT> ] ) , groupName , type , isAutoRefresh ) ) ) ; } private NacosPropertySource [ ] reqNacosConfig ( Properties configProperties , String [ ] dataIds , String groupId , ConfigType type , boolean isAutoRefresh ) { final NacosPropertySource [ ] propertySources = new NacosPropertySource [ dataIds . length ] ; for ( int i = <NUM_LIT> ; i < dataIds . length ; i ++ ) { if ( ! StringUtils . hasLength ( dataIds [ i ] ) ) { continue ; } final String dataId = environment . resolvePlaceholders ( dataIds [ i ] . trim ( ) ) ; final String config = NacosUtils . getContent ( builder . apply ( configProperties ) , dataId , groupId ) ; final NacosPropertySource nacosPropertySource = new NacosPropertySource ( dataId , groupId , buildDefaultPropertySourceName ( dataId , groupId , configProperties ) , config , type . getType ( ) ) ; nacosPropertySource . setDataId ( dataId ) ; nacosPropertySource . setType ( type . getType ( ) ) ; nacosPropertySource . setGroupId ( groupId ) ; nacosPropertySource . setAutoRefreshed ( isAutoRefresh ) ; logger . info ( \"<STR_LIT>\" , nacosPropertySource . getDataId ( ) , nacosPropertySource . getGroupId ( ) ) ; propertySources [ i ] = nacosPropertySource ; DeferNacosPropertySource defer = new DeferNacosPropertySource ( nacosPropertySource , configProperties , environment ) ; nacosPropertySources . add ( defer ) ; } return propertySources ; } public void addListenerIfAutoRefreshed ( ) {", "output": "addListenerIfAutoRefreshed ( nacosPropertySources ) ; } public void addListenerIfAutoRefreshed ( final List < DeferNacosPropertySource > deferNacosPropertySources ) { for ( DeferNacosPropertySource deferNacosPropertySource : deferNacosPropertySources ) { NacosPropertySourcePostProcessor . addListenerIfAutoRefreshed ( deferNacosPropertySource . getNacosPropertySource ( ) , deferNacosPropertySource . getProperties ( ) , deferNacosPropertySource . getEnvironment ( ) ) ; } } public List < DeferNacosPropertySource > getNacosPropertySources ( ) { return nacosPropertySources ; } public Properties getGlobalProperties ( ) { return globalProperties ; } public static class DeferNacosPropertySource { private final NacosPropertySource nacosPropertySource ; private final ConfigurableEnvironment environment ; private final Properties properties ; DeferNacosPropertySource ( NacosPropertySource nacosPropertySource , Properties properties , ConfigurableEnvironment environment ) { this . nacosPropertySource = nacosPropertySource ; this . properties = properties ; this . environment = environment ; } NacosPropertySource getNacosPropertySource ( ) { return nacosPropertySource ; } ConfigurableEnvironment getEnvironment ( ) { return environment ; } public Properties getProperties ( ) { return properties ; } } }"}, {"input": "package me . zhengjie . domain . vo ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . sql . Date ; import java . sql . Timestamp ; @ Data public class TradeVo { @ NotBlank private String body ; @ NotBlank private String subject ; @ ApiModelProperty ( hidden = true ) private String outTradeNo ; @ ApiModelProperty ( hidden = true ) private String tradeNo ; @ NotBlank private String totalAmount ; @ ApiModelProperty ( hidden = true ) private String state ; @ ApiModelProperty ( hidden = true ) private Timestamp createTime ; @ ApiModelProperty ( hidden = true ) private Date cancelTime ;", "output": "}"}, {"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class User extends DataObject { private String username ; private String password ; private UserStatus status ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . GradeConverter ; import cn . org . alan . exam . mapper . ExamMapper ; import cn . org . alan . exam . mapper . GradeMapper ; import cn . org . alan . exam . mapper . QuestionMapper ; import cn . org . alan . exam . mapper . UserMapper ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . form . GradeForm ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . service . IGradeService ; import cn . org . alan . exam . util . CacheClient ; import cn . org . alan . exam . util . ClassTokenGenerator ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import java . util . function . Function ; import java . util . stream . Collectors ; @ Service public class GradeServiceImpl extends ServiceImpl < GradeMapper , Grade > implements IGradeService { @ Resource private GradeMapper gradeMapper ; @ Resource private ExamMapper examMapper ; @ Resource private QuestionMapper questionMapper ; @ Resource private GradeConverter gradeConverter ; @ Resource private UserMapper userMapper ; @ Resource private IGradeService gradeService ; @ Resource private StringRedisTemplate stringRedisTemplate ; @ Resource private CacheClient cacheClient ; @ Override @ Transactional public Result < String > addGrade ( GradeForm gradeForm ) { gradeForm . setCode ( ClassTokenGenerator . generateClassToken ( <NUM_LIT> ) ) ; Grade grade = gradeConverter . formToEntity ( gradeForm ) ; int rows = gradeMapper . insert ( grade ) ; if ( rows == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } if ( grade . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + grade . getId ( ) . toString ( ) ) ; } stringRedisTemplate . delete ( \"<STR_LIT>\" + SecurityUtil . getUserId ( ) ) ;", "output": "return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ Transactional public Result < String > updateGrade ( Integer id , GradeForm gradeForm ) { LambdaUpdateWrapper < Grade > gradeUpdateWrapper = new LambdaUpdateWrapper < > ( ) ; gradeUpdateWrapper . set ( Grade :: getGradeName , gradeForm . getGradeName ( ) ) . eq ( Grade :: getId , id ) ; int rows = gradeMapper . update ( gradeUpdateWrapper ) ; if ( rows == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } Grade byId = getById ( id ) ; if ( byId . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + byId . getId ( ) . toString ( ) ) ; } stringRedisTemplate . delete ( \"<STR_LIT>\" + SecurityUtil . getUserId ( ) ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ Transactional public Result < String > deleteGrade ( Integer id ) { LambdaUpdateWrapper < Grade > gradeLambdaUpdateWrapper = new LambdaUpdateWrapper < > ( ) ; gradeLambdaUpdateWrapper . eq ( Grade :: getId , id ) . set ( Grade :: getIsDeleted , <NUM_LIT> ) ; int rows = gradeMapper . update ( gradeLambdaUpdateWrapper ) ; if ( rows == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } stringRedisTemplate . delete ( \"<STR_LIT>\" + id . toString ( ) ) ; stringRedisTemplate . delete ( \"<STR_LIT>\" + SecurityUtil . getUserId ( ) ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override public Result < IPage < GradeVO > > getPaging ( Integer pageNum , Integer pageSize , String gradeName ) { Integer role = <NUM_LIT> ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { role = <NUM_LIT> ; } int total = gradeMapper . countByCondition ( SecurityUtil . getUserId ( ) , gradeName , role ) ; int offset = ( pageNum - <NUM_LIT> ) * pageSize ; List < Integer > gradeIds = gradeMapper . selectGradeIdsPage ( SecurityUtil . getUserId ( ) , role , gradeName , offset , pageSize ) ; Map < Integer , GradeVO > cachedGradesMap = cacheClient . batchGet ( \"<STR_LIT>\" , gradeIds , GradeVO . class ) ; List < Integer > missIds = new ArrayList < > ( ) ; for ( Integer id : gradeIds ) { if ( ! cachedGradesMap . containsKey ( id ) ) { missIds . add ( id ) ; } } if ( ! missIds . isEmpty ( ) ) { List < GradeVO > missedGrades = gradeMapper . batchSelectByIds ( missIds ) ; Map < Integer , GradeVO > missedGradesMap = missedGrades . stream ( ) . collect ( Collectors . toMap ( GradeVO :: getId , Function . identity ( ) ) ) ; cacheClient . batchPut ( \"<STR_LIT>\" , missedGradesMap , <NUM_LIT> , TimeUnit . MINUTES ) ; cachedGradesMap . putAll ( missedGradesMap ) ; } List < GradeVO > finalResult = new ArrayList < > ( gradeIds . size ( ) ) ; for ( Integer id : gradeIds ) { finalResult . add ( cachedGradesMap . get ( id ) ) ; } IPage < GradeVO > resultPage = new Page < > ( pageNum , pageSize , Long . valueOf ( total ) ) ; resultPage . setRecords ( finalResult ) ; return Result . success ( \"<STR_LIT>\" , resultPage ) ; } @ Override public Result < String > removeUserGrade ( String ids ) { List < Integer > userIds = Arrays . stream ( ids . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; int rows = userMapper . removeUserGrade ( userIds ) ; if ( rows == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } userIds . forEach ( id -> { stringRedisTemplate . delete ( \"<STR_LIT>\" + id . toString ( ) ) ; } ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override public Result < List < GradeVO > > getAllGrade ( ) { Function < Integer , List > function = new Function < > ( ) { @ Override public List apply ( Integer userId ) { LambdaQueryWrapper < Grade > gradeLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; gradeLambdaQueryWrapper . eq ( Grade :: getUserId , userId ) . eq ( Grade :: getIsDeleted , <NUM_LIT> ) ; List < Grade > grades = gradeMapper . selectList ( gradeLambdaQueryWrapper ) ; List < GradeVO > gradeVOS = gradeConverter . listEntityToVo ( grades ) ; return gradeVOS ; } } ; List < GradeVO > result = cacheClient . queryWithPassThrough ( \"<STR_LIT>\" , SecurityUtil . getUserId ( ) , List . class , function , GradeVO . class , <NUM_LIT> , TimeUnit . MINUTES ) ; if ( result == null ) { return Result . failed ( \"<STR_LIT>\" ) ; } return Result . success ( \"<STR_LIT>\" , result ) ; } }"}, {"input": "package top . kangert . kspider . service ; import top . kangert . kspider . domain . Function ; import top . kangert . kspider . util . PageInfo ; import java . util . Map ; public interface FunctionService { Function addItem ( Map < String , Object > params ) ;", "output": "void deleteItem ( Map < String , Object > params ) ; void editItem ( Map < String , Object > params ) ; Function queryItem ( Long id ) ; PageInfo < Function > queryItems ( Map < String , Object > params ) ; }"}, {"input": "package com . youlai . system . service ; import com . youlai . system . model . dto . CaptchaResult ; import com . youlai . system . model . dto . LoginResult ; public interface AuthService { LoginResult login ( String username , String password ) ;", "output": "void logout ( ) ; CaptchaResult getCaptcha ( ) ; }"}, {"input": "package top . kangert . kspider . support ; import top . kangert . kspider . model . Plugin ; public interface Pluggable { Plugin register ( ) ;", "output": "}"}, {"input": "package top . kangert . kspider . repository ; import org . springframework . data . jpa . repository . JpaRepository ; import org . springframework . data . jpa . repository . JpaSpecificationExecutor ; import top . kangert . kspider . entity . Application ; public interface ApplicationRepository extends JpaRepository < Application , Long > , JpaSpecificationExecutor < Application > { Application findByAppName ( String AppName ) ;", "output": "Application findByAppSecretKey ( String appSecretKey ) ; }"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; import javax . validation . constraints . Max ; import javax . validation . constraints . Min ; import javax . validation . constraints . NotNull ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysLoginLogEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long infoId ; private Long userId ; private String userName ; private String status ; private String ipaddr ; private String loginLocation ; private String browser ; private String os ; private String msg ; @ JsonFormat ( pattern = \"<STR_LIT>\" , timezone = \"<STR_LIT>\" ) private Date loginTime ; private static final Integer PAGE_NUM = <NUM_LIT> ; private static final Integer PAGE_SIZE = <NUM_LIT> ; @ TableField ( exist = false ) private Map < String , Object > params ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ TableField ( exist = false ) @ JsonIgnore private Integer pageNum = PAGE_NUM ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Max ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ TableField ( exist = false ) @ JsonIgnore private Integer pageSize = PAGE_SIZE ; public Map < String , Object > getParams ( ) { if ( params == null ) { params = new HashMap < > ( ) ;", "output": "} return params ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) @ AllArgsConstructor @ NoArgsConstructor public class BooleanRespDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Boolean effect ;", "output": "}"}, {"input": "package com . yf . system . modules . user . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . yf . ability . Constant ; import com . yf . ability . captcha . service . CaptchaService ; import com . yf . ability . redis . service . RedisService ; import com . yf . ability . shiro . dto . SysUserLoginDTO ; import com . yf . ability . shiro . jwt . JwtUtils ; import com . yf . ability . shiro . service . ShiroUserService ; import com . yf . base . api . api . ApiError ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . BeanMapper ; import com . yf . base . utils . passwd . PassHandler ; import com . yf . base . utils . passwd . PassInfo ; import com . yf . base . utils . CacheKey ; import com . yf . base . utils . jackson . JsonHelper ; import com . yf . system . modules . config . enums . FuncSwitch ; import com . yf . system . modules . config . service . CfgSwitchService ; import com . yf . system . modules . menu . service . SysMenuService ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . system . modules . user . UserUtils ; import com . yf . system . modules . user . dto . request . * ; import com . yf . system . modules . user . dto . response . UserListRespDTO ; import com . yf . system . modules . user . entity . SysUser ; import com . yf . system . modules . user . enums . LoginType ; import com . yf . system . modules . user . enums . SysRoleId ; import com . yf . system . modules . user . enums . UserState ; import com . yf . system . modules . user . mapper . SysUserMapper ; import com . yf . system . modules . user . service . SysUserBindService ; import com . yf . system . modules . user . service . SysUserRoleService ; import com . yf . system . modules . user . service . SysUserService ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Service public class SysUserServiceImpl extends ServiceImpl < SysUserMapper , SysUser > implements SysUserService , ShiroUserService { @ Autowired private SysUserRoleService sysUserRoleService ; @ Autowired private RedisService redisService ; @ Autowired private CaptchaService captchaService ; @ Autowired private SysUserBindService sysUserBindService ; @ Autowired private CfgSwitchService cfgSwitchService ; @ Autowired private SysMenuService sysMenuService ; @ Override public SysUserSaveReqDTO detail ( String id ) { SysUser user = this . getById ( id ) ; SysUserSaveReqDTO respDTO = new SysUserSaveReqDTO ( ) ; BeanMapper . copy ( user , respDTO ) ; List < SysRole > roleList = sysUserRoleService . listRoles ( user . getId ( ) ) ; List < String > roles = new ArrayList < > ( ) ; for ( SysRole role : roleList ) { roles . add ( role . getId ( ) ) ; } respDTO . setRoles ( roles ) ; return respDTO ; } @ Override public IPage < UserListRespDTO > paging ( PagingReqDTO < SysUserQueryReqDTO > reqDTO ) { Page page = reqDTO . toPage ( ) ; IPage < UserListRespDTO > pageData = baseMapper . paging ( page , reqDTO . getParams ( ) ) ; return pageData ; } @ Transactional ( rollbackFor = Exception . class ) @ Override public void delete ( List < String > ids ) { int count = sysUserRoleService . countWithLevel ( ids , UserUtils . getRoleLevel ( ) ) ; if ( count < ids . size ( ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( ids . contains ( UserUtils . getUserId ( ) ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } this . removeByIds ( ids ) ; } @ Override public SysUserLoginDTO login ( SysUserLoginReqDTO reqDTO ) { if ( ! StringUtils . isBlank ( reqDTO . getCaptchaKey ( ) ) ) { boolean check = captchaService . checkCaptcha ( reqDTO . getCaptchaKey ( ) , reqDTO . getCaptchaValue ( ) ) ; if ( ! check ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } } QueryWrapper < SysUser > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysUser :: getUserName , reqDTO . getUserName ( ) ) ; SysUser user = this . getOne ( wrapper , false ) ; return this . checkAndLogin ( user , reqDTO . getPassword ( ) ) ; } private SysUserLoginDTO checkAndLogin ( SysUser user , String password ) { if ( user == null ) { throw new ServiceException ( ApiError . ERROR_90010001 ) ; } if ( UserState . DISABLED . equals ( user . getState ( ) ) ) { throw new ServiceException ( ApiError . ERROR_90010005 ) ; } if ( UserState . AUDIT . equals ( user . getState ( ) ) ) { throw new ServiceException ( ApiError . ERROR_90010006 ) ; } if ( ! StringUtils . isBlank ( password ) ) { boolean pass = PassHandler . checkPass ( password , user . getSalt ( ) , user . getPassword ( ) ) ; if ( ! pass ) { throw new ServiceException ( ApiError . ERROR_90010002 ) ; } } return this . setToken ( user ) ; } @ Override public List < String > permissions ( String userId ) { return sysUserRoleService . findUserPermission ( userId ) ; } @ Override public List < String > roles ( String userId ) { return sysUserRoleService . listRoleIds ( userId ) ; } @ Override public SysUserLoginDTO token ( String token ) { String username ; try { username = JwtUtils . getUsername ( token ) ; } catch ( Exception e ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } Map < String , Object > json = redisService . getJson ( Constant . USER_NAME_KEY + username ) ; if ( json == null ) { throw new ServiceException ( ApiError . ERROR_10010002 ) ; } SysUserLoginDTO respDTO = JsonHelper . parseObject ( json , SysUserLoginDTO . class ) ; return respDTO ; } @ CacheEvict ( value = CacheKey . TOKEN , key = \"<STR_LIT>\" ) @ Override public void logout ( String token ) { boolean tick = cfgSwitchService . isOn ( FuncSwitch . LOGIN_TICK ) ; if ( tick ) { try { String username = JwtUtils . getUsername ( token ) ; String [ ] keys = new String [ ] { Constant . USER_NAME_KEY + username } ; redisService . del ( keys ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } @ Transactional ( rollbackFor = Exception . class ) @ Override public void update ( SysUserUpdateReqDTO reqDTO ) { SysUser u1 = this . getById ( UserUtils . getUserId ( ) ) ; SysUser user = new SysUser ( ) ; user . setId ( UserUtils . getUserId ( ) ) ; BeanMapper . copy ( reqDTO , user ) ; boolean reLogin = false ; String password = reqDTO . getPassword ( ) ; if ( ! StringUtils . isBlank ( password ) ) { PassInfo passInfo = PassHandler . buildPassword ( password ) ; user . setPassword ( passInfo . getPassword ( ) ) ; user . setSalt ( passInfo . getSalt ( ) ) ; reLogin = true ; } if ( reLogin ) { String [ ] keys = new String [ ] { Constant . USER_NAME_KEY + user . getUserName ( ) } ; redisService . del ( keys ) ; } this . updateById ( user ) ; this . setToken ( user ) ; } @ CacheEvict ( value = CacheKey . MENU , allEntries = true ) @ Transactional ( rollbackFor = Exception . class ) @ Override public void save ( SysUserSaveReqDTO reqDTO ) { List < String > roles = reqDTO . getRoles ( ) ; if ( CollectionUtils . isEmpty ( roles ) ) { throw new ServiceException ( ApiError . ERROR_90010003 ) ; } QueryWrapper < SysUser > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysUser :: getUserName , reqDTO . getUserName ( ) ) ; if ( ! StringUtils . isBlank ( reqDTO . getId ( ) ) ) { wrapper . lambda ( ) . ne ( SysUser :: getId , reqDTO . getId ( ) ) ; } long count = this . count ( wrapper ) ; if ( count > <NUM_LIT> ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } SysUser user ; if ( StringUtils . isBlank ( reqDTO . getId ( ) ) ) { user = new SysUser ( ) ; BeanMapper . copy ( reqDTO , user ) ; user . setId ( IdWorker . getIdStr ( ) ) ; } else { user = this . getById ( reqDTO . getId ( ) ) ; BeanMapper . copy ( reqDTO , user ) ; } int level = sysUserRoleService . findMaxLevel ( reqDTO . getId ( ) ) ; if ( level > UserUtils . getRoleLevel ( ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( ! StringUtils . isBlank ( reqDTO . getPassword ( ) ) ) { PassInfo pass = PassHandler . buildPassword ( reqDTO . getPassword ( ) ) ; user . setPassword ( pass . getPassword ( ) ) ; user . setSalt ( pass . getSalt ( ) ) ; } sysUserRoleService . saveRoles ( user . getId ( ) , roles , true ) ; this . saveOrUpdate ( user ) ; if ( ! StringUtils . isBlank ( user . getMobile ( ) ) ) { sysUserBindService . save ( true , user . getId ( ) , LoginType . MOBILE , user . getMobile ( ) ) ; } } @ Transactional ( rollbackFor = Exception . class ) @ Override public SysUserLoginDTO reg ( UserRegReqDTO reqDTO ) { boolean check = captchaService . checkCaptcha ( reqDTO . getCaptchaKey ( ) , reqDTO . getCaptchaValue ( ) ) ; if ( ! check ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } boolean on = cfgSwitchService . isOn ( FuncSwitch . USER_REG ) ; if ( ! on ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } QueryWrapper < SysUser > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . select ( SysUser :: getId ) . eq ( SysUser :: getUserName , reqDTO . getUserName ( ) ) ; boolean exists = this . count ( wrapper ) > <NUM_LIT> ; if ( exists ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } return this . saveAndLogin ( null , reqDTO . getUserName ( ) , reqDTO . getDeptCode ( ) , reqDTO . getRealName ( ) , null , null , \"<STR_LIT>\" , reqDTO . getPassword ( ) ) ; } private SysUserLoginDTO saveAndLogin ( String userId , String userName , String deptCode , String realName , String role , String mobile , String avatar , String password ) { SysUser user = new SysUser ( ) ; if ( ! StringUtils . isBlank ( userId ) ) { user . setId ( userId ) ; } else { user . setId ( IdWorker . getIdStr ( ) ) ; } boolean on = cfgSwitchService . isOn ( FuncSwitch . USER_DEPT_TYPE ) ; if ( on ) { deptCode = cfgSwitchService . val ( FuncSwitch . USER_DEPT_CODE ) ; } boolean audit = cfgSwitchService . isOn ( FuncSwitch . USER_AUDIT ) ; if ( audit ) { user . setState ( UserState . AUDIT ) ; } else { user . setState ( UserState . NORMAL ) ; } user . setUserName ( userName ) ; user . setRealName ( realName ) ;", "output": "user . setDeptCode ( deptCode ) ; user . setMobile ( mobile ) ; user . setAvatar ( avatar ) ; PassInfo passInfo = PassHandler . buildPassword ( password ) ; user . setPassword ( passInfo . getPassword ( ) ) ; user . setSalt ( passInfo . getSalt ( ) ) ; List < String > roleList = new ArrayList < > ( ) ; if ( ! StringUtils . isBlank ( role ) ) { roleList . add ( role ) ; } else { roleList . add ( SysRoleId . USER ) ; } sysUserRoleService . saveRoles ( user . getId ( ) , roleList , false ) ; this . save ( user ) ; if ( ! StringUtils . isBlank ( mobile ) ) { sysUserBindService . save ( false , user . getId ( ) , LoginType . MOBILE , mobile ) ; } return this . setToken ( user ) ; } private SysUserLoginDTO setToken ( SysUser user ) { String key = Constant . USER_NAME_KEY + user . getUserName ( ) ; String json = redisService . getString ( key ) ; if ( ! StringUtils . isBlank ( json ) ) { redisService . del ( key ) ; } SysUserLoginDTO respDTO = new SysUserLoginDTO ( ) ; BeanMapper . copy ( user , respDTO ) ; if ( UserState . NORMAL . equals ( user . getState ( ) ) ) { String token = JwtUtils . sign ( user . getUserName ( ) ) ; respDTO . setToken ( token ) ; this . fillRoleData ( respDTO ) ; List < String > permissions = sysMenuService . listPermissionByRoles ( respDTO . getRoles ( ) ) ; respDTO . setPermissions ( permissions ) ; redisService . set ( key , JsonHelper . toJson ( respDTO ) ) ; } return respDTO ; } private void fillRoleData ( SysUserLoginDTO respDTO ) { List < SysRole > roleList = sysUserRoleService . listRoles ( respDTO . getId ( ) ) ; Integer roleLevel = <NUM_LIT> ; Integer dataScope = <NUM_LIT> ; List < String > roleIds = new ArrayList < > ( ) ; for ( SysRole role : roleList ) { roleIds . add ( role . getId ( ) ) ; if ( dataScope < role . getDataScope ( ) ) { dataScope = role . getDataScope ( ) ; } if ( roleLevel < role . getRoleLevel ( ) ) { roleLevel = role . getRoleLevel ( ) ; } } respDTO . setRoleLevel ( roleLevel ) ; respDTO . setDataScope ( dataScope ) ; respDTO . setRoles ( roleIds ) ; } }"}, {"input": "package top . kangert . kspider . io ; import cn . hutool . json . JSONUtil ; import top . kangert . kspider . io . SpiderResponse ; import org . jsoup . Connection . Response ; import org . jsoup . Jsoup ; import java . io . InputStream ; import java . util . Map ; public class HttpResponse implements SpiderResponse { private Response response ; private int statusCode ; private String urlLink ; private String htmlValue ; private String title ; private Object jsonValue ; public HttpResponse ( Response response ) { this . response = response ; this . statusCode = response . statusCode ( ) ;", "output": "this . urlLink = response . url ( ) . toExternalForm ( ) ; } @ Override public int getStatusCode ( ) { return statusCode ; } @ Override public String getTitle ( ) { if ( title == null ) { synchronized ( this ) { title = Jsoup . parse ( getHtml ( ) ) . title ( ) ; } } return title ; } @ Override public String getHtml ( ) { if ( htmlValue == null ) { synchronized ( this ) { htmlValue = response . body ( ) ; } } return htmlValue ; } @ Override public Object getJson ( ) { if ( jsonValue == null ) { jsonValue = JSONUtil . parseObj ( getHtml ( ) ) ; } return jsonValue ; } @ Override public Map < String , String > getCookies ( ) { return response . cookies ( ) ; } @ Override public Map < String , String > getHeaders ( ) { return response . headers ( ) ; } @ Override public byte [ ] getBytes ( ) { return response . bodyAsBytes ( ) ; } @ Override public String getContentType ( ) { return response . contentType ( ) ; } @ Override public void setCharset ( String charset ) { this . response . charset ( charset ) ; } @ Override public String getUrl ( ) { return urlLink ; } @ Override public InputStream getStream ( ) { return response . bodyStream ( ) ; } }"}, {"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . extension . service . IService ; import org . springblade . cgform . entity . FlowForm ; public interface IFlowFormService extends IService < FlowForm > {", "output": "}"}, {"input": "package com . yf . base . utils ; public class AbcTags { public static String [ ] tags = new String [ ] {", "output": "\"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static String get ( int index ) { if ( index > tags . length ) { return \"<STR_LIT>\" ; } return tags [ index ] ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . ContactLabel ; import com . xcs . wx . domain . vo . ContactLabelVO ; import org . mapstruct . Mapper ; import java . util . List ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface ContactLabelMapping { List < ContactLabelVO > convert ( List < ContactLabel > labels ) ;", "output": "}"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . DeptDto ; import ginyi . system . domain . model . dto . PostDto ; import ginyi . system . domain . model . dto . RoleDto ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . UserVo ; import java . util . HashMap ; import java . util . Set ; public interface ISysUserService { public void updateUser ( UserDto userDto ) ; public SysUser selectUserByUserName ( String userName ) ; public String checkUserNameUnique ( SysUser user ) ; public boolean registerUser ( SysUser user ) ; public void addUser ( UserDto userDto ) ; public UserVo getUserByUserId ( String userId ) ; public BaseVo < UserVo > list ( UserDto userDto , Long page , Long pageSize ) ; public void removeById ( Long userId ) ; public void removeUserByIds ( Set < Long > ids ) ; public void updateStatus ( UserDto userDto ) ; public BaseVo < HashMap < String , Object > > getUserListByDeptIds ( DeptDto deptDto ) ; public BaseVo < HashMap < String , Object > > getUserListByPostIds ( PostDto postDto ) ; public BaseVo < HashMap < String , Object > > getUserListByRoleIds ( RoleDto roleDto ) ;", "output": "}"}, {"input": "package com . xcs . wx . util ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . util . Arrays ; public class Pbkdf2HmacUtil { private Pbkdf2HmacUtil ( ) { } private static final String ALGORITHM = \"<STR_LIT>\" ; public static byte [ ] pbkdf2Hmac ( byte [ ] password , byte [ ] salt , int iterations , int dkLen ) throws NoSuchAlgorithmException , InvalidKeyException { Mac mac = Mac . getInstance ( ALGORITHM ) ; mac . init ( new SecretKeySpec ( password , ALGORITHM ) ) ; byte [ ] result = new byte [ dkLen ] ; byte [ ] block = new byte [ salt . length + <NUM_LIT> ] ; System . arraycopy ( salt , <NUM_LIT> , block , <NUM_LIT> , salt . length ) ; for ( int i = <NUM_LIT> ; i <= ( dkLen + mac . getMacLength ( ) - <NUM_LIT> ) / mac . getMacLength ( ) ; i ++ ) { block [ salt . length ] = ( byte ) ( i > > > <NUM_LIT> ) ; block [ salt . length + <NUM_LIT> ] = ( byte ) ( i > > > <NUM_LIT> ) ; block [ salt . length + <NUM_LIT> ] = ( byte ) ( i > > > <NUM_LIT> ) ; block [ salt . length + <NUM_LIT> ] = ( byte ) i ; byte [ ] u = mac . doFinal ( block ) ; byte [ ] t = u . clone ( ) ; for ( int j = <NUM_LIT> ; j < iterations ; j ++ ) { u = mac . doFinal ( u ) ; for ( int k = <NUM_LIT> ; k < t . length ; k ++ ) { t [ k ] ^= u [ k ] ; } } System . arraycopy ( t , <NUM_LIT> , result , ( i - <NUM_LIT> ) * mac . getMacLength ( ) , Math . min ( t . length , dkLen - ( i - <NUM_LIT> ) * mac . getMacLength ( ) ) ) ; } return result ; } public static boolean checkKey ( byte [ ] byteKey , byte [ ] macSalt , byte [ ] hashMac , byte [ ] message ) throws Exception { byte [ ] macKey = pbkdf2Hmac ( byteKey , macSalt , <NUM_LIT> , <NUM_LIT> ) ;", "output": "Mac mac = Mac . getInstance ( ALGORITHM ) ; SecretKeySpec keySpec = new SecretKeySpec ( macKey , ALGORITHM ) ; mac . init ( keySpec ) ; mac . update ( message ) ; mac . update ( new byte [ ] { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ) ; return Arrays . equals ( hashMac , mac . doFinal ( ) ) ; } }"}, {"input": "package org . springblade . cgform . model . generate ; import java . util . List ; import java . util . Map ; public interface IGenerate { Map < String , Object > dtaMapMethod ( ) throws Exception ;", "output": "List < String > generateCodeFile ( String paramString ) throws Exception ; List < String > generateCodeFile ( String paramString1 , String paramString2 , String paramString3 ) throws Exception ; }"}, {"input": "package com . yf . ability . shiro ; import org . apache . shiro . spring . web . ShiroFilterFactoryBean ; import org . apache . shiro . web . filter . InvalidRequestFilter ; import org . apache . shiro . web . filter . mgt . DefaultFilter ; import org . apache . shiro . web . filter . mgt . FilterChainManager ; import javax . servlet . Filter ; import java . util . Map ; public class CNFilterFactoryBean extends ShiroFilterFactoryBean { @ Override protected FilterChainManager createFilterChainManager ( ) { FilterChainManager manager = super . createFilterChainManager ( ) ; Map < String , Filter > filterMap = manager . getFilters ( ) ;", "output": "Filter invalidRequestFilter = filterMap . get ( DefaultFilter . invalidRequest . name ( ) ) ; if ( invalidRequestFilter instanceof InvalidRequestFilter ) { ( ( InvalidRequestFilter ) invalidRequestFilter ) . setBlockNonAscii ( false ) ; } return manager ; } }"}, {"input": "package ginyi . system . domain ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data public class SysCpu { @ ApiModelProperty ( \"<STR_LIT>\" ) private int cpuNum ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double total ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double sys ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double used ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double wait ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double free ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . plugin . dto . PluginDataDTO ; import com . yf . system . modules . plugin . entity . PluginData ; import java . util . List ; public interface PluginDataService extends IService < PluginData > { IPage < PluginDataDTO > paging ( PagingReqDTO < PluginDataDTO > reqDTO ) ; void save ( PluginDataDTO reqDTO ) ; void delete ( List < String > ids ) ;", "output": "PluginDataDTO detail ( String id ) ; List < PluginDataDTO > list ( PluginDataDTO reqDTO ) ; String findConfig ( String code ) ; String findServiceClazz ( String groupId ) ; }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class BooleanConverter implements Converter { private static final Set < String > TRUE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; private static final Set < String > FALSE_VALUES = new HashSet < String > ( Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; @ Override public boolean support ( Field field , CellValueType cellValueType ) { Class < ? > fieldType = field . getType ( ) ; return Boolean . class == fieldType || boolean . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; if ( TRUE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return true ; } if ( FALSE_VALUES . contains ( cellContent . toUpperCase ( ) ) ) { return false ; } return Boolean . class == fieldType ? null : false ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Boolean value = ( Boolean ) cellValue ;", "output": "cell . setCellType ( CellType . BOOLEAN ) ; cell . setCellValue ( value ) ; } }"}, {"input": "package com . yf . config ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . context . annotation . Configuration ; @ Data @ Configuration @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class BaseConfig { private Boolean demo ; private Boolean loginTick ; private String loginRedirect ; private String loginSyncPc ; private String loginSyncH5 ; public boolean isDemo ( ) { return this . demo != null && this . demo ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . oddfar . campus . common . domain . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Size ; @ Data @ EqualsAndHashCode ( callSuper = true ) @ TableName ( \"<STR_LIT>\" ) public class SysConfigEntity extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long configId ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String configName ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String configKey ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String configValue ; @ NotBlank ( message = \"<STR_LIT>\" ) private String configType ; @ NotBlank ( message = \"<STR_LIT>\" ) private String groupCode ; private String remark ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; public class Tuple < A , B > { private static final Tuple empty = new Tuple ( ) ; private A first ; private B second ; private Tuple ( ) { } ; public static < A , B > Tuple < A , B > empty ( ) { return empty ; } public static < A , B > Tuple < A , B > of ( A first , B second ) { Tuple < A , B > tuple = new Tuple < A , B > ( ) ; tuple . setFirst ( first ) ;", "output": "tuple . setSecond ( second ) ; return tuple ; } public A getFirst ( ) { return first ; } public void setFirst ( A first ) { this . first = first ; } public B getSecond ( ) { return second ; } public void setSecond ( B second ) { this . second = second ; } }"}, {"input": "package cn . org . alan . exam . common . handler ; import cn . org . alan . exam . util . DateTimeUtil ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . reflection . MetaObject ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; import org . springframework . stereotype . Component ; import java . lang . reflect . Field ; import java . time . LocalDateTime ; import java . util . Arrays ; import java . util . Objects ; @ Component @ Slf4j public class FiledFullHandler implements MetaObjectHandler { @ Override public void insertFill ( MetaObject metaObject ) { Class < ? > clazz = metaObject . getOriginalObject ( ) . getClass ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; Arrays . stream ( fields ) . forEach ( field -> { if ( \"<STR_LIT>\" . equals ( field . getName ( ) ) && ( Objects . isNull ( getFieldValByName ( \"<STR_LIT>\" , metaObject ) ) ) ) { log . info ( \"<STR_LIT>\" ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Integer . class , SecurityUtil . getUserId ( ) ) ;", "output": "} if ( \"<STR_LIT>\" . equals ( field . getName ( ) ) && ( Objects . isNull ( getFieldValByName ( \"<STR_LIT>\" , metaObject ) ) ) ) { log . info ( \"<STR_LIT>\" ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , LocalDateTime . class , DateTimeUtil . getDateTime ( ) ) ; } } ) ; } @ Override public void updateFill ( MetaObject metaObject ) { } }"}, {"input": "package org . springblade . config . util ; import org . springframework . util . StringUtils ; import java . beans . PropertyEditorSupport ; import java . sql . Timestamp ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils extends PropertyEditorSupport { public static ThreadLocal < SimpleDateFormat > date_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyyMMdd = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > date_sdf_wz = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > yyyymmddhhmmss = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > short_time_sdf = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; public static ThreadLocal < SimpleDateFormat > datetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { @ Override protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private static final long DAY_IN_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static final long HOUR_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long MINUTE_IN_MILLIS = <NUM_LIT> * <NUM_LIT> ; private static final long SECOND_IN_MILLIS = <NUM_LIT> ; private static SimpleDateFormat getSDFormat ( String pattern ) { return new SimpleDateFormat ( pattern ) ; } public static Calendar getCalendar ( ) { return Calendar . getInstance ( ) ; } public static Calendar getCalendar ( long millis ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( new Date ( millis ) ) ; return cal ; } public static Date getDate ( ) { return new Date ( ) ; } public static Date getDate ( long millis ) { return new Date ( millis ) ; } public static String timestamptoStr ( Timestamp time ) { Date date = null ;", "output": "if ( null != time ) { date = new Date ( time . getTime ( ) ) ; } return date2Str ( date_sdf . get ( ) ) ; } public static Timestamp str2Timestamp ( String str ) { Date date = str2Date ( str , date_sdf . get ( ) ) ; return new Timestamp ( date . getTime ( ) ) ; } public static Date str2Date ( String str , SimpleDateFormat sdf ) { if ( null == str || \"<STR_LIT>\" . equals ( str ) ) { return null ; } Date date = null ; try { date = sdf . parse ( str ) ; return date ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return null ; } public static String date2Str ( SimpleDateFormat date_sdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String dateformat ( String date , String format ) { SimpleDateFormat sformat = new SimpleDateFormat ( format ) ; Date _date = null ; try { _date = sformat . parse ( date ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } return sformat . format ( _date ) ; } public static String date2Str ( Date date , SimpleDateFormat date_sdf ) { if ( null == date ) { return null ; } return date_sdf . format ( date ) ; } public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; } public static Timestamp getTimestamp ( long millis ) { return new Timestamp ( millis ) ; } public static Timestamp getTimestamp ( String time ) { return new Timestamp ( Long . parseLong ( time ) ) ; } public static Timestamp getTimestamp ( ) { return new Timestamp ( System . currentTimeMillis ( ) ) ; } public static String now ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static Timestamp getTimestamp ( Date date ) { return new Timestamp ( date . getTime ( ) ) ; } public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; } public static Timestamp gettimestamp ( ) { Date dt = new Date ( ) ; DateFormat df = new SimpleDateFormat ( \"<STR_LIT>\" ) ; String nowTime = df . format ( dt ) ; Timestamp buydate = Timestamp . valueOf ( nowTime ) ; return buydate ; } public static long getMillis ( ) { return System . currentTimeMillis ( ) ; } public static long getMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } public static long getMillis ( Date date ) { return date . getTime ( ) ; } public static long getMillis ( Timestamp ts ) { return ts . getTime ( ) ; } public static String formatDate ( ) { return date_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDateTime ( ) { return datetimeFormat . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String getDataString ( SimpleDateFormat formatstr ) { return formatstr . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal ) { return date_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date ) { return date_sdf . get ( ) . format ( date ) ; } public static String formatDate ( long millis ) { return date_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatDate ( String pattern ) { return getSDFormat ( pattern ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatDate ( Calendar cal , String pattern ) { return getSDFormat ( pattern ) . format ( cal . getTime ( ) ) ; } public static String formatDate ( Date date , String pattern ) { return getSDFormat ( pattern ) . format ( date ) ; } public static String formatTime ( ) { return time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatTime ( long millis ) { return time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatTime ( Calendar cal ) { return time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; } public static String formatShortTime ( ) { return short_time_sdf . get ( ) . format ( getCalendar ( ) . getTime ( ) ) ; } public static String formatShortTime ( long millis ) { return short_time_sdf . get ( ) . format ( new Date ( millis ) ) ; } public static String formatShortTime ( Calendar cal ) { return short_time_sdf . get ( ) . format ( cal . getTime ( ) ) ; } public static String formatShortTime ( Date date ) { return short_time_sdf . get ( ) . format ( date ) ; } public static Date parseDate ( String src , String pattern ) throws ParseException { return getSDFormat ( pattern ) . parse ( src ) ; } public static Calendar parseCalendar ( String src , String pattern ) throws ParseException { Date date = parseDate ( src , pattern ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal ; } public static String formatAddDate ( String src , String pattern , int amount ) throws ParseException { Calendar cal ; cal = parseCalendar ( src , pattern ) ; cal . add ( Calendar . DATE , amount ) ; return formatDate ( cal ) ; } public static Timestamp parseTimestamp ( String src , String pattern ) throws ParseException { Date date = parseDate ( src , pattern ) ; return new Timestamp ( date . getTime ( ) ) ; } public static int dateDiff ( char flag , Calendar calSrc , Calendar calDes ) { long millisDiff = getMillis ( calSrc ) - getMillis ( calDes ) ; if ( flag == '<STR_LIT>' ) { return ( calSrc . get ( Calendar . YEAR ) - calDes . get ( Calendar . YEAR ) ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / DAY_IN_MILLIS ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / HOUR_IN_MILLIS ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / MINUTE_IN_MILLIS ) ; } if ( flag == '<STR_LIT>' ) { return ( int ) ( millisDiff / SECOND_IN_MILLIS ) ; } return <NUM_LIT> ; } @ Override public void setAsText ( String text ) throws IllegalArgumentException { if ( StringUtils . hasText ( text ) ) { try { if ( text . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> && text . length ( ) == <NUM_LIT> ) { setValue ( DateUtils . date_sdf . get ( ) . parse ( text ) ) ; } else if ( text . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> && text . length ( ) == <NUM_LIT> ) { setValue ( DateUtils . datetimeFormat . get ( ) . parse ( text ) ) ; } else { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } } catch ( ParseException ex ) { IllegalArgumentException iae = new IllegalArgumentException ( \"<STR_LIT>\" + ex . getMessage ( ) ) ; iae . initCause ( ex ) ; throw iae ; } } else { setValue ( null ) ; } } public static int getYear ( ) { GregorianCalendar calendar = new GregorianCalendar ( ) ; calendar . setTime ( getDate ( ) ) ; return calendar . get ( Calendar . YEAR ) ; } }"}, {"input": "package org . example . ddduser . infrastructure . repository . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; @ Data public class UserDetail extends DataObject { private Long userId ; private String nickName ; private String avatar ; private Gender gender ; private Integer age ; private String country ; private String province ; private String city ; private String county ; private String detailAddress ;", "output": "}"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String contractType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String contractCoinId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String jhwtServiceType ;", "output": "}"}, {"input": "package org . example . ddduser . application . service ; import org . example . ddduser . application . dto . result . UserProfile ; public interface UserQueryService { UserProfile profile ( ) ;", "output": "}"}, {"input": "package org . example . infrastructure . repository . example ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . microservice . core . DDDRepositoryImpl ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . domain . example . entity . ExampleEntity ; import org . example . domain . example . repository . ExampleRepository ; import org . example . infrastructure . convertor . example . ExampleConvertor ; import org . example . infrastructure . repository . example . database . ExampleMapper ; import org . example . infrastructure . repository . example . database . dataobject . Example ; import org . springframework . stereotype . Component ; @ Component public class ExampleRepositoryImpl extends DDDRepositoryImpl < ExampleEntity , Example , ExampleConvertor , ExampleMapper > implements ExampleRepository { @ Override public ExampleEntity getByUsername ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Example example = mapper . selectOne ( new QueryWrapper < Example > ( ) . lambda ( ) . eq ( Example :: getUsername , username ) ) ;", "output": "return convertor . toEntity ( example ) ; } }"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; import java . util . List ; @ Data public class DesformUpdateTimeModel {", "output": "List < String > idList ; }"}, {"input": "package org . springblade . cgform . model . query ; import org . springblade . config . util . ConvertUtils ; public enum QueryRuleEnum { GT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , GE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LT ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EQ ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , IN ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LEFT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , RIGHT_LIKE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SQL_RULES ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "private String value ; private String condition ; private String msg ; QueryRuleEnum ( String value , String condition , String msg ) { this . value = value ; this . condition = condition ; this . msg = msg ; } public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public String getCondition ( ) { return condition ; } public void setCondition ( String condition ) { this . condition = condition ; } public static QueryRuleEnum getByValue ( String value ) { if ( ConvertUtils . isEmpty ( value ) ) { return null ; } for ( QueryRuleEnum val : values ( ) ) { if ( val . getValue ( ) . equals ( value ) || val . getCondition ( ) . equals ( value ) ) { return val ; } } return null ; } }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Exam ; import cn . org . alan . exam . model . entity . ExamQuestion ; import cn . org . alan . exam . model . entity . Option ; import cn . org . alan . exam . model . form . exam . ExamAddForm ; import cn . org . alan . exam . model . form . exam . ExamUpdateForm ; import cn . org . alan . exam . model . vo . exam . * ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface ExamConverter { Page < ExamVO > pageEntityToVo ( Page < Exam > examPage ) ; Exam formToEntity ( ExamUpdateForm examUpdateForm ) ; Exam formToEntity ( ExamAddForm examAddForm ) ; List < ExamDetailRespVO > listEntityToExamDetailRespVO ( List < ExamQuestion > examQuestion ) ; ExamDetailVO examToExamDetailVO ( Exam exam ) ; ExamGradeListVO entityToExamGradeListVO ( Exam exam ) ; ExamQuestionVO examQuestionEntityToVO ( ExamQuestion examQuestion ) ; List < ExamQuestionVO > examQuestionListEntityToVO ( List < ExamQuestion > examQuestion ) ;", "output": "List < OptionVO > opListEntityToVO ( List < Option > examQuestion ) ; }"}, {"input": "package org . springblade . feign ; import org . springblade . core . tool . api . R ; import org . springblade . entity . * ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . * ; import java . util . Map ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMjkjWebClient { String API_PREFIX = \"<STR_LIT>\" ; String SEND_YX = API_PREFIX + \"<STR_LIT>\" ; String SEND_EMAIL = API_PREFIX + \"<STR_LIT>\" ; String SEND_PHONE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_XXL_JOB_ORDER_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String ORDER_APPEAL_TIME_OUT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MATH = API_PREFIX + \"<STR_LIT>\" ; String MARKET_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String INVITE_REWARD = API_PREFIX + \"<STR_LIT>\" ; String CONTRACT_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String RESET_MEMBER_LEVEL = API_PREFIX + \"<STR_LIT>\" ; String ORDER_STATUS = API_PREFIX + \"<STR_LIT>\" ; String WALLET_INFO = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_ASSERT = API_PREFIX + \"<STR_LIT>\" ; String CREATE_WALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_ADDFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_SUBFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_REMOVEFROZENWALLET = API_PREFIX + \"<STR_LIT>\" ; String WALLET_BUY_SELL = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_PROFIT = API_PREFIX + \"<STR_LIT>\" ; String WEALTH_CBSX_GOODS_STATUS = API_PREFIX + \"<STR_LIT>\" ; String SS_BCXX = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_NIGHT_FEE = API_PREFIX + \"<STR_LIT>\" ; String HANDLE_CONTRACT_RG = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_CANCEL = API_PREFIX + \"<STR_LIT>\" ; String ENTRUST_QUERY = API_PREFIX + \"<STR_LIT>\" ; String MEMBER_API_KEY = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( WALLET_INFO ) R < Map < String , Object > > getWalletInfo ( @ RequestBody WalletGetParam param ) ; @ PostMapping ( MEMBER_ASSERT ) R < Map < String , Object > > getMemberAssert ( @ RequestParam ( \"<STR_LIT>\" ) String memberId ) ; @ PostMapping ( CREATE_WALLET ) R < Map < String , Object > > createWallet ( @ RequestParam ( \"<STR_LIT>\" ) String id ) ; @ PostMapping ( WALLET_ADDWALLET ) R addWallet ( @ RequestBody AddWalletParam param ) ;", "output": "@ PostMapping ( WALLET_SUBWALLET ) R subWallet ( @ RequestBody SubWalletParam param ) ; @ PostMapping ( WALLET_ADDFROZENWALLET ) R addFrozenWallet ( @ RequestBody AddFrozenWalletParam param ) ; @ PostMapping ( WALLET_SUBFROZENWALLET ) R subFrozenWallet ( @ RequestBody SubFrozenWalletParam param ) ; @ PostMapping ( WALLET_REMOVEFROZENWALLET ) R removeFrozenWallet ( @ RequestBody RemoveWalletParam param ) ; @ PostMapping ( WALLET_BUY_SELL ) R walletBuySell ( @ RequestBody BuySellWalletParam param ) ; @ PostMapping ( SEND_YX ) Boolean sendYx ( @ RequestBody SendYxParam param ) ; @ PostMapping ( SEND_EMAIL ) Boolean sendEmail ( @ RequestBody SendEmailParam param ) ; @ PostMapping ( SEND_PHONE ) Boolean sendPhone ( @ RequestBody SendPhoneParam param ) ; @ PostMapping ( HANDLE_XXL_JOB_ORDER_TIME_OUT ) void orderTimeOutJobHandler ( ) ; @ PostMapping ( ORDER_APPEAL_TIME_OUT ) void orderAppealTimeOutJobHandler ( ) ; @ PostMapping ( RESET_MATH ) void resetMath ( ) ; @ PostMapping ( MARKET_PROFIT ) void marketProfit ( ) ; @ PostMapping ( INVITE_REWARD ) void inviteReward ( ) ; @ PostMapping ( CONTRACT_PROFIT ) void contractProfit ( @ RequestParam ( \"<STR_LIT>\" ) String param ) ; @ PostMapping ( RESET_MEMBER_LEVEL ) void resetMemberLevel ( @ RequestParam ( \"<STR_LIT>\" ) String operateMemberI ) ; @ PostMapping ( ORDER_STATUS ) R changeOrderStatus ( @ RequestParam ( \"<STR_LIT>\" ) String id , @ RequestParam ( \"<STR_LIT>\" ) String status ) ; @ PostMapping ( WEALTH_CBSX_PROFIT ) void wealthCbsxProfit ( ) ; @ PostMapping ( WEALTH_CBSX_GOODS_STATUS ) void changeCbsxGoodsStatus ( ) ; @ PostMapping ( SS_BCXX ) void appeal ( @ RequestBody Appeal appeal ) ; @ PostMapping ( HANDLE_NIGHT_FEE ) void handleNightFee ( ) ; @ PostMapping ( HANDLE_CONTRACT_RG ) R handleContractRg ( @ RequestParam ( \"<STR_LIT>\" ) String logContractId , @ RequestParam ( \"<STR_LIT>\" ) String type ) ; @ PostMapping ( ENTRUST ) R entrust ( @ RequestBody EntrustParamApi param ) ; @ PostMapping ( ENTRUST_CANCEL ) R cancelEntrust ( @ RequestBody CancelExchangeParamDTO param ) ; @ GetMapping ( ENTRUST_QUERY ) R queryEntrust ( @ RequestParam ( \"<STR_LIT>\" ) String entrustType , @ RequestParam ( \"<STR_LIT>\" ) String entrustFlag , @ RequestParam ( \"<STR_LIT>\" ) String symbol ) ; @ PostMapping ( MEMBER_API_KEY ) R < Map < String , Object > > getApiKey ( @ RequestParam ( \"<STR_LIT>\" ) String apiKey ) ; }"}, {"input": "package org . example . ddduser . infrastructure . repository ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . example . ddduser . infrastructure . repository . database . UserDetailMapper ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . User ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class UserRepositoryImpl implements UserRepository { @ Autowired private UserMapper userMapper ; @ Autowired private UserDetailMapper userDetailMapper ; @ Autowired private UserConvertor userConvertor ; @ Override public UserEntity find ( Long userId ) { if ( userId == null ) { return null ; } User user = userMapper . selectById ( userId ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userId ) ) ;", "output": "return userConvertor . toEntity ( user , userDetail ) ; } @ Override public UserEntity find ( String username ) { if ( TextUtil . isBlank ( username ) ) { return null ; } Wrapper < User > query = new QueryWrapper < User > ( ) . lambda ( ) . eq ( User :: getUsername , username ) ; User user = userMapper . selectOne ( query ) ; if ( user == null ) { return null ; } UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , user . getId ( ) ) ) ; return userConvertor . toEntity ( user , userDetail ) ; } @ Override public Long save ( UserEntity userEntity ) { if ( userEntity . getId ( ) != null ) { User existingUser = userMapper . selectById ( userEntity . getId ( ) ) ; if ( existingUser == null ) { return null ; } userConvertor . toUserPo ( userEntity , existingUser ) ; userMapper . updateById ( existingUser ) ; UserDetail userDetail = userDetailMapper . selectOne ( new QueryWrapper < UserDetail > ( ) . lambda ( ) . eq ( UserDetail :: getUserId , userEntity . getId ( ) ) ) ; userConvertor . toDetailPo ( userEntity , userDetail ) ; userDetailMapper . updateById ( userDetail ) ; return userEntity . getId ( ) ; } User newUser = userConvertor . toUserPo ( userEntity ) ; userMapper . insert ( newUser ) ; UserDetail userDetail = userConvertor . toDetailPo ( userEntity , newUser . getId ( ) ) ; userDetailMapper . insert ( userDetail ) ; return newUser . getId ( ) ; } }"}, {"input": "package org . springblade . cgform . service ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import org . springblade . cgform . model . KvModel ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . WebUtil ; import java . util . List ; import java . util . Map ; public interface IMjkjBaseSqlService { List < Map < String , Object > > getDataByTable ( String tableName ) ; List < Map < String , Object > > getDataByTable ( String tableName , List < String > customFieldList ) ; List < Map < String , Object > > getDataByTableRedis ( String tableName , Long time ) ; Map < String , Object > getTableById ( String tableName , String id ) ; Map < String , Object > getTableByIdL ( String tableName , Long id ) ; Map < String , Object > getTableById ( String tableName , String id , List < String > customFieldList ) ; Map < String , Object > getTableByIdRedis ( String tableName , String id , Long time ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue ) ; List < Map < String , Object > > getDataListByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; List < Map < String , Object > > getDataListByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue ) ;", "output": "Map < String , Object > getDataOneByField ( String tableName , String whereFieldName , Object whereFieldValue , List < String > customFieldList ) ; Map < String , Object > getDataOneByFieldRedis ( String tableName , String whereFieldName , Object whereFieldValue , Long time ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr ) ; Map < String , Object > getDataOneByFieldOrderBy ( String tableName , String whereFieldName , Object whereFieldValue , String orderByField , String orderStr , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type ) ; List < Map < String , Object > > getDataListByLike ( String tableName , String whereFieldName , Object whereFieldValue , String type , List < String > customFieldList ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue ) ; List < Map < String , Object > > getDataListByIn ( String tableName , String whereFieldName , List < Object > whereFieldValue , List < String > customFieldList ) ; List < KvModel > getSysDictItemList ( String dictCode , Boolean redisFlag ) ; String getSysDictItemValue ( String dictCode , String itemValue , Boolean redisFlag ) ; String getSysDictItemValueByText ( String dictCode , String itemText , Boolean redisFlag ) ; Map < String , Map < String , Object > > getData2Map ( String tableName , String key , Boolean redisFlag ) ; Long baseInsertData ( String tableName , Map < String , Object > dataMap ) ; Long baseSimpleIntegerSql ( String tableName , Map < String , Object > dataMap ) ; void baseUpdateData ( String tableName , Map < String , Object > map , String id ) ; void baseUpdateDataLong ( String tableName , Map < String , Object > map , Long id ) ; void baseUpdateDataWhere ( String tableName , Map < String , Object > map , String whereCol , String whereVal ) ; void baseUpdateDataTenantIgnore ( String tableName , Map < String , Object > map , String id ) ; Integer baseDeleteSqlStr ( String tableName , String id ) ; Integer baseDeleteSql ( String tableName , Long id ) ; Integer baseRealDeleteSql ( String tableName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , Long id ) ; Integer baseZdyDeleteSql ( String tableName , String whereFieldName , String id ) ; List < Long > getAdminIdList ( ) ; int getProcessingProgress ( String tableName , String batchCode ) ; int getProcessingProgressTotal ( String tableName , String batchCode ) ; List < Map < String , Object > > getBladeUserOauth ( String uuid , String source ) ; List < Map < String , Object > > getBladeUserOauthByUserId ( Long userId ) ; void unBindBladeUserOauth ( Long id ) ; < T > List < Map < String , T > > getDataListByFieldParams ( String tableName , Wrapper < T > wrapper ) ; < T > Map < String , T > getDataOneByFieldParams ( String tableName , Wrapper < T > wrapper ) ; < T > IPage < Map < String , T > > getDataIPageByFieldParams ( String tableName , IPage page , Wrapper < T > wrapper ) ; List < String > getAllBorrowMemberId ( ) ; List < String > getAllContractMemberId ( ) ; List < String > getMyAllContractSymbolName ( String memberId ) ; String getMngLanguage ( String str ) ; String getMngLanguage ( String lang , String str ) ; }"}, {"input": "package cn . org . alan . exam . model . form ; import cn . org . alan . exam . common . group . CertificateGroup ; import jakarta . validation . constraints . NotBlank ; public class CertificateForm { private Integer id ; @ NotBlank ( message = \"<STR_LIT>\" , groups = CertificateGroup . CertificateInsertGroup . class ) private String certificateName ; private String image ; @ NotBlank ( message = \"<STR_LIT>\" , groups = CertificateGroup . CertificateInsertGroup . class ) private String certificationNuit ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public String getCertificateName ( ) { return certificateName ; } public void setCertificateName ( String certificateName ) {", "output": "this . certificateName = certificateName ; } public String getImage ( ) { return image ; } public void setImage ( String image ) { this . image = image ; } public String getCertificationNuit ( ) { return certificationNuit ; } public void setCertificationNuit ( String certificationNuit ) { this . certificationNuit = certificationNuit ; } }"}, {"input": "package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . POST ) public @ interface AnonymousPostMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default \"<STR_LIT>\" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default {", "output": "} ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; }"}, {"input": "package top . kangert . kspider . service ; import java . util . Map ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import top . kangert . kspider . entity . User ; import top . kangert . kspider . util . PageInfo ; public interface UserService { PageInfo < User > findUser ( Map < String , Object > params ) ; void login ( HttpServletRequest request , HttpServletResponse response , User user ) ;", "output": "void add ( User user ) ; void delete ( Integer id ) ; }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; @ Data public class QuickParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinSymbol ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cou ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatSymbol ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String info ; private static final long serialVersionUID = <NUM_LIT> ;", "output": "}"}, {"input": "package ginyi . common . exception ; import ginyi . common . result . StateCode ; import lombok . Data ; @ Data public class UserPasswordRetryLimitExceedException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private StateCode state ; private Object data ; public UserPasswordRetryLimitExceedException ( StateCode state , Object data ) { this . state = state ; this . data = data ; }", "output": "public UserPasswordRetryLimitExceedException ( StateCode state ) { this . state = state ; this . data = data ; } }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . service . ContactHeadImgService ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . io . OutputStream ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class ContactHeadImgController { private final ContactHeadImgService contactHeadImgService ; @ GetMapping ( \"<STR_LIT>\" ) public void avatar ( String userName , HttpServletResponse response ) { byte [ ] avatarBytes = contactHeadImgService . avatar ( userName ) ; if ( avatarBytes != null ) {", "output": "response . setContentType ( \"<STR_LIT>\" ) ; response . setContentLength ( avatarBytes . length ) ; try ( OutputStream os = response . getOutputStream ( ) ) { os . write ( avatarBytes ) ; os . flush ( ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , e ) ; } } else { response . setStatus ( HttpServletResponse . SC_NOT_FOUND ) ; } } }"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class TreeModel { private String label ; private String store ; private String id ; private String pid ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import com . alibaba . nacos . api . naming . listener . EventListener ; import com . alibaba . nacos . api . naming . pojo . Instance ; import com . alibaba . nacos . api . naming . pojo . ListView ; import com . alibaba . nacos . api . naming . pojo . ServiceInfo ; import com . alibaba . nacos . api . selector . AbstractSelector ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import java . util . List ; import java . util . Properties ; class DelegatingNamingService implements NamingService , NacosServiceMetaData , DisposableBean { private final NamingService delegate ; private final Properties properties ; DelegatingNamingService ( NamingService delegate , Properties properties ) { this . delegate = delegate ; this . properties = properties ; } @ Override public void registerInstance ( String serviceName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port ) ; } @ Override public void registerInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . registerInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void registerInstance ( String serviceName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , instance ) ; } @ Override public void registerInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . registerInstance ( serviceName , groupName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port ) throws NacosException {", "output": "delegate . deregisterInstance ( serviceName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port ) ; } @ Override public void deregisterInstance ( String serviceName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , String ip , int port , String clusterName ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , ip , port , clusterName ) ; } @ Override public void deregisterInstance ( String serviceName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , instance ) ; } @ Override public void deregisterInstance ( String serviceName , String groupName , Instance instance ) throws NacosException { delegate . deregisterInstance ( serviceName , groupName , instance ) ; } @ Override public List < Instance > getAllInstances ( String serviceName ) throws NacosException { return delegate . getAllInstances ( serviceName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , clusters , subscribe ) ; } @ Override public List < Instance > getAllInstances ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . getAllInstances ( serviceName , groupName , clusters , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy ) ; } @ Override public List < Instance > selectInstances ( String serviceName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , clusters , healthy , subscribe ) ; } @ Override public List < Instance > selectInstances ( String serviceName , String groupName , List < String > clusters , boolean healthy , boolean subscribe ) throws NacosException { return delegate . selectInstances ( serviceName , groupName , clusters , healthy , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , clusters , subscribe ) ; } @ Override public Instance selectOneHealthyInstance ( String serviceName , String groupName , List < String > clusters , boolean subscribe ) throws NacosException { return delegate . selectOneHealthyInstance ( serviceName , groupName , clusters , subscribe ) ; } @ Override public void subscribe ( String serviceName , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , listener ) ; } @ Override public void subscribe ( String serviceName , String groupName , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , groupName , listener ) ; } @ Override public void subscribe ( String serviceName , List < String > clusters , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , clusters , listener ) ; } @ Override public void subscribe ( String serviceName , String groupName , List < String > clusters , EventListener listener ) throws NacosException { delegate . subscribe ( serviceName , groupName , clusters , listener ) ; } @ Override public void unsubscribe ( String serviceName , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , listener ) ; } @ Override public void unsubscribe ( String serviceName , String groupName , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , groupName , listener ) ; } @ Override public void unsubscribe ( String serviceName , List < String > clusters , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , clusters , listener ) ; } @ Override public void unsubscribe ( String serviceName , String groupName , List < String > clusters , EventListener listener ) throws NacosException { delegate . unsubscribe ( serviceName , groupName , clusters , listener ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , String groupName ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , groupName ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , AbstractSelector selector ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , selector ) ; } @ Override public ListView < String > getServicesOfServer ( int pageNo , int pageSize , String groupName , AbstractSelector selector ) throws NacosException { return delegate . getServicesOfServer ( pageNo , pageSize , groupName , selector ) ; } @ Override public List < ServiceInfo > getSubscribeServices ( ) throws NacosException { return delegate . getSubscribeServices ( ) ; } @ Override public String getServerStatus ( ) { return delegate . getServerStatus ( ) ; } @ Override public void shutDown ( ) throws NacosException { delegate . shutDown ( ) ; } @ Override public Properties getProperties ( ) { return properties ; } @ Override public void destroy ( ) throws Exception { shutDown ( ) ; } }"}, {"input": "package org . springblade . web . utils . resource ; import com . aliyun . oss . ClientConfiguration ; import com . aliyun . oss . OSSClient ; import com . aliyun . oss . common . auth . CredentialsProvider ; import com . aliyun . oss . common . auth . DefaultCredentialProvider ; import lombok . SneakyThrows ; import org . springblade . core . oss . AliossTemplate ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . entity . Oss ; public class AliOssBuilder { @ SneakyThrows public static OssTemplate template ( Oss oss , OssRule ossRule ) { ClientConfiguration conf = new ClientConfiguration ( ) ; conf . setMaxConnections ( <NUM_LIT> ) ; conf . setSocketTimeout ( <NUM_LIT> ) ; conf . setConnectionTimeout ( <NUM_LIT> ) ; conf . setConnectionRequestTimeout ( <NUM_LIT> ) ; conf . setIdleConnectionTime ( <NUM_LIT> ) ; conf . setMaxErrorRetry ( <NUM_LIT> ) ; OssProperties ossProperties = new OssProperties ( ) ; ossProperties . setEndpoint ( oss . getEndpoint ( ) ) ; ossProperties . setAccessKey ( oss . getAccessKey ( ) ) ; ossProperties . setSecretKey ( oss . getSecretKey ( ) ) ; ossProperties . setBucketName ( oss . getBucketName ( ) ) ; CredentialsProvider credentialsProvider = new DefaultCredentialProvider ( ossProperties . getAccessKey ( ) , ossProperties . getSecretKey ( ) ) ; OSSClient ossClient = new OSSClient ( ossProperties . getEndpoint ( ) , credentialsProvider , conf ) ; return new AliossTemplate ( ossClient , ossProperties , ossRule ) ;", "output": "} }"}, {"input": "package com . oddfar . campus . framework . service ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysDictDataEntity ; public interface SysDictDataService { PageResult < SysDictDataEntity > page ( SysDictDataEntity dictDataEntity ) ; int insertDictData ( SysDictDataEntity dictData ) ; SysDictDataEntity selectDictDataById ( Long dictCode ) ;", "output": "int updateDictData ( SysDictDataEntity dictData ) ; void deleteDictDataByIds ( Long [ ] dictCodes ) ; }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . util . ExtractUtils ; import org . jsoup . nodes . Element ; import org . jsoup . select . Elements ; import org . springframework . stereotype . Component ; import java . util . ArrayList ; import java . util . List ; @ Component public class ElementsFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return Elements . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String xpath ( Elements elements , String xpath ) { return ExtractUtils . getValueByXPath ( elements , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > xpaths ( Elements elements , String xpath ) { return ExtractUtils . getValuesByXPath ( elements , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( Elements elements , String regx ) { return ExtractUtils . getFirstMatcher ( elements . html ( ) , regx , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( Elements elements , String regx , int groupIndex ) { return ExtractUtils . getFirstMatcher ( elements . html ( ) , regx , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regx ( Elements elements , String regx , List < Integer > groups ) { return ExtractUtils . getFirstMatcher ( elements . html ( ) , regx , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( Elements elements , String regx ) { return ExtractUtils . getMatchers ( elements . html ( ) , regx , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( Elements elements , String regx , int groupIndex ) { return ExtractUtils . getMatchers ( elements . html ( ) , regx , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < List < String > > regxs ( Elements elements , String regx , List < Integer > groups ) { return ExtractUtils . getMatchers ( elements . html ( ) , regx , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element selector ( Elements elements , String selector ) { Elements foundElements = elements . select ( selector ) ; if ( foundElements . size ( ) > <NUM_LIT> ) { return foundElements . get ( <NUM_LIT> ) ; } return null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > attrs ( Elements elements , String key ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . attr ( key ) ) ; } return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > vals ( Elements elements ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . val ( ) ) ; } return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > texts ( Elements elements ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . text ( ) ) ; } return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > htmls ( Elements elements ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . html ( ) ) ; } return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > outerHtmls ( Elements elements ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . outerHtml ( ) ) ; }", "output": "return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > ownTexts ( Elements elements ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . ownText ( ) ) ; } return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > wholeTexts ( Elements elements ) { List < String > list = new ArrayList < > ( elements . size ( ) ) ; for ( Element element : elements ) { list . add ( element . wholeText ( ) ) ; } return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements selectors ( Elements elements , String selector ) { return elements . select ( selector ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements parents ( Elements elements ) { return elements . parents ( ) ; } }"}, {"input": "package com . oddfar . campus . common . enums ; public enum UserStatusEnum { OK ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DISABLE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DELETED ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private final String code ;", "output": "private final String info ; UserStatusEnum ( String code , String info ) { this . code = code ; this . info = info ; } public String getCode ( ) { return code ; } public String getInfo ( ) { return info ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class ManualScore implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer examQuAnswerId ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer score ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getExamQuAnswerId ( ) { return examQuAnswerId ; } public void setExamQuAnswerId ( Integer examQuAnswerId ) { this . examQuAnswerId = examQuAnswerId ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getScore ( ) { return score ; } public void setScore ( Integer score ) { this . score = score ; } public LocalDateTime getCreateTime ( ) { return createTime ; }", "output": "public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + examQuAnswerId + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + score + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" ; } }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . RepoConverter ; import cn . org . alan . exam . mapper . ExerciseRecordMapper ; import cn . org . alan . exam . mapper . QuestionMapper ; import cn . org . alan . exam . mapper . RepoMapper ; import cn . org . alan . exam . mapper . UserExerciseRecordMapper ; import cn . org . alan . exam . model . entity . ExerciseRecord ; import cn . org . alan . exam . model . entity . Question ; import cn . org . alan . exam . model . entity . Repo ; import cn . org . alan . exam . model . entity . UserExerciseRecord ; import cn . org . alan . exam . model . vo . repo . RepoListVO ; import cn . org . alan . exam . model . vo . repo . RepoVO ; import cn . org . alan . exam . model . vo . exercise . ExerciseRepoVO ; import cn . org . alan . exam . service . IRepoService ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . List ; @ Service public class RepoServiceImpl extends ServiceImpl < RepoMapper , Repo > implements IRepoService { @ Resource private RepoMapper repoMapper ; @ Resource private QuestionMapper questionMapper ; @ Resource private ExerciseRecordMapper exerciseRecordMapper ; @ Override public Result < String > addRepo ( Repo repo ) { repoMapper . insert ( repo ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override public Result < String > updateRepo ( Repo repo , Integer id ) { LambdaUpdateWrapper < Repo > updateWrapper = new LambdaUpdateWrapper < Repo > ( ) . eq ( Repo :: getId , id ) . set ( Repo :: getTitle , repo . getTitle ( ) ) ; repoMapper . update ( updateWrapper ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ Transactional public Result < String > deleteRepoById ( Integer id ) { LambdaUpdateWrapper < Question > wrapper = new LambdaUpdateWrapper < Question > ( ) . eq ( Question :: getRepoId , id ) . set ( Question :: getRepoId , null ) ; questionMapper . update ( wrapper ) ; LambdaUpdateWrapper < Repo > repoLambdaUpdateWrapper = new LambdaUpdateWrapper < > ( ) ; repoLambdaUpdateWrapper . eq ( Repo :: getId , id ) . set ( Repo :: getIsDeleted , <NUM_LIT> ) ; int result = repoMapper . update ( repoLambdaUpdateWrapper ) ; if ( result > <NUM_LIT> ) { return Result . success ( \"<STR_LIT>\" ) ; } return Result . failed ( \"<STR_LIT>\" ) ; } @ Override public Result < List < RepoListVO > > getRepoList ( String repoTitle ) { List < RepoListVO > list ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { list = repoMapper . selectRepoList ( repoTitle , SecurityUtil . getUserId ( ) ) ; } else { list = repoMapper . selectRepoList ( repoTitle , <NUM_LIT> ) ; } return Result . success ( \"<STR_LIT>\" , list ) ; } @ Override public Result < IPage < RepoVO > > pagingRepo ( Integer pageNum , Integer pageSize , String title ) { IPage < RepoVO > page = new Page < > ( pageNum , pageSize ) ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { page = repoMapper . pagingRepo ( page , title , SecurityUtil . getUserId ( ) ) ; } else { page = repoMapper . pagingRepo ( page , title , <NUM_LIT> ) ; } return Result . success ( null , page ) ; } @ Override public Result < IPage < ExerciseRepoVO > > getRepo ( Integer pageNum , Integer pageSize , String title ) {", "output": "IPage < ExerciseRepoVO > page = new Page < > ( pageNum , pageSize ) ; page = repoMapper . selectRepo ( page , title ) ; return Result . success ( null , page ) ; } }"}, {"input": "package org . springblade . cgform . model ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . config . exception . BusinessException ; import java . util . Map ; public interface CgformEnhanceJavaBatchInter {", "output": "Map < String , Object > getOtherParam ( String batchCode ) ; int execute ( CgformHead head , JSONObject jsonobject , Map < String , Object > otherMap ) throws BusinessException ; }"}, {"input": "package com . oddfar . campus . framework . interceptor ; import com . alibaba . fastjson2 . JSON ; import com . oddfar . campus . common . annotation . RepeatSubmit ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . utils . ServletUtils ; import org . springframework . stereotype . Component ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . lang . reflect . Method ; @ Component public abstract class RepeatSubmitInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { if ( handler instanceof HandlerMethod ) {", "output": "HandlerMethod handlerMethod = ( HandlerMethod ) handler ; Method method = handlerMethod . getMethod ( ) ; RepeatSubmit annotation = method . getAnnotation ( RepeatSubmit . class ) ; if ( annotation != null ) { if ( this . isRepeatSubmit ( request , annotation ) ) { R r = R . error ( annotation . message ( ) ) ; ServletUtils . renderString ( response , JSON . toJSONString ( r ) ) ; return false ; } } return true ; } else { return true ; } } public abstract boolean isRepeatSubmit ( HttpServletRequest request , RepeatSubmit annotation ) ; }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SubFrozenWalletParam { private String tableName ; private String walletId ; private BigDecimal subfrozenBalance ; private boolean messageRefreshFlag = true ;", "output": "}"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . vo . MsgVO ; import java . util . List ; public interface MsgService {", "output": "List < MsgVO > queryMsg ( String talker , Long nextSequence ) ; String exportMsg ( String talker ) ; }"}, {"input": "package top . kangert . kspider . config ; import lombok . extern . slf4j . Slf4j ; import top . kangert . kspider . entity . Application ; import top . kangert . kspider . exception . BaseException ; import top . kangert . kspider . exception . ExceptionCodes ; import top . kangert . kspider . repository . ApplicationRepository ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . http . Cookie ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Bean ; import org . springframework . http . HttpMethod ; import org . springframework . http . MediaType ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . config . annotation . web . builders . WebSecurity ; import org . springframework . security . config . annotation . web . configuration . EnableWebSecurity ; import org . springframework . security . config . annotation . web . configuration . WebSecurityCustomizer ; import org . springframework . security . config . http . SessionCreationPolicy ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . security . core . authority . SimpleGrantedAuthority ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . web . SecurityFilterChain ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; import org . springframework . web . filter . OncePerRequestFilter ; import cn . hutool . core . util . ObjectUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONUtil ; @ EnableWebSecurity @ Slf4j public class WebSecurityConfig { @ Autowired private ApplicationRepository applicationRepository ; class TokenAuthFilter extends OncePerRequestFilter { @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain chain ) throws IOException , ServletException { Cookie [ ] cookies = request . getCookies ( ) ; if ( ObjectUtil . isEmpty ( cookies ) ) { errorInfo ( response , ExceptionCodes . TOKEN_NON_EXISTENT ) ; return ; } String token = null ; for ( Cookie cookie : cookies ) { if ( \"<STR_LIT>\" . equals ( cookie . getName ( ) ) ) { token = cookie . getValue ( ) ; } } String tokenAuth = ( String ) request . getSession ( ) . getAttribute ( \"<STR_LIT>\" ) ; if ( StrUtil . isBlank ( tokenAuth ) ) { String appSecretKey = request . getHeader ( \"<STR_LIT>\" ) ; if ( StrUtil . isBlank ( appSecretKey ) ) { errorInfo ( response , ExceptionCodes . TOKEN_NON_EXISTENT ) ; return ; } Application application = applicationRepository . findByAppSecretKey ( appSecretKey ) ; if ( null == application ) { errorInfo ( response , ExceptionCodes . KEY_ERROR ) ; return ; } } else if ( ! tokenAuth . equals ( token ) ) { errorInfo ( response , ExceptionCodes . TOKEN_NON_EXISTENT ) ; return ; } String username = ( String ) request . getSession ( ) . getAttribute ( \"<STR_LIT>\" ) ; Collection < GrantedAuthority > authorities = new ArrayList < > ( ) ; authorities . add ( new SimpleGrantedAuthority ( \"<STR_LIT>\" ) ) ;", "output": "UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( username , tokenAuth , authorities ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authenticationToken ) ; chain . doFilter ( request , response ) ; } } private void errorInfo ( HttpServletResponse response , ExceptionCodes tokenNonExistent ) { errorInfo ( response , new BaseException ( tokenNonExistent ) ) ; } private void errorInfo ( HttpServletResponse response , BaseException exception ) { Map < String , Object > errorInfo = new HashMap < String , Object > ( ) ; errorInfo . put ( \"<STR_LIT>\" , exception . getCode ( ) ) ; errorInfo . put ( \"<STR_LIT>\" , exception . getMessage ( ) ) ; try { response . setContentType ( MediaType . APPLICATION_JSON_VALUE ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . getWriter ( ) . println ( JSONUtil . parseObj ( errorInfo ) . toString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ; } @ Bean SecurityFilterChain filterChain ( HttpSecurity http ) throws Exception { http . csrf ( ) . disable ( ) . sessionManagement ( ) . sessionCreationPolicy ( SessionCreationPolicy . ALWAYS ) . and ( ) . authorizeRequests ( ) . antMatchers ( HttpMethod . POST , \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . anyRequest ( ) . authenticated ( ) ; http . addFilterBefore ( new TokenAuthFilter ( ) , UsernamePasswordAuthenticationFilter . class ) ; return http . build ( ) ; } @ Bean WebSecurityCustomizer webSecurityCustomizer ( ) { return new WebSecurityCustomizer ( ) { @ Override public void customize ( WebSecurity web ) { web . ignoring ( ) . antMatchers ( \"<STR_LIT>\" ) ; web . ignoring ( ) . antMatchers ( HttpMethod . GET , \"<STR_LIT>\" ) ; web . ignoring ( ) . antMatchers ( HttpMethod . GET , \"<STR_LIT>\" ) ; } } ; } }"}, {"input": "package com . yf . system . modules . depart . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysDepart extends Model < SysDepart > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private Integer deptType ; @ TableField ( \"<STR_LIT>\" ) private String parentId ; @ TableField ( \"<STR_LIT>\" ) private String deptName ; @ TableField ( \"<STR_LIT>\" ) private String deptCode ; @ TableField ( \"<STR_LIT>\" ) private Integer deptLevel ; private Integer sort ; @ TableField ( \"<STR_LIT>\" ) private Date createTime ; @ TableField ( \"<STR_LIT>\" ) private Date updateTime ; @ TableField ( \"<STR_LIT>\" ) private String createBy ; @ TableField ( \"<STR_LIT>\" ) private String updateBy ;", "output": "}"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . bo . DecryptBO ; public interface DecryptService { void wechatDecrypt ( String password , DecryptBO decryptBO ) ;", "output": "}"}, {"input": "package org . example . ddduser . infrastructure . repository ; import io . github . chensheng . dddboot . web . core . BizException ; import io . github . chensheng . dddboot . web . core . Response ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . infrastructure . repository . microservice . WorkspaceMicroservice ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class WorkspaceRepositoryImpl implements WorkspaceRepository { @ Autowired private WorkspaceMicroservice workspaceFacade ; @ Override public void create ( Long userId ) { WorkspaceCreateRequest request = new WorkspaceCreateRequest ( ) ; request . setOwner ( userId ) ; Response < Workspace > response = workspaceFacade . create ( request ) ; if ( response == null || ! response . isSuccess ( ) ) { if ( response != null ) { throw new BizException ( response . getCode ( ) , response . getMsg ( ) ) ; }", "output": "else { throw new BizException ( ) ; } } } }"}, {"input": "package ginyi . system . mapper ; import ginyi . system . domain . SysLogOperation ; import java . util . List ; public interface SysOperLogMapper { public void insertOperlog ( SysLogOperation operLog ) ; public List < SysLogOperation > selectOperLogList ( SysLogOperation operLog ) ; public int deleteOperLogByIds ( Long [ ] operIds ) ; public SysLogOperation selectOperLogById ( Long operId ) ; public void cleanOperLog ( ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . io . URLResourceUtil ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . util . Properties ; public class PropertiesUtil { private static Logger logger = LoggerFactory . getLogger ( PropertiesUtil . class ) ; public static Boolean getBoolean ( Properties p , String name , Boolean defaultValue ) { return BooleanUtil . toBooleanObject ( p . getProperty ( name ) , defaultValue ) ; } public static Integer getInt ( Properties p , String name , Integer defaultValue ) { return NumberUtil . toIntObject ( p . getProperty ( name ) , defaultValue ) ; } public static Long getLong ( Properties p , String name , Long defaultValue ) { return NumberUtil . toLongObject ( p . getProperty ( name ) , defaultValue ) ; } public static Double getDouble ( Properties p , String name , Double defaultValue ) { return NumberUtil . toDoubleObject ( p . getProperty ( name ) , defaultValue ) ; } public static String getString ( Properties p , String name , String defaultValue ) { return p . getProperty ( name , defaultValue ) ; } public static Properties loadFromFile ( String generalPath ) { Properties p = new Properties ( ) ;", "output": "try ( Reader reader = new InputStreamReader ( URLResourceUtil . asStream ( generalPath ) , Charsets . UTF_8 ) ) { p . load ( reader ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + generalPath + \"<STR_LIT>\" , e ) ; } return p ; } public static Properties loadFromString ( String content ) { Properties p = new Properties ( ) ; try ( Reader reader = new StringReader ( content ) ) { p . load ( reader ) ; } catch ( IOException ignored ) { } return p ; } }"}, {"input": "package ginyi . common . result ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" ) public class CommonResult < T > implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer code ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String msg ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private T data ; private static < T > CommonResult < T > res ( StateCode state , T data ) { CommonResult < T > commonResult = new CommonResult < > ( ) ; commonResult . setCode ( state . getCode ( ) ) ; commonResult . setMsg ( state . getMessage ( ) ) ; commonResult . setData ( data ) ; return commonResult ; } public static < T > CommonResult < T > success ( ) { return res ( StateCode . SUCCESS , null ) ; } public static < T > CommonResult < T > success ( T data ) { return res ( StateCode . SUCCESS , data ) ; }", "output": "public static < T > CommonResult < T > error ( StateCode state ) { return res ( state , null ) ; } public static < T > CommonResult < T > error ( StateCode state , T data ) { return res ( state , data ) ; } }"}, {"input": "package cn . org . alan . exam . model . form . exam ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import jakarta . validation . constraints . * ; import lombok . Data ; import org . springframework . format . annotation . DateTimeFormat ; import java . time . LocalDateTime ; @ Data public class ExamUpdateForm { @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String title ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) private Integer examDuration ; private Integer maxCount ; @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ NotNull ( message = \"<STR_LIT>\" ) private Integer passedScore ; @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime startTime ; @ Future ( message = \"<STR_LIT>\" ) @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime endTime ; private String gradeIds ; private Integer certificateId ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer radioScore ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer multiScore ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer judgeScore ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer saqScore ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . CertificateConverter ; import cn . org . alan . exam . mapper . CertificateMapper ; import cn . org . alan . exam . model . entity . Certificate ; import cn . org . alan . exam . model . form . CertificateForm ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . model . vo . NoticeVO ; import cn . org . alan . exam . model . vo . certificate . MyCertificateVO ; import cn . org . alan . exam . service . ICertificateService ; import cn . org . alan . exam . util . CacheClient ; import cn . org . alan . exam . util . DateTimeUtil ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . concurrent . TimeUnit ; import java . util . function . Function ; import java . util . stream . Collectors ; @ Service public class CertificateServiceImpl extends ServiceImpl < CertificateMapper , Certificate > implements ICertificateService { @ Resource private CertificateMapper certificateMapper ; @ Resource private CertificateConverter certificateConverter ; @ Resource private CacheClient cacheClient ; @ Resource private StringRedisTemplate stringRedisTemplate ; @ Override @ Transactional public Result < String > addCertificate ( CertificateForm certificateForm ) { Certificate certificate = certificateConverter . fromToEntity ( certificateForm ) ; int insertRows = certificateMapper . insert ( certificate ) ; if ( insertRows > <NUM_LIT> ) { if ( certificate . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + certificate . getId ( ) . toString ( ) ) ; } return Result . success ( \"<STR_LIT>\" ) ; } else { return Result . failed ( \"<STR_LIT>\" ) ; } } @ Override public Result < IPage < Certificate > > pagingCertificate ( Integer pageNum , Integer pageSize , String certificateName , String certificationUnit ) { int total = certificateMapper . countByCondition ( SecurityUtil . getUserId ( ) , certificateName , certificationUnit ) ; int offset = ( pageNum - <NUM_LIT> ) * pageSize ; List < Integer > certificateIds = certificateMapper . selectCertificateIdsPage ( SecurityUtil . getUserId ( ) , certificateName , certificationUnit , offset , pageSize ) ; Map < Integer , Certificate > cachedGradesMap = cacheClient . batchGet ( \"<STR_LIT>\" , certificateIds , Certificate . class ) ; List < Integer > missIds = new ArrayList < > ( ) ; for ( Integer id : certificateIds ) { if ( ! cachedGradesMap . containsKey ( id ) ) { missIds . add ( id ) ; } } if ( ! missIds . isEmpty ( ) ) { List < Certificate > missedGrades = certificateMapper . batchSelectByIds ( missIds ) ; Map < Integer , Certificate > missedGradesMap = missedGrades . stream ( ) . collect ( Collectors . toMap ( Certificate :: getId , Function . identity ( ) ) ) ; cacheClient . batchPut ( \"<STR_LIT>\" , missedGradesMap , <NUM_LIT> , TimeUnit . MINUTES ) ; cachedGradesMap . putAll ( missedGradesMap ) ; } List < Certificate > finalResult = new ArrayList < > ( certificateIds . size ( ) ) ; for ( Integer id : certificateIds ) { finalResult . add ( cachedGradesMap . get ( id ) ) ; } IPage < Certificate > resultPage = new Page < > ( pageNum , pageSize , Long . valueOf ( total ) ) ; resultPage . setRecords ( finalResult ) ; return Result . success ( \"<STR_LIT>\" , resultPage ) ; } @ Override @ Transactional public Result < String > updateCertificate ( CertificateForm certificateForm ) { Certificate certificate = certificateConverter . fromToEntity ( certificateForm ) ; int affectedRows = certificateMapper . updateById ( certificate ) ; if ( affectedRows > <NUM_LIT> ) { if ( certificate . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + certificate . getId ( ) . toString ( ) ) ; } return Result . success ( \"<STR_LIT>\" ) ; } else { return Result . failed ( \"<STR_LIT>\" ) ; } } @ Override @ Transactional public Result < String > deleteCertificate ( Integer id ) { LambdaUpdateWrapper < Certificate > certificateLambdaUpdateWrapper = new LambdaUpdateWrapper < > ( ) ; certificateLambdaUpdateWrapper . eq ( Certificate :: getId , id ) . set ( Certificate :: getIsDeleted , <NUM_LIT> ) ; int affectedRows = certificateMapper . update ( certificateLambdaUpdateWrapper ) ; if ( affectedRows > <NUM_LIT> ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + id ) ; return Result . success ( \"<STR_LIT>\" ) ; }", "output": "else { return Result . failed ( \"<STR_LIT>\" ) ; } } @ Override public Result < IPage < MyCertificateVO > > getMyCertificatePaging ( Integer pageNum , Integer pageSize , String examName ) { Page < MyCertificateVO > myCertificateVOPage = new Page < > ( ) ; myCertificateVOPage = certificateMapper . selectMyCertificate ( myCertificateVOPage , pageNum , pageSize , SecurityUtil . getUserId ( ) , examName ) ; return Result . success ( \"<STR_LIT>\" , myCertificateVOPage ) ; } }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . UserExerciseRecordMapper ; import cn . org . alan . exam . model . entity . UserExerciseRecord ; import cn . org . alan . exam . service . IUserExerciseRecordService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class UserExerciseRecordServiceImpl extends ServiceImpl < UserExerciseRecordMapper , UserExerciseRecord > implements IUserExerciseRecordService {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . base . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; @ Target ( {", "output": "ElementType . PARAMETER , ElementType . FIELD , ElementType . METHOD } ) public @ interface Nullable { }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FlowForm { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processInstanceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String processDefinitionId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String resourceId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long desformDataId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date createTime ; private Long flowTime ;", "output": "}"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformIndex ; import org . apache . ibatis . annotations . Param ; public interface CgformIndexMapper extends BaseMapper < CgformIndex > {", "output": "int queryIndexCount ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; }"}, {"input": "package com . xcs . wx . repository ; import com . xcs . wx . domain . vo . SessionVO ; import java . util . List ; public interface SessionRepository {", "output": "List < SessionVO > querySession ( ) ; }"}, {"input": "package top . kangert . kspider . controller ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import org . springframework . beans . factory . annotation . Autowired ; import top . kangert . kspider . exception . ExceptionCodes ; import top . kangert . kspider . util . BaseResponse ; import top . kangert . kspider . util . PageInfo ; import top . kangert . kspider . vo . PageVo ; public class BaseController { @ Autowired HttpServletRequest request ; @ Autowired HttpServletResponse response ; protected BaseResponse successResponse ( ) { BaseResponse res = new BaseResponse ( ) ; res . setCode ( ExceptionCodes . SUCCESS . getCode ( ) ) ; res . setMessage ( ExceptionCodes . SUCCESS . getMessage ( ) ) ; res . setData ( null ) ; res . setPageInfo ( null ) ; return res ; }", "output": "protected BaseResponse successResponse ( Object data ) { BaseResponse res = new BaseResponse ( ) ; res . setCode ( ExceptionCodes . SUCCESS . getCode ( ) ) ; res . setMessage ( ExceptionCodes . SUCCESS . getMessage ( ) ) ; res . setData ( data ) ; res . setPageInfo ( null ) ; return res ; } protected BaseResponse successResponse ( PageInfo < ? > pageInfo ) { BaseResponse res = new BaseResponse ( ) ; res . setCode ( ExceptionCodes . SUCCESS . getCode ( ) ) ; res . setMessage ( ExceptionCodes . SUCCESS . getMessage ( ) ) ; res . setData ( pageInfo . getData ( ) ) ; PageVo pageVo = new PageVo ( ) ; pageVo . setCurrentPage ( pageInfo . getCurrentPage ( ) ) ; pageVo . setPageNums ( pageInfo . getPageNums ( ) ) ; pageVo . setPageSize ( pageInfo . getPageSize ( ) ) ; pageVo . setTotal ( pageInfo . getTotal ( ) ) ; res . setPageInfo ( pageVo ) ; return res ; } }"}, {"input": "package com . xcs . wx . config ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . context . annotation . Configuration ; import java . util . Map ; @ Data @ Configuration ( proxyBeanMethods = false ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class WeChatOffsetProperties { private Map < String , VersionConfig > version ; @ Data public static class VersionConfig { private Long nickname ; private Long account ; private Long mobile ; }", "output": "}"}, {"input": "package me . zhengjie . modules . quartz . config ; import org . quartz . spi . TriggerFiredBundle ; import org . springframework . beans . factory . config . AutowireCapableBeanFactory ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . quartz . AdaptableJobFactory ; import org . springframework . stereotype . Component ; @ Configuration public class QuartzConfig { @ Component ( \"<STR_LIT>\" ) public static class QuartzJobFactory extends AdaptableJobFactory { private final AutowireCapableBeanFactory capableBeanFactory ; public QuartzJobFactory ( AutowireCapableBeanFactory capableBeanFactory ) { this . capableBeanFactory = capableBeanFactory ;", "output": "} @ Override protected Object createJobInstance ( TriggerFiredBundle bundle ) throws Exception { Object jobInstance = super . createJobInstance ( bundle ) ; capableBeanFactory . autowireBean ( jobInstance ) ; return jobInstance ; } } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . ExamRepo ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IExamRepoService extends IService < ExamRepo > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import org . springframework . beans . factory . BeanFactory ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static java . util . Collections . emptyMap ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . merge ; public enum GlobalNacosPropertiesSource { DEFAULT ( GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , CONFIG ( CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , DISCOVERY ( DISCOVERY_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) , MAINTAIN ( MAINTAIN_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; private final String beanName ; GlobalNacosPropertiesSource ( String beanName ) { this . beanName = beanName ; } public Properties getMergedGlobalProperties ( BeanFactory beanFactory ) { Properties currentProperties = getProperties ( beanFactory , beanName ) ; Properties globalProperties = getProperties ( beanFactory , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; merge ( globalProperties , currentProperties ) ; return globalProperties ;", "output": "} private Properties getProperties ( BeanFactory beanFactory , String beanName ) { Properties properties = new Properties ( ) ; Map < ? , ? > propertiesSource = beanFactory . containsBean ( beanName ) ? beanFactory . getBean ( beanName , Properties . class ) : emptyMap ( ) ; properties . putAll ( propertiesSource ) ; return properties ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class ExerciseRecord implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer repoId ; private Integer questionId ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private String answer ; private Integer questionType ; private String options ; private Integer isRight ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getRepoId ( ) { return repoId ; } public void setRepoId ( Integer repoId ) { this . repoId = repoId ; } public Integer getQuestionId ( ) {", "output": "return questionId ; } public void setQuestionId ( Integer questionId ) { this . questionId = questionId ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public String getAnswer ( ) { return answer ; } public void setAnswer ( String answer ) { this . answer = answer ; } public Integer getQuestionType ( ) { return questionType ; } public void setQuestionType ( Integer questionType ) { this . questionType = questionType ; } public String getOptions ( ) { return options ; } public void setOptions ( String options ) { this . options = options ; } public Integer getIsRight ( ) { return isRight ; } public void setIsRight ( Integer isRight ) { this . isRight = isRight ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + repoId + \"<STR_LIT>\" + questionId + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + answer + \"<STR_LIT>\" + questionType + \"<STR_LIT>\" + options + \"<STR_LIT>\" + isRight + \"<STR_LIT>\" ; } }"}, {"input": "package com . oddfar . campus . common . constant ; public class UserConstants { public static final String SYS_USER = \"<STR_LIT>\" ; public static final String NORMAL = \"<STR_LIT>\" ; public static final String EXCEPTION = \"<STR_LIT>\" ; public static final String USER_DISABLE = \"<STR_LIT>\" ; public static final String ROLE_DISABLE = \"<STR_LIT>\" ; public static final String DICT_NORMAL = \"<STR_LIT>\" ; public static final String YES = \"<STR_LIT>\" ; public static final String YES_FRAME = \"<STR_LIT>\" ; public static final String NO_FRAME = \"<STR_LIT>\" ; public static final String TYPE_DIR = \"<STR_LIT>\" ; public static final String TYPE_MENU = \"<STR_LIT>\" ; public static final String TYPE_BUTTON = \"<STR_LIT>\" ; public final static String LAYOUT = \"<STR_LIT>\" ; public final static String PARENT_VIEW = \"<STR_LIT>\" ; public final static String INNER_LINK = \"<STR_LIT>\" ; public final static String UNIQUE = \"<STR_LIT>\" ; public final static String NOT_UNIQUE = \"<STR_LIT>\" ; public static final int USERNAME_MIN_LENGTH = <NUM_LIT> ; public static final int USERNAME_MAX_LENGTH = <NUM_LIT> ; public static final int PASSWORD_MIN_LENGTH = <NUM_LIT> ; public static final int PASSWORD_MAX_LENGTH = <NUM_LIT> ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import org . apache . ibatis . annotations . Update ; import java . util . List ; import java . util . Set ; public interface SysResourceMapper extends BaseMapperX < SysResourceEntity > { default PageResult < SysResourceEntity > selectPage ( SysResourceEntity resource ) { return selectPage ( new LambdaQueryWrapperX < SysResourceEntity > ( ) . betweenIfPresent ( SysResourceEntity :: getCreateTime , resource . getParams ( ) ) ) ; } @ Update ( \"<STR_LIT>\" ) void truncateResource ( ) ; Set < String > selectResourceCodeByRoleId ( Long roleId ) ;", "output": "List < Long > selectResourceListByRoleId ( Long roleId ) ; List < SysResourceEntity > selectResourceListByUserId ( SysResourceEntity resource ) ; List < SysResourceEntity > selectResourceList ( SysResourceEntity resource ) ; }"}, {"input": "package cn . org . alan . exam . model . vo . stat ; import lombok . Data ; @ Data public class GradeStudentVO { private Long id ; private String gradeName ; private Integer totalStudent ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . score ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class GradeScoreVO { private Integer id ; private Integer examId ; private Integer gradeId ; private Integer passedScore ; private String examTitle ; private String gradeName ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private Integer avgScore ; private Integer maxScore ; private Integer minScore ; private Integer attendNum ; private Integer absentNum ; private Integer passedNum ; private Integer totalNum ; private Double passingRate ;", "output": "}"}, {"input": "package ginyi . framework . websocket ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Component ; import javax . websocket . * ; import javax . websocket . server . PathParam ; import javax . websocket . server . ServerEndpoint ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CopyOnWriteArraySet ; @ Slf4j @ Component @ ServerEndpoint ( value = \"<STR_LIT>\" ) public class WebSocket { private Session session ; private String userId ; private static CopyOnWriteArraySet < WebSocket > webSockets = new CopyOnWriteArraySet < > ( ) ; private static ConcurrentHashMap < String , Session > sessionPool = new ConcurrentHashMap < > ( ) ; @ OnOpen public void onOpen ( Session session , @ PathParam ( value = \"<STR_LIT>\" ) String userId ) { try { this . session = session ; this . userId = userId ; webSockets . add ( this ) ; sessionPool . put ( userId , session ) ; log . info ( \"<STR_LIT>\" , userId , webSockets . size ( ) ) ; } catch ( Exception e ) { } } @ OnClose public void onClose ( ) { try { webSockets . remove ( this ) ; sessionPool . remove ( this . userId ) ; log . info ( \"<STR_LIT>\" , userId , webSockets . size ( ) ) ; } catch ( Exception e ) { } } @ OnMessage public void onMessage ( String message , @ PathParam ( value = \"<STR_LIT>\" ) String userId ) { log . info ( \"<STR_LIT>\" , userId , message ) ; } @ OnError public void onError ( Session session , Throwable error ) { log . error ( \"<STR_LIT>\" , error . getMessage ( ) ) ; error . printStackTrace ( ) ; } public void sendAllMessage ( String message ) { log . info ( \"<STR_LIT>\" + message ) ; for ( WebSocket webSocket : webSockets ) { try { if ( webSocket . session . isOpen ( ) ) { webSocket . session . getAsyncRemote ( ) . sendText ( message ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void sendOneMessage ( String userId , String message ) { Session session = sessionPool . get ( userId ) ; if ( session != null && session . isOpen ( ) ) { try { log . info ( \"<STR_LIT>\" + message ) ; session . getAsyncRemote ( ) . sendText ( message ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } public void sendMoreMessage ( String [ ] userIds , String message ) { for ( String userId : userIds ) { Session session = sessionPool . get ( userId ) ;", "output": "if ( session != null && session . isOpen ( ) ) { try { log . info ( \"<STR_LIT>\" + message ) ; session . getAsyncRemote ( ) . sendText ( message ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } }"}, {"input": "package org . springblade . gateway . mapper ; import org . apache . ibatis . annotations . Mapper ; import java . util . Map ; @ Mapper public interface MemberMapper {", "output": "Map < String , Object > getMember ( String apiKey ) ; }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class MyDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . score ; import lombok . Data ; @ Data public class QuestionAnalyseVO { private Integer rightCount ; private Integer totalCount ; private Double accuracy ;", "output": "}"}, {"input": "package com . yf . plugins . upload . local . dto ; import com . yf . base . api . api . dto . BaseDTO ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . multipart . MultipartFile ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class UploadReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private MultipartFile file ;", "output": "}"}, {"input": "package com . yf . base . utils . file ; import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; public class TextFileUtils { public static String readText ( String filePath ) { String s ; StringBuffer sb = new StringBuffer ( ) ; try { File f = new File ( filePath ) ; if ( ! f . exists ( ) ) { f . createNewFile ( ) ; } BufferedReader input = new BufferedReader ( new FileReader ( f ) ) ; while ( ( s = input . readLine ( ) ) != null ) { sb . append ( s ) . append ( \"<STR_LIT>\" ) ; } input . close ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return sb . toString ( ) ; } public static synchronized void append ( String filePath , String data ) { String s ; StringBuffer sb = new StringBuffer ( ) ; try { String dirPath = filePath . substring ( <NUM_LIT> , filePath . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; File dir = new File ( dirPath ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } File f = new File ( filePath ) ; if ( ! f . exists ( ) ) { f . createNewFile ( ) ; } ; BufferedReader input = new BufferedReader ( new FileReader ( f ) ) ; while ( ( s = input . readLine ( ) ) != null ) { sb . append ( s ) ; sb . append ( \"<STR_LIT>\" ) ; } input . close ( ) ; sb . append ( data ) ; BufferedWriter output = new BufferedWriter ( new FileWriter ( f ) ) ; output . write ( sb . toString ( ) ) ; output . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static synchronized void write ( String filePath , String data ) { try { String dirPath = filePath . substring ( <NUM_LIT> , filePath . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; File dir = new File ( dirPath ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } File f = new File ( filePath ) ; if ( ! f . exists ( ) ) { f . createNewFile ( ) ; } BufferedWriter output = new BufferedWriter ( new FileWriter ( f ) ) ; output . write ( data ) ; output . flush ( ) ; output . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public static String readFile ( InputStream is ) { StringBuffer sb = new StringBuffer ( ) ; try ( InputStreamReader reader = new InputStreamReader ( is ) ;", "output": "BufferedReader br = new BufferedReader ( reader ) ) { String line ; while ( ( line = br . readLine ( ) ) != null ) { sb . append ( line + \"<STR_LIT>\" ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; } public static void writeFile ( String text , String path ) { try { File writeName = new File ( path ) ; writeName . createNewFile ( ) ; try ( FileWriter writer = new FileWriter ( writeName ) ; BufferedWriter out = new BufferedWriter ( writer ) ) { out . write ( text ) ; out . flush ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }"}, {"input": "package org . springblade . web . config . engine . exchange ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import lombok . Data ; import org . apache . poi . ss . formula . functions . T ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . ForceModel ; import org . springblade . web . model . ForceModelAll ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchExchange { private String symbolName ; private BigDecimal lastPrice ; private Long lastTime ; private BigDecimal miniPriceChangeRefresh ; private List < EntrustModel > entrustList ; private List < ForceModel > zcForceList ; private boolean allSymbolNameFlag = false ; public CoinMatchExchange ( String symbolName ) { this . symbolName = symbolName ; this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; } public void init ( IMjkjBaseSqlService baseSqlService ) {", "output": "synchronized ( this ) { this . entrustList = new ArrayList < > ( ) ; this . zcForceList = new ArrayList < > ( ) ; this . miniPriceChangeRefresh = BigDecimal . ZERO ; this . addEntrust ( baseSqlService ) ; this . addFixedBorrow ( baseSqlService ) ; this . addFllSymbolNameFlag ( baseSqlService ) ; } } public void resetZcForce ( String memberId ) { List < ForceModel > forceList = this . zcForceList ; Iterator < ForceModel > iterator = forceList . iterator ( ) ; boolean addFlag = true ; while ( iterator . hasNext ( ) ) { ForceModel next = iterator . next ( ) ; if ( Func . equals ( memberId , next . getMemberId ( ) ) ) { next . setForcePrice ( BigDecimal . ZERO ) ; addFlag = false ; } } if ( addFlag ) { ForceModel forceModel = new ForceModel ( ) ; forceModel . setMemberId ( memberId ) ; forceModel . setForcePrice ( BigDecimal . ZERO ) ; forceList . add ( forceModel ) ; } } private void addEntrust ( IMjkjBaseSqlService baseSqlService ) { if ( Func . isEmpty ( this . entrustList ) ) { this . entrustList = new ArrayList < > ( ) ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , symbolName ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > selectEntrustList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isNotEmpty ( selectEntrustList ) ) { for ( Map < String , Object > entrustMap : selectEntrustList ) { String entrustCode = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String entrustType = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; String calculationMethod = MjkjUtils . getMap2Str ( entrustMap , \"<STR_LIT>\" ) ; List < EntrustModel . CalculationModel > list = JsonUtil . parseArray ( calculationMethod , EntrustModel . CalculationModel . class ) ; EntrustModel entrustModel = new EntrustModel ( ) ; entrustModel . setEntrustCode ( entrustCode ) ; entrustModel . setEntrustType ( entrustType ) ; entrustModel . setCalculationList ( list ) ; this . entrustList . add ( entrustModel ) ; } } } private void addFixedBorrow ( IMjkjBaseSqlService baseSqlService ) { this . zcForceList = new ArrayList < > ( ) ; QueryWrapper < Object > borrowWrapper = new QueryWrapper < > ( ) ; borrowWrapper . eq ( \"<STR_LIT>\" , symbolName ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; borrowWrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; List < Map < String , Object > > borrowList = baseSqlService . getDataListByFieldParams ( \"<STR_LIT>\" , borrowWrapper ) ; if ( Func . isNotEmpty ( borrowList ) ) { for ( Map < String , Object > borrowMap : borrowList ) { String memberId = MjkjUtils . getMap2Str ( borrowMap , \"<STR_LIT>\" ) ; this . resetZcForce ( memberId ) ; } } } private void addFllSymbolNameFlag ( IMjkjBaseSqlService baseSqlService ) { QueryWrapper < Object > exchangeWrapper = new QueryWrapper < > ( ) ; exchangeWrapper . eq ( \"<STR_LIT>\" , symbolName ) ; exchangeWrapper . eq ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; exchangeWrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; Map < String , Object > exchangeMap = baseSqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , exchangeWrapper ) ; if ( Func . isNotEmpty ( exchangeMap ) ) { this . allSymbolNameFlag = true ; } else { this . allSymbolNameFlag = false ; } } }"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . vo . * ; import java . util . List ; public interface DashboardService { StatsPanelVO statsPanel ( ) ; List < MsgTypeDistributionVO > msgTypeDistribution ( ) ; List < CountRecentMsgsVO > countRecentMsgs ( ) ; List < TopContactsVO > topContacts ( ) ; List < RecentUsedKeyWordVO > queryRecentUsedKeyWord ( ) ;", "output": "}"}, {"input": "package org . example . ddduser . application . dto . query ; import io . github . chensheng . dddboot . microservice . core . PageQuery ; import lombok . Data ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Data public class UserProfilePageQuery extends PageQuery { private String username ; private UserStatus status ; private Gender gender ; private String nickNameLike ; private Integer ageFrom ; private Integer ageTo ;", "output": "}"}, {"input": "package org . example . domain . example . repository ; import io . github . chensheng . dddboot . web . core . BizException ; public interface ExampleSecurityRepository { Long getLoginUser ( ) throws BizException ; Long getLoginUserQuietly ( ) ;", "output": "}"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . FTSRecentUsed ; public interface FTSRecentUsedMapper extends BaseMapper < FTSRecentUsed > {", "output": "}"}, {"input": "package org . springblade . web . service ; import org . springblade . web . model . MarketGoodsModel ; import org . springblade . web . model . param . MarketJoinParam ; import java . math . BigDecimal ; import java . util . Map ; public interface IMarketService { Object messageInitdata ( String type ) ;", "output": "}"}, {"input": "package top . kangert . kspider . constant ; public interface Constants { String ATOMIC_DEAD_CYCLE = \"<STR_LIT>\" ; String EXCEPTION_VARIABLE = \"<STR_LIT>\" ; String LAST_REQUEST_EXECUTE_TIME = \"<STR_LIT>\" ; String RESPONSE_VARIABLE = \"<STR_LIT>\" ; String SQL_RESULT = \"<STR_LIT>\" ; String KSPIDER_THREAD_GROUP_NAME = \"<STR_LIT>\" ; String KSPIDER_THREAD_NAME_PREFIX = \"<STR_LIT>\" ; String THREAD_COUNT = \"<STR_LIT>\" ; String RUN_SYNC = \"<STR_LIT>\" ; String NODE_TYPE = \"<STR_LIT>\" ; String NODE_LOOP_COUNT = \"<STR_LIT>\" ; String NODE_LOOP_INDEX = \"<STR_LIT>\" ; String NODE_LOOP_START_INDEX = \"<STR_LIT>\" ; String NODE_LOOP_END_INDEX = \"<STR_LIT>\" ;", "output": "String FUNCTION = \"<STR_LIT>\" ; String FLOW_ID = \"<STR_LIT>\" ; String DATASOURCE_ID = \"<STR_LIT>\" ; String YES = \"<STR_LIT>\" ; String QUARTZ_JOB_NAME_PREFIX = \"<STR_LIT>\" ; String QUARTZ_KSPIDER_FLOW_PARAM_NAME = \"<STR_LIT>\" ; String PROXY_HOST_PORT_SEPARATOR = \"<STR_LIT>\" ; String KSPIDER_FLOW_LOG_DIR_PREFIX = \"<STR_LIT>\" ; String KSPIDER_TASK_LOG_DIR_PREFIX = \"<STR_LIT>\" ; }"}, {"input": "package org . springblade . model ; import org . springblade . util . EthConvert ; import lombok . Data ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigInteger ; @ Data public class Contract { private String decimals ; private String address ; private BigInteger gasLimit ; private String eventTopic0 ; public EthConvert . Unit getUnit ( ) { if ( StringUtils . isEmpty ( decimals ) ) return EthConvert . Unit . ETHER ;", "output": "else return EthConvert . Unit . fromString ( decimals ) ; } }"}, {"input": "package com . youlai . system . laboratory ; import lombok . extern . slf4j . Slf4j ; import org . junit . jupiter . api . Test ; import org . springframework . boot . test . context . SpringBootTest ; import org . springframework . context . ApplicationContext ; import org . springframework . core . env . Environment ; @ SpringBootTest @ Slf4j public class ConfigLoadOrderTests { @ Test public void testConfigLoadOrder ( ApplicationContext context ) {", "output": "Environment environment = context . getEnvironment ( ) ; String property = environment . getProperty ( \"<STR_LIT>\" ) ; log . info ( property ) ; } }"}, {"input": "package ginyi . common . utils . uuid ; public class IdUtils { public static String randomUUID ( ) { return UUID . randomUUID ( ) . toString ( ) ;", "output": "} public static String simpleUUID ( ) { return UUID . randomUUID ( ) . toString ( true ) ; } public static String fastUUID ( ) { return UUID . fastUUID ( ) . toString ( ) ; } public static String fastSimpleUUID ( ) { return UUID . fastUUID ( ) . toString ( true ) ; } }"}, {"input": "package top . kangert . kspider . executor . node ; import org . springframework . stereotype . Component ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . websocket . WebSocketEvent ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Component public class StartExecutor implements NodeExecutor { @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "} @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { return new Shape ( supportType ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override public List < ConfigItem > configItems ( ) { List < ConfigItem > configItemList = new ArrayList < > ( ) ; Map < String , Object > maxThreadsAttr = new HashMap < > ( ) ; maxThreadsAttr . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; maxThreadsAttr . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; ConfigItem maxThreads = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_NUMBER_INPUT , ConfigItem . DataType . INT , Constants . THREAD_COUNT , \"<STR_LIT>\" , \"<STR_LIT>\" , maxThreadsAttr , null ) ; configItemList . add ( maxThreads ) ; return configItemList ; } }"}, {"input": "package com . xcs . wx . controller ; import lombok . RequiredArgsConstructor ; import org . springframework . core . io . FileSystemResource ; import org . springframework . core . io . Resource ; import org . springframework . core . io . UrlResource ; import org . springframework . http . MediaType ; import org . springframework . http . ResponseEntity ; import org . springframework . stereotype . Controller ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestParam ; import java . io . IOException ; import java . net . URLEncoder ; import java . nio . charset . StandardCharsets ; import java . nio . file . Path ; import java . nio . file . Paths ; @ Controller @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class ExportController { @ GetMapping ( \"<STR_LIT>\" ) public ResponseEntity < Resource > download ( @ RequestParam String path ) throws IOException { Path filePath = Paths . get ( path ) ; Resource resource = new FileSystemResource ( filePath . toFile ( ) ) ; if ( ! resource . exists ( ) ) { return ResponseEntity . notFound ( ) . build ( ) ; } String encodedFilename = URLEncoder . encode ( resource . getFilename ( ) , StandardCharsets . UTF_8 . name ( ) ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "String contentDisposition = \"<STR_LIT>\" + encodedFilename ; return ResponseEntity . ok ( ) . contentType ( MediaType . parseMediaType ( \"<STR_LIT>\" ) ) . header ( \"<STR_LIT>\" , contentDisposition ) . body ( resource ) ; } }"}, {"input": "package com . yf . system . modules . plugin . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . base . utils . BeanMapper ; import com . yf . base . utils . jackson . JsonHelper ; import com . yf . system . modules . plugin . dto . PluginSchemaDTO ; import com . yf . system . modules . plugin . entity . PluginSchema ; import com . yf . system . modules . plugin . mapper . PluginSchemaMapper ; import com . yf . system . modules . plugin . service . PluginSchemaService ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class PluginSchemaServiceImpl extends ServiceImpl < PluginSchemaMapper , PluginSchema > implements PluginSchemaService { @ Override public IPage < PluginSchemaDTO > paging ( PagingReqDTO < PluginSchemaDTO > reqDTO ) { QueryWrapper < PluginSchema > wrapper = new QueryWrapper < > ( ) ; PluginSchemaDTO params = reqDTO . getParams ( ) ; IPage < PluginSchema > page = this . page ( reqDTO . toPage ( ) , wrapper ) ; IPage < PluginSchemaDTO > pageData = JsonHelper . parseObject ( page , new TypeReference < Page < PluginSchemaDTO > > ( ) { } ) ; return pageData ; } @ Override public void save ( PluginSchemaDTO reqDTO ) { PluginSchema entity = new PluginSchema ( ) ; BeanMapper . copy ( reqDTO , entity ) ; this . saveOrUpdate ( entity ) ; } @ Override public void delete ( List < String > ids ) { this . removeByIds ( ids ) ; } @ Override public PluginSchemaDTO detail ( String id ) { PluginSchema entity = this . getById ( id ) ; PluginSchemaDTO dto = new PluginSchemaDTO ( ) ; BeanMapper . copy ( entity , dto ) ; return dto ; } @ Override public List < PluginSchemaDTO > list ( PluginSchemaDTO reqDTO ) { QueryWrapper < PluginSchema > wrapper = new QueryWrapper < > ( ) ; List < PluginSchema > list = this . list ( wrapper ) ; List < PluginSchemaDTO > dtoList = BeanMapper . mapList ( list , PluginSchemaDTO . class ) ; return dtoList ;", "output": "} }"}, {"input": "package com . oddfar . campus . framework . mapper ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysDictTypeEntity ; import java . util . Map ; public interface SysDictTypeMapper extends BaseMapperX < SysDictTypeEntity > { default PageResult < SysDictTypeEntity > selectPage ( SysDictTypeEntity dictType ) { return selectPage ( new LambdaQueryWrapperX < SysDictTypeEntity > ( ) . likeIfPresent ( SysDictTypeEntity :: getDictName , dictType . getDictName ( ) ) . likeIfPresent ( SysDictTypeEntity :: getDictType , dictType . getDictType ( ) ) . eqIfPresent ( SysDictTypeEntity :: getStatus , dictType . getStatus ( ) ) . betweenIfPresent ( SysDictTypeEntity :: getCreateTime , dictType . getParams ( ) ) ) ;", "output": "} default LambdaQueryWrapper < SysDictTypeEntity > creatWrapper ( SysDictTypeEntity dictType ) { Map < String , Object > params = dictType . getParams ( ) ; String beginTime = ( String ) params . get ( \"<STR_LIT>\" ) ; String endTime = ( String ) params . get ( \"<STR_LIT>\" ) ; return new LambdaQueryWrapperX < SysDictTypeEntity > ( ) . ge ( ObjectUtil . isNotEmpty ( beginTime ) , SysDictTypeEntity :: getCreateTime , beginTime ) . le ( ObjectUtil . isNotEmpty ( endTime ) , SysDictTypeEntity :: getCreateTime , endTime ) ; } }"}, {"input": "package ginyi . framework . security . filter ; import ginyi . common . utils . Constants ; import ginyi . common . utils . http . HttpHelper ; import javax . servlet . ReadListener ; import javax . servlet . ServletInputStream ; import javax . servlet . ServletResponse ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletRequestWrapper ; import java . io . BufferedReader ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStreamReader ; public class RepeatedlyRequestWrapper extends HttpServletRequestWrapper { private final byte [ ] body ; public RepeatedlyRequestWrapper ( HttpServletRequest request , ServletResponse response ) throws IOException { super ( request ) ; request . setCharacterEncoding ( Constants . UTF8 ) ; response . setCharacterEncoding ( Constants . UTF8 ) ; body = HttpHelper . getBodyString ( request ) . getBytes ( Constants . UTF8 ) ;", "output": "} @ Override public BufferedReader getReader ( ) throws IOException { return new BufferedReader ( new InputStreamReader ( getInputStream ( ) ) ) ; } @ Override public ServletInputStream getInputStream ( ) throws IOException { final ByteArrayInputStream bais = new ByteArrayInputStream ( body ) ; return new ServletInputStream ( ) { @ Override public int read ( ) throws IOException { return bais . read ( ) ; } @ Override public int available ( ) throws IOException { return body . length ; } @ Override public boolean isFinished ( ) { return false ; } @ Override public boolean isReady ( ) { return false ; } @ Override public void setReadListener ( ReadListener readListener ) { } } ; } }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class InviteRewardModel { private BigDecimal monthUsdt = BigDecimal . ZERO ; private BigDecimal yesterdayUsdt = BigDecimal . ZERO ;", "output": "}"}, {"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; @ Slf4j @ Component @ AllArgsConstructor public class BodyCacheFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . flatMap ( dataBuffer -> { DataBufferUtils . retain ( dataBuffer ) ; Flux < DataBuffer > cachedFlux = Flux . defer ( ( ) -> Flux . just ( dataBuffer . slice ( <NUM_LIT> , dataBuffer . readableByteCount ( ) ) ) ) ; ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator ( exchange . getRequest ( ) ) { @ Override public Flux < DataBuffer > getBody ( ) { return cachedFlux ; } } ; return chain . filter ( exchange . mutate ( ) . request ( mutatedRequest ) . build ( ) ) ; } ) ; } return chain . filter ( exchange ) ; }", "output": "@ Override public int getOrder ( ) { return HIGHEST_PRECEDENCE ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import com . google . common . base . Utf8 ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . collection . ListUtil ; import org . apache . commons . lang3 . StringUtils ; import java . util . ArrayList ; import java . util . List ; public class MoreStringUtil { public static List < String > split ( @ Nullable final String str , final char separatorChar ) { return split ( str , separatorChar , <NUM_LIT> ) ; } public static List < String > split ( @ Nullable final String str , final char separatorChar , int expectParts ) { if ( str == null ) { return null ; } final int len = str . length ( ) ; if ( len == <NUM_LIT> ) { return ListUtil . emptyList ( ) ; } final List < String > list = new ArrayList < String > ( expectParts ) ; int i = <NUM_LIT> ; int start = <NUM_LIT> ; boolean match = false ; while ( i < len ) { if ( str . charAt ( i ) == separatorChar ) { if ( match ) { list . add ( str . substring ( start , i ) ) ; match = false ; } start = ++ i ; continue ; } match = true ; i ++ ; } if ( match ) { list . add ( str . substring ( start , i ) ) ; } return list ; } public static Splitter charsSplitter ( final String separatorChars ) { return Splitter . on ( CharMatcher . anyOf ( separatorChars ) ) ; } public static String replaceFirst ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . indexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; } public static String replaceLast ( @ Nullable String s , char sub , char with ) { if ( s == null ) { return null ; } int index = s . lastIndexOf ( sub ) ; if ( index == - <NUM_LIT> ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ;", "output": "return new String ( str ) ; } public static boolean startWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) { return false ; } return s . charAt ( <NUM_LIT> ) == c ; } public static boolean endWith ( @ Nullable CharSequence s , char c ) { if ( StringUtils . isEmpty ( s ) ) { return false ; } return s . charAt ( s . length ( ) - <NUM_LIT> ) == c ; } public static String removeEnd ( final String s , final char c ) { if ( endWith ( s , c ) ) { return s . substring ( <NUM_LIT> , s . length ( ) - <NUM_LIT> ) ; } return s ; } public static int utf8EncodedLength ( @ Nullable CharSequence sequence ) { if ( StringUtils . isEmpty ( sequence ) ) { return <NUM_LIT> ; } return Utf8 . encodedLength ( sequence ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . enums ; import com . alibaba . nacos . common . utils . StringUtils ; public enum FileTypeEnum { YML ( \"<STR_LIT>\" ) , YAML ( \"<STR_LIT>\" ) , TXT ( \"<STR_LIT>\" ) , TEXT ( \"<STR_LIT>\" ) , JSON ( \"<STR_LIT>\" ) , XML ( \"<STR_LIT>\" ) , HTM ( \"<STR_LIT>\" ) , HTML ( \"<STR_LIT>\" ) , PROPERTIES ( \"<STR_LIT>\" ) ; private String fileType ; FileTypeEnum ( String fileType ) { this . fileType = fileType ; } public String getFileType ( ) { return this . fileType ; } public static FileTypeEnum getFileTypeEnumByFileExtensionOrFileType ( String extOrFileType ) { if ( StringUtils . isNotBlank ( extOrFileType ) ) {", "output": "String upperExtName = extOrFileType . trim ( ) . toUpperCase ( ) ; for ( FileTypeEnum value : VALUES ) { if ( value . name ( ) . equals ( upperExtName ) ) { return value ; } } } return FileTypeEnum . PROPERTIES ; } private static final FileTypeEnum [ ] VALUES = FileTypeEnum . values ( ) ; }"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; import java . io . Serializable ; @ Data public class KvModel implements Serializable { private String k ; private String v ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import lombok . AccessLevel ; import lombok . Getter ; import lombok . RequiredArgsConstructor ; import java . util . List ; @ Getter @ RequiredArgsConstructor ( access = AccessLevel . PACKAGE ) public class PageResult < T > { private final List < T > content ; private final long totalElements ;", "output": "}"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class SysUserRole { private Long userId ; private Long roleId ; @ TableField ( exist = false ) private static final long serialVersionUID = <NUM_LIT> ;", "output": "}"}, {"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExamplePageQuery extends PageQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ; @ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ; @ Override protected Long getMaxSize ( ) { return <NUM_LIT> ;", "output": "} }"}, {"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; public class SelSearchFieldCommentConverter extends TableFieldCommentConverter { public SelSearchFieldCommentConverter ( CgformField onlcgformfield ) {", "output": "super ( onlcgformfield . getDictTable ( ) , onlcgformfield . getDictField ( ) , onlcgformfield . getDictText ( ) ) ; } }"}, {"input": "package org . springblade . cgform . controller ; import cn . hutool . core . io . FileUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import com . google . common . collect . Lists ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringEscapeUtils ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . enums . CgformConstant ; import org . springblade . cgform . enums . CgformEnum ; import org . springblade . cgform . model . * ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . * ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DbConfig ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . * ; import org . springblade . core . cache . utils . CacheUtil ; import org . springblade . core . mp . support . Condition ; import org . springblade . core . mp . support . Query ; import org . springblade . core . oss . model . BladeFile ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . utils . resource . OssBuilder ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . swing . tree . TreeModel ; import javax . validation . Valid ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . time . Duration ; import java . time . temporal . TemporalUnit ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class CgformApiController extends BaseController { private final ICgformHeadService cgformHeadService ; private final ICgformFieldService cgformFieldService ; private final ICgformEnhanceJavaService javaService ; private final ICgformEnhanceSqlService sqlService ; private final BladeRedis redis ; private static final String CGFORM_ID_REDIS_KEY = \"<STR_LIT>\" ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ GetMapping ( { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public R < Map < String , Object > > getData ( @ PathVariable ( \"<STR_LIT>\" ) Long headId , HttpServletRequest req ) { Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; String langRedisKey = CGFORM_ID_REDIS_KEY + headId ; if ( Func . isNotEmpty ( property ) && property . startsWith ( \"<STR_LIT>\" ) ) { if ( headId == <NUM_LIT> && redis . exists ( langRedisKey ) ) { } } CgformHead onlCgformHead = cgformHeadService . getById ( headId ) ; if ( Func . isEmpty ( onlCgformHead ) ) { return R . fail ( \"<STR_LIT>\" ) ;", "output": "} String nologinSelect = onlCgformHead . getNologinSelect ( ) ; if ( Func . equals ( nologinSelect , \"<STR_LIT>\" ) ) { BladeUser user = AuthUtil . getUser ( ) ; if ( Func . isEmpty ( user ) ) { return R . fail ( \"<STR_LIT>\" ) ; } String noViewRoleStrList = onlCgformHead . getNoViewDataRole ( ) ; if ( Func . isNotEmpty ( noViewRoleStrList ) ) { List < Long > roleList = Func . toLongList ( noViewRoleStrList ) ; BladeUser onlineUser = AuthUtil . getUser ( ) ; String roleIdStrList = onlineUser . getRoleId ( ) ; List < Long > onlineRoleList = Func . toLongList ( roleIdStrList ) ; List < Long > collect = roleList . stream ( ) . filter ( item -> onlineRoleList . contains ( item ) ) . collect ( Collectors . toList ( ) ) ; if ( Func . isNotEmpty ( collect ) ) { return R . fail ( \"<STR_LIT>\" ) ; } } } try { String tableName = onlCgformHead . getTableName ( ) ; Map < String , Object > params = SqlSymbolUtil . getParameterMap ( req ) ; Map < String , Object > resultMap = new HashMap < > ( ) ; if ( Func . equals ( onlCgformHead . getFormCategory ( ) , \"<STR_LIT>\" ) ) { resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; } else { resultMap = cgformFieldService . queryAutolistPage ( tableName , headId , params , null ) ; } Long total = MjkjUtils . getMap2Long ( resultMap , \"<STR_LIT>\" ) ; List < Map < String , Object > > dataList = ( List ) resultMap . get ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( dataList ) ) { dataList = new ArrayList < > ( ) ; } javaService . executeEnhanceList ( onlCgformHead , MjkjConstant . ENHANCE_QUERY , dataList , params ) ; sqlService . executeEnhanceSqlList ( onlCgformHead , MjkjConstant . ENHANCE_QUERY , params ) ; sqlService . executeEnhanceSqlList ( onlCgformHead , MjkjConstant . ENHANCE_QUERYANEXPORT , params ) ; if ( Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) && Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) ) { resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; return R . data ( resultMap ) ; } if ( Func . isNotEmpty ( params . get ( \"<STR_LIT>\" ) ) ) { resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; } resultMap . put ( \"<STR_LIT>\" , params . get ( \"<STR_LIT>\" ) ) ; Integer pageSzie = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; if ( Func . isNotEmpty ( dataList ) && pageSzie != - <NUM_LIT> ) { int size = dataList . size ( ) ; Object pageNoObj = params . get ( \"<STR_LIT>\" ) ; Object pageSizeObj = params . get ( \"<STR_LIT>\" ) ; if ( size > total . intValue ( ) && Func . isNotEmpty ( pageNoObj ) && Func . isNotEmpty ( pageNoObj ) ) { Integer page = Func . toInt ( pageNoObj ) ; Integer pageSize = Func . toInt ( pageSizeObj ) ; dataList = dataList . stream ( ) . skip ( ( page - <NUM_LIT> ) * pageSize ) . limit ( pageSize ) . collect ( Collectors . toList ( ) ) ; resultMap . put ( \"<STR_LIT>\" , size ) ; resultMap . put ( \"<STR_LIT>\" , dataList ) ; } } else if ( Func . isNotEmpty ( dataList ) && pageSzie == - <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , dataList ) ; if ( headId == <NUM_LIT> ) { redis . setEx ( langRedisKey , resultMap , Duration . ofMinutes ( <NUM_LIT> ) ) ; } } else { Object idList = params . get ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( idList ) ) { resultMap . put ( \"<STR_LIT>\" , idList ) ; } } return R . data ( resultMap ) ; } catch ( Exception e ) { e . getStackTrace ( ) ; return R . fail ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } } }"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . youlai . system . model . entity . SysUserRole ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface SysUserRoleMapper extends BaseMapper < SysUserRole > {", "output": "int countUsersForRole ( Long roleId ) ; }"}, {"input": "package top . kangert . kspider . service . impl ; import cn . hutool . core . convert . Convert ; import top . kangert . kspider . config . SpiderConfig ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . dao . SpiderFlowRepository ; import top . kangert . kspider . domain . SpiderFlow ; import top . kangert . kspider . exception . BaseException ; import top . kangert . kspider . exception . ExceptionCodes ; import top . kangert . kspider . io . Line ; import top . kangert . kspider . io . RandomAccessFileReader ; import top . kangert . kspider . job . SpiderJobManager ; import top . kangert . kspider . service . BaseService ; import top . kangert . kspider . service . SpiderFlowService ; import top . kangert . kspider . service . SpiderTaskService ; import top . kangert . kspider . util . PageInfo ; import lombok . extern . slf4j . Slf4j ; import org . quartz . CronScheduleBuilder ; import org . quartz . CronTrigger ; import org . quartz . TriggerBuilder ; import org . quartz . TriggerUtils ; import org . quartz . spi . OperableTrigger ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . domain . Page ; import org . springframework . data . domain . Pageable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . PlatformTransactionManager ; import org . springframework . transaction . annotation . Transactional ; import cn . hutool . core . date . DateUtil ; import javax . annotation . Resource ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . Objects ; @ Service @ Slf4j public class SpiderFlowServiceImpl extends BaseService implements SpiderFlowService { @ Resource private SpiderConfig spiderConfig ; @ Resource private SpiderJobManager spiderJobManager ; @ Resource private SpiderTaskService spiderTaskService ; @ Resource private SpiderFlowRepository spiderFlowRepository ; @ Autowired @ SuppressWarnings ( \"<STR_LIT>\" ) private PlatformTransactionManager txManager ; @ Override public SpiderFlow getById ( Long id ) { return spiderFlowRepository . findById ( id ) . orElse ( null ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public SpiderFlow addItem ( Map < String , Object > params ) { checkParams ( params , null ) ; SpiderFlow spiderFlow = transformEntity ( params , SpiderFlow . class ) ; SpiderFlow flow = spiderFlowRepository . save ( spiderFlow ) ; return flow ; } @ Override public void editItem ( Map < String , Object > params ) { checkParams ( params , new String [ ] { \"<STR_LIT>\" } ) ; Long flowId = Convert . toLong ( params . get ( \"<STR_LIT>\" ) ) ; SpiderFlow flow = queryItem ( flowId ) ; if ( flow == null ) { throw new BaseException ( ExceptionCodes . DB_DATA_WRONG ) ; } copyProperties ( params , flow ) ; spiderFlowRepository . save ( flow ) ; } @ Override public void deleteItem ( Map < String , Object > params ) { checkParams ( params , new String [ ] {", "output": "\"<STR_LIT>\" } ) ; Long flowId = Convert . toLong ( params . get ( \"<STR_LIT>\" ) ) ; if ( spiderJobManager . removeJob ( flowId ) ) { spiderFlowRepository . deleteById ( flowId ) ; } } @ Override public SpiderFlow queryItem ( Long id ) { if ( id == null ) { throw new BaseException ( ExceptionCodes . ARGUMENTS_ERROR ) ; } SpiderFlow spiderFlow = spiderFlowRepository . findSpiderFlowByFlowId ( id ) ; return spiderFlow ; } @ Override public PageInfo < SpiderFlow > queryItems ( Map < String , Object > params ) { checkParams ( params , null ) ; Pageable pageable = processPage ( params ) ; Page < SpiderFlow > pageInfo = spiderFlowRepository . findAll ( multipleConditionsBuilder ( params ) , pageable ) ; return new PageInfo < SpiderFlow > ( pageInfo ) ; } @ Override public List < SpiderFlow > findOtherFlows ( Long id ) { return spiderFlowRepository . findByFlowIdNot ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void removeById ( Long id ) { spiderFlowRepository . deleteById ( id ) ; } @ Override public List < String > getRecentTriggerTime ( String cron , int numTimes ) { List < String > list = new ArrayList < > ( ) ; CronTrigger trigger ; try { trigger = TriggerBuilder . newTrigger ( ) . withSchedule ( CronScheduleBuilder . cronSchedule ( cron ) ) . build ( ) ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" + cron + \"<STR_LIT>\" ) ; } List < Date > dates = TriggerUtils . computeFireTimes ( ( OperableTrigger ) trigger , null , numTimes ) ; for ( Date date : dates ) { list . add ( DateUtil . format ( date , \"<STR_LIT>\" ) ) ; } return list ; } @ Override public List < Line > log ( Long id , Long taskId , String keywords , Long index , Integer count , Boolean reversed , Boolean matchCase , Boolean regex ) { if ( Objects . isNull ( taskId ) ) { Long maxId = spiderTaskService . getMaxTaskIdByFlowId ( id ) ; if ( Objects . isNull ( maxId ) ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } else { taskId = maxId ; } } List < Line > lines ; String flowFolder = Constants . KSPIDER_FLOW_LOG_DIR_PREFIX + id ; String taskFolder = Constants . KSPIDER_TASK_LOG_DIR_PREFIX + taskId ; File logFile = new File ( new File ( spiderConfig . getWorkspace ( ) ) , \"<STR_LIT>\" + File . separator + flowFolder + File . separator + \"<STR_LIT>\" + File . separator + taskFolder + \"<STR_LIT>\" ) ; try ( RandomAccessFileReader reader = new RandomAccessFileReader ( new RandomAccessFile ( logFile , \"<STR_LIT>\" ) , index == null ? - <NUM_LIT> : index , reversed == null || reversed ) ) { lines = reader . readLine ( count == null ? <NUM_LIT> : count , keywords , matchCase != null && matchCase , regex != null && regex ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } catch ( IOException e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return lines ; } }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BinanceFilters { private BigDecimal minPrice ; private BigDecimal maxPrice ; private Integer priceScale ; private BigDecimal minQty ; private BigDecimal maxQty ; private Integer scale ;", "output": "}"}, {"input": "package com . yf . system . modules . config . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . system . modules . config . entity . CfgSwitch ; import java . util . Map ; public interface CfgSwitchService extends IService < CfgSwitch > { Map < String , Object > allMap ( ) ;", "output": "Boolean isOn ( String id ) ; String val ( String id ) ; void save ( Map < String , Object > map ) ; }"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . lang . Assert ; import cn . hutool . core . util . ObjectUtil ; import cn . hutool . core . util . StrUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . common . constant . SystemConstants ; import com . youlai . system . common . model . Option ; import com . youlai . system . security . util . SecurityUtils ; import com . youlai . system . converter . RoleConverter ; import com . youlai . system . mapper . SysRoleMapper ; import com . youlai . system . model . entity . SysRole ; import com . youlai . system . model . entity . SysRoleMenu ; import com . youlai . system . model . form . RoleForm ; import com . youlai . system . model . query . RolePageQuery ; import com . youlai . system . model . vo . RolePageVO ; import com . youlai . system . security . service . PermissionService ; import com . youlai . system . service . SysRoleMenuService ; import com . youlai . system . service . SysRoleService ; import com . youlai . system . service . SysUserRoleService ; import lombok . RequiredArgsConstructor ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . Arrays ; import java . util . List ; import java . util . Set ; @ Service @ RequiredArgsConstructor public class SysRoleServiceImpl extends ServiceImpl < SysRoleMapper , SysRole > implements SysRoleService { private final SysRoleMenuService roleMenuService ; private final SysUserRoleService userRoleService ; private final RoleConverter roleConverter ; @ Override public Page < RolePageVO > getRolePage ( RolePageQuery queryParams ) { int pageNum = queryParams . getPageNum ( ) ; int pageSize = queryParams . getPageSize ( ) ; String keywords = queryParams . getKeywords ( ) ; Page < SysRole > rolePage = this . page ( new Page < > ( pageNum , pageSize ) , new LambdaQueryWrapper < SysRole > ( ) . and ( StrUtil . isNotBlank ( keywords ) , wrapper -> wrapper . like ( StrUtil . isNotBlank ( keywords ) , SysRole :: getName , keywords ) . or ( ) . like ( StrUtil . isNotBlank ( keywords ) , SysRole :: getCode , keywords ) ) . ne ( ! SecurityUtils . isRoot ( ) , SysRole :: getCode , SystemConstants . ROOT_ROLE_CODE ) ) ; return roleConverter . convertToPageVo ( rolePage ) ; } @ Override public List < Option > listRoleOptions ( ) { List < SysRole > roleList = this . list ( new LambdaQueryWrapper < SysRole > ( ) . ne ( ! SecurityUtils . isRoot ( ) , SysRole :: getCode , SystemConstants . ROOT_ROLE_CODE ) . select ( SysRole :: getId , SysRole :: getName ) . orderByAsc ( SysRole :: getSort ) ) ; return roleConverter . entities2Options ( roleList ) ; } @ Override public boolean saveRole ( RoleForm roleForm ) { Long roleId = roleForm . getId ( ) ; SysRole oldRole = null ; if ( roleId != null ) { oldRole = this . getById ( roleId ) ; Assert . isTrue ( oldRole != null , \"<STR_LIT>\" ) ; } String roleCode = roleForm . getCode ( ) ; long count = this . count ( new LambdaQueryWrapper < SysRole > ( ) . ne ( roleId != null , SysRole :: getId , roleId ) . and ( wrapper -> wrapper . eq ( SysRole :: getCode , roleCode ) . or ( ) . eq ( SysRole :: getName , roleForm . getName ( ) ) ) ) ; Assert . isTrue ( count == <NUM_LIT> , \"<STR_LIT>\" ) ; SysRole role = roleConverter . toEntity ( roleForm ) ; boolean result = this . saveOrUpdate ( role ) ; if ( result ) { if ( oldRole != null && ( ! StrUtil . equals ( oldRole . getCode ( ) , roleCode ) || ! ObjectUtil . equals ( oldRole . getStatus ( ) , roleForm . getStatus ( ) ) ) ) { roleMenuService . refreshRolePermsCache ( oldRole . getCode ( ) , roleCode ) ; } } return result ; } @ Override public RoleForm getRoleForm ( Long roleId ) { SysRole entity = this . getById ( roleId ) ;", "output": "return roleConverter . toForm ( entity ) ; } @ Override public boolean updateRoleStatus ( Long roleId , Integer status ) { SysRole role = this . getById ( roleId ) ; Assert . isTrue ( role != null , \"<STR_LIT>\" ) ; role . setStatus ( status ) ; boolean result = this . updateById ( role ) ; if ( result ) { roleMenuService . refreshRolePermsCache ( role . getCode ( ) ) ; } return result ; } @ Override public boolean deleteRoles ( String ids ) { Assert . isTrue ( StrUtil . isNotBlank ( ids ) , \"<STR_LIT>\" ) ; List < Long > roleIds = Arrays . stream ( ids . split ( \"<STR_LIT>\" ) ) . map ( Long :: parseLong ) . toList ( ) ; for ( Long roleId : roleIds ) { SysRole role = this . getById ( roleId ) ; Assert . isTrue ( role != null , \"<STR_LIT>\" ) ; boolean isRoleAssigned = userRoleService . hasAssignedUsers ( roleId ) ; Assert . isTrue ( ! isRoleAssigned , \"<STR_LIT>\" , role . getName ( ) ) ; boolean deleteResult = this . removeById ( roleId ) ; if ( deleteResult ) { roleMenuService . refreshRolePermsCache ( role . getCode ( ) ) ; } } return true ; } @ Override public List < Long > getRoleMenuIds ( Long roleId ) { return roleMenuService . listMenuIdsByRoleId ( roleId ) ; } @ Override @ Transactional @ CacheEvict ( cacheNames = \"<STR_LIT>\" , key = \"<STR_LIT>\" ) public boolean assignMenusToRole ( Long roleId , List < Long > menuIds ) { SysRole role = this . getById ( roleId ) ; Assert . isTrue ( role != null , \"<STR_LIT>\" ) ; roleMenuService . remove ( new LambdaQueryWrapper < SysRoleMenu > ( ) . eq ( SysRoleMenu :: getRoleId , roleId ) ) ; if ( CollectionUtil . isNotEmpty ( menuIds ) ) { List < SysRoleMenu > roleMenus = menuIds . stream ( ) . map ( menuId -> new SysRoleMenu ( roleId , menuId ) ) . toList ( ) ; roleMenuService . saveBatch ( roleMenus ) ; } roleMenuService . refreshRolePermsCache ( role . getCode ( ) ) ; return true ; } @ Override public Integer getMaximumDataScope ( Set < String > roles ) { Integer dataScope = this . baseMapper . getMaximumDataScope ( roles ) ; return dataScope ; } }"}, {"input": "package com . yf . ability . excel ; import cn . hutool . core . io . IoUtil ; import com . yf . ability . excel . annotation . ExcelField ; import com . yf . ability . excel . service . ExcelDictService ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . DateUtils ; import com . yf . base . utils . Reflections ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . stereotype . Component ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . * ; @ Component public class ExportExcel { @ Lazy @ Autowired private ExcelDictService excelDictService ; public void export ( HttpServletResponse response , Class clazz , String title , List list ) { if ( CollectionUtils . isEmpty ( list ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } Field [ ] fields = clazz . getDeclaredFields ( ) ; List < Field > fieldList = new ArrayList < > ( ) ; for ( Field field : fields ) { if ( ! field . isAccessible ( ) ) { field . setAccessible ( true ) ; } boolean export = field . isAnnotationPresent ( ExcelField . class ) ; if ( ! export ) { continue ; } fieldList . add ( field ) ; } Collections . sort ( fieldList , ( o1 , o2 ) -> { ExcelField a1 = o1 . getAnnotation ( ExcelField . class ) ; ExcelField a2 = o2 . getAnnotation ( ExcelField . class ) ; return a1 . sort ( ) - a2 . sort ( ) ; } ) ; try { this . write ( response , fieldList , title , list ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void write ( HttpServletResponse response , List < Field > fieldList , String title , List list ) throws IOException { MyExcelWriter writer = MyExcelWriter . getBigWriter ( ) ; List < Map < String , Object > > rows = this . processRows ( fieldList , list ) ; writer . merge ( rows . get ( <NUM_LIT> ) . size ( ) - <NUM_LIT> , title ) ; writer . write ( rows , true ) ; writer . autoSizeColumnAll ( ) ; ServletOutputStream out = response . getOutputStream ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; writer . flush ( out , true ) ; writer . close ( ) ; IoUtil . close ( out ) ; } public List < Map < String , Object > > processRows ( List < Field > fieldList , List list ) { List < Map < String , Object > > all = new ArrayList < > ( ) ; for ( Object data : list ) { Map < String , Object > row = new LinkedHashMap < > ( ) ; for ( Field field : fieldList ) { ExcelField ann = field . getAnnotation ( ExcelField . class ) ; Object val = Reflections . invokeGetter ( data , field . getName ( ) ) ; String result = this . transData ( ann , val ) ; row . put ( ann . title ( ) , result ) ; } all . add ( row ) ; } return all ; } private String transDict ( ExcelField ann , Object val ) { String table = ann . dictTable ( ) ; String code = ann . dictCode ( ) ; String text = ann . dicText ( ) ; String key = String . valueOf ( val ) ; if ( StringUtils . isEmpty ( key ) ) { return key ; } try { if ( StringUtils . isEmpty ( table ) ) { return excelDictService . findDictText ( code , key ) ; } return excelDictService . findTableText ( table , text , code , key ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return String . valueOf ( val ) ; } private String transData ( ExcelField ann , Object val ) { if ( val == null ) { return \"<STR_LIT>\" ; } if ( val instanceof Date ) { String pattern = ann . pattern ( ) ; if ( StringUtils . isEmpty ( pattern ) ) { pattern = \"<STR_LIT>\" ; } return DateUtils . formatDate ( ( Date ) val , pattern ) ; } String filter = ann . filter ( ) ; if ( ! StringUtils . isEmpty ( filter ) ) { return this . transFilter ( val , filter ) ; }", "output": "String dic = ann . dictCode ( ) ; if ( ! StringUtils . isEmpty ( dic ) ) { return this . transDict ( ann , val ) ; } return String . valueOf ( val ) ; } private String transFilter ( Object val , String filter ) { String [ ] arr = filter . split ( \"<STR_LIT>\" ) ; if ( arr . length > <NUM_LIT> ) { for ( String item : arr ) { String [ ] arr1 = item . split ( \"<STR_LIT>\" ) ; if ( ( ( val == null || \"<STR_LIT>\" . equals ( String . valueOf ( val ) ) ) && \"<STR_LIT>\" . equals ( arr1 [ <NUM_LIT> ] ) ) || String . valueOf ( val ) . equals ( arr1 [ <NUM_LIT> ] ) ) { return arr1 [ <NUM_LIT> ] ; } } } return String . valueOf ( val ) ; } }"}, {"input": "package com . yf . system . modules . plugin . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . plugin . dto . PluginGroupDTO ; import com . yf . system . modules . plugin . entity . PluginGroup ; import java . util . List ; public interface PluginGroupService extends IService < PluginGroup > { IPage < PluginGroupDTO > paging ( PagingReqDTO < PluginGroupDTO > reqDTO ) ; void save ( PluginGroupDTO reqDTO ) ; void delete ( List < String > ids ) ; PluginGroupDTO detail ( String id ) ;", "output": "List < PluginGroupDTO > list ( PluginGroupDTO reqDTO ) ; }"}, {"input": "package org . springblade . common . config ; import lombok . AllArgsConstructor ; import org . springframework . context . annotation . Configuration ; @ Configuration @ AllArgsConstructor public class BladeCommonConfiguration {", "output": "}"}, {"input": "package com . yf . system . modules . plugin . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class PluginSchema extends Model < PluginSchema > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; private String schemaData ; @ TableField ( \"<STR_LIT>\" ) private String groupId ;", "output": "}"}, {"input": "package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . LocalStorage ; import me . zhengjie . domain . vo . LocalStorageQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; public interface LocalStorageService extends IService < LocalStorage > { PageResult < LocalStorage > queryAll ( LocalStorageQueryCriteria criteria , Page < Object > page ) ; List < LocalStorage > queryAll ( LocalStorageQueryCriteria criteria ) ; LocalStorage create ( String name , MultipartFile file ) ; void update ( LocalStorage resources ) ; void deleteAll ( Long [ ] ids ) ; void download ( List < LocalStorage > localStorages , HttpServletResponse response ) throws IOException ;", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class PopupProperty extends CommonProperty { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; private String destFields ; private String orgFields ; public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getDestFields ( ) { return destFields ;", "output": "} public void setDestFields ( String destFields ) { this . destFields = destFields ; } public String getOrgFields ( ) { return orgFields ; } public void setOrgFields ( String orgFields ) { this . orgFields = orgFields ; } public PopupProperty ( ) { } public PopupProperty ( String key , String title , String code , String destFields , String orgFields ) { this . view = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . code = code ; this . destFields = destFields ; this . orgFields = orgFields ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( code != null ) { prop . put ( \"<STR_LIT>\" , code ) ; } if ( destFields != null ) { prop . put ( \"<STR_LIT>\" , destFields ) ; } if ( orgFields != null ) { prop . put ( \"<STR_LIT>\" , orgFields ) ; } map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractForceModel { private BigDecimal forcePrice ; private String contractLogId ; private String direction ;", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . model . DictModel ; import java . io . Serializable ; import java . util . List ; import java . util . Map ; public abstract class CommonProperty implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String key ; protected String type ; protected List < DictModel > include ; protected Object constant ; protected String view ; protected String title ; protected Integer order ; protected boolean disabled ; protected String defVal ; public String getDefVal ( ) { return defVal ; } public void setDefVal ( String defVal ) { this . defVal = defVal ; } public boolean isDisabled ( ) { return disabled ; } public void setDisabled ( boolean disabled ) { this . disabled = disabled ; } public String getView ( ) { return view ; }", "output": "public void setView ( String view ) { this . view = view ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public List < DictModel > getInclude ( ) { return include ; } public void setInclude ( List < DictModel > include ) { this . include = include ; } public Object getConstant ( ) { return constant ; } public void setConstant ( Object constant ) { this . constant = constant ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getOrder ( ) { return order ; } public void setOrder ( Integer order ) { this . order = order ; } public abstract Map < String , Object > getPropertyJson ( ) ; public JSONObject getCommonJson ( ) { JSONObject json = new JSONObject ( ) ; json . put ( \"<STR_LIT>\" , type ) ; if ( include != null && include . size ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , include ) ; } if ( constant != null ) { json . put ( \"<STR_LIT>\" , constant ) ; } if ( title != null ) { json . put ( \"<STR_LIT>\" , title ) ; } if ( order != null ) { json . put ( \"<STR_LIT>\" , order ) ; } if ( view == null ) { json . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { json . put ( \"<STR_LIT>\" , view ) ; } if ( disabled ) { String str = \"<STR_LIT>\" ; JSONObject ui = JSONObject . parseObject ( str ) ; json . put ( \"<STR_LIT>\" , ui ) ; } if ( defVal != null && defVal . length ( ) > <NUM_LIT> ) { json . put ( \"<STR_LIT>\" , defVal ) ; } return json ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryUtils ; import org . springframework . beans . factory . ListableBeanFactory ; import org . springframework . beans . factory . NoUniqueBeanDefinitionException ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . Ordered ; import org . springframework . core . annotation . AnnotationAwareOrderComparator ; import org . springframework . util . ClassUtils ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . util . * ; import static java . lang . String . format ; import static org . springframework . beans . factory . BeanFactoryUtils . beanNamesForTypeIncludingAncestors ; import static org . springframework . beans . factory . BeanFactoryUtils . beanOfTypeIncludingAncestors ; public class BeanUtils { private static final Log logger = LogFactory . getLog ( BeanUtils . class ) ; private static final String [ ] EMPTY_BEAN_NAMES = new String [ <NUM_LIT> ] ; public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return isBeanPresent ( beanFactory , beanClass , false ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; return ! org . springframework . util . ObjectUtils . isEmpty ( beanNames ) ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName , boolean includingAncestors ) { boolean present = false ; ClassLoader classLoader = beanFactory . getClass ( ) . getClassLoader ( ) ; if ( ClassUtils . isPresent ( beanClassName , classLoader ) ) { Class beanClass = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; present = isBeanPresent ( beanFactory , beanClass , includingAncestors ) ; } return present ; } public static boolean isBeanPresent ( ListableBeanFactory beanFactory , String beanClassName ) { return isBeanPresent ( beanFactory , beanClassName , false ) ; } public static boolean isBeanPresent ( BeanFactory beanFactory , String beanName , Class < ? > beanClass ) throws NullPointerException { return beanFactory . containsBean ( beanName ) && beanFactory . isTypeMatch ( beanName , beanClass ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { if ( includingAncestors ) { return beanNamesForTypeIncludingAncestors ( beanFactory , beanClass , true , false ) ; } else { return beanFactory . getBeanNamesForType ( beanClass , true , false ) ; } } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass ) { return getBeanNames ( beanFactory , beanClass , false ) ; } public static String [ ] getBeanNames ( ConfigurableListableBeanFactory beanFactory , Class < ? > beanClass , boolean includingAncestors ) { return getBeanNames ( ( ListableBeanFactory ) beanFactory , beanClass , includingAncestors ) ; } public static Class < ? > resolveBeanType ( String beanClassName , ClassLoader classLoader ) { if ( ! StringUtils . hasText ( beanClassName ) ) { return null ; } Class < ? > beanType = null ; try { beanType = ClassUtils . resolveClassName ( beanClassName , classLoader ) ; beanType = ClassUtils . getUserClass ( beanType ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return beanType ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass , boolean includingAncestors ) throws BeansException { String [ ] beanNames = getBeanNames ( beanFactory , beanClass , includingAncestors ) ; if ( ObjectUtils . isEmpty ( beanNames ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"<STR_LIT>\" + beanClass . getName ( ) + \"<STR_LIT>\" ) ; } return null ; } T bean = null ; try { bean = includingAncestors ? beanOfTypeIncludingAncestors ( beanFactory , beanClass ) : beanFactory . getBean ( beanClass ) ; } catch ( Exception e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } return bean ; } public static < T > T getOptionalBean ( ListableBeanFactory beanFactory , Class < T > beanClass ) throws BeansException { return getOptionalBean ( beanFactory , beanClass , false ) ; } public static < T > T getBeanIfAvailable ( BeanFactory beanFactory , String beanName , Class < T > beanType ) throws BeansException { if ( isBeanPresent ( beanFactory , beanName , beanType ) ) { return beanFactory . getBean ( beanName , beanType ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( format ( \"<STR_LIT>\" , beanName , beanType . getName ( ) ) ) ; } return null ; } public static < T > List < T > getSortedBeans ( ListableBeanFactory beanFactory , Class < T > type ) { Map < String , T > beansOfType = BeanFactoryUtils . beansOfTypeIncludingAncestors ( beanFactory , type ) ; List < T > beansList = new ArrayList < T > ( beansOfType . values ( ) ) ; AnnotationAwareOrderComparator . sort ( beansList ) ; return Collections . unmodifiableList ( beansList ) ; } public static < T > Map < String , T > sort ( final Map < String , T > beansMap ) { Map < String , T > unmodifiableBeansMap = Collections . unmodifiableMap ( beansMap ) ; List < NamingBean < T > > namingBeans = new ArrayList < NamingBean < T > > ( unmodifiableBeansMap . size ( ) ) ; for ( Map . Entry < String , T > entry : unmodifiableBeansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; T bean = entry . getValue ( ) ; NamingBean < T > namingBean = new NamingBean < T > ( beanName , bean ) ;", "output": "namingBeans . add ( namingBean ) ; } AnnotationAwareOrderComparator . sort ( namingBeans ) ; Map < String , T > sortedBeansMap = new LinkedHashMap < String , T > ( beansMap . size ( ) ) ; for ( NamingBean < T > namingBean : namingBeans ) { sortedBeansMap . put ( namingBean . name , namingBean . bean ) ; } return sortedBeansMap ; } static class NamingBean < T > extends AnnotationAwareOrderComparator implements Comparable < NamingBean > , Ordered { private final String name ; private final T bean ; NamingBean ( String name , T bean ) { this . name = name ; this . bean = bean ; } @ Override public int compareTo ( NamingBean o ) { return compare ( this , o ) ; } @ Override public int getOrder ( ) { return getOrder ( bean ) ; } } }"}, {"input": "package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface DatabaseMapper extends BaseMapper < Database > {", "output": "IPage < Database > findAll ( @ Param ( \"<STR_LIT>\" ) DatabaseQueryCriteria criteria , Page < Object > page ) ; List < Database > findAll ( @ Param ( \"<STR_LIT>\" ) DatabaseQueryCriteria criteria ) ; }"}, {"input": "package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . domain . DictDetail ; import me . zhengjie . modules . system . mapper . DictDetailMapper ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . mapper . DictMapper ; import me . zhengjie . modules . system . service . DictService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class DictServiceImpl extends ServiceImpl < DictMapper , Dict > implements DictService { private final DictMapper dictMapper ; private final RedisUtils redisUtils ; private final DictDetailMapper deleteDetail ; @ Override public PageResult < Dict > queryAll ( DictQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < Dict > dicts = dictMapper . findAll ( criteria ) ; Long total = dictMapper . countAll ( criteria ) ; return PageUtil . toPage ( dicts , total ) ; } @ Override public List < Dict > queryAll ( DictQueryCriteria criteria ) { return dictMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Dict resources ) { save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Dict resources ) { delCaches ( resources ) ; Dict dict = getById ( resources . getId ( ) ) ; dict . setName ( resources . getName ( ) ) ; dict . setDescription ( resources . getDescription ( ) ) ; saveOrUpdate ( dict ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { List < Dict > dicts = dictMapper . selectBatchIds ( ids ) ; for ( Dict dict : dicts ) { delCaches ( dict ) ; } dictMapper . deleteBatchIds ( ids ) ; deleteDetail . deleteByDictBatchIds ( ids ) ; } @ Override public void download ( List < Dict > dicts , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Dict dict : dicts ) { if ( CollectionUtil . isNotEmpty ( dict . getDictDetails ( ) ) ) {", "output": "for ( DictDetail dictDetail : dict . getDictDetails ( ) ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , dict . getName ( ) ) ; map . put ( \"<STR_LIT>\" , dict . getDescription ( ) ) ; map . put ( \"<STR_LIT>\" , dictDetail . getLabel ( ) ) ; map . put ( \"<STR_LIT>\" , dictDetail . getValue ( ) ) ; map . put ( \"<STR_LIT>\" , dictDetail . getCreateTime ( ) ) ; list . add ( map ) ; } } else { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , dict . getName ( ) ) ; map . put ( \"<STR_LIT>\" , dict . getDescription ( ) ) ; map . put ( \"<STR_LIT>\" , null ) ; map . put ( \"<STR_LIT>\" , null ) ; map . put ( \"<STR_LIT>\" , dict . getCreateTime ( ) ) ; list . add ( map ) ; } } FileUtil . downloadExcel ( list , response ) ; } public void delCaches ( Dict dict ) { redisUtils . del ( CacheKey . DICT_NAME + dict . getName ( ) ) ; } }"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . lang . Assert ; import cn . hutool . core . util . ObjectUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . youlai . system . common . constant . SystemConstants ; import com . youlai . system . enums . MenuTypeEnum ; import com . youlai . system . enums . StatusEnum ; import com . youlai . system . common . model . KeyValue ; import com . youlai . system . common . model . Option ; import com . youlai . system . converter . MenuConverter ; import com . youlai . system . mapper . SysMenuMapper ; import com . youlai . system . model . bo . RouteBO ; import com . youlai . system . model . entity . SysMenu ; import com . youlai . system . model . form . MenuForm ; import com . youlai . system . model . query . MenuQuery ; import com . youlai . system . model . vo . MenuVO ; import com . youlai . system . model . vo . RouteVO ; import com . youlai . system . service . SysMenuService ; import com . youlai . system . service . SysRoleMenuService ; import lombok . RequiredArgsConstructor ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor public class SysMenuServiceImpl extends ServiceImpl < SysMenuMapper , SysMenu > implements SysMenuService { private final MenuConverter menuConverter ; private final SysRoleMenuService roleMenuService ; @ Override public List < MenuVO > listMenus ( MenuQuery queryParams ) { List < SysMenu > menus = this . list ( new LambdaQueryWrapper < SysMenu > ( ) . like ( StrUtil . isNotBlank ( queryParams . getKeywords ( ) ) , SysMenu :: getName , queryParams . getKeywords ( ) ) . orderByAsc ( SysMenu :: getSort ) ) ; Set < Long > menuIds = menus . stream ( ) . map ( SysMenu :: getId ) . collect ( Collectors . toSet ( ) ) ; Set < Long > parentIds = menus . stream ( ) . map ( SysMenu :: getParentId ) . collect ( Collectors . toSet ( ) ) ; List < Long > rootIds = parentIds . stream ( ) . filter ( id -> ! menuIds . contains ( id ) ) . toList ( ) ; return rootIds . stream ( ) . flatMap ( rootId -> buildMenuTree ( rootId , menus ) . stream ( ) ) . collect ( Collectors . toList ( ) ) ; } private List < MenuVO > buildMenuTree ( Long parentId , List < SysMenu > menuList ) { return CollectionUtil . emptyIfNull ( menuList ) . stream ( ) . filter ( menu -> menu . getParentId ( ) . equals ( parentId ) ) . map ( entity -> { MenuVO menuVO = menuConverter . convertToVo ( entity ) ; List < MenuVO > children = buildMenuTree ( entity . getId ( ) , menuList ) ; menuVO . setChildren ( children ) ; return menuVO ; } ) . toList ( ) ; } @ Override public List < Option > listMenuOptions ( ) { List < SysMenu > menuList = this . list ( new LambdaQueryWrapper < SysMenu > ( ) . orderByAsc ( SysMenu :: getSort ) ) ; return buildMenuOptions ( SystemConstants . ROOT_NODE_ID , menuList ) ; } private List < Option > buildMenuOptions ( Long parentId , List < SysMenu > menuList ) { List < Option > menuOptions = new ArrayList < > ( ) ; for ( SysMenu menu : menuList ) { if ( menu . getParentId ( ) . equals ( parentId ) ) { Option option = new Option ( menu . getId ( ) , menu . getName ( ) ) ; List < Option > subMenuOptions = buildMenuOptions ( menu . getId ( ) , menuList ) ; if ( ! subMenuOptions . isEmpty ( ) ) { option . setChildren ( subMenuOptions ) ; } menuOptions . add ( option ) ; } } return menuOptions ; } @ Override public List < RouteVO > listRoutes ( Set < String > roles ) { if ( CollectionUtil . isEmpty ( roles ) ) { return Collections . emptyList ( ) ; } List < RouteBO > menuList = this . baseMapper . listRoutes ( roles ) ; return buildRoutes ( SystemConstants . ROOT_NODE_ID , menuList ) ; } private List < RouteVO > buildRoutes ( Long parentId , List < RouteBO > menuList ) { List < RouteVO > routeList = new ArrayList < > ( ) ; for ( RouteBO menu : menuList ) { if ( menu . getParentId ( ) . equals ( parentId ) ) { RouteVO routeVO = toRouteVo ( menu ) ; List < RouteVO > children = buildRoutes ( menu . getId ( ) , menuList ) ; if ( ! children . isEmpty ( ) ) { routeVO . setChildren ( children ) ; } routeList . add ( routeVO ) ; } } return routeList ; } private RouteVO toRouteVo ( RouteBO routeBO ) { RouteVO routeVO = new RouteVO ( ) ; String routeName = routeBO . getRouteName ( ) ; if ( StrUtil . isBlank ( routeName ) ) { routeName = StringUtils . capitalize ( StrUtil . toCamelCase ( routeBO . getRoutePath ( ) , '<STR_LIT>' ) ) ; } routeVO . setName ( routeName ) ; routeVO . setPath ( routeBO . getRoutePath ( ) ) ; routeVO . setRedirect ( routeBO . getRedirect ( ) ) ; routeVO . setComponent ( routeBO . getComponent ( ) ) ; RouteVO . Meta meta = new RouteVO . Meta ( ) ; meta . setTitle ( routeBO . getName ( ) ) ; meta . setIcon ( routeBO . getIcon ( ) ) ; meta . setHidden ( StatusEnum . DISABLE . getValue ( ) . equals ( routeBO . getVisible ( ) ) ) ; if ( MenuTypeEnum . MENU . equals ( routeBO . getType ( ) ) && ObjectUtil . equals ( routeBO . getKeepAlive ( ) , <NUM_LIT> ) ) { meta . setKeepAlive ( true ) ; } meta . setAlwaysShow ( ObjectUtil . equals ( routeBO . getAlwaysShow ( ) , <NUM_LIT> ) ) ; String paramsJson = routeBO . getParams ( ) ; if ( StrUtil . isNotBlank ( paramsJson ) ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; try { Map < String , String > paramMap = objectMapper . readValue ( paramsJson , new TypeReference < > ( ) { } ) ; meta . setParams ( paramMap ) ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } } routeVO . setMeta ( meta ) ; return routeVO ; } @ Override @ CacheEvict ( cacheNames = \"<STR_LIT>\" , key = \"<STR_LIT>\" ) public boolean saveMenu ( MenuForm menuForm ) { MenuTypeEnum menuType = menuForm . getType ( ) ; if ( menuType == MenuTypeEnum . CATALOG ) { String path = menuForm . getRoutePath ( ) ; if ( menuForm . getParentId ( ) == <NUM_LIT> && ! path . startsWith ( \"<STR_LIT>\" ) ) { menuForm . setRoutePath ( \"<STR_LIT>\" + path ) ; } menuForm . setComponent ( \"<STR_LIT>\" ) ; } else if ( menuType == MenuTypeEnum . EXTLINK ) { menuForm . setComponent ( null ) ; } SysMenu entity = menuConverter . toEntity ( menuForm ) ; String treePath = generateMenuTreePath ( menuForm . getParentId ( ) ) ; entity . setTreePath ( treePath ) ; List < KeyValue > params = menuForm . getParams ( ) ; if ( CollectionUtil . isNotEmpty ( params ) ) { entity . setParams ( JSONUtil . toJsonStr ( params . stream ( ) . collect ( Collectors . toMap ( KeyValue :: getKey , KeyValue :: getValue ) ) ) ) ; } else { entity . setParams ( null ) ; } boolean result = this . saveOrUpdate ( entity ) ; if ( result ) { if ( menuForm . getId ( ) != null ) { roleMenuService . refreshRolePermsCache ( ) ; } } return result ; } private String generateMenuTreePath ( Long parentId ) { if ( SystemConstants . ROOT_NODE_ID . equals ( parentId ) ) {", "output": "return String . valueOf ( parentId ) ; } else { SysMenu parent = this . getById ( parentId ) ; return parent != null ? parent . getTreePath ( ) + \"<STR_LIT>\" + parent . getId ( ) : null ; } } @ Override @ CacheEvict ( cacheNames = \"<STR_LIT>\" , key = \"<STR_LIT>\" ) public boolean updateMenuVisible ( Long menuId , Integer visible ) { return this . update ( new LambdaUpdateWrapper < SysMenu > ( ) . eq ( SysMenu :: getId , menuId ) . set ( SysMenu :: getVisible , visible ) ) ; } @ Override public MenuForm getMenuForm ( Long id ) { SysMenu entity = this . getById ( id ) ; Assert . isTrue ( entity != null , \"<STR_LIT>\" ) ; MenuForm formData = menuConverter . toForm ( entity ) ; String params = entity . getParams ( ) ; if ( StrUtil . isNotBlank ( params ) ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; try { Map < String , String > paramMap = objectMapper . readValue ( params , new TypeReference < > ( ) { } ) ; List < KeyValue > transformedList = paramMap . entrySet ( ) . stream ( ) . map ( entry -> new KeyValue ( entry . getKey ( ) , entry . getValue ( ) ) ) . toList ( ) ; formData . setParams ( transformedList ) ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } } return formData ; } @ Override @ CacheEvict ( cacheNames = \"<STR_LIT>\" , key = \"<STR_LIT>\" ) public boolean deleteMenu ( Long id ) { boolean result = this . remove ( new LambdaQueryWrapper < SysMenu > ( ) . eq ( SysMenu :: getId , id ) . or ( ) . apply ( \"<STR_LIT>\" , id ) ) ; if ( result ) { roleMenuService . refreshRolePermsCache ( ) ; } return result ; } }"}, {"input": "package org . springblade . plugin . message . constant ; public interface MessageConstant { String socketPublic = \"<STR_LIT>\" ; String SocketTopic_INDEX = \"<STR_LIT>\" ; String SocketTopic_XH_DEPTH = \"<STR_LIT>\" ; String SocketTopic_UBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBW_DEPTH = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DEPTH = \"<STR_LIT>\" ; String SocketTopic_XH_DETAIL = \"<STR_LIT>\" ; String SocketTopic_UBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBW_DETAIL = \"<STR_LIT>\" ; String SocketTopic_BBWJG_DETAIL = \"<STR_LIT>\" ; String SocketTopic_XH_TRADE = \"<STR_LIT>\" ;", "output": "String SocketTopic_UBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBW_TRADE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_TRADE = \"<STR_LIT>\" ; String SocketTopic_XH_KLINE = \"<STR_LIT>\" ; String SocketTopic_UBW_KLINE = \"<STR_LIT>\" ; String SocketTopic_BBW_KLINE = \"<STR_LIT>\" ; String SocketTopic_BBWJG_KLINE = \"<STR_LIT>\" ; String Sockettopic_ALL_SYMBOL = \"<STR_LIT>\" ; }"}, {"input": "package com . oddfar . campus . framework . api . sysconfig ; import cn . hutool . core . convert . Convert ; public class ConfigExpander { public static String getUserDefaultAvatar ( ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" ) ; } public static String getLoginCaptchaType ( ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } public static String getFileProfile ( ) { String osName = System . getProperty ( \"<STR_LIT>\" ) . toLowerCase ( ) ; if ( osName . contains ( \"<STR_LIT>\" ) ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } if ( osName . contains ( \"<STR_LIT>\" ) ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } if ( osName . contains ( \"<STR_LIT>\" ) ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } return null ;", "output": "} public static String getAvatarPath ( ) { return getFileProfile ( ) + \"<STR_LIT>\" ; } public static Boolean getGlobalControllerOpenFlag ( ) { String flag = ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; return Convert . toBool ( flag ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . time ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . util . concurrent . atomic . AtomicReference ; public class CachingDateFormatter { private FastDateFormat fastDateFormat ; private AtomicReference < CachedTime > cachedTime ; private boolean onSecond ; public CachingDateFormatter ( String pattern ) {", "output": "this ( FastDateFormat . getInstance ( pattern ) ) ; } public CachingDateFormatter ( FastDateFormat fastDateFormat ) { this . fastDateFormat = fastDateFormat ; onSecond = fastDateFormat . getPattern ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ; long current = System . currentTimeMillis ( ) ; this . cachedTime = new AtomicReference < CachedTime > ( new CachedTime ( current , fastDateFormat . format ( current ) ) ) ; } public String format ( final long timestampMillis ) { CachedTime cached = cachedTime . get ( ) ; long timestamp = onSecond ? timestampMillis / <NUM_LIT> : timestampMillis ; if ( timestamp != cached . timestamp ) { final CachedTime newCachedTime = new CachedTime ( timestamp , fastDateFormat . format ( timestampMillis ) ) ; cachedTime . compareAndSet ( cached , newCachedTime ) ; cached = newCachedTime ; } return cached . formatted ; } static final class CachedTime { public long timestamp ; public String formatted ; public CachedTime ( final long timestamp , String formatted ) { this . timestamp = timestamp ; this . formatted = formatted ; } } }"}, {"input": "package com . yf . config . websocket ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import javax . websocket . server . ServerEndpointConfig ; public class CustomSpringConfigurator extends ServerEndpointConfig . Configurator implements ApplicationContextAware { private static volatile BeanFactory context ; @ Override public < T > T getEndpointInstance ( Class < T > clazz ) throws InstantiationException { return context . getBean ( clazz ) ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException {", "output": "CustomSpringConfigurator . context = applicationContext ; } }"}, {"input": "package org . example . infrastructure . convertor . example ; import io . github . chensheng . dddboot . microservice . core . DDDConvertor ; import org . example . application . example . dto . result . ExampleResult ; import org . example . domain . example . entity . ExampleEntity ; import org . example . infrastructure . repository . example . database . dataobject . Example ; import org . mapstruct . Mapper ; import org . mapstruct . MappingConstants ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface ExampleConvertor extends DDDConvertor < ExampleEntity , Example , ExampleResult > {", "output": "}"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . vo . UserInfoVO ; import com . xcs . wx . domain . vo . UserVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . domain . vo . WeChatConfigVO ; import com . xcs . wx . service . UserService ; import com . xcs . wx . service . WeChatService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PutMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { private final UserService userService ; private final WeChatService weChatService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < WeChatConfigVO > > readWeChatConfig ( ) { return ResponseVO . ok ( weChatService . readWeChatConfig ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < UserInfoVO > userInfo ( ) {", "output": "return ResponseVO . ok ( userService . userInfo ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < String > avatar ( ) { return ResponseVO . ok ( userService . avatar ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < String > nickname ( ) { return ResponseVO . ok ( userService . nickname ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < UserVO > > users ( ) { return ResponseVO . ok ( userService . users ( ) ) ; } @ PutMapping ( \"<STR_LIT>\" ) public ResponseVO < String > switchUser ( String wxId ) { userService . switchUser ( wxId ) ; return ResponseVO . ok ( \"<STR_LIT>\" ) ; } }"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import io . github . chensheng . dddboot . web . core . BizException ; public interface DDDRepository < E extends DDDEntity > { Long save ( E entity ) throws BizException ;", "output": "E getById ( Long id ) throws BizException ; int remove ( E entity ) throws BizException ; }"}, {"input": "package com . yf . system . modules . menu . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . system . modules . depart . dto . request . DepartSortReqDTO ; import com . yf . system . modules . menu . dto . SysMenuDTO ; import com . yf . system . modules . menu . dto . response . MenuTreeRespDTO ; import com . yf . system . modules . menu . dto . response . RouteRespDTO ; import com . yf . system . modules . menu . entity . SysMenu ; import java . util . List ; public interface SysMenuService extends IService < SysMenu > { List < RouteRespDTO > listMenuByRoles ( List < String > roleIds ) ; List < String > listPermissionByRoles ( List < String > roleIds ) ; List < MenuTreeRespDTO > listTree ( ) ; void sort ( DepartSortReqDTO reqDTO ) ;", "output": "void save ( SysMenuDTO reqDTO ) ; void delete ( List < String > ids ) ; }"}, {"input": "package com . oddfar . campus . framework . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import java . util . Set ; public interface SysUserService { PageResult < SysUserEntity > page ( SysUserEntity sysUserEntity ) ; SysUserEntity selectUserByUserName ( String userName ) ; SysUserEntity selectUserById ( Long userId ) ; Page < SysUserEntity > selectAllocatedList ( SysUserEntity user ) ; Page < SysUserEntity > selectUnallocatedList ( SysUserEntity user ) ; String selectUserRoleGroup ( String userName ) ; boolean registerUser ( SysUserEntity user ) ; int insertUser ( SysUserEntity user ) ; int updateUser ( SysUserEntity user ) ;", "output": "int deleteUserByIds ( Long [ ] userIds ) ; int updateUserProfile ( SysUserEntity user ) ; int updateUserStatus ( SysUserEntity user ) ; boolean updateUserAvatar ( String userName , String avatar ) ; int resetPwd ( SysUserEntity user ) ; void checkUserAllowed ( SysUserEntity user ) ; void insertUserAuth ( Long userId , Long [ ] roleIds ) ; void insertUserAuth ( Long userId , Set < String > roleKey ) ; int resetUserPwd ( String userName , String password ) ; boolean checkUserNameUnique ( SysUserEntity user ) ; boolean checkPhoneUnique ( SysUserEntity user ) ; boolean checkEmailUnique ( SysUserEntity user ) ; }"}, {"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . mapper . JsonMapper ; import feign . FeignException ; import feign . Response ; import feign . Util ; import feign . codec . DecodeException ; import feign . codec . Decoder ; import org . apache . http . HttpStatus ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; public class DefaultJacksonDecoder implements Decoder { @ Override public Object decode ( Response response , Type type ) throws IOException , DecodeException , FeignException { if ( response . status ( ) == HttpStatus . SC_NOT_FOUND ) {", "output": "return Util . emptyValueOf ( type ) ; } if ( response . body ( ) == null ) { return null ; } Reader reader = response . body ( ) . asReader ( ) ; if ( ! reader . markSupported ( ) ) { reader = new BufferedReader ( reader ) ; } reader . mark ( <NUM_LIT> ) ; if ( reader . read ( ) == - <NUM_LIT> ) { return null ; } reader . reset ( ) ; return JsonMapper . nonNullMapper ( ) . fromJson ( reader , type ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . score ; import cn . org . alan . exam . util . excel . ExcelExport ; import lombok . Data ; @ Data public class ExportScoreVO { @ ExcelExport ( \"<STR_LIT>\" ) private String realName ; @ ExcelExport ( \"<STR_LIT>\" ) private String gradeName ; @ ExcelExport ( \"<STR_LIT>\" ) private Double score ; @ ExcelExport ( value = \"<STR_LIT>\" , sort = <NUM_LIT> ) private Integer ranking ;", "output": "}"}, {"input": "package com . youlai . system . model . vo ; import com . fasterxml . jackson . annotation . JsonInclude ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Schema ( description = \"<STR_LIT>\" ) @ Data @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) public class RouteVO { @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String path ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String component ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String redirect ; @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private Meta meta ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public static class Meta { @ Schema ( description = \"<STR_LIT>\" ) private String title ; @ Schema ( description = \"<STR_LIT>\" ) private String icon ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Boolean hidden ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ JsonInclude ( JsonInclude . Include . NON_NULL ) private Boolean keepAlive ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ JsonInclude ( JsonInclude . Include . NON_NULL ) private Boolean alwaysShow ; @ Schema ( description = \"<STR_LIT>\" ) private Map < String , String > params ; } @ Schema ( description = \"<STR_LIT>\" ) private List < RouteVO > children ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class MyBillParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" ) private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String billsType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ;", "output": "}"}, {"input": "package org . springblade . cgform . model . flow ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data public class FlowModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public static final int MODEL_TYPE_BPMN = <NUM_LIT> ; public static final int MODEL_TYPE_FORM = <NUM_LIT> ; public static final int MODEL_TYPE_APP = <NUM_LIT> ; public static final int MODEL_TYPE_DECISION_TABLE = <NUM_LIT> ; public static final int MODEL_TYPE_CMMN = <NUM_LIT> ; private String id ; private String name ; private String modelKey ; private String description ; private Date created ; private Date lastUpdated ; private String createdBy ; private String lastUpdatedBy ; private Integer version ; private String modelEditorJson ; private String modelComment ; private Integer modelType ; private String tenantId ; private byte [ ] thumbnail ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . mapper ; import me . zhengjie . modules . system . domain . Dept ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . Set ; @ Mapper public interface RoleDeptMapper { void insertData ( @ Param ( \"<STR_LIT>\" ) Long roleId , @ Param ( \"<STR_LIT>\" ) Set < Dept > depts ) ; void deleteByRoleId ( @ Param ( \"<STR_LIT>\" ) Long roleId ) ; void deleteByRoleIds ( @ Param ( \"<STR_LIT>\" ) Set < Long > roleIds ) ;", "output": "}"}, {"input": "package com . youlai . system . model . vo ; import com . fasterxml . jackson . annotation . JsonFormat ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . time . LocalDateTime ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class RolePageVO { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private String code ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" ) private Integer sort ; @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime updateTime ;", "output": "}"}, {"input": "package com . youlai . system . plugin . easyexcel ; import com . alibaba . excel . event . AnalysisEventListener ; public abstract class MyAnalysisEventListener < T > extends AnalysisEventListener < T > { private String msg ; public abstract String getMsg ( ) ;", "output": "}"}, {"input": "package org . springblade . config . handler ; import com . alibaba . fastjson . JSONObject ; import org . apache . commons . lang . StringUtils ; import org . apache . commons . lang . math . RandomUtils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class FillRuleHandlerImpl implements IFillRuleHandler { public FillRuleHandlerImpl ( ) { } public Object execute ( JSONObject params , JSONObject formData ) { String var3 = \"<STR_LIT>\" ; if ( params != null ) { Object var4 = params . get ( \"<STR_LIT>\" ) ;", "output": "if ( var4 != null ) { var3 = var4 . toString ( ) ; } } SimpleDateFormat var8 = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int var5 = RandomUtils . nextInt ( <NUM_LIT> ) + <NUM_LIT> ; String var6 = var3 + var8 . format ( new Date ( ) ) + var5 ; String var7 = formData . getString ( \"<STR_LIT>\" ) ; if ( ! StringUtils . isEmpty ( var7 ) ) { var6 = var6 + var7 ; } return var6 ; } }"}, {"input": "package com . oddfar . campus . framework . service ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysDictDataEntity ; import com . oddfar . campus . common . domain . entity . SysDictTypeEntity ; import java . util . List ; public interface SysDictTypeService { PageResult < SysDictTypeEntity > page ( SysDictTypeEntity sysDictTypeEntity ) ; List < SysDictDataEntity > selectDictDataByType ( String dictType ) ;", "output": "SysDictTypeEntity selectDictTypeById ( Long dictId ) ; List < SysDictTypeEntity > selectDictTypeAll ( ) ; int updateDictType ( SysDictTypeEntity dictType ) ; int insertDictType ( SysDictTypeEntity dictType ) ; void deleteDictTypeByIds ( Long [ ] dictIds ) ; void resetDictCache ( ) ; void loadingDictCache ( ) ; boolean checkDictTypeUnique ( SysDictTypeEntity dictType ) ; }"}, {"input": "package com . youlai . system . model . query ; import com . youlai . system . common . base . BasePageQuery ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class DictPageQuery extends BasePageQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ; @ Schema ( description = \"<STR_LIT>\" ) private String typeCode ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import me . zhengjie . modules . system . domain . vo . MenuVo ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface MenuService extends IService < Menu > { List < Menu > queryAll ( MenuQueryCriteria criteria , Boolean isQuery ) throws Exception ; Menu findById ( long id ) ; void create ( Menu resources ) ; void update ( Menu resources ) ; Set < Menu > getChildMenus ( List < Menu > menuList , Set < Menu > menuSet ) ; List < Menu > buildTree ( List < Menu > menus ) ; List < MenuVo > buildMenus ( List < Menu > menus ) ; void delete ( Set < Menu > menuSet ) ; void download ( List < Menu > menus , HttpServletResponse response ) throws IOException ; List < Menu > getMenus ( Long pid ) ; List < Menu > getSuperior ( Menu menu , List < Menu > objects ) ;", "output": "List < Menu > findByUser ( Long currentUserId ) ; }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; public class CellContentConverterFactory { private static final Logger logger = LoggerFactory . getLogger ( CellContentConverterFactory . class ) ; private static final List < Converter > converters = new ArrayList < Converter > ( ) ; static {", "output": "converters . add ( new HyperLinkConverter ( ) ) ; converters . add ( new BooleanConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new IntegerConverter ( ) ) ; converters . add ( new LongConverter ( ) ) ; converters . add ( new FloatConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new ShortConverter ( ) ) ; converters . add ( new BigDecimalConverter ( ) ) ; converters . add ( new DoubleConverter ( ) ) ; converters . add ( new DateConverter ( ) ) ; converters . add ( new StringConverter ( ) ) ; } public static Object fromCellContent ( String cellContent , Field field , CellValueType type , String format , boolean use1904DateWindowing ) { if ( TextUtil . isEmpty ( cellContent ) || field == null ) { return null ; } for ( Converter converter : converters ) { if ( converter . support ( field , type ) ) { return converter . fromCellContent ( cellContent , field , format , use1904DateWindowing ) ; } } return null ; } public static void setCellContent ( Workbook workbook , Cell cell , Object rowData , Field field , CellValueType type , String format ) { if ( workbook == null || cell == null || rowData == null || field == null ) { return ; } Object cellValue ; try { ReflectionUtil . makeAccessible ( field ) ; cellValue = ReflectionUtil . getFieldValue ( rowData , field ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return ; } if ( cellValue == null ) { return ; } for ( Converter converter : converters ) { if ( converter . support ( field , type ) ) { converter . setCellContent ( workbook , cell , cellValue , format ) ; return ; } } } }"}, {"input": "package cn . org . alan . exam ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . session . data . redis . config . annotation . web . http . EnableRedisHttpSession ; @ SpringBootApplication @ EnableRedisHttpSession ( maxInactiveIntervalInSeconds = <NUM_LIT> * <NUM_LIT> ) public class ExamApplication { public static void main ( String [ ] args ) { SpringApplication . run ( ExamApplication . class , args ) ; }", "output": "}"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . domain . GenConfig ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; @ Mapper public interface GenConfigMapper extends BaseMapper < GenConfig > {", "output": "GenConfig findByTableName ( @ Param ( \"<STR_LIT>\" ) String tableName ) ; }"}, {"input": "package ginyi . common . constant ; public class CommonMessageConstants { public static final String LOGIN_SUCCESS = \"<STR_LIT>\" ; public static final String REGISTER_SUCCESS = \"<STR_LIT>\" ; public static final String REDIS_KEY_NOT_EXIST = \"<STR_LIT>\" ; public static final String REDIS_VALUE_TYPE_NOT_MATCH = \"<STR_LIT>\" ; public static final String SYS_ERROR = \"<STR_LIT>\" ; public static final String SYS_AUTHENTICATION_VALID = \"<STR_LIT>\" ; public static final String SYS_REQUEST_ILLEGAL = \"<STR_LIT>\" ; public static final String SYS_CAPTCHA_NOT_EXIST = \"<STR_LIT>\" ; public static final String SYS_PREVIEW_ENV = \"<STR_LIT>\" ; public static final String SYS_BED_REQUEST = \"<STR_LIT>\" ; public static final String UPLOAD_FILE_ERROR = \"<STR_LIT>\" ; public static final String UPLOAD_SIZE_EXCEED = \"<STR_LIT>\" ; public static final String VERIFY_EXPIRE = \"<STR_LIT>\" ; public static final String VERiFY_INCORRECT = \"<STR_LIT>\" ; public static final String USER_PASSWORD_NOT_MATCH = \"<STR_LIT>\" ; public static final String USER_EXIST = \"<STR_LIT>\" ; public static final String USER_NOT_EXIST = \"<STR_LIT>\" ; public static final String USER_IS_DELETED = \"<STR_LIT>\" ; public static final String USER_IS_FORBIDDEN = \"<STR_LIT>\" ; public static final String USER_IS_LOCKED = \"<STR_LIT>\" ; public static final String USER_NAME_USED = \"<STR_LIT>\" ; public static final String USER_NOT_FOUND = \"<STR_LIT>\" ; public static final String USER_ID_NOT_FOUND = \"<STR_LIT>\" ; public static final String USER_STATUS_ILLEGAL = \"<STR_LIT>\" ; public static final String USER_IDS_ILLEGAL = \"<STR_LIT>\" ; public static final String MENU_COMPONENT_NOT_EXIST = \"<STR_LIT>\" ; public static final String MENU_PATH_NOT_EXIST = \"<STR_LIT>\" ; public static final String MENU_NAME_USED = \"<STR_LIT>\" ; public static final String MENU_NOT_EXIST = \"<STR_LIT>\" ; public static final String MENU_PARENT_NOT_EXIST = \"<STR_LIT>\" ; public static final String MENU_ID_NOT_FOUND = \"<STR_LIT>\" ; public static final String MENU_STATUS_ILLEGAL = \"<STR_LIT>\" ; public static final String POST_NOT_EXIST = \"<STR_LIT>\" ; public static final String POST_NAME_USED = \"<STR_LIT>\" ; public static final String POST_CODE_USED = \"<STR_LIT>\" ; public static final String POST_ID_NOT_FOUND = \"<STR_LIT>\" ; public static final String POST_STATUS_ILLEGAL = \"<STR_LIT>\" ; public static final String ROLE_NOT_EXIST = \"<STR_LIT>\" ; public static final String ROLE_NAME_USED = \"<STR_LIT>\" ; public static final String ROLE_PERMISSION_CODE_USED = \"<STR_LIT>\" ; public static final String ROLE_MENU_NOT_EXIST = \"<STR_LIT>\" ; public static final String ROLE_ID_NOT_FOUND = \"<STR_LIT>\" ; public static final String ROLE_STATUS_ILLEGAL = \"<STR_LIT>\" ; public static final String DEPT_NOT_EXIST = \"<STR_LIT>\" ; public static final String DEPT_NAME_USED = \"<STR_LIT>\" ; public static final String DEPT_PARENT_NOT_EXIST = \"<STR_LIT>\" ; public static final String DEPT_ID_NOT_FOUND = \"<STR_LIT>\" ; public static final String DEPT_STATUS_ILLEGAL = \"<STR_LIT>\" ; public static final String NOTICE_NOT_EXIST = \"<STR_LIT>\" ; public static final String NOTICE_CURRENT_USER_NOT_EXIST = \"<STR_LIT>\" ; public static final String NOTICE_HAVE_READ = \"<STR_LIT>\" ; public static final String NOTICE_NOT_ALLOW = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . PropertyKeyConst ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . core . env . Environment ; import org . springframework . util . CollectionUtils ; import java . util . Map ; import java . util . Properties ; public class NacosPropertiesBuilder { public static Properties buildNacosProperties ( Environment environment , String serverAddr , String namespaceId , String endpoint , String secretKey , String accessKey , String ramRoleName , String configLongPollTimeout , String configRetryTimeout , String maxRetry , boolean enableRemoteSyncConfig , String username , String password ) { Properties properties = new Properties ( ) ; processPropertiesData ( properties , environment , serverAddr , PropertyKeyConst . SERVER_ADDR ) ; processPropertiesData ( properties , environment , namespaceId , PropertyKeyConst . NAMESPACE ) ; processPropertiesData ( properties , environment , endpoint , PropertyKeyConst . ENDPOINT ) ; processPropertiesData ( properties , environment , secretKey , PropertyKeyConst . SECRET_KEY ) ; processPropertiesData ( properties , environment , accessKey , PropertyKeyConst . ACCESS_KEY ) ; processPropertiesData ( properties , environment , ramRoleName , PropertyKeyConst . RAM_ROLE_NAME ) ; processPropertiesData ( properties , environment , configLongPollTimeout , PropertyKeyConst . CONFIG_LONG_POLL_TIMEOUT ) ; processPropertiesData ( properties , environment , configRetryTimeout , PropertyKeyConst . CONFIG_RETRY_TIME ) ; processPropertiesData ( properties , environment , maxRetry , PropertyKeyConst . MAX_RETRY ) ; processPropertiesData ( properties , environment , username , PropertyKeyConst . USERNAME ) ; processPropertiesData ( properties , environment , password , PropertyKeyConst . PASSWORD ) ;", "output": "properties . put ( PropertyKeyConst . ENABLE_REMOTE_SYNC_CONFIG , String . valueOf ( enableRemoteSyncConfig ) ) ; return properties ; } private static void processPropertiesData ( Properties properties , Environment environment , String keyword , String key ) { if ( StringUtils . isNotBlank ( keyword ) ) { properties . put ( key , environment . resolvePlaceholders ( keyword ) ) ; } } public static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } }"}, {"input": "package cn . org . alan . exam . model . vo . exercise ; import cn . org . alan . exam . model . entity . Option ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; import java . util . List ; @ Data public class AnswerInfoVO { private Integer id ; private String content ; private Integer repoId ; private String image ; private String repoTitle ; private Integer quType ; private String analysis ; private String answerContent ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private List < Option > options ;", "output": "}"}, {"input": "package org . springblade . config . db ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformIndex ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class TableModel implements Serializable { private String tableName ; private String isDbSynch ; private String content ; private String jformVersion ; private Integer jformType ; private String jformPkType ; private String jformPkSequence ; private Integer relationType ; private String subTableStr ; private Integer tabOrder ; private List < CgformField > columns ; private List < CgformIndex > indexes ; private String treeParentIdFieldName ; private String treeIdFieldname ; private String treeFieldname ; private DataBaseConfig dbConfig ;", "output": "}"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; @ Data @ TableName ( value = \"<STR_LIT>\" , autoResultMap = true ) public class FTSContactContent { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer docId ; @ TableField ( \"<STR_LIT>\" ) private String alias ; @ TableField ( \"<STR_LIT>\" ) private String nickname ; @ TableField ( \"<STR_LIT>\" ) private String remark ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; @ Component @ Comment ( \"<STR_LIT>\" ) public class ThreadFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void sleep ( Long sleepTime ) {", "output": "try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . common . constant . SecurityConstants ; import com . youlai . system . mapper . SysRoleMenuMapper ; import com . youlai . system . model . bo . RolePermsBO ; import com . youlai . system . model . entity . SysRoleMenu ; import com . youlai . system . service . SysRoleMenuService ; import jakarta . annotation . PostConstruct ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . stereotype . Service ; import java . util . List ; import java . util . Set ; @ Service @ RequiredArgsConstructor @ Slf4j public class SysRoleMenuServiceImpl extends ServiceImpl < SysRoleMenuMapper , SysRoleMenu > implements SysRoleMenuService { private final RedisTemplate < String , Object > redisTemplate ; @ PostConstruct public void initRolePermsCache ( ) { log . info ( \"<STR_LIT>\" ) ;", "output": "refreshRolePermsCache ( ) ; } @ Override public void refreshRolePermsCache ( ) { redisTemplate . opsForHash ( ) . delete ( SecurityConstants . ROLE_PERMS_PREFIX , \"<STR_LIT>\" ) ; List < RolePermsBO > list = this . baseMapper . getRolePermsList ( null ) ; if ( CollectionUtil . isNotEmpty ( list ) ) { list . forEach ( item -> { String roleCode = item . getRoleCode ( ) ; Set < String > perms = item . getPerms ( ) ; if ( CollectionUtil . isNotEmpty ( perms ) ) { redisTemplate . opsForHash ( ) . put ( SecurityConstants . ROLE_PERMS_PREFIX , roleCode , perms ) ; } } ) ; } } @ Override public void refreshRolePermsCache ( String roleCode ) { redisTemplate . opsForHash ( ) . delete ( SecurityConstants . ROLE_PERMS_PREFIX , roleCode ) ; List < RolePermsBO > list = this . baseMapper . getRolePermsList ( roleCode ) ; if ( CollectionUtil . isNotEmpty ( list ) ) { RolePermsBO rolePerms = list . get ( <NUM_LIT> ) ; if ( rolePerms == null ) { return ; } Set < String > perms = rolePerms . getPerms ( ) ; if ( CollectionUtil . isNotEmpty ( perms ) ) { redisTemplate . opsForHash ( ) . put ( SecurityConstants . ROLE_PERMS_PREFIX , roleCode , perms ) ; } } } @ Override public void refreshRolePermsCache ( String oldRoleCode , String newRoleCode ) { redisTemplate . opsForHash ( ) . delete ( SecurityConstants . ROLE_PERMS_PREFIX , oldRoleCode ) ; List < RolePermsBO > list = this . baseMapper . getRolePermsList ( newRoleCode ) ; if ( CollectionUtil . isNotEmpty ( list ) ) { RolePermsBO rolePerms = list . get ( <NUM_LIT> ) ; if ( rolePerms == null ) { return ; } Set < String > perms = rolePerms . getPerms ( ) ; redisTemplate . opsForHash ( ) . put ( SecurityConstants . ROLE_PERMS_PREFIX , newRoleCode , perms ) ; } } @ Override public Set < String > getRolePermsByRoleCodes ( Set < String > roles ) { return this . baseMapper . listRolePerms ( roles ) ; } @ Override public List < Long > listMenuIdsByRoleId ( Long roleId ) { return this . baseMapper . listMenuIdsByRoleId ( roleId ) ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class QuotePriceParam implements Serializable { @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) @ NotBlank private String source ; @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , required = true ) private String target ; @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" ) private String amount ; @ ApiModelProperty ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" ) private String [ ] serviceIds ;", "output": "}"}, {"input": "package com . yf . base . api . api . dto ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; public class PagingRespDTO < T > extends Page < T > { @ Override public long getPages ( ) {", "output": "if ( this . getSize ( ) == <NUM_LIT> ) { return <NUM_LIT> ; } else { long pages = this . getTotal ( ) / this . getSize ( ) ; if ( this . getTotal ( ) % this . getSize ( ) != <NUM_LIT> ) { ++ pages ; } return pages ; } } }"}, {"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelUserFieldCommentConverter extends FieldFieldCommentConverter { public SelUserFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysUser = \"<STR_LIT>\" ; String realname = \"<STR_LIT>\" ; String username = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysUser , realname , username ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } }", "output": "@ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToTxt ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } }"}, {"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . ThreadPoolExecutor ; @ Slf4j @ Configuration @ EnableAsync public class SyncPoolConfiguration { @ Bean ( name = \"<STR_LIT>\" ) public ThreadPoolTaskExecutor executor ( ) { ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor ( ) ; taskExecutor . setCorePoolSize ( <NUM_LIT> ) ; taskExecutor . setMaxPoolSize ( <NUM_LIT> ) ; taskExecutor . setQueueCapacity ( <NUM_LIT> ) ; taskExecutor . setKeepAliveSeconds ( <NUM_LIT> ) ; taskExecutor . setThreadNamePrefix ( \"<STR_LIT>\" ) ; taskExecutor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ;", "output": "taskExecutor . initialize ( ) ; return taskExecutor ; } }"}, {"input": "package com . yf ; import lombok . extern . log4j . Log4j2 ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . net . InetAddress ; import java . net . UnknownHostException ; @ Log4j2 @ SpringBootApplication @ EnableCaching public class BootApplication { public static void main ( String [ ] args ) throws UnknownHostException { ConfigurableApplicationContext application = SpringApplication . run ( BootApplication . class , args ) ;", "output": "Environment env = application . getEnvironment ( ) ; String ip = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; String port = env . getProperty ( \"<STR_LIT>\" ) ; String path = env . getProperty ( \"<STR_LIT>\" ) ; if ( path == null ) { path = \"<STR_LIT>\" ; } log . info ( \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + port + path + \"<STR_LIT>\" + \"<STR_LIT>\" + ip + \"<STR_LIT>\" + port + path + \"<STR_LIT>\" + \"<STR_LIT>\" + ip + \"<STR_LIT>\" + port + path + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } }"}, {"input": "package ginyi . framework . core . config ; import lombok . extern . slf4j . Slf4j ; import org . fusesource . jansi . Ansi ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . net . InetAddress ; import java . net . UnknownHostException ; @ Slf4j public class AppConfig { public static String colorPrint ( String s , Ansi . Color color ) { return Ansi . ansi ( ) . eraseScreen ( ) . fg ( color ) . a ( s ) . reset ( ) . toString ( ) ; } public static void printAppInfo ( ConfigurableApplicationContext context ) throws UnknownHostException { ConfigurableEnvironment env = context . getEnvironment ( ) ; String projectName = env . getProperty ( \"<STR_LIT>\" ) ; String contextPath = env . getProperty ( \"<STR_LIT>\" ) ; String port = env . getProperty ( \"<STR_LIT>\" ) ; String baseUrl = \"<STR_LIT>\" + InetAddress . getLocalHost ( ) . getHostAddress ( ) + \"<STR_LIT>\" + port + contextPath ; String swaggerDoc = baseUrl + \"<STR_LIT>\" ;", "output": "String knife4jDoc = baseUrl + \"<STR_LIT>\" ; String startSuccess = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + projectName + \"<STR_LIT>\" + \"<STR_LIT>\" + baseUrl + \"<STR_LIT>\" + \"<STR_LIT>\" + knife4jDoc + \"<STR_LIT>\" + swaggerDoc + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" , colorPrint ( startSuccess , Ansi . Color . CYAN ) ) ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . form . exam . ExamAddForm ; import cn . org . alan . exam . model . form . exam . ExamUpdateForm ; import cn . org . alan . exam . model . form . examquanswer . ExamQuAnswerAddForm ; import cn . org . alan . exam . model . vo . exam . * ; import cn . org . alan . exam . service . IExamService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . NotNull ; import jakarta . validation . constraints . Pattern ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class ExamController { @ Resource private IExamService examService ; @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > createExam ( @ Validated @ RequestBody ExamAddForm examAddForm ) { return examService . createExam ( examAddForm ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > startExam ( @ RequestParam ( \"<STR_LIT>\" ) @ NotNull Integer examId ) { return examService . startExam ( examId ) ; } @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > updateExam ( @ Validated @ RequestBody ExamUpdateForm examUpdateForm , @ PathVariable ( \"<STR_LIT>\" ) @ NotNull Integer id ) { return examService . updateExam ( examUpdateForm , id ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > deleteExam ( @ PathVariable ( \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" ) String ids ) { return examService . deleteExam ( ids ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < ExamVO > > getPagingExam ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String title ) { return examService . getPagingExam ( pageNum , pageSize , title ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < ExamQuestionListVO > getQuestionList ( @ PathVariable ( \"<STR_LIT>\" ) @ NotBlank Integer examId ) {", "output": "return examService . getQuestionList ( examId ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < ExamQuDetailVO > getQuestionSingle ( @ RequestParam ( \"<STR_LIT>\" ) Integer examId , @ RequestParam ( \"<STR_LIT>\" ) Integer questionId ) { return examService . getQuestionSingle ( examId , questionId ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < ExamQuCollectVO > > getCollect ( @ PathVariable ( \"<STR_LIT>\" ) @ NotNull Integer examId ) { return examService . getCollect ( examId ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < ExamDetailVO > getDetail ( @ RequestParam ( \"<STR_LIT>\" ) @ NotBlank Integer examId ) { return examService . getDetail ( examId ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < ExamGradeListVO > > getGradeExamList ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String title ) { return examService . getGradeExamList ( pageNum , pageSize , title ) ; } @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < Integer > addCheat ( @ PathVariable ( \"<STR_LIT>\" ) @ NotNull Integer examId ) { return examService . addCheat ( examId ) ; } @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > addAnswer ( @ Validated @ RequestBody ExamQuAnswerAddForm examQuAnswerForm ) { return examService . addAnswer ( examQuAnswerForm ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < ExamQuDetailVO > handleExam ( @ PathVariable ( \"<STR_LIT>\" ) @ NotNull Integer examId ) { return examService . handExam ( examId ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . reflect . ClassUtil ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import javax . xml . bind . * ; import javax . xml . bind . annotation . XmlAnyElement ; import javax . xml . namespace . QName ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Collection ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class XmlMapper { private static ConcurrentMap < Class , JAXBContext > jaxbContexts = new ConcurrentHashMap < Class , JAXBContext > ( ) ; public static String toXml ( Object root ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , null ) ; } public static String toXml ( Object root , String encoding ) { Class clazz = ClassUtil . unwrapCglib ( root ) ; return toXml ( root , clazz , encoding ) ; } public static String toXml ( Object root , Class clazz , String encoding ) { try { StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( root , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static String toXml ( Collection < ? > root , String rootName , Class clazz ) { return toXml ( root , rootName , clazz , null ) ; } public static String toXml ( Collection < ? > root , String rootName , Class clazz , String encoding ) { try { CollectionWrapper wrapper = new CollectionWrapper ( ) ; wrapper . collection = root ; JAXBElement < CollectionWrapper > wrapperElement = new JAXBElement < CollectionWrapper > ( new QName ( rootName ) , CollectionWrapper . class , wrapper ) ; StringWriter writer = new StringWriter ( ) ; createMarshaller ( clazz , encoding ) . marshal ( wrapperElement , writer ) ; return writer . toString ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static < T > T fromXml ( String xml , Class < T > clazz ) { try { StringReader reader = new StringReader ( xml ) ; return ( T ) createUnmarshaller ( clazz ) . unmarshal ( reader ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Marshaller createMarshaller ( Class clazz , String encoding ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; Marshaller marshaller = jaxbContext . createMarshaller ( ) ; marshaller . setProperty ( Marshaller . JAXB_FORMATTED_OUTPUT , Boolean . TRUE ) ; if ( StringUtils . isNotBlank ( encoding ) ) { marshaller . setProperty ( Marshaller . JAXB_ENCODING , encoding ) ; } return marshaller ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static Unmarshaller createUnmarshaller ( Class clazz ) { try { JAXBContext jaxbContext = getJaxbContext ( clazz ) ; return jaxbContext . createUnmarshaller ( ) ; } catch ( JAXBException e ) { throw ExceptionUtil . unchecked ( e ) ; } } protected static JAXBContext getJaxbContext ( Class clazz ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; JAXBContext jaxbContext = jaxbContexts . get ( clazz ) ; if ( jaxbContext == null ) { try { jaxbContext = JAXBContext . newInstance ( clazz , CollectionWrapper . class ) ; jaxbContexts . putIfAbsent ( clazz , jaxbContext ) ; } catch ( JAXBException ex ) { throw new RuntimeException ( \"<STR_LIT>\" + clazz + \"<STR_LIT>\" + ex . getMessage ( ) , ex ) ; } } return jaxbContext ; } public static class CollectionWrapper {", "output": "@ XmlAnyElement protected Collection < ? > collection ; } }"}, {"input": "package com . oddfar . campus . framework . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysUserRoleEntity ; import java . util . List ; import java . util . Set ; public interface SysRoleService extends IService < SysUserRoleEntity > { PageResult < SysRoleEntity > page ( SysRoleEntity sysRoleEntity ) ; List < SysRoleEntity > selectRoleList ( SysRoleEntity role ) ; Set < String > selectRolePermissionByUserId ( Long userId ) ; SysRoleEntity selectRoleById ( Long roleId ) ; List < SysRoleEntity > selectRoleAll ( ) ; List < SysRoleEntity > selectRolesByUserId ( Long userId ) ; int insertRole ( SysRoleEntity role ) ; int updateRole ( SysRoleEntity role ) ; int updateRoleStatus ( SysRoleEntity role ) ;", "output": "int deleteRoleByIds ( Long [ ] roleIds ) ; int deleteAuthUser ( SysUserRoleEntity userRole ) ; int deleteAuthUsers ( Long roleId , Long [ ] userIds ) ; boolean insertAuthUsers ( Long roleId , Long [ ] userIds ) ; int countUserRoleByRoleId ( Long roleId ) ; boolean checkRoleNameUnique ( SysRoleEntity role ) ; boolean checkRoleKeyUnique ( SysRoleEntity role ) ; void checkRoleAllowed ( SysRoleEntity role ) ; void resetRoleAuthCache ( ) ; }"}, {"input": "package me . zhengjie . utils ; import com . qiniu . storage . Region ; import java . text . SimpleDateFormat ; import java . util . Date ; public class QiNiuUtil { private static final String HUAD = \"<STR_LIT>\" ; private static final String HUAB = \"<STR_LIT>\" ; private static final String HUAN = \"<STR_LIT>\" ; private static final String BEIM = \"<STR_LIT>\" ; public static Region getRegion ( String zone ) { if ( HUAD . equals ( zone ) ) { return Region . huadong ( ) ; } else if ( HUAB . equals ( zone ) ) { return Region . huabei ( ) ; } else if ( HUAN . equals ( zone ) ) { return Region . huanan ( ) ; } else if ( BEIM . equals ( zone ) ) { return Region . beimei ( ) ;", "output": "} else { return Region . qvmHuadong ( ) ; } } public static String getKey ( String file ) { SimpleDateFormat sdf = new SimpleDateFormat ( \"<STR_LIT>\" ) ; Date date = new Date ( ) ; return FileUtil . getFileNameNoEx ( file ) + \"<STR_LIT>\" + sdf . format ( date ) + \"<STR_LIT>\" + FileUtil . getExtensionName ( file ) ; } }"}, {"input": "package org . springblade . cgform . model . generate . impl . provider ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . util . FileUtil ; import org . springblade . cgform . model . generate . util . TemplatePathUtil ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class FileProvider { protected static String defaultEncoding = \"<STR_LIT>\" ; protected List < String > msg = new ArrayList < > ( ) ; protected void generateCodeFile ( FileVo rootfileObj , String projectPath , Map < String , Object > dataMap ) throws Exception { log . debug ( \"<STR_LIT>\" + projectPath ) ; for ( int i = <NUM_LIT> ; i < rootfileObj . getTemplateRootDirs ( ) . size ( ) ; i ++ ) { File file = ( File ) rootfileObj . getTemplateRootDirs ( ) . get ( i ) ; loadTemplate ( projectPath , file , dataMap , rootfileObj ) ; } } protected void loadTemplate ( String projectPath , File firstfile , Map < String , Object > dataMap , FileVo rootfileObj ) throws Exception { if ( firstfile == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } log . info ( \"<STR_LIT>\" + firstfile . getAbsolutePath ( ) + \"<STR_LIT>\" + rootfileObj . getStylePath ( ) + \"<STR_LIT>\" + DbConfig . projectPath ) ; List < File > localList = FileUtil . fileArrSort ( firstfile ) ; log . debug ( \"<STR_LIT>\" + localList . size ( ) ) ; log . debug ( \"<STR_LIT>\" + localList . toString ( ) ) ; for ( int i = <NUM_LIT> ; i < localList . size ( ) ; i ++ ) { File localFile = ( File ) localList . get ( i ) ; templateDraw ( projectPath , firstfile , dataMap , localFile , rootfileObj ) ; } } protected void templateDraw ( String projectPath , File firstfile , Map < String , Object > dataMap , File secondFile , FileVo rootfileObj ) throws Exception { log . debug ( \"<STR_LIT>\" + firstfile . getPath ( ) ) ; log . debug ( \"<STR_LIT>\" + secondFile . getPath ( ) ) ; String templateFile = FileUtil . fileArrSort ( firstfile , secondFile ) ; try { log . debug ( \"<STR_LIT>\" + templateFile ) ; if ( ( rootfileObj . getStylePath ( ) != null ) && ( ! \"<STR_LIT>\" . equals ( rootfileObj . getStylePath ( ) ) ) && ( ! templateFile . replace ( File . separator , \"<STR_LIT>\" ) . startsWith ( rootfileObj . getStylePath ( ) ) ) ) { return ; } String outputFilepath = handleFileObj ( dataMap , templateFile , rootfileObj ) ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; String str3 ; String str4 ; if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . sourceRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } else if ( outputFilepath . startsWith ( \"<STR_LIT>\" ) ) { str3 = projectPath + File . separator + DbConfig . webRoot . replace ( \"<STR_LIT>\" , File . separator ) ; str4 = str3 ; outputFilepath = outputFilepath . substring ( \"<STR_LIT>\" . length ( ) ) ; outputFilepath = str4 + outputFilepath ; log . debug ( \"<STR_LIT>\" + outputFilepath ) ; templateDraw ( templateFile , outputFilepath , dataMap , rootfileObj ) ; } } catch ( Exception e ) { log . error ( e . toString ( ) , e ) ; } } protected void templateDraw ( String templatePath , String writePath , Map < String , Object > dataMap , FileVo FileObj ) throws Exception { if ( writePath . endsWith ( \"<STR_LIT>\" ) ) { writePath = writePath . substring ( <NUM_LIT> , writePath . length ( ) - <NUM_LIT> ) ; } Template localTemplate = templateConfig ( templatePath , FileObj ) ; localTemplate . setOutputEncoding ( defaultEncoding ) ; File localFile = FileUtil . readFile ( writePath ) ; log . info ( \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" + writePath ) ; TemplatePathUtil . templateDraw ( localTemplate , dataMap , localFile , defaultEncoding ) ; if ( ! isOneVn ( localFile ) ) { msg . add ( \"<STR_LIT>\" + writePath ) ;", "output": "} if ( isOneVn ( localFile ) ) { writeOneVn ( localFile , \"<STR_LIT>\" ) ; } } protected Template templateConfig ( String paramString , FileVo parama ) throws IOException { return TemplatePathUtil . templateConfig ( parama . getTemplateRootDirs ( ) , defaultEncoding , paramString ) . getTemplate ( paramString ) ; } protected boolean isOneVn ( File paramFile ) { if ( paramFile . getName ( ) . startsWith ( \"<STR_LIT>\" ) ) { return true ; } return false ; } protected void writeOneVn ( File writefile , String paramString ) { InputStreamReader localInputStreamReader = null ; BufferedReader localBufferedReader = null ; List < OutputStreamWriter > localArrayList = new ArrayList < > ( ) ; try { localInputStreamReader = new InputStreamReader ( new FileInputStream ( writefile ) , \"<STR_LIT>\" ) ; localBufferedReader = new BufferedReader ( localInputStreamReader ) ; int m = <NUM_LIT> ; OutputStreamWriter localOutputStreamWriter = null ; String str1 ; while ( ( str1 = localBufferedReader . readLine ( ) ) != null ) { if ( ( str1 . trim ( ) . length ( ) > <NUM_LIT> ) && ( str1 . startsWith ( paramString ) ) ) { String str2 = str1 . substring ( paramString . length ( ) ) ; String str3 = writefile . getParentFile ( ) . getAbsolutePath ( ) ; str2 = str3 + File . separator + str2 ; log . info ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) + \"<STR_LIT>\" + str2 ) ; localOutputStreamWriter = new OutputStreamWriter ( new FileOutputStream ( str2 ) , \"<STR_LIT>\" ) ; localArrayList . add ( localOutputStreamWriter ) ; msg . add ( \"<STR_LIT>\" + str2 ) ; m = <NUM_LIT> ; } else if ( m != <NUM_LIT> ) { localOutputStreamWriter . append ( str1 + \"<STR_LIT>\" ) ; } } for ( int n = <NUM_LIT> ; n < localArrayList . size ( ) ; n ++ ) { ( ( Writer ) localArrayList . get ( n ) ) . close ( ) ; } localBufferedReader . close ( ) ; localInputStreamReader . close ( ) ; log . debug ( \"<STR_LIT>\" + writefile . getAbsolutePath ( ) ) ; deleteFile ( writefile ) ; return ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( localBufferedReader != null ) { localBufferedReader . close ( ) ; } if ( localInputStreamReader != null ) { localInputStreamReader . close ( ) ; } if ( localArrayList . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < localArrayList . size ( ) ; i ++ ) { if ( localArrayList . get ( i ) != null ) { ( ( Writer ) localArrayList . get ( i ) ) . close ( ) ; } } } } catch ( IOException localIOException5 ) { localIOException5 . printStackTrace ( ) ; } } } protected static String handleFileObj ( Map < String , Object > dataMap , String templatePath , FileVo rootfileObj ) throws Exception { String str1 = templatePath ; int i = - <NUM_LIT> ; if ( ( i = templatePath . indexOf ( '<STR_LIT>' ) ) != - <NUM_LIT> ) { str1 = templatePath . substring ( <NUM_LIT> , i ) ; String localObject1 = templatePath . substring ( i + <NUM_LIT> ) ; Object localObject2 = dataMap . get ( localObject1 ) ; if ( localObject2 == null ) { System . err . println ( \"<STR_LIT>\" + ( String ) localObject1 + \"<STR_LIT>\" + templatePath + \"<STR_LIT>\" ) ; return null ; } if ( ! \"<STR_LIT>\" . equals ( String . valueOf ( localObject2 ) ) ) { log . error ( \"<STR_LIT>\" + ( String ) localObject1 + \"<STR_LIT>\" + templatePath ) ; return null ; } } Object localObject1 = TemplatePathUtil . templateConfig ( rootfileObj . getTemplateRootDirs ( ) , defaultEncoding , \"<STR_LIT>\" ) ; str1 = TemplatePathUtil . a ( str1 , dataMap , ( Configuration ) localObject1 ) ; Object localObject2 = rootfileObj . getStylePath ( ) ; if ( ( localObject2 != null ) && ( localObject2 != \"<STR_LIT>\" ) ) { str1 = str1 . substring ( ( ( String ) localObject2 ) . length ( ) + <NUM_LIT> ) ; } String str2 = str1 . substring ( str1 . lastIndexOf ( \"<STR_LIT>\" ) ) ; String str3 = str1 . substring ( <NUM_LIT> , str1 . lastIndexOf ( \"<STR_LIT>\" ) ) . replace ( \"<STR_LIT>\" , File . separator ) ; str1 = str3 + str2 ; return str1 ; } protected static boolean deleteFile ( File paramFile ) { boolean bool = false ; int i = <NUM_LIT> ; while ( ( ! bool ) && ( i ++ < <NUM_LIT> ) ) { System . gc ( ) ; bool = paramFile . delete ( ) ; } return bool ; } protected static String strSubStartEnd ( String str1 , String str2 ) { boolean flag = true ; boolean flag1 = true ; do { int index = str1 . indexOf ( str2 ) == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ; int index2 = str1 . lastIndexOf ( str2 ) + <NUM_LIT> == str1 . length ( ) ? str1 . lastIndexOf ( str2 ) : str1 . length ( ) ; str1 = str1 . substring ( index , index2 ) ; flag = str1 . indexOf ( str2 ) == <NUM_LIT> ; flag1 = str1 . lastIndexOf ( str2 ) + <NUM_LIT> == str1 . length ( ) ; } while ( flag || flag1 ) ; return str1 ; } }"}, {"input": "package org . example . dddworkspace . application . dto . command ; import lombok . Data ; import javax . validation . constraints . NotNull ; @ Data public class WorkspaceCreateCommand { @ NotNull ( message = \"<STR_LIT>\" ) private Long owner ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . modules . system . domain . Job ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . domain . vo . JobQueryCriteria ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . mapper . JobMapper ; import me . zhengjie . modules . system . service . JobService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class JobServiceImpl extends ServiceImpl < JobMapper , Job > implements JobService { private final JobMapper jobMapper ; private final RedisUtils redisUtils ; private final UserMapper userMapper ; @ Override public PageResult < Job > queryAll ( JobQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( jobMapper . findAll ( criteria , page ) ) ; } @ Override public List < Job > queryAll ( JobQueryCriteria criteria ) { return jobMapper . findAll ( criteria ) ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public Job findById ( Long id ) { return getById ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Job resources ) { Job job = jobMapper . findByName ( resources . getName ( ) ) ; if ( job != null ) { throw new EntityExistException ( Job . class , \"<STR_LIT>\" , resources . getName ( ) ) ; } save ( resources ) ; } @ Override @ CacheEvict ( key = \"<STR_LIT>\" ) @ Transactional ( rollbackFor = Exception . class ) public void update ( Job resources ) { Job job = getById ( resources . getId ( ) ) ; Job old = jobMapper . findByName ( resources . getName ( ) ) ;", "output": "if ( old != null && ! old . getId ( ) . equals ( resources . getId ( ) ) ) { throw new EntityExistException ( Job . class , \"<STR_LIT>\" , resources . getName ( ) ) ; } resources . setId ( job . getId ( ) ) ; saveOrUpdate ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; redisUtils . delByKeys ( CacheKey . JOB_ID , ids ) ; } @ Override public void download ( List < Job > jobs , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Job job : jobs ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , job . getName ( ) ) ; map . put ( \"<STR_LIT>\" , job . getEnabled ( ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , job . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public void verification ( Set < Long > ids ) { if ( userMapper . countByJobs ( ids ) > <NUM_LIT> ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . UserExamsScore ; import cn . org . alan . exam . model . vo . answer . UncorrectedUserVO ; import cn . org . alan . exam . model . vo . score . ExportScoreVO ; import cn . org . alan . exam . model . vo . score . GradeScoreVO ; import cn . org . alan . exam . model . vo . score . UserScoreVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import java . util . List ; public interface UserExamsScoreMapper extends BaseMapper < UserExamsScore > { IPage < GradeScoreVO > scoreStatistics ( IPage < GradeScoreVO > page , Integer gradeId , String examTitle , Integer userId , Integer roleId ) ; IPage < UserScoreVO > pagingScore ( IPage < UserScoreVO > page , Integer gradeId , Integer examId , String realName ) ; Integer getNumberOfApplicants ( Integer examId ) ; Integer getCorrectedPaper ( Integer examId ) ; List < ExportScoreVO > selectScores ( Integer examId , Integer gradeId ) ; IPage < UncorrectedUserVO > uncorrectedUser ( IPage < UncorrectedUserVO > page , Integer examId , String realName ) ;", "output": "}"}, {"input": "package com . yf . plugins . upload . local . utils ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . yf . base . utils . DateUtils ; import org . springframework . web . multipart . MultipartFile ; import java . io . File ; import java . util . Date ; public class OssUtils { private static final String SUFFIX_SPLIT = \"<STR_LIT>\" ; public static String renameFile ( String fileName ) { if ( ! fileName . contains ( SUFFIX_SPLIT ) ) { return fileName ; } String suffix = fileName . substring ( fileName . lastIndexOf ( \"<STR_LIT>\" ) ) ;", "output": "return IdWorker . getIdStr ( ) + suffix ; } public static String processPath ( MultipartFile file ) { String fileName = file . getOriginalFilename ( ) ; fileName = OssUtils . renameFile ( fileName ) ; String dir = DateUtils . formatDate ( new Date ( ) , \"<STR_LIT>\" ) ; return new StringBuffer ( dir ) . append ( fileName ) . toString ( ) ; } public static String processPath ( String fileName ) { fileName = OssUtils . renameFile ( fileName ) ; String dir = DateUtils . formatDate ( new Date ( ) , \"<STR_LIT>\" ) ; return new StringBuffer ( dir ) . append ( fileName ) . toString ( ) ; } public static void checkDir ( String fileName ) { int index = fileName . lastIndexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return ; } File file = new File ( fileName . substring ( <NUM_LIT> , index ) ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } } }"}, {"input": "package top . kangert . kspider . model ; import lombok . AllArgsConstructor ; import lombok . Getter ; import lombok . Setter ; @ Getter @ Setter @ AllArgsConstructor public class Plugin { private String name ; private String url ;", "output": "}"}, {"input": "package ginyi . common . utils . text ; import ginyi . common . utils . StringUtils ; public class StrFormatter { public static final String EMPTY_JSON = \"<STR_LIT>\" ; public static final char C_BACKSLASH = '<STR_LIT>' ; public static final char C_DELIM_START = '<STR_LIT>' ; public static final char C_DELIM_END = '<STR_LIT>' ; public static String format ( final String strPattern , final Object ... argArray ) { if ( StringUtils . isEmpty ( strPattern ) || StringUtils . isEmpty ( argArray ) ) { return strPattern ; } final int strPatternLength = strPattern . length ( ) ; StringBuilder sbuf = new StringBuilder ( strPatternLength + <NUM_LIT> ) ; int handledPosition = <NUM_LIT> ; int delimIndex ; for ( int argIndex = <NUM_LIT> ; argIndex < argArray . length ; argIndex ++ ) { delimIndex = strPattern . indexOf ( EMPTY_JSON , handledPosition ) ; if ( delimIndex == - <NUM_LIT> ) { if ( handledPosition == <NUM_LIT> ) { return strPattern ; } else { sbuf . append ( strPattern , handledPosition , strPatternLength ) ; return sbuf . toString ( ) ; } } else { if ( delimIndex > <NUM_LIT> && strPattern . charAt ( delimIndex - <NUM_LIT> ) == C_BACKSLASH ) { if ( delimIndex > <NUM_LIT> && strPattern . charAt ( delimIndex - <NUM_LIT> ) == C_BACKSLASH ) { sbuf . append ( strPattern , handledPosition , delimIndex - <NUM_LIT> ) ; sbuf . append ( Convert . utf8Str ( argArray [ argIndex ] ) ) ; handledPosition = delimIndex + <NUM_LIT> ; } else { argIndex -- ; sbuf . append ( strPattern , handledPosition , delimIndex - <NUM_LIT> ) ; sbuf . append ( C_DELIM_START ) ;", "output": "handledPosition = delimIndex + <NUM_LIT> ; } } else { sbuf . append ( strPattern , handledPosition , delimIndex ) ; sbuf . append ( Convert . utf8Str ( argArray [ argIndex ] ) ) ; handledPosition = delimIndex + <NUM_LIT> ; } } } sbuf . append ( strPattern , handledPosition , strPattern . length ( ) ) ; return sbuf . toString ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import org . springframework . beans . TypeConverter ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . MethodParameter ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Map ; public final class ObjectUtils { private ObjectUtils ( ) { } public static void cleanMapOrCollectionField ( final Object bean ) { ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { field . setAccessible ( true ) ; if ( field . isAnnotationPresent ( NacosIgnore . class ) ) { return ; } Class < ? > type = field . getType ( ) ; if ( Map . class . isAssignableFrom ( type ) || Collection . class . isAssignableFrom ( type ) ) { field . set ( bean , null ) ; } } } ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Field field , Object value ) { TypeConverter converter = beanFactory . getTypeConverter ( ) ; return converter . convertIfNecessary ( value , field . getType ( ) , field ) ; } public static Object convertIfNecessary ( ConfigurableListableBeanFactory beanFactory , Method method , Object value ) { Class < ? > [ ] paramTypes = method . getParameterTypes ( ) ; Object [ ] arguments = new Object [ paramTypes . length ] ;", "output": "TypeConverter converter = beanFactory . getTypeConverter ( ) ; if ( arguments . length == <NUM_LIT> ) { return converter . convertIfNecessary ( value , paramTypes [ <NUM_LIT> ] , new MethodParameter ( method , <NUM_LIT> ) ) ; } for ( int i = <NUM_LIT> ; i < arguments . length ; i ++ ) { arguments [ i ] = converter . convertIfNecessary ( value , paramTypes [ i ] , new MethodParameter ( method , i ) ) ; } return arguments ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . DesformHead ; import java . util . List ; public interface DesformHeadMapper extends BaseMapper < DesformHead > {", "output": "List < DesformHead > openList ( ) ; }"}, {"input": "package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DeployService extends IService < Deploy > {", "output": "PageResult < Deploy > queryAll ( DeployQueryCriteria criteria , Page < Object > page ) ; List < Deploy > queryAll ( DeployQueryCriteria criteria ) ; void create ( Deploy resources ) ; void update ( Deploy resources ) ; void delete ( Set < Long > ids ) ; void deploy ( String fileSavePath , Long appId ) ; String serverStatus ( Deploy resources ) ; String startServer ( Deploy resources ) ; String stopServer ( Deploy resources ) ; String serverReduction ( DeployHistory resources ) ; void download ( List < Deploy > queryAll , HttpServletResponse response ) throws IOException ; }"}, {"input": "package org . example . dddworkspace ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) {", "output": "SpringApplication app = new SpringApplication ( Application . class ) ; app . run ( args ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class ContactLabelVO { private String labelId ; private String labelName ;", "output": "}"}, {"input": "package com . yf . ability . upload . service ; import com . yf . plugins . upload . local . dto . UploadRespDTO ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; public interface UploadService { UploadRespDTO upload ( MultipartFile multipartFile ) ;", "output": "String upload ( String localFile ) ; void download ( HttpServletRequest request , HttpServletResponse response ) throws IOException ; }"}, {"input": "package com . youlai . system . converter ; import com . youlai . system . model . entity . SysMenu ; import com . youlai . system . model . form . MenuForm ; import com . youlai . system . model . vo . MenuVO ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface MenuConverter { MenuVO convertToVo ( SysMenu entity ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) MenuForm toForm ( SysMenu entity ) ; @ Mapping ( target = \"<STR_LIT>\" , ignore = true ) SysMenu toEntity ( MenuForm menuForm ) ;", "output": "}"}, {"input": "package com . yf . system . modules . depart . controller ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdReqDTO ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . base . utils . BeanMapper ; import com . yf . system . modules . depart . dto . SysDepartDTO ; import com . yf . system . modules . depart . dto . request . DepartSortReqDTO ; import com . yf . system . modules . depart . dto . response . SysDepartTreeDTO ; import com . yf . system . modules . depart . entity . SysDepart ; import com . yf . system . modules . depart . service . SysDepartService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . apache . shiro . authz . annotation . Logical ; import org . apache . shiro . authz . annotation . RequiresPermissions ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysDepartController extends BaseController { @ Autowired private SysDepartService baseService ; @ RequiresPermissions ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" } , logical = Logical . OR ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest save ( @ RequestBody SysDepartDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest edit ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ;", "output": "return super . success ( ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest < SysDepartDTO > find ( @ RequestBody BaseIdReqDTO reqDTO ) { SysDepart entity = baseService . getById ( reqDTO . getId ( ) ) ; SysDepartDTO dto = new SysDepartDTO ( ) ; BeanMapper . copy ( entity , dto ) ; return super . success ( dto ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest < List < SysDepartTreeDTO > > tree ( ) { List < SysDepartTreeDTO > dtoList = baseService . findTree ( true ) ; return super . success ( dtoList ) ; } @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest < List < SysDepartTreeDTO > > treeSelect ( ) { List < SysDepartTreeDTO > dtoList = baseService . findTree ( false ) ; return super . success ( dtoList ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } , logical = Logical . OR ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest sort ( @ RequestBody DepartSortReqDTO reqDTO ) { baseService . sort ( reqDTO ) ; return super . success ( ) ; } }"}, {"input": "package me . zhengjie . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotEmpty ; import java . util . List ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class EmailVo { @ NotEmpty private List < String > tos ; @ NotBlank private String subject ; @ NotBlank private String content ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import org . springframework . context . ApplicationEvent ; public abstract class NacosConfigEvent extends ApplicationEvent { private final String dataId ; private final String groupId ; public NacosConfigEvent ( ConfigService configService , String dataId , String groupId ) { super ( configService ) ; this . dataId = dataId ; this . groupId = groupId ; } @ Override public final ConfigService getSource ( ) { return ( ConfigService ) super . getSource ( ) ; }", "output": "public final ConfigService getConfigService ( ) { return getSource ( ) ; } public final String getDataId ( ) { return dataId ; } public final String getGroupId ( ) { return groupId ; } }"}, {"input": "package com . youlai . system . config ; import org . springframework . boot . web . servlet . FilterRegistrationBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import java . util . Collections ; @ Configuration public class CorsConfig { @ Bean public FilterRegistrationBean filterRegistrationBean ( ) { CorsConfiguration corsConfiguration = new CorsConfiguration ( ) ; corsConfiguration . setAllowedOriginPatterns ( Collections . singletonList ( \"<STR_LIT>\" ) ) ; corsConfiguration . addAllowedHeader ( CorsConfiguration . ALL ) ; corsConfiguration . addAllowedMethod ( CorsConfiguration . ALL ) ; corsConfiguration . setAllowCredentials ( true ) ; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , corsConfiguration ) ; CorsFilter corsFilter = new CorsFilter ( source ) ; FilterRegistrationBean < CorsFilter > filterRegistrationBean = new FilterRegistrationBean < > ( corsFilter ) ;", "output": "filterRegistrationBean . setOrder ( - <NUM_LIT> ) ; return filterRegistrationBean ; } }"}, {"input": "package cn . org . alan . exam . util ; import com . aliyun . oss . OSS ; import com . aliyun . oss . OSSClientBuilder ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Component ; import org . springframework . web . multipart . MultipartFile ; import java . io . IOException ; import java . io . InputStream ; import java . util . Arrays ; import java . util . UUID ; @ Component public class AliOSSUtil { @ Value ( \"<STR_LIT>\" ) private String endpoint ; @ Value ( \"<STR_LIT>\" ) private String accessKeyId ; @ Value ( \"<STR_LIT>\" ) private String accessKeySecret ; @ Value ( \"<STR_LIT>\" ) private String bucketName ; public String upload ( MultipartFile file ) throws IOException { InputStream inputStream = file . getInputStream ( ) ;", "output": "String originalFilename = file . getOriginalFilename ( ) ; assert originalFilename != null : \"<STR_LIT>\" ; String fileName = UUID . randomUUID ( ) + originalFilename . substring ( originalFilename . lastIndexOf ( \"<STR_LIT>\" ) ) ; OSS ossClient = new OSSClientBuilder ( ) . build ( endpoint , accessKeyId , accessKeySecret ) ; ossClient . putObject ( bucketName , fileName , inputStream ) ; String url = endpoint . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] + \"<STR_LIT>\" + bucketName + \"<STR_LIT>\" + endpoint . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] + \"<STR_LIT>\" + fileName ; ossClient . shutdown ( ) ; return url ; } public boolean isImage ( String filename ) { String lastName = filename . substring ( filename . lastIndexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) ; String [ ] lastnames = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; return Arrays . asList ( lastnames ) . contains ( lastName ) ; } public boolean isOverSize ( MultipartFile file ) { return file . getSize ( ) > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; } }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import java . util . Arrays ; import java . util . List ; @ Component public class ArrayFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return Object [ ] . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static int size ( Object [ ] objs ) {", "output": "return objs . length ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String join ( Object [ ] objs , String separator ) { return StrUtil . join ( separator , objs ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String join ( Object [ ] objs ) { return StrUtil . join ( \"<STR_LIT>\" , objs ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < ? > toList ( Object [ ] objs ) { return Arrays . asList ( objs ) ; } }"}, {"input": "package com . oddfar . campus . common . core . page ; import cn . hutool . core . collection . CollUtil ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . oddfar . campus . common . core . text . Convert ; import com . oddfar . campus . common . exception . ServiceException ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . sql . SqlUtil ; import lombok . Data ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; @ Data public class PageQuery implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private static final String PAGE_NUM = \"<STR_LIT>\" ; private static final String PAGE_SIZE = \"<STR_LIT>\" ; private Integer pageSize ; private Integer pageNum ; private String orderByColumn ; private String isAsc ; public static final int DEFAULT_PAGE_NUM = <NUM_LIT> ; public static final int DEFAULT_PAGE_SIZE = <NUM_LIT> ; public final static String COMMA = \"<STR_LIT>\" ; public < T > Page < T > build ( ) { Integer pageNum = ObjectUtil . defaultIfNull ( getPageNum ( ) , DEFAULT_PAGE_NUM ) ; Integer pageSize = ObjectUtil . defaultIfNull ( getPageSize ( ) , DEFAULT_PAGE_SIZE ) ; if ( pageNum <= <NUM_LIT> ) { pageNum = DEFAULT_PAGE_NUM ; } Page < T > page = new Page < > ( pageNum , pageSize ) ; List < OrderItem > orderItems = buildOrderItem ( ) ; if ( CollUtil . isNotEmpty ( orderItems ) ) { page . addOrder ( orderItems ) ; } return page ; } public < T > Page < T > buildPage ( ) { Integer pageNum = Convert . toInt ( ServletUtils . getParameter ( PAGE_NUM ) , DEFAULT_PAGE_NUM ) ; Integer pageSize = Convert . toInt ( ServletUtils . getParameter ( PAGE_SIZE ) , DEFAULT_PAGE_SIZE ) ; if ( pageNum <= <NUM_LIT> ) { pageNum = DEFAULT_PAGE_NUM ; } Page < T > page = new Page < > ( pageNum , pageSize ) ; List < OrderItem > orderItems = buildOrderItem ( ) ; if ( CollUtil . isNotEmpty ( orderItems ) ) { page . addOrder ( orderItems ) ; } return page ; } private List < OrderItem > buildOrderItem ( ) { if ( StringUtils . isBlank ( orderByColumn ) || StringUtils . isBlank ( isAsc ) ) { return null ; } String orderBy = SqlUtil . escapeOrderBySql ( orderByColumn ) ; orderBy = StringUtils . toUnderScoreCase ( orderBy ) ; isAsc = StringUtils . replaceEach ( isAsc , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } , new String [ ] {", "output": "\"<STR_LIT>\" , \"<STR_LIT>\" } ) ; String [ ] orderByArr = orderBy . split ( COMMA ) ; String [ ] isAscArr = isAsc . split ( COMMA ) ; if ( isAscArr . length != <NUM_LIT> && isAscArr . length != orderByArr . length ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } List < OrderItem > list = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < orderByArr . length ; i ++ ) { String orderByStr = orderByArr [ i ] ; String isAscStr = isAscArr . length == <NUM_LIT> ? isAscArr [ <NUM_LIT> ] : isAscArr [ i ] ; if ( \"<STR_LIT>\" . equals ( isAscStr ) ) { list . add ( OrderItem . asc ( orderByStr ) ) ; } else if ( \"<STR_LIT>\" . equals ( isAscStr ) ) { list . add ( OrderItem . desc ( orderByStr ) ) ; } else { throw new ServiceException ( \"<STR_LIT>\" ) ; } } return list ; } }"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; public class OrderItem { private String column ; private boolean asc = true ; public String getColumn ( ) { return column ; } public void setColumn ( String column ) { this . column = column ; } public boolean isAsc ( ) { return asc ; } public void setAsc ( boolean asc ) { this . asc = asc ;", "output": "} }"}, {"input": "package org . example . application . example . service ; import io . github . chensheng . dddboot . microservice . core . DDDQueryService ; import org . example . application . example . dto . result . ExampleResult ; public interface ExampleQueryService extends DDDQueryService < ExampleResult > {", "output": "}"}, {"input": "package org . example ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; @ SpringBootApplication @ MapperScan ( \"<STR_LIT>\" ) public class Application { public static void main ( String [ ] args ) {", "output": "SpringApplication app = new SpringApplication ( Application . class ) ; app . run ( args ) ; } }"}, {"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import org . springblade . core . tool . utils . Func ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; @ NoArgsConstructor public class ConverterUtil { public static final int A = <NUM_LIT> ; public static final int B = <NUM_LIT> ; public static void converter ( int id , List < Map < String , Object > > mapList , List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > fieldCommentConverters = ControlTypeUtil . getFieldCommentConverters ( onlCgformFields ) ; for ( Map < String , Object > stringObjectMap : mapList ) { Iterator < Entry < String , Object > > iterator1 = stringObjectMap . entrySet ( ) . iterator ( ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; while ( iterator1 . hasNext ( ) ) { Entry < String , Object > entry = iterator1 . next ( ) ; Object entryValue = entry . getValue ( ) ; if ( entryValue != null ) { String entryKey = ( String ) entry . getKey ( ) ; FieldCommentConverter fieldCommentConverter = ( FieldCommentConverter ) fieldCommentConverters . get ( entryKey ) ; if ( fieldCommentConverter != null ) { String entryValueStr = entryValue . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( entryValueStr ) : fieldCommentConverter . converterToVal ( entryValueStr ) ; if ( Func . isNotEmpty ( entryValueStr ) && Func . isNotEmpty ( s ) ) { converter ( fieldCommentConverter , stringObjectMap , id ) ; converter ( fieldCommentConverter , hashMap , entryValueStr ) ; stringObjectMap . put ( entryKey , s ) ; } } } } for ( Object o : hashMap . keySet ( ) ) {", "output": "String s = ( String ) o ; stringObjectMap . put ( s , hashMap . get ( s ) ) ; } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , int id ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ; if ( config != null ) { String linkField = ( String ) config . get ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isNotEmpty ( linkField ) ) { String [ ] linkFields = linkField . split ( \"<STR_LIT>\" ) ; for ( String linkField1 : linkFields ) { Object linkFieldValue1 = map . get ( linkField1 ) ; if ( linkFieldValue1 != null ) { String linkFieldStr = linkFieldValue1 . toString ( ) ; String s = id == <NUM_LIT> ? fieldCommentConverter . converterToTxt ( linkFieldStr ) : fieldCommentConverter . converterToVal ( linkFieldStr ) ; map . put ( linkField1 , s ) ; } } } } } private static void converter ( FieldCommentConverter fieldCommentConverter , Map < String , Object > map , String s ) { Map < String , String > config = fieldCommentConverter . getConfig ( ) ; if ( config != null ) { String treeText = ( String ) config . get ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isNotEmpty ( treeText ) ) { map . put ( treeText , s ) ; } } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . beans . factory . xml . BeanDefinitionParser ; import org . springframework . beans . factory . xml . ParserContext ; import org . springframework . core . env . Environment ; import org . w3c . dom . Element ; import java . util . Properties ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . registerGlobalNacosProperties ; public class GlobalNacosPropertiesBeanDefinitionParser implements BeanDefinitionParser { @ Override public BeanDefinition parse ( Element element , ParserContext parserContext ) { Properties properties = new Properties ( ) ; Environment environment = parserContext . getDelegate ( ) . getReaderContext ( ) . getReader ( ) . getEnvironment ( ) ; properties . setProperty ( PropertyKeyConst . ENDPOINT , element . getAttribute ( ENDPOINT ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , element . getAttribute ( NAMESPACE ) ) ; properties . setProperty ( PropertyKeyConst . ACCESS_KEY , element . getAttribute ( ACCESS_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SECRET_KEY , element . getAttribute ( SECRET_KEY ) ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , element . getAttribute ( SERVER_ADDR ) ) ; properties . setProperty ( PropertyKeyConst . CLUSTER_NAME , element . getAttribute ( CLUSTER_NAME ) ) ;", "output": "properties . setProperty ( PropertyKeyConst . ENCODE , element . getAttribute ( ENCODE ) ) ; properties . setProperty ( PropertyKeyConst . USERNAME , element . getAttribute ( USERNAME ) ) ; properties . setProperty ( PropertyKeyConst . PASSWORD , element . getAttribute ( PASSWORD ) ) ; BeanDefinitionRegistry registry = parserContext . getRegistry ( ) ; registerGlobalNacosProperties ( properties , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; return null ; } }"}, {"input": "package com . oddfar . campus . common . annotation ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Inherited @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface RepeatSubmit { public int interval ( ) default <NUM_LIT> ; public String message ( ) default \"<STR_LIT>\" ;", "output": "}"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . SysDictItem ; import org . springblade . cgform . model . DictModel ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface DictItemMapper extends BaseMapper < SysDictItem > {", "output": "List < DictModel > queryDictItemsByCode ( @ Param ( \"<STR_LIT>\" ) String code ) ; }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysLogLogin ; import java . util . List ; public interface ISysLogininforService { public void insertLogininfor ( SysLogLogin logininfor ) ; public List < SysLogLogin > selectLogininforList ( SysLogLogin logininfor ) ; public int deleteLogininforByIds ( Long [ ] infoIds ) ; public void cleanLogininfor ( ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . Repo ; import cn . org . alan . exam . model . vo . repo . RepoListVO ; import cn . org . alan . exam . model . vo . repo . RepoVO ; import cn . org . alan . exam . service . IRepoService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class RepoController { @ Resource private IRepoService iRepoService ; @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > addRepo ( @ Validated @ RequestBody Repo repo ) { return iRepoService . addRepo ( repo ) ; } @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > updateRepo ( @ Validated @ RequestBody Repo repo , @ PathVariable ( \"<STR_LIT>\" ) Integer id ) { return iRepoService . updateRepo ( repo , id ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > deleteRepoById ( @ PathVariable ( \"<STR_LIT>\" ) Integer id ) { return iRepoService . deleteRepoById ( id ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < RepoListVO > > getRepoList ( @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String repoTitle ) {", "output": "return iRepoService . getRepoList ( repoTitle ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < RepoVO > > pagingRepo ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String title ) { return iRepoService . pagingRepo ( pageNum , pageSize , title ) ; } }"}, {"input": "package com . oddfar . campus . common . utils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; public class Threads { private static final Logger logger = LoggerFactory . getLogger ( Threads . class ) ; public static void sleep ( long milliseconds ) { try {", "output": "Thread . sleep ( milliseconds ) ; } catch ( InterruptedException e ) { return ; } } public static void shutdownAndAwaitTermination ( ExecutorService pool ) { if ( pool != null && ! pool . isShutdown ( ) ) { pool . shutdown ( ) ; try { if ( ! pool . awaitTermination ( <NUM_LIT> , TimeUnit . SECONDS ) ) { pool . shutdownNow ( ) ; if ( ! pool . awaitTermination ( <NUM_LIT> , TimeUnit . SECONDS ) ) { logger . info ( \"<STR_LIT>\" ) ; } } } catch ( InterruptedException ie ) { pool . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } } public static void printException ( Runnable r , Throwable t ) { if ( t == null && r instanceof Future < ? > ) { try { Future < ? > future = ( Future < ? > ) r ; if ( future . isDone ( ) ) { future . get ( ) ; } } catch ( CancellationException ce ) { t = ce ; } catch ( ExecutionException ee ) { t = ee . getCause ( ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; } } if ( t != null ) { logger . error ( t . getMessage ( ) , t ) ; } } }"}, {"input": "package com . yf . base . utils . download ; import org . apache . commons . lang3 . StringUtils ; import org . apache . http . HttpEntity ; import org . apache . http . HttpResponse ; import org . apache . http . client . methods . HttpGet ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClients ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . io . FileOutputStream ; import java . io . InputStream ; public class DownloadUtil { private static Logger logger = LoggerFactory . getLogger ( \"<STR_LIT>\" ) ; public static String download ( String url , String dir , String fileName ) throws Exception { CloseableHttpClient client = HttpClients . createDefault ( ) ; File dirFile = new File ( dir ) ; if ( ! dirFile . exists ( ) ) { dirFile . mkdirs ( ) ; } if ( StringUtils . isEmpty ( fileName ) ) { fileName = extractUrlFileName ( url ) ; } try { HttpGet httpGet = new HttpGet ( url ) ; logger . info ( \"<STR_LIT>\" + httpGet . getURI ( ) ) ; HttpResponse response = client . execute ( httpGet ) ; File targetFile = new File ( dir , fileName ) ; if ( targetFile . exists ( ) ) { targetFile . delete ( ) ;", "output": "} FileOutputStream fos = new FileOutputStream ( targetFile ) ; HttpEntity entity = response . getEntity ( ) ; if ( entity != null ) { InputStream is = entity . getContent ( ) ; try { byte b [ ] = new byte [ <NUM_LIT> ] ; int j ; while ( ( j = is . read ( b ) ) != - <NUM_LIT> ) { fos . write ( b , <NUM_LIT> , j ) ; } fos . flush ( ) ; fos . close ( ) ; } catch ( Exception ex ) { throw ex ; } finally { is . close ( ) ; } if ( targetFile . exists ( ) ) { return targetFile . getCanonicalPath ( ) ; } } } catch ( Exception e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { client . close ( ) ; } return null ; } private static String extractUrlFileName ( String url ) { int index = url . lastIndexOf ( \"<STR_LIT>\" ) ; if ( index != - <NUM_LIT> ) { return url . substring ( index + <NUM_LIT> ) ; } return null ; } }"}, {"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; @ Slf4j public class SqlInjectionUtil { private final static String TABLE_DICT_SIGN_SALT = \"<STR_LIT>\" ; private final static String xssStr = \"<STR_LIT>\" ; public static void filterContent ( String value ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } public static void filterContent ( String [ ] values ) { String [ ] xssArr = xssStr . split ( \"<STR_LIT>\" ) ; for ( String value : values ) { if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } } return ; } @ Deprecated public static void specialFilterContent ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) {", "output": "return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } @ Deprecated public static void specialFilterContentForOnlineReport ( String value ) { String specialXssStr = \"<STR_LIT>\" ; String [ ] xssArr = specialXssStr . split ( \"<STR_LIT>\" ) ; if ( value == null || \"<STR_LIT>\" . equals ( value ) ) { return ; } value = value . toLowerCase ( ) ; for ( int i = <NUM_LIT> ; i < xssArr . length ; i ++ ) { if ( value . indexOf ( xssArr [ i ] ) > - <NUM_LIT> || value . startsWith ( xssArr [ i ] . trim ( ) ) ) { log . error ( \"<STR_LIT>\" , xssArr [ i ] ) ; log . error ( \"<STR_LIT>\" , value ) ; throw new RuntimeException ( \"<STR_LIT>\" + value ) ; } } return ; } }"}, {"input": "package com . youlai . system . model . bo ; import lombok . Data ; @ Data public class VisitCount { private String date ; private Integer count ;", "output": "}"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeAddParam { private String memberId ; private String exchangeType ; private String symbolName ; private String entrustId ; private String entrustType ; private String type ; private BigDecimal price ; private BigDecimal num ;", "output": "}"}, {"input": "package com . youlai . system . model . query ; import com . youlai . system . common . base . BasePageQuery ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Data @ Schema public class PermPageQuery extends BasePageQuery { @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private Long menuId ;", "output": "}"}, {"input": "package com . yf . system . modules . user . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . user . dto . SysUserRoleDTO ; import com . yf . system . modules . user . dto . request . UserRoleReqDTO ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . system . modules . user . entity . SysUserRole ; import java . util . List ; public interface SysUserRoleService extends IService < SysUserRole > { IPage < SysUserRoleDTO > paging ( PagingReqDTO < SysUserRoleDTO > reqDTO ) ; List < SysRole > listRoles ( String userId ) ; void saveRoles ( String userId , List < String > ids , boolean check ) ; void batchRole ( UserRoleReqDTO reqDTO ) ; void removeByUserIds ( List < String > ids ) ; SysUserRole findMaxRole ( String userId ) ; int countWithLevel ( List < String > userId , Integer roleLevel ) ;", "output": "int findMaxLevel ( String userId ) ; List < String > findUserPermission ( String userId ) ; List < String > listRoleIds ( String userId ) ; }"}, {"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . domain . repository . LocationRepository ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . repository . WorkspaceRepository ; import org . example . ddduser . domain . user . UserDomainService ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . domain . user . valueobject . Address ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class UserCommandServiceImpl implements UserCommandService { @ Autowired private UserDomainService userDomainService ; @ Autowired private UserRepository userRepository ; @ Autowired private LocationRepository locationRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private WorkspaceRepository workspaceRepository ; @ Override public void register ( UserRegisterCommand command ) { userDomainService . validateUsername ( command . getUsername ( ) ) ; UserEntity user = UserEntity . create ( command . getUsername ( ) , command . getPassword ( ) ) ; Long userId = userRepository . save ( user ) ; workspaceRepository . create ( userId ) ;", "output": "} @ Override public void modifyProfile ( ModifyProfileCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyProfile ( command . getNickName ( ) , command . getAvatar ( ) , command . getGender ( ) , command . getAge ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyPassword ( ModifyPasswordCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; user . modifyPassword ( command . getOldPassword ( ) , command . getNewPassword ( ) ) ; userRepository . save ( user ) ; } @ Override public void modifyAddress ( ModifyAddressCommand command ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity user = userRepository . find ( userId ) ; Address address = locationRepository . find ( command . getLongitude ( ) , command . getLatitude ( ) ) ; user . modifyAddress ( address ) ; userRepository . save ( user ) ; } }"}, {"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . cgform . mapper . DesformHeadMapper ; import org . springblade . cgform . service . IDesformHeadService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class DesformHeadServiceImpl extends BaseServiceImpl < DesformHeadMapper , DesformHead > implements IDesformHeadService { @ Autowired private DesformHeadMapper desformHeadMapper ; public List < DesformHead > openList ( ) {", "output": "return desformHeadMapper . openList ( ) ; } }"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ Data public class Appeal { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Long orderId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long initiatorId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long associateId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull private Integer type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String reason ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> ) private String description ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String proof ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String contact ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phone ;", "output": "}"}, {"input": "package org . example . ddduser . domain . user ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . ddduser . domain . user . valueobject . Address ; import org . example . ddduser . domain . user . valueobject . Gender ; import org . example . ddduser . domain . user . valueobject . UserStatus ; @ Getter @ Builder public class UserEntity { private Long id ; private String username ; private String password ; private UserStatus status ; private String nickName ; private String avatar ; private Gender gender = Gender . UNKNOWN ; private Integer age ; private Address address = Address . builder ( ) . build ( ) ; public static UserEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } UserEntity user = builder ( ) . build ( ) ; user . username = username ; user . password = password ; user . status = UserStatus . ENABLE ; return user ; } public void modifyPassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ;", "output": "} if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; } public void modifyProfile ( String nickName , String avatar , Gender gender , Integer age ) { this . nickName = nickName ; this . avatar = avatar ; this . age = age ; if ( gender != null ) { this . gender = gender ; } else { this . gender = Gender . UNKNOWN ; } } public void modifyAddress ( Address address ) { this . address = address ; } public void enable ( ) { if ( this . status == UserStatus . ENABLE ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . status = UserStatus . ENABLE ; } public void disable ( ) { if ( this . status == UserStatus . DISABLE ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . status = UserStatus . DISABLE ; } }"}, {"input": "package org . springblade . cgform . enums ; public interface CgformConstant { Integer ONLINE_TABLE_TYPE_SUB = Integer . valueOf ( <NUM_LIT> ) ; Integer ONLINE_TABLE_TYPE_ONE = Integer . valueOf ( <NUM_LIT> ) ;", "output": "Integer ONLINE_TABLE_TYPE_MAIN = Integer . valueOf ( <NUM_LIT> ) ; String ONLINE_JS_CHANGE_FUNCTION_NAME = \"<STR_LIT>\" ; }"}, {"input": "package me . zhengjie . modules . security . service . dto ; import com . alibaba . fastjson . annotation . JSONField ; import lombok . AllArgsConstructor ; import lombok . Getter ; import me . zhengjie . modules . system . domain . User ; import org . springframework . security . core . userdetails . UserDetails ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Getter @ AllArgsConstructor public class JwtUserDto implements UserDetails { private final User user ; private final List < Long > dataScopes ; private final List < AuthorityDto > authorities ; public Set < String > getRoles ( ) { return authorities . stream ( ) . map ( AuthorityDto :: getAuthority ) . collect ( Collectors . toSet ( ) ) ; } @ Override @ JSONField ( serialize = false ) public String getPassword ( ) { return user . getPassword ( ) ; } @ Override @ JSONField ( serialize = false ) public String getUsername ( ) { return user . getUsername ( ) ;", "output": "} @ JSONField ( serialize = false ) @ Override public boolean isAccountNonExpired ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isAccountNonLocked ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isCredentialsNonExpired ( ) { return true ; } @ Override @ JSONField ( serialize = false ) public boolean isEnabled ( ) { return user . getEnabled ( ) ; } }"}, {"input": "package top . kangert . kspider . logback ; import ch . qos . logback . classic . spi . ILoggingEvent ; import ch . qos . logback . core . rolling . RollingFileAppender ; import ch . qos . logback . core . rolling . TriggeringPolicy ; import ch . qos . logback . core . spi . DeferredProcessingAware ; import ch . qos . logback . core . status . ErrorStatus ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . context . SpiderContextHolder ; import top . kangert . kspider . context . SpiderJobContext ; import java . io . File ; import java . io . IOException ; import java . io . OutputStream ; public class SpiderFlowFileAppender extends RollingFileAppender < ILoggingEvent > { @ Override protected void subAppend ( ILoggingEvent event ) { TriggeringPolicy < ILoggingEvent > triggeringPolicy = this . getTriggeringPolicy ( ) ; synchronized ( triggeringPolicy ) { if ( triggeringPolicy . isTriggeringEvent ( new File ( this . getFile ( ) ) , event ) ) { this . rollover ( ) ; } } if ( this . isStarted ( ) ) { SpiderContext context = SpiderContextHolder . get ( ) ; OutputStream out = this . getOutputStream ( ) ; if ( context != null ) { if ( context instanceof SpiderJobContext ) { SpiderJobContext jobContext = ( SpiderJobContext ) context ; out = jobContext . getOutputStream ( ) ; } } try { if ( event instanceof DeferredProcessingAware ) { ( ( DeferredProcessingAware ) event ) . prepareForDeferredProcessing ( ) ;", "output": "} byte [ ] byteArray = this . encoder . encode ( event ) ; this . writeBytes ( out , byteArray ) ; } catch ( IOException e ) { this . started = false ; this . addStatus ( new ErrorStatus ( \"<STR_LIT>\" , this , e ) ) ; } } } private void writeBytes ( OutputStream out , byte [ ] byteArray ) throws IOException { if ( byteArray != null && byteArray . length != <NUM_LIT> ) { this . lock . lock ( ) ; try { out . write ( byteArray ) ; if ( this . isImmediateFlush ( ) ) { out . flush ( ) ; } } finally { this . lock . unlock ( ) ; } } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . annotation . NacosIgnore ; import com . alibaba . nacos . api . config . annotation . NacosProperty ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . enums . FileTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . MutablePropertyValues ; import org . springframework . beans . PropertyValues ; import org . springframework . beans . factory . config . BeanExpressionContext ; import org . springframework . beans . factory . config . BeanExpressionResolver ; import org . springframework . beans . factory . config . ConfigurableBeanFactory ; import org . springframework . context . expression . EnvironmentAccessor ; import org . springframework . context . expression . StandardBeanExpressionResolver ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . util . CollectionUtils ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . regex . Pattern ; import static com . alibaba . nacos . api . PropertyKeyConst . * ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public abstract class NacosUtils { public static final String DEFAULT_STRING_ATTRIBUTE_VALUE = \"<STR_LIT>\" ; public static final String DEFAULT_CONFIG_TYPE_VALUE = \"<STR_LIT>\" ; public static final boolean DEFAULT_BOOLEAN_ATTRIBUTE_VALUE = false ; public static final String SEPARATOR = \"<STR_LIT>\" ; public static final long DEFAULT_TIMEOUT = Long . getLong ( \"<STR_LIT>\" , <NUM_LIT> ) ; private static final Set < Class < ? > > NON_BEAN_CLASSES = Collections . unmodifiableSet ( new HashSet < Class < ? > > ( Arrays . asList ( Object . class , Class . class ) ) ) ; private static ExpressionParser parser = new SpelExpressionParser ( ) ; private static BeanExpressionResolver resolver = new StandardBeanExpressionResolver ( ) ; private static ConcurrentHashMap < String , Expression > expressionCache = new ConcurrentHashMap ( ) ; private static ConcurrentHashMap < Environment , StandardEvaluationContext > environmentContextCache = new ConcurrentHashMap ( ) ; private static final Logger logger = LoggerFactory . getLogger ( NacosUtils . class ) ; public static String buildDefaultPropertySourceName ( String dataId , String groupId , Map < ? , ? > properties ) { return build ( dataId , groupId , identify ( properties ) ) ; } public static String identify ( NacosProperties nacosProperties ) { return identify ( getAnnotationAttributes ( nacosProperties ) ) ; } public static String identify ( Map < ? , ? > properties ) { String namespace = ( String ) properties . get ( NAMESPACE ) ; String serverAddress = ( String ) properties . get ( SERVER_ADDR ) ; String contextPath = ( String ) properties . get ( CONTEXT_PATH ) ; String clusterName = ( String ) properties . get ( CLUSTER_NAME ) ; String endpoint = ( String ) properties . get ( ENDPOINT ) ; String accessKey = ( String ) properties . get ( ACCESS_KEY ) ; String secretKey = ( String ) properties . get ( SECRET_KEY ) ; String encode = ( String ) properties . get ( ENCODE ) ; return build ( namespace , clusterName , serverAddress , contextPath , endpoint , accessKey , secretKey , encode ) ; } private static String build ( Object ... values ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Object value : values ) { String stringValue = value == null ? null : String . valueOf ( value ) ; if ( StringUtils . hasText ( stringValue ) ) { stringBuilder . append ( stringValue ) ; } stringBuilder . append ( SEPARATOR ) ; } return stringBuilder . toString ( ) ; } public static boolean isDefault ( final NacosProperties nacosProperties ) { final List < Object > records = new LinkedList < Object > ( ) ; ReflectionUtils . doWithMethods ( nacosProperties . annotationType ( ) , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { if ( Modifier . isPublic ( method . getModifiers ( ) ) && method . getParameterTypes ( ) . length == <NUM_LIT> ) { Object defaultValue = method . getDefaultValue ( ) ; if ( defaultValue != null ) { try { Object returnValue = method . invoke ( nacosProperties ) ; if ( ! defaultValue . equals ( returnValue ) ) { records . add ( returnValue ) ; } } catch ( Exception e ) { } } } } } ) ; return records . isEmpty ( ) ; } public static String readFromEnvironment ( String label , Environment environment ) { String value = resolvePlaceholders ( label , environment ) ; return StringUtils . hasText ( value ) ? evaluate ( value , environment ) : value ; } public static Object readFromBeanFactory ( String label , ConfigurableBeanFactory beanFactory ) { if ( beanFactory == null ) { return label ; } String value = beanFactory . resolveEmbeddedValue ( label ) ; return StringUtils . hasText ( value ) ? evaluate ( value , beanFactory ) : value ; } public static String resolvePlaceholders ( String label , Environment environment ) { return environment == null ? label : environment . resolvePlaceholders ( label ) ; } public static String evaluate ( String value , Environment environment ) { Expression expression = expressionCache . get ( value ) ; if ( expression == null ) { expression = parser . parseExpression ( value , new TemplateParserContext ( ) ) ; expressionCache . put ( value , expression ) ; } StandardEvaluationContext evaluationContext = environmentContextCache . get ( environment ) ; if ( evaluationContext == null ) { evaluationContext = new StandardEvaluationContext ( environment ) ; evaluationContext . addPropertyAccessor ( new EnvironmentAccessor ( ) ) ; environmentContextCache . put ( environment , evaluationContext ) ; } return expression . getValue ( evaluationContext , String . class ) ; } public static Object evaluate ( String value , ConfigurableBeanFactory beanFactory ) { return resolver . evaluate ( value , new BeanExpressionContext ( beanFactory , null ) ) ; } public static String readFileExtension ( String dataId ) { int lastIndex = dataId . lastIndexOf ( \"<STR_LIT>\" ) ; final String extName = dataId . substring ( lastIndex + <NUM_LIT> ) ; FileTypeEnum fileTypeEnum = FileTypeEnum . getFileTypeEnumByFileExtensionOrFileType ( extName ) ; return fileTypeEnum . getFileType ( ) ; } public static PropertyValues resolvePropertyValues ( Object bean , String content , String type ) { return resolvePropertyValues ( bean , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , content , type ) ; } public static PropertyValues resolvePropertyValues ( Object bean , final String prefix , String dataId , String groupId , String content , String type ) { final Map < String , Object > configProperties = toProperties ( dataId , groupId , content , type ) ; final MutablePropertyValues propertyValues = new MutablePropertyValues ( ) ; ReflectionUtils . doWithFields ( bean . getClass ( ) , new ReflectionUtils . FieldCallback ( ) { @ Override public void doWith ( Field field ) throws IllegalArgumentException , IllegalAccessException { String propertyName = NacosUtils . resolvePropertyName ( field ) ; propertyName = StringUtils . isEmpty ( prefix ) ? propertyName : prefix + \"<STR_LIT>\" + propertyName ; if ( hasText ( propertyName ) ) { if ( Collection . class . isAssignableFrom ( field . getType ( ) ) || Map . class . isAssignableFrom ( field . getType ( ) ) ) { bindContainer ( prefix , propertyName , configProperties , propertyValues ) ; return ; } if ( containsDescendantOf ( configProperties . keySet ( ) , propertyName ) && ! isUnbindableBean ( field . getType ( ) ) ) { bindBean ( propertyName , field . getType ( ) , configProperties , propertyValues ) ; return ; } if ( configProperties . containsKey ( propertyName ) ) { String propertyValue = String . valueOf ( configProperties . get ( propertyName ) ) ; propertyValues . add ( field . getName ( ) , propertyValue ) ; } } } } ) ; return propertyValues ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver ) { return resolveProperties ( nacosProperties , propertyResolver , null ) ; } public static Properties resolveProperties ( NacosProperties nacosProperties , PropertyResolver propertyResolver , Properties defaultProperties ) { Map < String , Object > attributes = getAnnotationAttributes ( nacosProperties ) ; return resolveProperties ( attributes , propertyResolver , defaultProperties ) ; } public static Properties resolveProperties ( Map < String , Object > attributes , PropertyResolver propertyResolver , Properties defaultProperties ) { if ( CollectionUtils . isEmpty ( attributes ) ) { return defaultProperties ; } Properties resolveProperties = resolveProperties ( attributes , propertyResolver ) ; merge ( resolveProperties , defaultProperties ) ; return resolveProperties ; } public static Properties resolveProperties ( Map < ? , ? > properties , PropertyResolver propertyResolver ) { PropertiesPlaceholderResolver propertiesPlaceholderResolver = new PropertiesPlaceholderResolver ( propertyResolver ) ; return propertiesPlaceholderResolver . resolve ( properties ) ; } protected static void merge ( Properties targetProperties , Properties sourceProperties ) { if ( CollectionUtils . isEmpty ( sourceProperties ) ) { return ; } for ( Map . Entry entry : sourceProperties . entrySet ( ) ) { String propertyName = ( String ) entry . getKey ( ) ; if ( ! targetProperties . containsKey ( propertyName ) ) { String propertyValue = ( String ) entry . getValue ( ) ; targetProperties . setProperty ( propertyName , propertyValue ) ; } } } public static String getContent ( ConfigService configService , String dataId , String groupId ) { String content = null ; try { content = configService . getConfig ( dataId , groupId , DEFAULT_TIMEOUT ) ; } catch ( NacosException e ) {", "output": "if ( logger . isErrorEnabled ( ) ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } } return content ; } private static void bindBean ( String propertyName , Class < ? > target , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { Object propertyValue = configProperties . get ( propertyName ) ; if ( propertyValue != null ) { propertyValues . add ( propertyName , propertyValue ) ; } if ( isUnbindableBean ( target ) ) { return ; } Field [ ] fields = target . getDeclaredFields ( ) ; for ( Field field : fields ) { String mergePropertyName = propertyName + \"<STR_LIT>\" + NacosUtils . resolvePropertyName ( field ) ; bindBean ( mergePropertyName , field . getType ( ) , configProperties , propertyValues ) ; } } private static boolean containsDescendantOf ( Set < String > names , String propertyName ) { for ( String name : names ) { if ( name . startsWith ( propertyName + \"<STR_LIT>\" ) ) { return true ; } } return false ; } private static boolean isUnbindableBean ( Class < ? > resolved ) { if ( resolved . isPrimitive ( ) || NON_BEAN_CLASSES . contains ( resolved ) ) { return true ; } return resolved . getName ( ) . startsWith ( \"<STR_LIT>\" ) ; } private static void bindContainer ( String prefix , String fieldName , Map < String , Object > configProperties , MutablePropertyValues propertyValues ) { String regx1 = fieldName + \"<STR_LIT>\" ; String regx2 = fieldName + \"<STR_LIT>\" ; Pattern pattern1 = Pattern . compile ( regx1 ) ; Pattern pattern2 = Pattern . compile ( regx2 ) ; Set < String > enumeration = configProperties . keySet ( ) ; for ( Object item : enumeration ) { final String s = String . valueOf ( item ) ; String name = StringUtils . isEmpty ( prefix ) ? s : s . replace ( prefix + \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Object value = configProperties . get ( s ) ; if ( configProperties . containsKey ( fieldName ) ) { bindContainer ( prefix , fieldName , listToProperties ( fieldName , String . valueOf ( configProperties . get ( fieldName ) ) ) , propertyValues ) ; } else if ( pattern1 . matcher ( s ) . find ( ) ) { propertyValues . add ( name , value ) ; } else if ( pattern2 . matcher ( s ) . find ( ) ) { int index = s . indexOf ( '<STR_LIT>' ) ; if ( index != - <NUM_LIT> ) { String key = s . substring ( index + <NUM_LIT> ) ; propertyValues . add ( s . substring ( <NUM_LIT> , index ) + \"<STR_LIT>\" + key + \"<STR_LIT>\" , value ) ; } } } } private static Map < String , Object > listToProperties ( String fieldName , String content ) { String [ ] splits = content . split ( \"<STR_LIT>\" ) ; int index = <NUM_LIT> ; Map < String , Object > properties = new LinkedHashMap < String , Object > ( ) ; for ( String s : splits ) { properties . put ( fieldName + \"<STR_LIT>\" + index + \"<STR_LIT>\" , s . trim ( ) ) ; index ++ ; } return properties ; } private static String resolvePropertyName ( Field field ) { if ( getAnnotation ( field , NacosIgnore . class ) != null ) { return null ; } NacosProperty nacosProperty = getAnnotation ( field , NacosProperty . class ) ; return nacosProperty != null ? nacosProperty . value ( ) : field . getName ( ) ; } public static < T > Class < T > resolveGenericType ( Class < ? > declaredClass ) { ParameterizedType parameterizedType = ( ParameterizedType ) declaredClass . getGenericSuperclass ( ) ; Type [ ] actualTypeArguments = parameterizedType . getActualTypeArguments ( ) ; return ( Class < T > ) actualTypeArguments [ <NUM_LIT> ] ; } public static Map < String , Object > toProperties ( String text ) { return toProperties ( text , \"<STR_LIT>\" ) ; } public static Map < String , Object > toProperties ( String text , String type ) { return toProperties ( \"<STR_LIT>\" , \"<STR_LIT>\" , text , type ) ; } public static Map < String , Object > toProperties ( String dataId , String group , String text ) { return toProperties ( dataId , group , text , \"<STR_LIT>\" ) ; } public static Map < String , Object > toProperties ( String dataId , String group , String text , String type ) { type = type . toLowerCase ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( type ) ) { type = \"<STR_LIT>\" ; } return ConfigParseUtils . toProperties ( dataId , group , text , type ) ; } }"}, {"input": "package ginyi . common . utils . text ; import ginyi . common . utils . StringUtils ; import org . apache . commons . lang3 . ArrayUtils ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; public class Convert { public static String toStr ( Object value , String defaultValue ) { if ( null == value ) { return defaultValue ; } if ( value instanceof String ) { return ( String ) value ; } return value . toString ( ) ; } public static String toStr ( Object value ) { return toStr ( value , null ) ; } public static Boolean toBool ( Object value ) { return toBool ( value , null ) ; } public static Boolean toBool ( Object value , Boolean defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Boolean ) { return ( Boolean ) value ; } String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } valueStr = valueStr . trim ( ) . toLowerCase ( ) ; switch ( valueStr ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : case \"<STR_LIT>\" : case \"<STR_LIT>\" : return true ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : case \"<STR_LIT>\" : return false ; default : return defaultValue ; } } public static Integer toInt ( Object value ) { return toInt ( value , null ) ; }", "output": "public static Integer toInt ( Object value , Integer defaultValue ) { if ( value == null ) { return defaultValue ; } if ( value instanceof Integer ) { return ( Integer ) value ; } if ( value instanceof Number ) { return ( ( Number ) value ) . intValue ( ) ; } final String valueStr = toStr ( value , null ) ; if ( StringUtils . isEmpty ( valueStr ) ) { return defaultValue ; } try { return Integer . parseInt ( valueStr . trim ( ) ) ; } catch ( Exception e ) { return defaultValue ; } } public static String utf8Str ( Object obj ) { return str ( obj , CharsetKit . CHARSET_UTF_8 ) ; } public static String str ( Object obj , Charset charset ) { if ( null == obj ) { return null ; } if ( obj instanceof String ) { return ( String ) obj ; } else if ( obj instanceof byte [ ] ) { return str ( ( byte [ ] ) obj , charset ) ; } else if ( obj instanceof Byte [ ] ) { byte [ ] bytes = ArrayUtils . toPrimitive ( ( Byte [ ] ) obj ) ; return str ( bytes , charset ) ; } else if ( obj instanceof ByteBuffer ) { return str ( ( ByteBuffer ) obj , charset ) ; } return obj . toString ( ) ; } }"}, {"input": "package org . springblade . config . util . jsonschema ; import com . alibaba . fastjson . JSONObject ; import lombok . extern . slf4j . Slf4j ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public class JsonschemaUtil { public static JSONObject getJsonSchema ( JsonSchemaDescrip descrip , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , descrip . get$schema ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getType ( ) ) ; obj . put ( \"<STR_LIT>\" , descrip . getTitle ( ) ) ; List < String > requiredArr = descrip . getRequired ( ) ; obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; log . info ( \"<STR_LIT>\" + obj . toJSONString ( ) ) ;", "output": "return obj ; } public static JSONObject getSubJsonSchema ( String title , List < String > requiredArr , List < CommonProperty > propertyList ) { JSONObject obj = new JSONObject ( ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; obj . put ( \"<STR_LIT>\" , title ) ; if ( requiredArr == null ) { requiredArr = new ArrayList < String > ( ) ; } obj . put ( \"<STR_LIT>\" , requiredArr ) ; JSONObject properties = new JSONObject ( ) ; for ( CommonProperty commonProperty : propertyList ) { Map < String , Object > map = commonProperty . getPropertyJson ( ) ; properties . put ( map . get ( \"<STR_LIT>\" ) . toString ( ) , map . get ( \"<STR_LIT>\" ) ) ; } obj . put ( \"<STR_LIT>\" , properties ) ; return obj ; } }"}, {"input": "package top . kangert . kspider . controller ; import top . kangert . kspider . controller . BaseController ; import top . kangert . kspider . domain . SpiderFlow ; import top . kangert . kspider . io . Line ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . service . SpiderFlowService ; import top . kangert . kspider . support . ExecutorFactory ; import top . kangert . kspider . util . BaseResponse ; import top . kangert . kspider . util . PageInfo ; import top . kangert . kspider . vo . SpiderNodeVo ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PathVariable ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONUtil ; import java . util . Collections ; import java . util . List ; import java . util . Map ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ Slf4j public class SpiderFlowController extends BaseController { @ Autowired private SpiderFlowService spiderFlowService ; @ Autowired private ExecutorFactory executorFactory ; @ PostMapping ( value = \"<STR_LIT>\" ) public BaseResponse querySpiderFlowList ( @ RequestBody Map < String , Object > params ) { PageInfo < SpiderFlow > spiderFlowPage = spiderFlowService . queryItems ( params ) ; return successResponse ( spiderFlowPage ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) public BaseResponse querySpiderFlowJson ( @ PathVariable ( \"<STR_LIT>\" ) Long flowId ) { SpiderFlow spiderFlow = spiderFlowService . queryItem ( flowId ) ; return successResponse ( spiderFlow ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse addSpiderFlow ( @ RequestBody Map < String , Object > params ) { spiderFlowService . addItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse editSpiderFlow ( @ RequestBody Map < String , Object > params ) { spiderFlowService . editItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse deleteSpiderFlow ( @ RequestBody Map < String , Object > params ) { spiderFlowService . deleteItem ( params ) ; return successResponse ( ) ; } @ GetMapping ( \"<STR_LIT>\" ) public BaseResponse log ( Long id , Long taskId , String keywords , Long index , Integer count , Boolean reversed , Boolean matchCase , Boolean regex ) { List < Line > log = spiderFlowService . log ( id , taskId , keywords , index , count , reversed , matchCase , regex ) ; return successResponse ( log ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse shapes ( ) { List < Shape > shapes = executorFactory . shapes ( ) ; return successResponse ( shapes ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse nodeConfigItemList ( @ RequestBody Map < String , String > params ) { Long flowId = Long . parseLong ( params . get ( \"<STR_LIT>\" ) ) ; String nodeId = params . get ( \"<STR_LIT>\" ) ; String nodeName = params . get ( \"<STR_LIT>\" ) ; List < ConfigItem > configItems = Collections . emptyList ( ) ; if ( flowId != null && nodeId != null ) { configItems = executorFactory . configItemList ( nodeName ) ; if ( configItems . size ( ) <= <NUM_LIT> ) { return successResponse ( configItems ) ; } SpiderFlow spiderFlow = spiderFlowService . queryItem ( flowId ) ; if ( StrUtil . isBlank ( spiderFlow . getJson ( ) ) ) { return successResponse ( configItems ) ; }", "output": "List < SpiderNodeVo > nodeList = JSONUtil . toList ( JSONUtil . parseObj ( spiderFlow . getJson ( ) ) . get ( \"<STR_LIT>\" ) . toString ( ) , SpiderNodeVo . class ) ; for ( ConfigItem configItem : configItems ) { for ( SpiderNodeVo spiderNodeVo : nodeList ) { if ( StrUtil . equals ( nodeId , spiderNodeVo . getNodeId ( ) ) ) { List < ConfigItem > form = spiderNodeVo . getForm ( ) ; for ( ConfigItem item : form ) { if ( StrUtil . equals ( configItem . getPropName ( ) , item . getPropName ( ) ) ) { configItem . setValue ( ConfigItem . transform ( item . getValue ( ) , item . getDataType ( ) ) ) ; } } } } } } return successResponse ( configItems ) ; } }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . ExamQuestionMapper ; import cn . org . alan . exam . model . entity . ExamQuestion ; import cn . org . alan . exam . service . IExamQuestionService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class ExamQuestionServiceImpl extends ServiceImpl < ExamQuestionMapper , ExamQuestion > implements IExamQuestionService {", "output": "}"}, {"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchange { private ConcurrentHashMap < String , CoinMatchExchange > matchMap ; public CoinMatchFactoryExchange ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String symbolName , CoinMatchExchange match ) { log . info ( \"<STR_LIT>\" , symbolName ) ; if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public void reset ( String symbolName , IMjkjBaseSqlService baseSqlService ) { try { CoinMatchExchange coinMatchExchange = this . matchMap . get ( symbolName ) ; coinMatchExchange . init ( baseSqlService ) ; } catch ( Exception e ) { } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; } public CoinMatchExchange getExchangeCoinMatchAuto ( String symbolName , IMjkjBaseSqlService baseSqlService ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { CoinMatchExchange match = new CoinMatchExchange ( symbolName ) ; match . init ( baseSqlService ) ; this . matchMap . put ( symbolName , match ) ; } return this . matchMap . get ( symbolName ) ;", "output": "} public Map < String , CoinMatchExchange > getMatchMap ( ) { return this . matchMap ; } }"}, {"input": "package com . oddfar . campus . common . core . text ; import com . oddfar . campus . common . utils . StringUtils ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; public class CharsetKit { public static final String ISO_8859_1 = \"<STR_LIT>\" ; public static final String UTF_8 = \"<STR_LIT>\" ; public static final String GBK = \"<STR_LIT>\" ; public static final Charset CHARSET_ISO_8859_1 = Charset . forName ( ISO_8859_1 ) ; public static final Charset CHARSET_UTF_8 = Charset . forName ( UTF_8 ) ; public static final Charset CHARSET_GBK = Charset . forName ( GBK ) ; public static Charset charset ( String charset ) { return StringUtils . isEmpty ( charset ) ? Charset . defaultCharset ( ) : Charset . forName ( charset ) ; }", "output": "public static String convert ( String source , String srcCharset , String destCharset ) { return convert ( source , Charset . forName ( srcCharset ) , Charset . forName ( destCharset ) ) ; } public static String convert ( String source , Charset srcCharset , Charset destCharset ) { if ( null == srcCharset ) { srcCharset = StandardCharsets . ISO_8859_1 ; } if ( null == destCharset ) { destCharset = StandardCharsets . UTF_8 ; } if ( StringUtils . isEmpty ( source ) || srcCharset . equals ( destCharset ) ) { return source ; } return new String ( source . getBytes ( srcCharset ) , destCharset ) ; } public static String systemCharset ( ) { return Charset . defaultCharset ( ) . name ( ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . record ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . fasterxml . jackson . annotation . JsonFormat ; import jakarta . validation . constraints . NotNull ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class ExerciseRecordVO { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; @ NotNull ( message = \"<STR_LIT>\" ) private String title ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ;", "output": "}"}, {"input": "package com . yf . ability . shiro . jwt ; import lombok . Data ; import org . apache . shiro . authc . AuthenticationToken ; @ Data public class JwtToken implements AuthenticationToken { private static final long serialVersionUID = <NUM_LIT> ; private String token ; public JwtToken ( String token ) { this . token = token ;", "output": "} @ Override public Object getPrincipal ( ) { return token ; } @ Override public Object getCredentials ( ) { return token ; } }"}, {"input": "package me . zhengjie . modules . system . rest ; import cn . hutool . core . lang . Dict ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class RoleController { private final RoleService roleService ; private static final String ENTITY_NAME = \"<STR_LIT>\" ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Role > findRoleById ( @ PathVariable Long id ) { return new ResponseEntity < > ( roleService . findById ( id ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportRole ( HttpServletResponse response , RoleQueryCriteria criteria ) throws IOException { roleService . download ( roleService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < List < Role > > queryAllRole ( ) { return new ResponseEntity < > ( roleService . queryAll ( ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Role > > queryRole ( RoleQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( roleService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > getRoleLevel ( ) { return new ResponseEntity < > ( Dict . create ( ) . set ( \"<STR_LIT>\" , getLevels ( null ) ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createRole ( @ Validated @ RequestBody Role resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( \"<STR_LIT>\" + ENTITY_NAME + \"<STR_LIT>\" ) ; } getLevels ( resources . getLevel ( ) ) ; roleService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateRole ( @ Validated ( Role . Update . class ) @ RequestBody Role resources ) { getLevels ( resources . getLevel ( ) ) ; roleService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateRoleMenu ( @ RequestBody Role resources ) { Role role = roleService . getById ( resources . getId ( ) ) ; getLevels ( role . getLevel ( ) ) ; roleService . updateMenu ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteRole ( @ RequestBody Set < Long > ids ) { for ( Long id : ids ) { Role role = roleService . getById ( id ) ; getLevels ( role . getLevel ( ) ) ; } roleService . verification ( ids ) ; roleService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } private int getLevels ( Integer level ) { List < Integer > levels = roleService . findByUsersId ( SecurityUtils . getCurrentUserId ( ) ) . stream ( ) . map ( Role :: getLevel ) . collect ( Collectors . toList ( ) ) ;", "output": "int min = Collections . min ( levels ) ; if ( level != null ) { if ( level < min ) { throw new BadRequestException ( \"<STR_LIT>\" + min + \"<STR_LIT>\" + level ) ; } } return min ; } }"}, {"input": "package me . zhengjie . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . service . GenConfigService ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class GenConfigController { private final GenConfigService genConfigService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < GenConfig > queryGenConfig ( @ PathVariable String tableName ) { return new ResponseEntity < > ( genConfigService . find ( tableName ) , HttpStatus . OK ) ;", "output": "} @ PutMapping @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < GenConfig > updateGenConfig ( @ Validated @ RequestBody GenConfig genConfig ) { return new ResponseEntity < > ( genConfigService . update ( genConfig . getTableName ( ) , genConfig ) , HttpStatus . OK ) ; } }"}, {"input": "package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; @ Mapper public interface MenuMapper extends BaseMapper < Menu > { List < Menu > findAll ( @ Param ( \"<STR_LIT>\" ) MenuQueryCriteria criteria ) ; LinkedHashSet < Menu > findByRoleIdsAndTypeNot ( @ Param ( \"<STR_LIT>\" ) Set < Long > roleIds , @ Param ( \"<STR_LIT>\" ) Integer type ) ; List < Menu > findByPidIsNullOrderByMenuSort ( ) ; List < Menu > findByPidOrderByMenuSort ( @ Param ( \"<STR_LIT>\" ) Long pid ) ; @ Select ( \"<STR_LIT>\" ) Menu findByTitle ( @ Param ( \"<STR_LIT>\" ) String title ) ; @ Select ( \"<STR_LIT>\" ) Menu findByComponentName ( @ Param ( \"<STR_LIT>\" ) String name ) ; @ Select ( \"<STR_LIT>\" ) int countByPid ( @ Param ( \"<STR_LIT>\" ) Long pid ) ; @ Select ( \"<STR_LIT>\" ) void updateSubCntById ( @ Param ( \"<STR_LIT>\" ) int count , @ Param ( \"<STR_LIT>\" ) Long menuId ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . Objects ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Job extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long jobSort ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean enabled ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Job job = ( Job ) o ; return Objects . equals ( id , job . id ) ; }", "output": "@ Override public int hashCode ( ) { return Objects . hash ( id ) ; } }"}, {"input": "package com . yf . base . utils . file ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . zip . CRC32 ; import java . util . zip . CheckedOutputStream ; import java . util . zip . ZipEntry ; import java . util . zip . ZipOutputStream ; public class ZipUtils { private static final int BUFFER_SIZE = <NUM_LIT> ; public static void compress ( String srcFilePath , String destFilePath ) { File src = new File ( srcFilePath ) ; if ( ! src . exists ( ) ) { throw new RuntimeException ( srcFilePath + \"<STR_LIT>\" ) ; } File zipFile = new File ( destFilePath ) ; try { FileOutputStream fos = new FileOutputStream ( zipFile ) ; CheckedOutputStream cos = new CheckedOutputStream ( fos , new CRC32 ( ) ) ; ZipOutputStream zos = new ZipOutputStream ( cos ) ; String baseDir = \"<STR_LIT>\" ; compressByType ( src , zos , baseDir ) ; zos . close ( ) ; fos . close ( ) ; cos . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }", "output": "private static void compressByType ( File src , ZipOutputStream zos , String baseDir ) { if ( ! src . exists ( ) ) { return ; } System . out . println ( \"<STR_LIT>\" + baseDir + src . getName ( ) ) ; if ( src . isFile ( ) ) { compressFile ( src , zos , baseDir ) ; } else if ( src . isDirectory ( ) ) { compressDir ( src , zos , baseDir ) ; } } private static void compressFile ( File file , ZipOutputStream zos , String baseDir ) { if ( ! file . exists ( ) ) { return ; } try { BufferedInputStream bis = new BufferedInputStream ( new FileInputStream ( file ) ) ; ZipEntry entry = new ZipEntry ( baseDir + file . getName ( ) ) ; zos . putNextEntry ( entry ) ; int count ; byte [ ] buf = new byte [ BUFFER_SIZE ] ; while ( ( count = bis . read ( buf ) ) != - <NUM_LIT> ) { zos . write ( buf , <NUM_LIT> , count ) ; } bis . close ( ) ; } catch ( Exception e ) { } } private static void compressDir ( File dir , ZipOutputStream zos , String baseDir ) { if ( ! dir . exists ( ) ) { return ; } File [ ] files = dir . listFiles ( ) ; if ( files . length == <NUM_LIT> ) { try { zos . putNextEntry ( new ZipEntry ( baseDir + dir . getName ( ) + File . separator ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } for ( File file : files ) { compressByType ( file , zos , baseDir + dir . getName ( ) + File . separator ) ; } } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class FixedStillParam { private String symbolName ; private String symbol ; private BigDecimal cou ;", "output": "}"}, {"input": "package me . zhengjie . config ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . stereotype . Service ; import java . util . Arrays ; import java . util . List ; import java . util . stream . Collectors ; @ Service ( value = \"<STR_LIT>\" ) public class AuthorityConfig { public Boolean check ( String ... permissions ) { List < String > elPermissions = SecurityUtils . getCurrentUser ( ) . getAuthorities ( ) . stream ( ) . map ( GrantedAuthority :: getAuthority ) . collect ( Collectors . toList ( ) ) ; return elPermissions . contains ( \"<STR_LIT>\" ) || Arrays . stream ( permissions ) . anyMatch ( elPermissions :: contains ) ; }", "output": "}"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysNotice ; import ginyi . system . domain . model . dto . NoticeDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . NoticeVo ; public interface ISysNoticeService { public BaseVo < SysNotice > list ( NoticeDto noticeDto , Long page , Long pageSize ) ; public void add ( NoticeDto noticeDto ) ; public BaseVo < NoticeVo > getUserNoticeList ( Long page , Long pageSize ) ; public void haveRead ( Long noticeId ) ; public void remove ( Long noticeId ) ; public void updateNotice ( NoticeDto noticeDto ) ;", "output": "}"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . SqliteMaster ; import com . xcs . wx . mapper . SqliteMasterMapper ; import com . xcs . wx . repository . SqliteMasterRepository ; import org . springframework . stereotype . Repository ; @ Repository @ DS ( value = DataSourceType . MICRO_MSG_DB ) public class SqliteMasterRepositoryImpl extends ServiceImpl < SqliteMasterMapper , SqliteMaster > implements SqliteMasterRepository { @ Override public boolean isTableExists ( String tableName ) {", "output": "LambdaQueryWrapper < SqliteMaster > wrapper = Wrappers . < SqliteMaster > lambdaQuery ( ) . eq ( SqliteMaster :: getType , \"<STR_LIT>\" ) . eq ( SqliteMaster :: getTblName , tableName ) ; return super . count ( wrapper ) > <NUM_LIT> ; } }"}, {"input": "package org . springblade . web . mapper ; import java . math . BigDecimal ; public interface WalletMapper { void addWallet ( String id , BigDecimal balance ) ;", "output": "void addFrozenWallet ( String id , BigDecimal frozenBalance ) ; void subFrozenWallet ( String id , BigDecimal frozenBalance ) ; void removeFrozenWallet ( String id , BigDecimal frozenBalance ) ; void addWalletStop ( String id , BigDecimal balance ) ; void addFrozenWalletStop ( String id , BigDecimal frozenBalance ) ; void subFrozenWalletStop ( String id , BigDecimal frozenBalance ) ; void removeFrozenWalletStop ( String id , BigDecimal frozenBalance ) ; }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . vo . record . ExamRecordDetailVO ; import cn . org . alan . exam . model . vo . record . ExamRecordVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordDetailVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordVO ; import cn . org . alan . exam . service . IExerciseRecordService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class RecordController { @ Resource private IExerciseRecordService exerciseRecordService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < ExamRecordVO > > getExamRecordPage ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String examName ) { return exerciseRecordService . getExamRecordPage ( pageNum , pageSize , examName ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < ExamRecordDetailVO > > getExamRecordDetail ( @ RequestParam ( \"<STR_LIT>\" ) Integer examId ) {", "output": "return exerciseRecordService . getExamRecordDetail ( examId ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < ExerciseRecordVO > > getExerciseRecordPage ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String repoName ) { return exerciseRecordService . getExerciseRecordPage ( pageNum , pageSize , repoName ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < ExerciseRecordDetailVO > > getExerciseRecordDetail ( @ RequestParam ( \"<STR_LIT>\" ) Integer exerciseId ) { return exerciseRecordService . getExerciseRecordDetail ( exerciseId ) ; } }"}, {"input": "package com . xcs . wx . controller ; import cn . hutool . system . SystemUtil ; import com . xcs . wx . domain . dto . DecryptDTO ; import com . xcs . wx . domain . vo . DatabaseVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . service . DatabaseService ; import lombok . RequiredArgsConstructor ; import org . springframework . http . MediaType ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import org . springframework . web . servlet . mvc . method . annotation . SseEmitter ; import java . io . IOException ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class DatabaseController { private final DatabaseService databaseService ; @ GetMapping ( \"<STR_LIT>\" ) public SseEmitter decrypt ( DecryptDTO decryptDTO ) { SseEmitter emitter = new SseEmitter ( <NUM_LIT> ) ; new Thread ( ( ) -> { if ( SystemUtil . getJavaInfo ( ) . getVersionInt ( ) < <NUM_LIT> ) { try { emitter . send ( ResponseVO . error ( - <NUM_LIT> , \"<STR_LIT>\" ) , MediaType . APPLICATION_JSON ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { emitter . complete ( ) ; } return ; }", "output": "databaseService . decrypt ( emitter , decryptDTO ) ; } ) . start ( ) ; return emitter ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < DatabaseVO > > decrypt ( String wxId ) { return ResponseVO . ok ( databaseService . getDatabase ( wxId ) ) ; } }"}, {"input": "package com . yf . system . modules . user . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . user . entity . SysUserBind ; public interface SysUserBindMapper extends BaseMapper < SysUserBind > {", "output": "}"}, {"input": "package top . kangert . kspider . util ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . exception . BaseException ; import top . kangert . kspider . exception . ExceptionCodes ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . vo . SpiderNodeVo ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONObject ; import cn . hutool . json . JSONUtil ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class SpiderFlowUtils { public static SpiderNode parseJsonToSpiderNode ( String json ) { JSONObject parseObj = null ; try { parseObj = JSONUtil . parseObj ( json ) ; } catch ( Exception e ) { throw new BaseException ( ExceptionCodes . PARSE_JSON_ERROR ) ; }", "output": "Map < String , SpiderNode > nodeMap = new HashMap < > ( ) ; SpiderNode fristNode = null ; List < SpiderNodeVo > spiderNodeList = parseObj . getBeanList ( \"<STR_LIT>\" , SpiderNodeVo . class ) ; if ( spiderNodeList == null ) { throw new BaseException ( ExceptionCodes . PARSE_JSON_ERROR ) ; } for ( SpiderNodeVo spiderNodeVo : spiderNodeList ) { SpiderNode spiderNode = new SpiderNode ( ) ; spiderNode . setNodeId ( spiderNodeVo . getNodeId ( ) ) ; spiderNode . setNodeName ( spiderNodeVo . getName ( ) ) ; Map < String , Object > spiderFlowJsonProperty = new HashMap < > ( ) ; spiderFlowJsonProperty . put ( Constants . NODE_TYPE , spiderNodeVo . getName ( ) ) ; if ( spiderNodeVo . getForm ( ) . size ( ) != <NUM_LIT> ) { getSpiderFlowJsonProperty ( spiderFlowJsonProperty , spiderNodeVo . getForm ( ) ) ; } spiderNode . setJsonProperty ( spiderFlowJsonProperty ) ; nodeMap . put ( spiderNode . getNodeId ( ) , spiderNode ) ; if ( \"<STR_LIT>\" . equals ( spiderNodeVo . getName ( ) ) ) { fristNode = spiderNode ; } } List < SpiderNodeVo > connectList = parseObj . getBeanList ( \"<STR_LIT>\" , SpiderNodeVo . class ) ; if ( connectList == null ) { throw new BaseException ( ExceptionCodes . PARSE_JSON_ERROR ) ; } for ( SpiderNodeVo spiderNodeVo : connectList ) { if ( nodeMap . containsKey ( spiderNodeVo . getSourceId ( ) ) && StrUtil . isNotBlank ( spiderNodeVo . getTargetId ( ) ) ) { SpiderNode currNode = nodeMap . get ( spiderNodeVo . getSourceId ( ) ) ; SpiderNode targetNode = nodeMap . get ( spiderNodeVo . getTargetId ( ) ) ; targetNode . setCondition ( currNode . getNodeId ( ) , spiderNodeVo . getCondition ( ) ) ; targetNode . setConditionType ( currNode . getNodeId ( ) , spiderNodeVo . getExceptionFlow ( ) ) ; targetNode . setTransmitVariable ( currNode . getNodeId ( ) , spiderNodeVo . getTransmitVariable ( ) ) ; currNode . addNextNode ( targetNode ) ; } } return fristNode ; } private static void getSpiderFlowJsonProperty ( Map < String , Object > jsonProperty , List < ConfigItem > fromList ) { if ( fromList . size ( ) > <NUM_LIT> ) { fromList . stream ( ) . forEach ( from -> { Object transValue = ConfigItem . transform ( from . getValue ( ) , from . getDataType ( ) ) ; jsonProperty . put ( from . getPropName ( ) , transValue ) ; } ) ; } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . EnableNacos ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . core . env . PropertySource ; import java . lang . annotation . * ; import java . util . Map ; import static com . alibaba . nacos . api . common . Constants . DEFAULT_GROUP ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . DEFAULT_STRING_ATTRIBUTE_VALUE ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Repeatable ( NacosPropertySources . class ) public @ interface NacosPropertySource { String NAME_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String GROUP_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String DATA_ID_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AUTO_REFRESHED_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String FIRST_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String BEFORE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String AFTER_ATTRIBUTE_NAME = \"<STR_LIT>\" ;", "output": "String PROPERTIES_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String CONFIG_TYPE_ATTRIBUTE_NAME = \"<STR_LIT>\" ; String name ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String groupId ( ) default DEFAULT_GROUP ; String dataId ( ) ; boolean autoRefreshed ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; boolean first ( ) default DEFAULT_BOOLEAN_ATTRIBUTE_VALUE ; String before ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; String after ( ) default DEFAULT_STRING_ATTRIBUTE_VALUE ; ConfigType type ( ) default ConfigType . UNSET ; NacosProperties properties ( ) default @ NacosProperties ; }"}, {"input": "package org . example . application . example . dto . query ; import io . github . chensheng . dddboot . microservice . core . * ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class ExampleListQuery extends ListQuery { @ QuerySortable private String username ; @ QueryCondition ( column = \"<STR_LIT>\" , operator = ConditionOperator . like ) private String usernameLike ; @ QuerySortable ( order = OrderType . DESC ) private ExampleStatus status ; @ Override protected Long getMaxLimit ( ) { return <NUM_LIT> ;", "output": "} }"}, {"input": "package me . zhengjie . utils ; import java . io . PrintWriter ; import java . io . StringWriter ; public class ThrowableUtil { public static String getStackTrace ( Throwable throwable ) { StringWriter sw = new StringWriter ( ) ; try ( PrintWriter pw = new PrintWriter ( sw ) ) { throwable . printStackTrace ( pw ) ; return sw . toString ( ) ;", "output": "} } }"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . config . properties . CampusConfig ; import com . oddfar . campus . common . utils . StringUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController public class SysIndexController { @ Autowired private CampusConfig campusConfig ; @ RequestMapping ( \"<STR_LIT>\" ) public String index ( ) { return StringUtils . format ( \"<STR_LIT>\" , campusConfig . getName ( ) , campusConfig . getVersion ( ) ) ; }", "output": "}"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . domain . EmailConfig ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface EmailConfigMapper extends BaseMapper < EmailConfig > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . openfeign . annotation ; import io . github . chensheng . dddboot . openfeign . core . FeignClientRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . TYPE ) @ Documented @ Import ( FeignClientRegistrar . class ) public @ interface EnableFeignClients {", "output": "}"}, {"input": "package top . kangert . kspider . listener ; import top . kangert . kspider . context . SpiderContext ; public interface SpiderListener { void beforeStart ( SpiderContext context ) ;", "output": "void afterEnd ( SpiderContext context ) ; }"}, {"input": "package com . youlai . system . common . model ; import com . fasterxml . jackson . annotation . JsonInclude ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data @ NoArgsConstructor public class KeyValue { public KeyValue ( String key , String value ) { this . key = key ;", "output": "this . value = value ; } @ Schema ( description = \"<STR_LIT>\" ) private String key ; @ Schema ( description = \"<STR_LIT>\" ) private String value ; }"}, {"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Oss extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer category ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ossCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String secretKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucketName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String appId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String region ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;", "output": "}"}, {"input": "package com . yf . ability . captcha . service ; public interface CaptchaService { void saveCaptcha ( String key , String value ) ;", "output": "boolean checkCaptcha ( String key , String input ) ; }"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class UserRegReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String password ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String realName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String deptCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String captchaKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String captchaValue ;", "output": "}"}, {"input": "package cn . org . alan . exam . config ; import javax . sql . DataSource ; import java . sql . SQLException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Properties ; public class ShardingsphereConfig {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . xml . NamespaceHandler ; import org . springframework . beans . factory . xml . NamespaceHandlerSupport ; public class NacosNamespaceHandler extends NamespaceHandlerSupport { @ Override public void init ( ) { registerBeanDefinitionParser ( \"<STR_LIT>\" , new NacosAnnotationDrivenBeanDefinitionParser ( ) ) ; registerBeanDefinitionParser ( \"<STR_LIT>\" , new GlobalNacosPropertiesBeanDefinitionParser ( ) ) ; registerBeanDefinitionParser ( \"<STR_LIT>\" , new NacosPropertySourceBeanDefinitionParser ( ) ) ; }", "output": "}"}, {"input": "package ginyi . system . domain . model . vo ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . beans . factory . annotation . Value ; @ Data @ ApiModel ( \"<STR_LIT>\" ) public class LoginVo { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String token ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String tokenHeader ;", "output": "}"}, {"input": "package top . kangert . kspider . context ; import com . alibaba . ttl . TransmittableThreadLocal ; public class SpiderContextHolder { private static final ThreadLocal < SpiderContext > THREAD_LOCAL = new TransmittableThreadLocal < > ( ) ; public static SpiderContext get ( ) { return THREAD_LOCAL . get ( ) ; } public static void set ( SpiderContext context ) { THREAD_LOCAL . set ( context ) ; } public static void remove ( ) { THREAD_LOCAL . remove ( ) ; }", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . GradeExerciseMapper ; import cn . org . alan . exam . model . entity . GradeExercise ; import cn . org . alan . exam . service . IGradeExerciseService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class GradeExerciseServiceImpl extends ServiceImpl < GradeExerciseMapper , GradeExercise > implements IGradeExerciseService {", "output": "}"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . dto . DecryptDTO ; import com . xcs . wx . domain . vo . DatabaseVO ; import org . springframework . web . servlet . mvc . method . annotation . SseEmitter ; import java . util . List ; public interface DatabaseService { void decrypt ( SseEmitter emitter , DecryptDTO decryptDTO ) ;", "output": "List < DatabaseVO > getDatabase ( String wxId ) ; }"}, {"input": "package ginyi . system . domain . model . dto ; import io . swagger . annotations . ApiModel ; import lombok . Data ; @ Data @ ApiModel ( \"<STR_LIT>\" ) public class RegisterDto extends LoginDto {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface QuerySortable { OrderType order ( ) default OrderType . NONE ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . springframework . stereotype . Component ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Component public class MapFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return Map . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > toList ( Map < ? , ? > map , String separator ) { return map . entrySet ( ) . stream ( ) . map ( entry -> entry . getKey ( ) + separator + entry . getValue ( ) ) . collect ( Collectors . toList ( ) ) ;", "output": "} }"}, {"input": "package org . springblade . cgform . controller ; import cn . hutool . http . HttpUtil ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import lombok . extern . slf4j . Slf4j ; import org . apache . poi . ss . usermodel . Workbook ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . cgform . service . ICgformHeadService ; import org . springblade . config . exception . DBException ; import org . springblade . config . util . BrowserUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . jdbc . support . incrementer . OracleSequenceMaxValueIncrementer ; import org . springframework . jdbc . support . incrementer . PostgresSequenceMaxValueIncrementer ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import javax . sql . DataSource ; import java . io . IOException ; import java . io . OutputStream ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . sql . SQLException ; import java . util . * ; @ Slf4j public class BaseController extends BladeController { @ Autowired private ICgformHeadService cgformHeadService ; @ Autowired private ICgformFieldService cgformFieldService ; public void isOpenServer ( ) { } public Map < String , Object > paramStr2Map ( HttpServletRequest request ) { String paramsStr = request . getParameter ( \"<STR_LIT>\" ) ; Map < String , Object > hashMap = new HashMap < > ( ) ; String paramStr = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( paramsStr ) ) { try { paramStr = URLDecoder . decode ( paramsStr , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( e . getMessage ( ) , e ) ; } if ( paramStr != null ) { hashMap = JSONObject . parseObject ( paramStr , Map . class ) ; } } return hashMap ; } protected void outpuFile ( String fileUrl , String name , HttpServletRequest request , HttpServletResponse response ) { OutputStream out = null ; try { byte [ ] buffer = HttpUtil . downloadBytes ( fileUrl ) ; response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String suffix = fileUrl . substring ( fileUrl . lastIndexOf ( \"<STR_LIT>\" ) ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename ) ; } out = response . getOutputStream ( ) ; out . write ( buffer ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected void outpuExcel ( CgformHead onlCgformHead , Workbook workbook , HttpServletRequest request , HttpServletResponse response ) { ServletOutputStream servletOutputStream = null ; try { response . setContentType ( \"<STR_LIT>\" ) ; String browse = BrowserUtils . checkBrowse ( request ) ; String name = onlCgformHead . getTableTxt ( ) + \"<STR_LIT>\" + onlCgformHead . getTableVersion ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( browse . substring ( <NUM_LIT> , <NUM_LIT> ) ) ) { response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + URLEncoder . encode ( name , \"<STR_LIT>\" ) + \"<STR_LIT>\" ) ; } else { String filename = new String ( name . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + filename + \"<STR_LIT>\" ) ; } servletOutputStream = response . getOutputStream ( ) ; workbook . write ( servletOutputStream ) ; response . flushBuffer ( ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" + e . getMessage ( ) , e ) ; } finally { if ( servletOutputStream != null ) { try { servletOutputStream . close ( ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } } protected Object getIdByType ( CgformHead head , DataSource dataSource , String databaseType ) throws SQLException , DBException { Object result = null ; String id = head . getIdType ( ) ; String idSequence = head . getIdSequence ( ) ; if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { return SqlSymbolUtil . getIdWorkerId ( ) ; } if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { return Func . toStr ( IdWorker . getId ( ) ) ; } if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { if ( ConvertUtils . isNotEmpty ( databaseType ) && \"<STR_LIT>\" . equalsIgnoreCase ( databaseType ) ) { OracleSequenceMaxValueIncrementer oracleSequence = new OracleSequenceMaxValueIncrementer ( dataSource , \"<STR_LIT>\" ) ; try { result = oracleSequence . nextLongValue ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( ConvertUtils . isNotEmpty ( databaseType ) && \"<STR_LIT>\" . equalsIgnoreCase ( databaseType ) ) { PostgresSequenceMaxValueIncrementer postgresSequence = new PostgresSequenceMaxValueIncrementer ( dataSource , \"<STR_LIT>\" ) ; try { result = postgresSequence . nextLongValue ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } else { result = null ; } } else if ( ConvertUtils . isNotEmpty ( id ) && \"<STR_LIT>\" . equalsIgnoreCase ( id ) ) { if ( ConvertUtils . isNotEmpty ( databaseType ) && \"<STR_LIT>\" . equalsIgnoreCase ( databaseType ) ) { OracleSequenceMaxValueIncrementer oracleSequence = new OracleSequenceMaxValueIncrementer ( dataSource , idSequence ) ; try { result = oracleSequence . nextLongValue ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( ConvertUtils . isNotEmpty ( databaseType ) && \"<STR_LIT>\" . equalsIgnoreCase ( databaseType ) ) { PostgresSequenceMaxValueIncrementer postgresSequence = new PostgresSequenceMaxValueIncrementer ( dataSource , idSequence ) ; try { result = postgresSequence . nextLongValue ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } else { result = null ; }", "output": "} else { result = SqlSymbolUtil . getIdWorkerId ( ) ; } return result ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . common . group . UserGroup ; import cn . org . alan . exam . model . form . UserForm ; import cn . org . alan . exam . model . vo . UserVO ; import cn . org . alan . exam . service . IUserService ; import cn . org . alan . exam . util . AliOSSUtil ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import java . util . Objects ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Resource private IUserService iUserService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < UserVO > info ( ) { return iUserService . info ( ) ; } @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > createUser ( @ Validated ( UserGroup . CreateUserGroup . class ) @ RequestBody UserForm userForm ) { return iUserService . createUser ( userForm ) ; } @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > updatePassword ( @ Validated ( UserGroup . UpdatePasswordGroup . class ) @ RequestBody UserForm userForm ) { return iUserService . updatePassword ( userForm ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > deleteBatchByIds ( @ PathVariable ( \"<STR_LIT>\" ) String ids ) { return iUserService . deleteBatchByIds ( ids ) ; } @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > importUsers ( @ RequestParam ( \"<STR_LIT>\" ) MultipartFile file ) {", "output": "return iUserService . importUsers ( file ) ; } @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > joinGrade ( @ RequestParam ( \"<STR_LIT>\" ) String code ) { return iUserService . joinGrade ( code ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < UserVO > > pagingUser ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Integer gradeId , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String realName ) { return iUserService . pagingUser ( pageNum , pageSize , gradeId , realName ) ; } @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > uploadAvatar ( @ RequestPart ( \"<STR_LIT>\" ) MultipartFile file ) { return iUserService . uploadAvatar ( file ) ; } }"}, {"input": "package org . example . infrastructure . repository . example . database ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . example . infrastructure . repository . example . database . dataobject . ExampleDetail ; public interface ExampleDetailMapper extends BaseMapper < ExampleDetail > {", "output": "}"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class ExamGrade implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer examId ; private Integer gradeId ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getExamId ( ) { return examId ; } public void setExamId ( Integer examId ) { this . examId = examId ; } public Integer getGradeId ( ) { return gradeId ; } public void setGradeId ( Integer gradeId ) { this . gradeId = gradeId ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + gradeId + \"<STR_LIT>\" ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . config ; import com . alibaba . fastjson2 . JSON ; import com . alibaba . fastjson2 . JSONReader ; import com . alibaba . fastjson2 . JSONWriter ; import org . springframework . data . redis . serializer . RedisSerializer ; import org . springframework . data . redis . serializer . SerializationException ; import java . nio . charset . Charset ; public class FastJson2JsonRedisSerializer < T > implements RedisSerializer < T > { public static final Charset DEFAULT_CHARSET = Charset . forName ( \"<STR_LIT>\" ) ; private Class < T > clazz ; public FastJson2JsonRedisSerializer ( Class < T > clazz ) { super ( ) ; this . clazz = clazz ; } @ Override public byte [ ] serialize ( T t ) throws SerializationException { if ( t == null ) { return new byte [ <NUM_LIT> ] ; } return JSON . toJSONString ( t , JSONWriter . Feature . WriteClassName ) . getBytes ( DEFAULT_CHARSET ) ; }", "output": "@ Override public T deserialize ( byte [ ] bytes ) throws SerializationException { if ( bytes == null || bytes . length <= <NUM_LIT> ) { return null ; } String str = new String ( bytes , DEFAULT_CHARSET ) ; return JSON . parseObject ( str , clazz , JSONReader . Feature . SupportAutoType ) ; } }"}, {"input": "package me . zhengjie . config ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . data . domain . AuditorAware ; import org . springframework . stereotype . Component ; import java . util . Optional ; @ Component ( \"<STR_LIT>\" ) public class AuditorConfig implements AuditorAware < String > { @ Override public Optional < String > getCurrentAuditor ( ) { try { return Optional . of ( SecurityUtils . getCurrentUsername ( ) ) ; } catch ( Exception ignored ) {", "output": "} return Optional . of ( \"<STR_LIT>\" ) ; } }"}, {"input": "package ginyi . server . admin . controller ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import ginyi . common . annotation . Log ; import ginyi . common . enums . BusinessType ; import ginyi . common . result . CommonResult ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . DeptDto ; import ginyi . system . domain . model . dto . PostDto ; import ginyi . system . domain . model . dto . RoleDto ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . UserVo ; import ginyi . system . service . ISysUserService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . extern . slf4j . Slf4j ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; import java . util . HashMap ; import java . util . Set ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ Slf4j @ RequestMapping ( \"<STR_LIT>\" ) public class SysUserController { @ Resource private ISysUserService userService ; @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . DELETE ) public CommonResult delete ( @ PathVariable ( \"<STR_LIT>\" ) Long userId ) { userService . removeById ( userId ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < UserVo > getUserByUserId ( @ PathVariable ( \"<STR_LIT>\" ) String userId ) { UserVo user = userService . getUserByUserId ( userId ) ; return CommonResult . success ( user ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . DELETE ) public CommonResult delete ( @ RequestBody Set < Long > ids ) { userService . removeUserByIds ( ids ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . UPDATE ) @ ApiOperationSupport ( includeParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public CommonResult updateStatus ( @ RequestBody UserDto userDto ) { userService . updateStatus ( userDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . INSERT ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult add ( @ RequestBody @ Validated ( AddGroup . class ) UserDto userDto ) { userService . addUser ( userDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . UPDATE ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult update ( @ RequestBody @ Validated ( UpdateGroup . class ) UserDto userDto ) { userService . updateUser ( userDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult < BaseVo < UserVo > > list ( @ RequestBody UserDto userDto , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long page , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long pageSize ) { BaseVo < UserVo > baseVo = userService . list ( userDto , page , pageSize ) ; return CommonResult . success ( baseVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult < BaseVo < HashMap < String , Object > > > getUserListByDeptIds ( @ RequestBody DeptDto deptDto ) { BaseVo < HashMap < String , Object > > userList = userService . getUserListByDeptIds ( deptDto ) ; return CommonResult . success ( userList ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult < BaseVo < HashMap < String , Object > > > getUserListByPostIds ( @ RequestBody PostDto postDto ) { BaseVo < HashMap < String , Object > > userList = userService . getUserListByPostIds ( postDto ) ; return CommonResult . success ( userList ) ;", "output": "} @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult < BaseVo < HashMap < String , Object > > > getUserListByPostIds ( @ RequestBody RoleDto roleDto ) { BaseVo < HashMap < String , Object > > userList = userService . getUserListByRoleIds ( roleDto ) ; return CommonResult . success ( userList ) ; } }"}, {"input": "package com . youlai . system . model . vo ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . youlai . system . enums . LogModuleEnum ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . io . Serializable ; import java . time . LocalDateTime ; @ Data @ Schema ( description = \"<STR_LIT>\" ) public class LogPageVO implements Serializable { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private LogModuleEnum module ; @ Schema ( description = \"<STR_LIT>\" ) private String content ; @ Schema ( description = \"<STR_LIT>\" ) private String requestUri ; @ Schema ( description = \"<STR_LIT>\" ) private String method ; @ Schema ( description = \"<STR_LIT>\" ) private String ip ; @ Schema ( description = \"<STR_LIT>\" ) private String region ; @ Schema ( description = \"<STR_LIT>\" ) private String browser ; @ Schema ( description = \"<STR_LIT>\" ) private String os ; @ Schema ( description = \"<STR_LIT>\" ) private Long executionTime ; @ Schema ( description = \"<STR_LIT>\" ) private Long createBy ; @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; @ Schema ( description = \"<STR_LIT>\" ) private String operator ;", "output": "}"}, {"input": "package org . springblade . config . util ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BrowserUtils { public static boolean isIE ( HttpServletRequest request ) { return ( request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> || request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) ? true : false ; } public static Double getIEversion ( HttpServletRequest request ) { Double version = <NUM_LIT> ; if ( getBrowserType ( request , IE11 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE10 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE9 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE8 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE7 ) ) { version = <NUM_LIT> ; } else if ( getBrowserType ( request , IE6 ) ) { version = <NUM_LIT> ; } return version ; } public static BrowserType getBrowserType ( HttpServletRequest request ) { BrowserType browserType = null ; if ( getBrowserType ( request , IE11 ) ) { browserType = BrowserType . IE11 ; } if ( getBrowserType ( request , IE10 ) ) { browserType = BrowserType . IE10 ; } if ( getBrowserType ( request , IE9 ) ) { browserType = BrowserType . IE9 ; } if ( getBrowserType ( request , IE8 ) ) { browserType = BrowserType . IE8 ; } if ( getBrowserType ( request , IE7 ) ) { browserType = BrowserType . IE7 ; } if ( getBrowserType ( request , IE6 ) ) { browserType = BrowserType . IE6 ; } if ( getBrowserType ( request , FIREFOX ) ) { browserType = BrowserType . Firefox ; } if ( getBrowserType ( request , SAFARI ) ) { browserType = BrowserType . Safari ; } if ( getBrowserType ( request , CHROME ) ) { browserType = BrowserType . Chrome ; } if ( getBrowserType ( request , OPERA ) ) { browserType = BrowserType . Opera ; } if ( getBrowserType ( request , \"<STR_LIT>\" ) ) { browserType = BrowserType . Camino ; } return browserType ; } private static boolean getBrowserType ( HttpServletRequest request , String brosertype ) { return request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) . indexOf ( brosertype ) > <NUM_LIT> ? true : false ; } private final static String IE11 = \"<STR_LIT>\" ; private final static String IE10 = \"<STR_LIT>\" ; private final static String IE9 = \"<STR_LIT>\" ; private final static String IE8 = \"<STR_LIT>\" ; private final static String IE7 = \"<STR_LIT>\" ; private final static String IE6 = \"<STR_LIT>\" ; private final static String MAXTHON = \"<STR_LIT>\" ; private final static String QQ = \"<STR_LIT>\" ; private final static String GREEN = \"<STR_LIT>\" ; private final static String SE360 = \"<STR_LIT>\" ; private final static String FIREFOX = \"<STR_LIT>\" ; private final static String OPERA = \"<STR_LIT>\" ; private final static String CHROME = \"<STR_LIT>\" ; private final static String SAFARI = \"<STR_LIT>\" ; private final static String OTHER = \"<STR_LIT>\" ; public static String checkBrowse ( HttpServletRequest request ) { String userAgent = request . getHeader ( \"<STR_LIT>\" ) ; if ( regex ( OPERA , userAgent ) ) { return OPERA ; } if ( regex ( CHROME , userAgent ) ) { return CHROME ; } if ( regex ( FIREFOX , userAgent ) ) { return FIREFOX ;", "output": "} if ( regex ( SAFARI , userAgent ) ) { return SAFARI ; } if ( regex ( SE360 , userAgent ) ) { return SE360 ; } if ( regex ( GREEN , userAgent ) ) { return GREEN ; } if ( regex ( QQ , userAgent ) ) { return QQ ; } if ( regex ( MAXTHON , userAgent ) ) { return MAXTHON ; } if ( regex ( IE11 , userAgent ) ) { return IE11 ; } if ( regex ( IE10 , userAgent ) ) { return IE10 ; } if ( regex ( IE9 , userAgent ) ) { return IE9 ; } if ( regex ( IE8 , userAgent ) ) { return IE8 ; } if ( regex ( IE7 , userAgent ) ) { return IE7 ; } if ( regex ( IE6 , userAgent ) ) { return IE6 ; } return OTHER ; } public static boolean regex ( String regex , String str ) { Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( str ) ; return m . find ( ) ; } private static Map < String , String > langMap = new HashMap < String , String > ( ) ; private final static String ZH = \"<STR_LIT>\" ; private final static String ZH_CN = \"<STR_LIT>\" ; private final static String EN = \"<STR_LIT>\" ; private final static String EN_US = \"<STR_LIT>\" ; static { langMap . put ( ZH , ZH_CN ) ; langMap . put ( EN , EN_US ) ; } public static String getBrowserLanguage ( HttpServletRequest request ) { String browserLang = request . getLocale ( ) . getLanguage ( ) ; String browserLangCode = ( String ) langMap . get ( browserLang ) ; if ( browserLangCode == null ) { browserLangCode = EN_US ; } return browserLangCode ; } public static boolean isDesktop ( HttpServletRequest request ) { return ! isMobile ( request ) ; } public static boolean isMobile ( HttpServletRequest request ) { String ua = request . getHeader ( \"<STR_LIT>\" ) . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( \"<STR_LIT>\" ) ; return pattern . matcher ( ua ) . find ( ) ; } }"}, {"input": "package org . springblade . config . util ; import io . jsonwebtoken . Claims ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tool . support . Kv ; import org . springblade . core . tool . utils . * ; import javax . servlet . http . HttpServletRequest ; import java . util . Map ; import java . util . Objects ; public class MyAuthUtil { private static final String BLADE_USER_REQUEST_ATTR = \"<STR_LIT>\" ; private static final String HEADER = \"<STR_LIT>\" ; private static final String ACCOUNT = \"<STR_LIT>\" ; private static final String USER_NAME = \"<STR_LIT>\" ; private static final String NICK_NAME = \"<STR_LIT>\" ; private static final String USER_ID = \"<STR_LIT>\" ; private static final String DEPT_ID = \"<STR_LIT>\" ; private static final String POST_ID = \"<STR_LIT>\" ; private static final String ROLE_ID = \"<STR_LIT>\" ; private static final String ROLE_NAME = \"<STR_LIT>\" ; private static final String TENANT_ID = \"<STR_LIT>\" ; private static final String OAUTH_ID = \"<STR_LIT>\" ; private static final String CLIENT_ID = \"<STR_LIT>\" ; private static final String DETAIL = \"<STR_LIT>\" ; private static JwtProperties jwtProperties ; public MyAuthUtil ( ) { } private static JwtProperties getJwtProperties ( ) { if ( jwtProperties == null ) { jwtProperties = ( JwtProperties ) SpringUtil . getBean ( JwtProperties . class ) ; } return jwtProperties ; } public static BladeUser getUser ( ) { HttpServletRequest request = WebUtil . getRequest ( ) ; if ( request == null ) { return null ; } else { Object bladeUser = request . getAttribute ( \"<STR_LIT>\" ) ; if ( bladeUser == null ) { bladeUser = getUser ( request ) ; if ( bladeUser != null ) { request . setAttribute ( \"<STR_LIT>\" , bladeUser ) ; } } return ( BladeUser ) bladeUser ; } } public static BladeUser getUser ( HttpServletRequest request ) { Claims claims = getClaims ( request ) ; if ( claims == null ) { return null ; } else { String clientId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Long userId = Func . toLong ( claims . get ( \"<STR_LIT>\" ) ) ; String tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String oauthId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String deptId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String postId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String roleId = Func . toStrWithEmpty ( claims . get ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; String account = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String roleName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String nickName = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; Kv detail = Kv . create ( ) . setAll ( ( Map ) claims . get ( \"<STR_LIT>\" ) ) ; BladeUser bladeUser = new BladeUser ( ) ; bladeUser . setClientId ( clientId ) ; bladeUser . setUserId ( userId ) ; bladeUser . setTenantId ( tenantId ) ; bladeUser . setOauthId ( oauthId ) ; bladeUser . setAccount ( account ) ; bladeUser . setDeptId ( deptId ) ; bladeUser . setPostId ( postId ) ; bladeUser . setRoleId ( roleId ) ; bladeUser . setRoleName ( roleName ) ; bladeUser . setUserName ( userName ) ; bladeUser . setNickName ( nickName ) ; bladeUser . setDetail ( detail ) ; return bladeUser ; } } public static boolean isAdministrator ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static boolean isAdmin ( ) { return StringUtil . containsAny ( getUserRole ( ) , new CharSequence [ ] { \"<STR_LIT>\" } ) ; } public static Long getUserId ( ) { BladeUser user = getUser ( ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static Long getUserId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? - <NUM_LIT> : user . getUserId ( ) ; } public static String getUserAccount ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserAccount ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getAccount ( ) ; } public static String getUserName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getUserName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getUserName ( ) ; } public static String getNickName ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getNickName ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getNickName ( ) ; } public static String getDeptId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getDeptId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getDeptId ( ) ; } public static String getPostId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getPostId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getPostId ( ) ; } public static String getUserRole ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getUserRole ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getRoleName ( ) ; } public static String getTenantId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getTenantId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getTenantId ( ) ; } public static String getOauthId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ; } public static String getOauthId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getOauthId ( ) ;", "output": "} public static String getClientId ( ) { BladeUser user = getUser ( ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static String getClientId ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? \"<STR_LIT>\" : user . getClientId ( ) ; } public static Kv getDetail ( ) { BladeUser user = getUser ( ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Kv getDetail ( HttpServletRequest request ) { BladeUser user = getUser ( request ) ; return null == user ? Kv . create ( ) : user . getDetail ( ) ; } public static Claims getClaims ( HttpServletRequest request ) { String auth = request . getParameter ( \"<STR_LIT>\" ) ; Claims claims = null ; String token ; String tenantId ; if ( StringUtil . isNotBlank ( auth ) ) { token = JwtUtil . getToken ( auth ) ; } else { tenantId = request . getParameter ( \"<STR_LIT>\" ) ; token = JwtUtil . getToken ( tenantId ) ; } if ( StringUtil . isNotBlank ( token ) ) { claims = parseJWT ( token ) ; } if ( ObjectUtil . isNotEmpty ( claims ) && getJwtProperties ( ) . getState ( ) ) { tenantId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String userId = Func . toStr ( claims . get ( \"<STR_LIT>\" ) ) ; String accessToken = JwtUtil . getAccessToken ( tenantId , userId , token ) ; if ( ! token . equalsIgnoreCase ( accessToken ) ) { return null ; } } return claims ; } public static String getHeader ( ) { return getHeader ( ( HttpServletRequest ) Objects . requireNonNull ( WebUtil . getRequest ( ) ) ) ; } public static String getHeader ( HttpServletRequest request ) { return request . getHeader ( \"<STR_LIT>\" ) ; } public static Claims parseJWT ( String jsonWebToken ) { return JwtUtil . parseJWT ( jsonWebToken ) ; } }"}, {"input": "package com . yf . base . utils ; import java . text . SimpleDateFormat ; import java . util . Calendar ; import java . util . Date ; import java . util . GregorianCalendar ; public class DateUtils { public static int calcExpDays ( Date userCreateTime ) { Calendar start = Calendar . getInstance ( ) ; start . setTime ( userCreateTime ) ; Calendar now = Calendar . getInstance ( ) ; now . setTime ( new Date ( ) ) ; long l = now . getTimeInMillis ( ) - start . getTimeInMillis ( ) ; int days = new Long ( l / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) ) . intValue ( ) ; return days ; } public static String dateNow ( String format ) {", "output": "SimpleDateFormat fmt = new SimpleDateFormat ( format ) ; Calendar c = new GregorianCalendar ( ) ; return fmt . format ( c . getTime ( ) ) ; } public static String formatDate ( Date time , String format ) { SimpleDateFormat fmt = new SimpleDateFormat ( format ) ; return fmt . format ( time . getTime ( ) ) ; } public static Date parseDate ( String date ) { return parseDate ( date , \"<STR_LIT>\" ) ; } public static Date parseDate ( String date , String pattern ) { if ( pattern == null ) { pattern = \"<STR_LIT>\" ; } SimpleDateFormat fmt = new SimpleDateFormat ( pattern ) ; try { return fmt . parse ( date ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ; } public static Date endTimeOfDay ( ) { Calendar cl = Calendar . getInstance ( ) ; cl . setTimeInMillis ( System . currentTimeMillis ( ) ) ; cl . set ( Calendar . HOUR_OF_DAY , <NUM_LIT> ) ; cl . set ( Calendar . MINUTE , <NUM_LIT> ) ; cl . set ( Calendar . SECOND , <NUM_LIT> ) ; System . out . println ( DateUtils . formatDate ( cl . getTime ( ) , \"<STR_LIT>\" ) ) ; return cl . getTime ( ) ; } }"}, {"input": "package com . youlai . system . model . dto ; import com . alibaba . excel . annotation . ExcelProperty ; import lombok . Data ; @ Data public class UserImportDTO { @ ExcelProperty ( value = \"<STR_LIT>\" ) private String username ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String nickname ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String genderLabel ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String mobile ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String email ; @ ExcelProperty ( \"<STR_LIT>\" ) private String roleCodes ; @ ExcelProperty ( \"<STR_LIT>\" ) private String deptCode ;", "output": "}"}, {"input": "package me . zhengjie . modules . quartz . domain ; import com . baomidou . mybatisplus . annotation . * ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . sql . Timestamp ; @ Data @ TableName ( \"<STR_LIT>\" ) public class QuartzLog implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String jobName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String beanName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String methodName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String params ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String cronExpression ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Boolean isSuccess ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String exceptionDetail ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long time ; @ TableField ( fill = FieldFill . INSERT ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Timestamp createTime ;", "output": "}"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MongoDetail { private String symbol ; private BigDecimal close ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal zdf ; private BigDecimal tradeTurnover ; private String contractSize ; private String base_coin_scale ; private String coin_scale ; private String bzicon ; private String icon ; private Long updateTime ; private Integer type ; private Integer executeFlag ; private String contractSelfPriceId ;", "output": "}"}, {"input": "package top . kangert . kspider . job ; import top . kangert . kspider . KspiderRuntime ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . domain . SpiderTask ; import lombok . extern . slf4j . Slf4j ; import org . quartz . CronScheduleBuilder ; import org . quartz . CronTrigger ; import org . quartz . JobBuilder ; import org . quartz . JobDetail ; import org . quartz . JobKey ; import org . quartz . Scheduler ; import org . quartz . SchedulerException ; import org . quartz . TriggerBuilder ; import org . quartz . TriggerKey ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import java . util . Date ; @ Component @ Slf4j public class SpiderJobManager { private KspiderRuntime spider ; private SpiderJob spiderJob ; @ Resource private Scheduler quartzScheduler ; @ Autowired public void setSpider ( KspiderRuntime spider ) {", "output": "this . spider = spider ; } @ Autowired public void setSpiderJob ( SpiderJob spiderJob ) { this . spiderJob = spiderJob ; } public Date addJob ( SpiderTask task ) { try { JobDetail job = JobBuilder . newJob ( SpiderJob . class ) . withIdentity ( getJobKey ( task . getFlowId ( ) ) ) . build ( ) ; job . getJobDataMap ( ) . put ( Constants . QUARTZ_KSPIDER_FLOW_PARAM_NAME , task ) ; CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder . cronSchedule ( task . getCron ( ) ) . withMisfireHandlingInstructionDoNothing ( ) ; CronTrigger trigger = TriggerBuilder . newTrigger ( ) . withIdentity ( getTriggerKey ( task . getFlowId ( ) ) ) . withSchedule ( cronScheduleBuilder ) . build ( ) ; return quartzScheduler . scheduleJob ( job , trigger ) ; } catch ( SchedulerException e ) { log . error ( \"<STR_LIT>\" , e ) ; return null ; } } public void run ( Long taskId ) { spider . getThreadPool ( ) . submit ( ( ) -> spiderJob . run ( taskId ) ) ; } public boolean removeJob ( Long flowId ) { try { quartzScheduler . deleteJob ( getJobKey ( flowId ) ) ; return true ; } catch ( SchedulerException e ) { log . error ( \"<STR_LIT>\" , e ) ; return false ; } } private JobKey getJobKey ( Long flowId ) { return JobKey . jobKey ( Constants . QUARTZ_JOB_NAME_PREFIX + flowId ) ; } private TriggerKey getTriggerKey ( Long flowId ) { return TriggerKey . triggerKey ( Constants . QUARTZ_JOB_NAME_PREFIX + flowId ) ; } }"}, {"input": "package org . example . dddworkspace . application . dto . result ; import lombok . Data ; @ Data public class WorkspaceResult { private String name ; private Long owner ;", "output": "}"}, {"input": "package com . yf . base . utils ; import com . yf . base . api . api . ApiError ; import com . yf . base . api . api . ApiRest ; import com . yf . base . utils . jackson . JsonHelper ; import lombok . extern . log4j . Log4j2 ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; @ Log4j2 public class InjectUtils { public static void setValue ( Object object , Object value , String ... fields ) throws Exception { for ( String fieldName : fields ) { Field field = getField ( object . getClass ( ) , fieldName ) ; if ( field == null ) { continue ; } field . setAccessible ( true ) ; field . set ( object , value ) ; } }", "output": "public static Field getField ( Class < ? > clazz , String name ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( name . equals ( field . getName ( ) ) ) { return field ; } } Class < ? > superclass = clazz . getSuperclass ( ) ; if ( null == superclass ) { return null ; } return getField ( superclass , name ) ; } public static void restError ( HttpServletResponse response ) { try { ApiRest apiRest = new ApiRest ( ApiError . ERROR_10010002 ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . getWriter ( ) . write ( JsonHelper . toJson ( apiRest ) ) ; response . getWriter ( ) . close ( ) ; } catch ( IOException e ) { } } public static void extractFields ( Class clazz , List < Field > allFields ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { allFields . add ( field ) ; } if ( clazz . getSuperclass ( ) != null ) { extractFields ( clazz . getSuperclass ( ) , allFields ) ; } } public static List < Field > extractAllFields ( Class clazz ) { List < Field > fields = new ArrayList < > ( ) ; extractFields ( clazz , fields ) ; return fields ; } }"}, {"input": "package top . kangert . kspider . util ; import org . springframework . security . core . context . SecurityContextHolder ; import top . kangert . kspider . entity . User ; import top . kangert . kspider . exception . BaseException ; import top . kangert . kspider . exception . ExceptionCodes ; public class MySecurityContextHolder { public static User getCurrentUser ( ) { User user ; try {", "output": "user = ( User ) SecurityContextHolder . getContext ( ) . getAuthentication ( ) . getPrincipal ( ) ; } catch ( Exception e ) { throw new BaseException ( ExceptionCodes . ERROR , \"<STR_LIT>\" ) ; } return user ; } }"}, {"input": "package ginyi . server . admin . controller ; import ginyi . common . annotation . Log ; import ginyi . common . enums . BusinessType ; import ginyi . common . result . CommonResult ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . SessionUserVo ; import ginyi . system . service . ISysOnlineService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; import java . util . Set ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysOnlineController { @ Resource private ISysOnlineService onlineService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public CommonResult < BaseVo < SessionUserVo > > getOnlineUserList ( @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long page , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long pageSize ) { BaseVo < SessionUserVo > list = onlineService . getOnlineUserList ( page , pageSize ) ;", "output": "return CommonResult . success ( list ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . CLEAN ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult removeUser ( @ PathVariable ( \"<STR_LIT>\" ) String sessionId ) { onlineService . removeUser ( sessionId ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . CLEAN ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult removeUser ( @ RequestBody Set < String > ids ) { onlineService . removeUser ( ids ) ; return CommonResult . success ( ) ; } }"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KlineMessageModel { Kline kline ; String contractType ; String symbolName ; @ Data public static class Kline { private BigDecimal openPrice = BigDecimal . ZERO ;", "output": "private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ; private BigDecimal volume = BigDecimal . ZERO ; private BigDecimal turnover = BigDecimal . ZERO ; private Integer type ; } }"}, {"input": "package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface DeployHistoryMapper extends BaseMapper < DeployHistory > { IPage < DeployHistory > findAll ( @ Param ( \"<STR_LIT>\" ) DeployHistoryQueryCriteria criteria , Page < Object > page ) ; List < DeployHistory > findAll ( @ Param ( \"<STR_LIT>\" ) DeployHistoryQueryCriteria criteria ) ;", "output": "}"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . youlai . system . model . entity . SysRole ; import org . apache . ibatis . annotations . Mapper ; import java . util . Set ; @ Mapper public interface SysRoleMapper extends BaseMapper < SysRole > { Integer getMaximumDataScope ( Set < String > roles ) ;", "output": "}"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . constant . CacheConstants ; import ginyi . common . exception . UserPasswordNotMatchException ; import ginyi . common . exception . UserPasswordRetryLimitExceedException ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . framework . security . context . AuthenticationContextHolder ; import ginyi . framework . security . utils . SecurityUtils ; import ginyi . system . domain . SysUser ; import ginyi . system . service . ISysPasswordService ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . security . core . Authentication ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . concurrent . TimeUnit ; @ Service public class SysPasswordServiceImpl implements ISysPasswordService { @ Resource private RedisCache redisCache ; @ Value ( value = \"<STR_LIT>\" ) private int maxRetryCount ; @ Value ( value = \"<STR_LIT>\" ) private int lockTime ; public void validate ( SysUser user ) { Authentication usernamePasswordAuthenticationToken = AuthenticationContextHolder . getContext ( ) ; String username = usernamePasswordAuthenticationToken . getName ( ) ; String password = usernamePasswordAuthenticationToken . getCredentials ( ) . toString ( ) ; Integer retryCount = redisCache . getCacheObject ( getCacheKey ( username ) , Integer . class ) ; if ( retryCount == null ) { retryCount = <NUM_LIT> ; } if ( retryCount >= maxRetryCount ) { StringBuilder errorMessage = new StringBuilder ( ) ; errorMessage . append ( \"<STR_LIT>\" ) . append ( maxRetryCount ) . append ( \"<STR_LIT>\" ) . append ( lockTime ) . append ( \"<STR_LIT>\" ) ; throw new UserPasswordRetryLimitExceedException ( StateCode . ERROR_UNAUTHENTICATION , errorMessage ) ; } if ( ! matches ( user , password ) ) { retryCount = retryCount + <NUM_LIT> ; redisCache . setCacheObject ( getCacheKey ( username ) , retryCount , lockTime , TimeUnit . MINUTES ) ; throw new UserPasswordNotMatchException ( ) ; } else { clearLoginRecordCache ( username ) ; }", "output": "} public boolean matches ( SysUser user , String rawPassword ) { return SecurityUtils . matchesPassword ( rawPassword , user . getPassword ( ) ) ; } private String getCacheKey ( String username ) { return CacheConstants . PWD_ERR_CNT_KEY + username ; } public void clearLoginRecordCache ( String loginName ) { if ( redisCache . hasKey ( getCacheKey ( loginName ) ) ) { redisCache . removeCacheObject ( getCacheKey ( loginName ) ) ; } } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class ChatRoomInfoVO { private String announcement ; private Integer infoVersion ; private String announcementEditor ; private String announcementPublisher ; private Long announcementPublishTime ; private String strAnnouncementPublishTime ; private Integer chatRoomStatus ;", "output": "}"}, {"input": "package com . youlai . system . config ; import org . springframework . boot . autoconfigure . cache . CacheProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . cache . annotation . EnableCaching ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . cache . RedisCacheConfiguration ; import org . springframework . data . redis . cache . RedisCacheManager ; import org . springframework . data . redis . cache . RedisCacheWriter ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . serializer . RedisSerializationContext ; import org . springframework . data . redis . serializer . RedisSerializer ; @ EnableCaching @ EnableConfigurationProperties ( CacheProperties . class ) @ Configuration @ ConditionalOnProperty ( name = \"<STR_LIT>\" ) public class RedisCacheConfig { @ Bean public RedisCacheManager redisCacheManager ( RedisConnectionFactory redisConnectionFactory , CacheProperties cacheProperties ) { return RedisCacheManager . builder ( RedisCacheWriter . nonLockingRedisCacheWriter ( redisConnectionFactory ) ) . cacheDefaults ( redisCacheConfiguration ( cacheProperties ) ) . build ( ) ; } @ Bean RedisCacheConfiguration redisCacheConfiguration ( CacheProperties cacheProperties ) { RedisCacheConfiguration config = RedisCacheConfiguration . defaultCacheConfig ( ) ; config = config . serializeKeysWith ( RedisSerializationContext . SerializationPair . fromSerializer ( RedisSerializer . string ( ) ) ) ; config = config . serializeValuesWith ( RedisSerializationContext . SerializationPair . fromSerializer ( RedisSerializer . json ( ) ) ) ; CacheProperties . Redis redisProperties = cacheProperties . getRedis ( ) ;", "output": "if ( redisProperties . getTimeToLive ( ) != null ) { config = config . entryTtl ( redisProperties . getTimeToLive ( ) ) ; } if ( ! redisProperties . isCacheNullValues ( ) ) { config = config . disableCachingNullValues ( ) ; } if ( ! redisProperties . isUseKeyPrefix ( ) ) { config = config . disableKeyPrefix ( ) ; } config = config . computePrefixWith ( name -> name + \"<STR_LIT>\" ) ; return config ; } }"}, {"input": "package me . zhengjie . base ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import org . apache . commons . lang3 . builder . ToStringBuilder ; import org . springframework . data . annotation . CreatedBy ; import org . springframework . data . annotation . LastModifiedBy ; import java . io . Serializable ; import java . lang . reflect . Field ; import java . sql . Timestamp ; @ Getter @ Setter public class BaseEntity implements Serializable { @ CreatedBy @ TableField ( fill = FieldFill . INSERT ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String createBy ; @ LastModifiedBy @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String updateBy ; @ TableField ( fill = FieldFill . INSERT ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Timestamp createTime ; @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Timestamp updateTime ; public @ interface Create { } public @ interface Update { } @ Override public String toString ( ) {", "output": "ToStringBuilder builder = new ToStringBuilder ( this ) ; Field [ ] fields = this . getClass ( ) . getDeclaredFields ( ) ; try { for ( Field f : fields ) { f . setAccessible ( true ) ; builder . append ( f . getName ( ) , f . get ( this ) ) . append ( \"<STR_LIT>\" ) ; } } catch ( Exception e ) { builder . append ( \"<STR_LIT>\" ) ; } return builder . toString ( ) ; } }"}, {"input": "package org . springblade . common . aspect ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springblade . core . log . event . ApiLogEvent ; import org . springblade . core . log . model . LogApi ; import org . springblade . core . log . utils . LogAbstractUtil ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ Aspect @ Component public class MjkjAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint point ) throws Throwable {", "output": "try { HttpServletRequest request = WebUtil . getRequest ( ) ; String requestURI = request . getRequestURI ( ) ; List < String > list = new ArrayList < > ( ) ; list . add ( \"<STR_LIT>\" ) ; list . add ( \"<STR_LIT>\" ) ; for ( String url : list ) { if ( requestURI . startsWith ( url ) ) { return point . proceed ( ) ; } } String className = point . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = point . getSignature ( ) . getName ( ) ; long beginTime = System . currentTimeMillis ( ) ; Object result = point . proceed ( ) ; long time = System . currentTimeMillis ( ) - beginTime ; this . publishEvent ( methodName , className , \"<STR_LIT>\" , time ) ; return result ; } catch ( Exception e ) { } return point . proceed ( ) ; } public static void publishEvent ( String methodName , String methodClass , String title , long time ) { HttpServletRequest request = WebUtil . getRequest ( ) ; LogApi logApi = new LogApi ( ) ; logApi . setType ( \"<STR_LIT>\" ) ; logApi . setTitle ( title ) ; logApi . setTime ( String . valueOf ( time ) ) ; logApi . setMethodClass ( methodClass ) ; logApi . setMethodName ( methodName ) ; LogAbstractUtil . addRequestInfoToLog ( request , logApi ) ; Map < String , Object > event = new HashMap ( <NUM_LIT> ) ; event . put ( \"<STR_LIT>\" , logApi ) ; SpringUtil . publishEvent ( new ApiLogEvent ( event ) ) ; } }"}, {"input": "package com . oddfar . campus . framework . listener ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import com . oddfar . campus . framework . api . resource . ResourceCollectorApi ; import com . oddfar . campus . framework . service . SysResourceService ; import com . oddfar . campus . framework . service . SysRoleService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . boot . context . event . ApplicationReadyEvent ; import org . springframework . context . ApplicationListener ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component public class ReadyEventListener implements ApplicationListener < ApplicationReadyEvent > { @ Autowired private SysResourceService resourceService ; @ Autowired private SysRoleService roleService ; @ Override public void onApplicationEvent ( ApplicationReadyEvent event ) { ConfigurableApplicationContext applicationContext = event . getApplicationContext ( ) ; resourceService . truncateResource ( ) ; ResourceCollectorApi resourceCollectorApi = applicationContext . getBean ( ResourceCollectorApi . class ) ; List < SysResourceEntity > allResources = resourceCollectorApi . getAllResources ( ) ; resourceService . saveBatch ( allResources ) ; roleService . resetRoleAuthCache ( ) ;", "output": "} }"}, {"input": "package com . oddfar . campus . common . enums ; public enum BizCodeEnum { UNKNOWN_EXCEPTION ( <NUM_LIT> , \"<STR_LIT>\" ) , VALID_EXCEPTION ( <NUM_LIT> , \"<STR_LIT>\" ) ; private Integer code ; private String msg ; private BizCodeEnum ( Integer code , String msg ) { this . code = code ; this . msg = msg ; } public Integer getCode ( ) {", "output": "return code ; } public String getMsg ( ) { return msg ; } }"}, {"input": "package top . kangert . kspider . concurrent ; import java . util . concurrent . CompletableFuture ; import java . util . concurrent . Future ; import java . util . concurrent . FutureTask ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import top . kangert . kspider . constant . Constants ; public class SpiderThreadPoolExecutor { private int maxThreads ; private final long keepAliveTime = <NUM_LIT> ; private final ThreadPoolExecutor threadPoolExecutor ; private final AtomicInteger threadNumber = new AtomicInteger ( <NUM_LIT> ) ; private final String KSPIDER_THREAD_NAME_PREFIX = Constants . KSPIDER_THREAD_NAME_PREFIX ; private static final ThreadGroup KSPIDER_THREAD_GROUP = new ThreadGroup ( Constants . KSPIDER_THREAD_GROUP_NAME ) ; public SpiderThreadPoolExecutor ( int maxThreads ) { this . maxThreads = maxThreads ; this . threadPoolExecutor = new ThreadPoolExecutor ( maxThreads , maxThreads , keepAliveTime , TimeUnit . MILLISECONDS , new LinkedBlockingQueue < > ( ) , r -> new Thread ( KSPIDER_THREAD_GROUP , r , KSPIDER_THREAD_NAME_PREFIX + threadNumber . getAndIncrement ( ) ) ) ; } public Future < ? > submit ( Runnable runnable ) { return threadPoolExecutor . submit ( runnable ) ; } public SubThreadPoolExecutor createSubThreadPoolExecutor ( int threads ) { return new SubThreadPoolExecutor ( Math . min ( this . maxThreads , threads ) ) ; } public class SubThreadPoolExecutor { private int threads ; private Future < ? > [ ] tasks ; private final long waitTaskTimeout = <NUM_LIT> ; private volatile boolean running = true ; private volatile boolean submitting = false ; private AtomicInteger executingTaskNumber = new AtomicInteger ( <NUM_LIT> ) ; private LinkedBlockingQueue < FutureTask < ? > > candidateTaskQueue ; public SubThreadPoolExecutor ( int threads ) { this . threads = threads ; this . tasks = new Future [ threads ] ; this . candidateTaskQueue = new LinkedBlockingQueue < > ( ) ; } private int index ( ) { for ( int i = <NUM_LIT> ; i < threads ; i ++ ) { if ( tasks [ i ] == null || tasks [ i ] . isDone ( ) ) { return i ; } } return - <NUM_LIT> ; } private void removeDoneFuture ( ) { for ( int i = <NUM_LIT> ; i < threads ; i ++ ) { try { if ( tasks [ i ] != null && tasks [ i ] . get ( waitTaskTimeout , TimeUnit . MILLISECONDS ) == null ) { tasks [ i ] = null ; } } catch ( Throwable ignored ) { } } } private void await ( ) { while ( index ( ) == - <NUM_LIT> ) { removeDoneFuture ( ) ; } } public void awaitTermination ( ) { while ( executingTaskNumber . get ( ) > <NUM_LIT> ) { removeDoneFuture ( ) ; } running = false ; synchronized ( candidateTaskQueue ) { candidateTaskQueue . notifyAll ( ) ; } } public < T > Future < T > submitAsync ( Runnable runnable , T value ) { FutureTask < T > futureTask = new FutureTask < > ( ( ) -> { try { executingTaskNumber . incrementAndGet ( ) ; runnable . run ( ) ; } finally { executingTaskNumber . decrementAndGet ( ) ; } } , value ) ; candidateTaskQueue . add ( futureTask ) ; if ( ! submitting ) {", "output": "submitting = true ; CompletableFuture . runAsync ( this :: submit ) ; } synchronized ( candidateTaskQueue ) { candidateTaskQueue . notifyAll ( ) ; } return futureTask ; } private void submit ( ) { while ( running ) { synchronized ( candidateTaskQueue ) { try { if ( candidateTaskQueue . isEmpty ( ) ) { candidateTaskQueue . wait ( ) ; } while ( ! candidateTaskQueue . isEmpty ( ) ) { FutureTask < ? > futureTask = candidateTaskQueue . remove ( ) ; await ( ) ; tasks [ index ( ) ] = threadPoolExecutor . submit ( futureTask ) ; } } catch ( InterruptedException ignored ) { } } } } } }"}, {"input": "package com . youlai . system . controller ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . common . model . Option ; import com . youlai . system . common . result . PageResult ; import com . youlai . system . common . result . Result ; import com . youlai . system . enums . LogModuleEnum ; import com . youlai . system . model . query . DictPageQuery ; import com . youlai . system . model . vo . DictPageVO ; import com . youlai . system . plugin . norepeat . annotation . PreventRepeatSubmit ; import com . youlai . system . model . form . DictForm ; import com . youlai . system . plugin . syslog . annotation . LogAnnotation ; import com . youlai . system . service . SysDictService ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import io . swagger . v3 . oas . annotations . Operation ; import lombok . RequiredArgsConstructor ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import java . util . List ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class SysDictController { private final SysDictService dictService ; @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ LogAnnotation ( value = \"<STR_LIT>\" , module = LogModuleEnum . DICT ) public PageResult < DictPageVO > getDictPage ( DictPageQuery queryParams ) { Page < DictPageVO > result = dictService . getDictPage ( queryParams ) ; return PageResult . success ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < Option > > getDictOptions ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable String code ) { List < Option > options = dictService . listDictItemsByCode ( code ) ; return Result . success ( options ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < DictForm > getDictForm ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable Long id ) { DictForm formData = dictService . getDictForm ( id ) ; return Result . success ( formData ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) @ PreventRepeatSubmit public Result saveDict ( @ RequestBody DictForm formData ) { boolean result = dictService . saveDict ( formData ) ; return Result . judge ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result updateDict ( @ PathVariable Long id , @ RequestBody DictForm DictForm ) { boolean status = dictService . updateDict ( id , DictForm ) ; return Result . judge ( status ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result deleteDictionaries ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable String ids ) { dictService . deleteDictByIds ( ids ) ; return Result . success ( ) ;", "output": "} }"}, {"input": "package com . yf . system . modules . user . controller ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . yf . ability . shiro . dto . SysUserLoginDTO ; import com . yf . base . api . annon . DataProtect ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . * ; import com . yf . base . api . exception . ServiceException ; import com . yf . system . modules . user . dto . request . * ; import com . yf . system . modules . user . dto . response . UserListRespDTO ; import com . yf . system . modules . user . entity . SysUser ; import com . yf . system . modules . user . enums . UserState ; import com . yf . system . modules . user . service . SysUserRoleService ; import com . yf . system . modules . user . service . SysUserService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . extern . log4j . Log4j2 ; import org . apache . shiro . authz . annotation . Logical ; import org . apache . shiro . authz . annotation . RequiresPermissions ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import javax . servlet . http . HttpServletRequest ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ Log4j2 @ RequestMapping ( \"<STR_LIT>\" ) public class SysUserController extends BaseController { @ Autowired private SysUserService baseService ; @ Autowired private SysUserRoleService sysUserRoleService ; @ RequiresPermissions ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" } , logical = Logical . OR ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < SysUserSaveReqDTO > detail ( @ RequestBody BaseIdReqDTO reqDTO ) { SysUserSaveReqDTO respDTO = baseService . detail ( reqDTO . getId ( ) ) ; return super . success ( respDTO ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < SysUserLoginDTO > login ( @ RequestBody SysUserLoginReqDTO reqDTO ) { SysUserLoginDTO respDTO = baseService . login ( reqDTO ) ; return super . success ( respDTO ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest logout ( HttpServletRequest request ) { String token = request . getHeader ( \"<STR_LIT>\" ) ; baseService . logout ( token ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest info ( @ RequestBody BaseTokenReqDTO reqDTO ) { SysUserLoginDTO respDTO = baseService . token ( reqDTO . getToken ( ) ) ; return success ( respDTO ) ; } @ DataProtect ( clazz = SysUser . class , update = true , currUsr = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest update ( @ RequestBody SysUserUpdateReqDTO reqDTO ) { baseService . update ( reqDTO ) ; return success ( ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" } , logical = Logical . OR ) @ DataProtect ( clazz = SysUser . class , update = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody SysUserSaveReqDTO reqDTO ) { baseService . save ( reqDTO ) ; return success ( ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ DataProtect ( clazz = SysUser . class , delete = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest delete ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ RequiresPermissions ( value = {", "output": "\"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < IPage < UserListRespDTO > > paging ( @ RequestBody PagingReqDTO < SysUserQueryReqDTO > reqDTO ) { IPage < UserListRespDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest state ( @ RequestBody BaseStateReqDTO reqDTO ) { QueryWrapper < SysUser > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysUser :: getId , reqDTO . getIds ( ) ) . ne ( SysUser :: getUserName , \"<STR_LIT>\" ) ; SysUser record = new SysUser ( ) ; record . setState ( reqDTO . getState ( ) ) ; baseService . update ( record , wrapper ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < SysUserLoginDTO > reg ( @ RequestBody UserRegReqDTO reqDTO ) { SysUserLoginDTO respDTO = baseService . reg ( reqDTO ) ; if ( UserState . AUDIT . equals ( respDTO . getState ( ) ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } return success ( respDTO ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest batchRole ( @ RequestBody UserRoleReqDTO reqDTO ) { sysUserRoleService . batchRole ( reqDTO ) ; return success ( ) ; } }"}, {"input": "package org . example . ddduser . domain . user . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class Address { private String country ; private String province ; private String city ; private String county ; private String detail ; public Address ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ;", "output": "this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; } public String getFullAddress ( ) { if ( TextUtil . isBlank ( detail ) ) { return null ; } return country + province + city + county + detail ; } }"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import cn . hutool . core . codec . Base64Decoder ; import cn . hutool . core . codec . Base64Encoder ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; @ Component @ Comment ( \"<STR_LIT>\" ) public class Base64FunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ;", "output": "} @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String encode ( byte [ ] bytes ) { return bytes != null ? Base64Encoder . encode ( bytes ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String encode ( String content , String charset ) { return encode ( StringFunctionExecutor . bytes ( content , charset ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String encode ( String content ) { return encode ( StringFunctionExecutor . bytes ( content ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] encodeBytes ( byte [ ] bytes ) { return bytes != null ? Base64Encoder . encode ( bytes , false ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] encodeBytes ( String content , String charset ) { return encodeBytes ( StringFunctionExecutor . bytes ( content , charset ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] encodeBytes ( String content ) { return encodeBytes ( StringFunctionExecutor . bytes ( content ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] decode ( String base64 ) { return base64 != null ? Base64Decoder . decode ( base64 ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] decode ( byte [ ] base64 ) { return base64 != null ? Base64Decoder . decode ( base64 ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String decodeString ( String base64 ) { return base64 != null ? new String ( Base64Decoder . decode ( base64 ) ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String decodeString ( byte [ ] base64 ) { return base64 != null ? new String ( Base64Decoder . decode ( base64 ) ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String decodeString ( byte [ ] base64 , String charset ) { return base64 != null ? StringFunctionExecutor . newString ( Base64Decoder . decode ( base64 ) , charset ) : null ; } }"}, {"input": "package com . yf . base . api . exception ; import com . mysql . cj . jdbc . exceptions . MysqlDataTruncation ; import com . yf . base . api . api . ApiRest ; import org . apache . shiro . authz . AuthorizationException ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . http . HttpStatus ; import org . springframework . ui . Model ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . WebDataBinder ; import org . springframework . web . bind . annotation . * ; import java . text . MessageFormat ; import java . util . regex . Matcher ; import static java . util . regex . Pattern . compile ; @ RestControllerAdvice public class ServiceExceptionHandler { @ InitBinder public void initWebBinder ( WebDataBinder binder ) { } @ ModelAttribute public void addAttribute ( Model model ) { } @ ExceptionHandler ( { ServiceException . class } ) @ ResponseStatus ( HttpStatus . OK ) public ApiRest serviceExceptionHandler ( ServiceException e ) { return new ApiRest ( e ) ; } @ ExceptionHandler ( { AuthorizationException . class } ) @ ResponseStatus ( HttpStatus . OK ) public ApiRest shiroExceptionHandler ( AuthorizationException e ) { ApiRest rest = new ApiRest ( ) ; rest . setMsg ( \"<STR_LIT>\" ) ; rest . setCode ( - <NUM_LIT> ) ; return rest ; } @ ExceptionHandler ( MethodArgumentNotValidException . class ) @ ResponseStatus ( HttpStatus . OK ) public ApiRest handleMethodArgumentNotValidException ( MethodArgumentNotValidException e ) { ApiRest apiRest = new ApiRest ( ) ; apiRest . setCode ( <NUM_LIT> ) ; apiRest . setMsg ( e . getBindingResult ( ) . getFieldError ( ) . getDefaultMessage ( ) ) ; return apiRest ; } @ ExceptionHandler ( MysqlDataTruncation . class ) @ ResponseStatus ( HttpStatus . OK ) public ApiRest handleMysqlDataTruncation ( MysqlDataTruncation e ) { ApiRest apiRest = new ApiRest ( ) ; apiRest . setCode ( <NUM_LIT> ) ; String msg = e . getMessage ( ) ; Matcher m = compile ( \"<STR_LIT>\" ) . matcher ( msg ) ; while ( m . find ( ) ) { msg = MessageFormat . format ( \"<STR_LIT>\" , m . group ( <NUM_LIT> ) ) ; } apiRest . setMsg ( msg ) ; return apiRest ; } @ ExceptionHandler ( NoSuchBeanDefinitionException . class ) @ ResponseStatus ( HttpStatus . OK ) public ApiRest handleNoSuchBeanDefinitionException ( NoSuchBeanDefinitionException e ) { ApiRest apiRest = new ApiRest ( ) ;", "output": "apiRest . setCode ( <NUM_LIT> ) ; apiRest . setMsg ( e . getMessage ( ) ) ; return apiRest ; } }"}, {"input": "package com . oddfar . campus . common . core ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . toolkit . support . SFunction ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . oddfar . campus . common . core . page . PageQuery ; import com . oddfar . campus . common . domain . PageResult ; import org . apache . ibatis . annotations . Param ; import java . util . Collection ; import java . util . List ; public interface BaseMapperX < T > extends BaseMapper < T > { default PageResult < T > selectPage ( @ Param ( \"<STR_LIT>\" ) Wrapper < T > queryWrapper ) { PageQuery pageQuery = new PageQuery ( ) ; Page < T > page = pageQuery . buildPage ( ) ; selectPage ( page , queryWrapper ) ; return new PageResult ( page . getRecords ( ) , page . getTotal ( ) ) ; }", "output": "default T selectOne ( String field , Object value ) { return selectOne ( new QueryWrapper < T > ( ) . eq ( field , value ) ) ; } default T selectOne ( SFunction < T , ? > field , Object value ) { return selectOne ( new LambdaQueryWrapper < T > ( ) . eq ( field , value ) ) ; } default T selectOne ( String field1 , Object value1 , String field2 , Object value2 ) { return selectOne ( new QueryWrapper < T > ( ) . eq ( field1 , value1 ) . eq ( field2 , value2 ) ) ; } default T selectOne ( SFunction < T , ? > field1 , Object value1 , SFunction < T , ? > field2 , Object value2 ) { return selectOne ( new LambdaQueryWrapper < T > ( ) . eq ( field1 , value1 ) . eq ( field2 , value2 ) ) ; } default Long selectCount ( ) { return selectCount ( new QueryWrapper < T > ( ) ) ; } default Long selectCount ( String field , Object value ) { return selectCount ( new QueryWrapper < T > ( ) . eq ( field , value ) ) ; } default Long selectCount ( SFunction < T , ? > field , Object value ) { return selectCount ( new LambdaQueryWrapper < T > ( ) . eq ( field , value ) ) ; } default List < T > selectList ( ) { return selectList ( new QueryWrapper < > ( ) ) ; } default List < T > selectList ( String field , Object value ) { return selectList ( new QueryWrapper < T > ( ) . eq ( field , value ) ) ; } default List < T > selectList ( SFunction < T , ? > field , Object value ) { return selectList ( new LambdaQueryWrapper < T > ( ) . eq ( field , value ) ) ; } default List < T > selectList ( String field , Collection < ? > values ) { return selectList ( new QueryWrapper < T > ( ) . in ( field , values ) ) ; } default List < T > selectList ( SFunction < T , ? > field , Collection < ? > values ) { return selectList ( new LambdaQueryWrapper < T > ( ) . in ( field , values ) ) ; } default void insertBatch ( Collection < T > entities ) { entities . forEach ( this :: insert ) ; } default void updateBatch ( T update ) { update ( update , new QueryWrapper < > ( ) ) ; } }"}, {"input": "package org . example . ddduser . application . service ; public interface UserMngCommandService { void enable ( Long userId ) ;", "output": "void disable ( Long userId ) ; }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . io . FileUtil ; import cn . hutool . core . lang . Opt ; import cn . hutool . core . util . ObjUtil ; import cn . hutool . core . util . StrUtil ; import com . alibaba . excel . EasyExcel ; import com . google . protobuf . InvalidProtocolBufferException ; import com . xcs . wx . domain . ChatRoomInfo ; import com . xcs . wx . domain . dto . ChatRoomDTO ; import com . xcs . wx . domain . vo . * ; import com . xcs . wx . mapping . ChatRoomMapping ; import com . xcs . wx . protobuf . ChatRoomProto ; import com . xcs . wx . repository . ChatRoomInfoRepository ; import com . xcs . wx . repository . ChatRoomRepository ; import com . xcs . wx . repository . ContactHeadImgUrlRepository ; import com . xcs . wx . repository . ContactRepository ; import com . xcs . wx . service . ChatRoomService ; import com . xcs . wx . util . DirUtil ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Service ; import java . io . File ; import java . util . Date ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Slf4j @ Service @ RequiredArgsConstructor public class ChatRoomServiceImpl implements ChatRoomService { private final ChatRoomRepository chatRoomRepository ; private final ChatRoomMapping chatRoomMapping ; private final ContactRepository contactRepository ; private final ChatRoomInfoRepository chatRoomInfoRepository ; private final ContactHeadImgUrlRepository contactHeadImgUrlRepository ; @ Override public PageVO < ChatRoomVO > queryChatRoom ( ChatRoomDTO chatRoomDTO ) { return Opt . ofNullable ( chatRoomRepository . queryChatRoom ( chatRoomDTO ) ) . map ( page -> { for ( ChatRoomVO chatRoom : page . getRecords ( ) ) { chatRoom . setMemberCount ( handleMembersCount ( chatRoom . getRoomData ( ) ) ) ; } return page ; } ) . map ( page -> { for ( ChatRoomVO chatRoom : page . getRecords ( ) ) { if ( ! StrUtil . isBlank ( chatRoom . getHeadImgUrl ( ) ) ) { continue ; } chatRoom . setHeadImgUrl ( \"<STR_LIT>\" + chatRoom . getChatRoomName ( ) ) ; } return page ; } ) . map ( page -> new PageVO < > ( page . getCurrent ( ) , page . getSize ( ) , page . getTotal ( ) , page . getRecords ( ) ) ) . orElse ( new PageVO < > ( chatRoomDTO . getCurrent ( ) , chatRoomDTO . getPageSize ( ) , <NUM_LIT> , null ) ) ; } @ Override public ChatRoomDetailVO queryChatRoomDetail ( String chatRoomName ) { return Opt . ofNullable ( chatRoomRepository . queryChatRoomDetail ( chatRoomName ) ) . map ( chatRoomMapping :: convert ) . ifPresent ( this :: populateChatRoomDetails ) . ifPresent ( this :: populateChatRoomInfo ) . ifPresent ( this :: populateChatRoomMember ) . orElse ( null ) ; } @ Override public String exportChatRoom ( ) { String filePath = DirUtil . getExportDir ( \"<STR_LIT>\" ) ; FileUtil . mkdir ( new File ( filePath ) . getParent ( ) ) ; EasyExcel . write ( filePath , ExportChatRoomVO . class ) . sheet ( \"<STR_LIT>\" ) . doWrite ( ( ) -> { List < ExportChatRoomVO > exportChatRoomVOS = chatRoomRepository . exportChatRoom ( ) ; for ( ExportChatRoomVO exportChatRoomVO : exportChatRoomVOS ) { exportChatRoomVO . setMemberCount ( handleMembersCount ( exportChatRoomVO . getRoomData ( ) ) ) ; } return exportChatRoomVOS ; } ) ; return filePath ; } private void populateChatRoomDetails ( ChatRoomDetailVO chatRoomDetailVo ) { chatRoomDetailVo . setChatRoomTitle ( contactRepository . getContactNickname ( chatRoomDetailVo . getChatRoomName ( ) ) ) ; chatRoomDetailVo . setCreateBy ( contactRepository . getContactNickname ( chatRoomDetailVo . getReserved2 ( ) ) ) ; chatRoomDetailVo . setHeadImgUrl ( contactHeadImgUrlRepository . queryHeadImgUrlByUserName ( chatRoomDetailVo . getChatRoomName ( ) ) ) ; } private void populateChatRoomInfo ( ChatRoomDetailVO chatRoomDetailVo ) { ChatRoomInfo chatRoomInfo = chatRoomInfoRepository . queryChatRoomInfo ( chatRoomDetailVo . getChatRoomName ( ) ) ; ChatRoomInfoVO chatRoomInfoVO = chatRoomMapping . convert ( chatRoomInfo ) ; Long announcementPublishTime = chatRoomInfoVO . getAnnouncementPublishTime ( ) ; if ( ObjUtil . isNotEmpty ( announcementPublishTime ) && announcementPublishTime > <NUM_LIT> ) { chatRoomInfoVO . setStrAnnouncementPublishTime ( DateUtil . formatDateTime ( new Date ( announcementPublishTime * <NUM_LIT> ) ) ) ; } chatRoomInfoVO . setAnnouncementPublisher ( contactRepository . getContactNickname ( chatRoomInfoVO . getAnnouncementEditor ( ) ) ) ; chatRoomDetailVo . setChatRoomInfo ( chatRoomInfoVO ) ; } private void populateChatRoomMember ( ChatRoomDetailVO chatRoomDetailVo ) { try { ChatRoomProto . ChatRoom chatRoom = ChatRoomProto . ChatRoom . parseFrom ( chatRoomDetailVo . getRoomData ( ) ) ; List < ChatRoomProto . Member > membersList = chatRoom . getMembersList ( ) ; List < String > memberWxIds = membersList . stream ( ) . map ( ChatRoomProto . Member :: getWxId ) . collect ( Collectors . toList ( ) ) ; Map < String , String > headImgUrlMap = contactHeadImgUrlRepository . queryHeadImgUrl ( memberWxIds ) ; Map < String , String > contactNicknameMap = contactRepository . getContactNickname ( memberWxIds ) ; chatRoomDetailVo . setMembers ( chatRoomMapping . convert ( membersList , headImgUrlMap , contactNicknameMap ) ) ; } catch ( InvalidProtocolBufferException e ) { log . error ( \"<STR_LIT>\" , e ) ; } } private Integer handleMembersCount ( byte [ ] roomData ) { ChatRoomProto . ChatRoom chatRoomProto = null ; try {", "output": "chatRoomProto = ChatRoomProto . ChatRoom . parseFrom ( roomData ) ; } catch ( InvalidProtocolBufferException e ) { log . error ( \"<STR_LIT>\" , e ) ; } if ( chatRoomProto == null ) { return <NUM_LIT> ; } return chatRoomProto . getMembersList ( ) . size ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . base . CharMatcher ; import com . google . common . base . Splitter ; import java . util . List ; public class WildcardMatcher { public static boolean match ( CharSequence string , CharSequence pattern ) { return match ( string , pattern , <NUM_LIT> , <NUM_LIT> ) ; } private static boolean match ( CharSequence string , CharSequence pattern , final int sNdxConst , final int pNdxConst ) { int pLen = pattern . length ( ) ; if ( pLen == <NUM_LIT> ) { if ( pattern . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; int sNdx = sNdxConst ; int pNdx = pNdxConst ; while ( true ) { if ( ( sNdx >= sLen ) ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '<STR_LIT>' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return false ; } char p = pattern . charAt ( pNdx ) ; if ( ! nextIsNotWildcard ) { if ( p == '<STR_LIT>' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == '<STR_LIT>' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == '<STR_LIT>' ) { char pNext = <NUM_LIT> ; if ( pNdx + <NUM_LIT> < pLen ) { pNext = pattern . charAt ( pNdx + <NUM_LIT> ) ; } if ( pNext == '<STR_LIT>' ) {", "output": "pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } if ( p != string . charAt ( sNdx ) ) { return false ; } sNdx ++ ; pNdx ++ ; } } public static int matchOne ( String src , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( match ( src , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } protected static final String PATH_MATCH = \"<STR_LIT>\" ; protected static final Splitter PATH_SPLITTER = Splitter . on ( CharMatcher . anyOf ( \"<STR_LIT>\" ) ) ; public static int matchPathOne ( String platformDependentPath , String ... patterns ) { for ( int i = <NUM_LIT> ; i < patterns . length ; i ++ ) { if ( matchPath ( platformDependentPath , patterns [ i ] ) ) { return i ; } } return - <NUM_LIT> ; } public static boolean matchPath ( String path , String pattern ) { List < String > pathElements = PATH_SPLITTER . splitToList ( path ) ; List < String > patternElements = PATH_SPLITTER . splitToList ( pattern ) ; return matchTokens ( pathElements . toArray ( new String [ <NUM_LIT> ] ) , patternElements . toArray ( new String [ <NUM_LIT> ] ) ) ; } protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { int patNdxStart = <NUM_LIT> ; int patNdxEnd = patterns . length - <NUM_LIT> ; int tokNdxStart = <NUM_LIT> ; int tokNdxEnd = tokens . length - <NUM_LIT> ; while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxStart ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxStart ] , patDir ) ) { return false ; } patNdxStart ++ ; tokNdxStart ++ ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } if ( patNdxStart > patNdxEnd ) { return false ; } while ( ( patNdxStart <= patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { String patDir = patterns [ patNdxEnd ] ; if ( patDir . equals ( PATH_MATCH ) ) { break ; } if ( ! match ( tokens [ tokNdxEnd ] , patDir ) ) { return false ; } patNdxEnd -- ; tokNdxEnd -- ; } if ( tokNdxStart > tokNdxEnd ) { for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { int patIdxTmp = - <NUM_LIT> ; for ( int i = patNdxStart + <NUM_LIT> ; i <= patNdxEnd ; i ++ ) { if ( patterns [ i ] . equals ( PATH_MATCH ) ) { patIdxTmp = i ; break ; } } if ( patIdxTmp == patNdxStart + <NUM_LIT> ) { patNdxStart ++ ; continue ; } int patLength = ( patIdxTmp - patNdxStart - <NUM_LIT> ) ; int strLength = ( tokNdxEnd - tokNdxStart + <NUM_LIT> ) ; int ndx = - <NUM_LIT> ; strLoop : for ( int i = <NUM_LIT> ; i <= strLength - patLength ; i ++ ) { for ( int j = <NUM_LIT> ; j < patLength ; j ++ ) { String subPat = patterns [ patNdxStart + j + <NUM_LIT> ] ; String subStr = tokens [ tokNdxStart + i + j ] ; if ( ! match ( subStr , subPat ) ) { continue strLoop ; } } ndx = tokNdxStart + i ; break ; } if ( ndx == - <NUM_LIT> ) { return false ; } patNdxStart = patIdxTmp ; tokNdxStart = ndx + patLength ; } for ( int i = patNdxStart ; i <= patNdxEnd ; i ++ ) { if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { return false ; } } return true ; } }"}, {"input": "package com . oddfar . campus . common . domain . model ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . Set ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class SysRoleAuthList {", "output": "Long roleID ; Set < String > perms ; Set < String > resourceCode ; }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . UserDailyLoginDurationMapper ; import cn . org . alan . exam . mapper . UserExamsScoreMapper ; import cn . org . alan . exam . model . entity . UserDailyLoginDuration ; import cn . org . alan . exam . model . entity . UserExamsScore ; import cn . org . alan . exam . service . IUserDailyLoginDurationService ; import cn . org . alan . exam . service . IUserExamsScoreService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class UserDailyLoginDurationServiceImpl extends ServiceImpl < UserDailyLoginDurationMapper , UserDailyLoginDuration > implements IUserDailyLoginDurationService {", "output": "}"}, {"input": "package com . yf . system . modules . role . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . system . modules . role . entity . SysRoleMenu ; import java . util . List ; public interface SysRoleMenuService extends IService < SysRoleMenu > { List < String > findRoleMenus ( String roleId ) ; void saveRoleIds ( String roleId , List < String > ids ) ;", "output": "}"}, {"input": "package org . example . ddduser . application . dto . command ; import lombok . Data ; import javax . validation . constraints . NotNull ; @ Data public class ModifyAddressCommand { @ NotNull ( message = \"<STR_LIT>\" ) private Double longitude ; @ NotNull ( message = \"<STR_LIT>\" ) private Double latitude ;", "output": "}"}, {"input": "package com . oddfar . campus . common . utils . uuid ; import cn . hutool . core . lang . UUID ; public class IdUtils { public static String randomUUID ( ) { return UUID . randomUUID ( ) . toString ( ) ; } public static String simpleUUID ( ) { return UUID . randomUUID ( ) . toString ( true ) ; } public static String fastUUID ( ) { return UUID . fastUUID ( ) . toString ( ) ; } public static String fastSimpleUUID ( ) {", "output": "return UUID . fastUUID ( ) . toString ( true ) ; } }"}, {"input": "package org . example . ddduser . infrastructure . repository . database ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . example . ddduser . infrastructure . repository . database . dataobject . UserDetail ; public interface UserDetailMapper extends BaseMapper < UserDetail > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . config ; import io . github . chensheng . dddboot . microservice . core . ApplicationContextHolder ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration public class MicroServiceAutoConfiguration { @ Bean public ApplicationContextHolder applicationContextHolder ( ) {", "output": "return new ApplicationContextHolder ( ) ; } }"}, {"input": "package com . youlai . system . config . property ; import cn . hutool . core . map . MapUtil ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; import java . util . Map ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) @ Data public class GeneratorProperties { private Map < String , TemplateConfig > templateConfigs = MapUtil . newHashMap ( true ) ; @ Data public static class TemplateConfig { private String templatePath ; private String packageName ;", "output": "} }"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class MenuVo implements Serializable { private String name ; private String path ; private Boolean hidden ; private String redirect ; private String component ; private Boolean alwaysShow ; private MenuMetaVo meta ; private List < MenuVo > children ;", "output": "}"}, {"input": "package com . xcs . wx . domain . bo ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import com . fasterxml . jackson . dataformat . xml . annotation . JacksonXmlProperty ; import com . fasterxml . jackson . dataformat . xml . annotation . JacksonXmlRootElement ; import com . fasterxml . jackson . dataformat . xml . annotation . JacksonXmlText ; import lombok . Data ; import java . util . List ; @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) @ JacksonXmlRootElement ( localName = \"<STR_LIT>\" ) public class TimelineObjectBO { @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String id ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String username ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private Long createTime ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String contentDesc ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String contentDescShowType ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String contentDescScene ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String asPrivate ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String sightFolded ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String showFlag ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private AppInfo appInfo ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String sourceUserName ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String sourceNickName ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String statisticsData ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String statExtStr ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private ContentObject contentObject ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String publicUserName ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private Location location ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private StreamVideo streamVideo ; @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class AppInfo { @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String id ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String version ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String appName ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String installUrl ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String fromUrl ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String isForceUpdate ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String isHidden ; } @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class ContentObject { @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private Integer contentStyle ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String description ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String title ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String contentUrl ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private List < Media > mediaList ; @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class Media { @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String id ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String type ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String title ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String description ;", "output": "@ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String asPrivate ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String userData ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String subType ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String videoSize ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private Url url ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private Thumb thumb ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String size ; } @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class Url { @ JacksonXmlProperty ( isAttribute = true ) private int type ; @ JacksonXmlProperty ( isAttribute = true ) private String md5 ; @ JacksonXmlProperty ( isAttribute = true ) private String videomd5 ; @ JacksonXmlText private String value ; } @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class Thumb { @ JacksonXmlProperty ( isAttribute = true ) private int type ; @ JacksonXmlText private String value ; } } @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class Location { @ JacksonXmlProperty ( isAttribute = true , localName = \"<STR_LIT>\" ) private String poiClassifyId ; @ JacksonXmlProperty ( isAttribute = true , localName = \"<STR_LIT>\" ) private String poiName ; @ JacksonXmlProperty ( isAttribute = true , localName = \"<STR_LIT>\" ) private String poiAddress ; @ JacksonXmlProperty ( isAttribute = true , localName = \"<STR_LIT>\" ) private Integer poiClassifyType ; @ JacksonXmlProperty ( isAttribute = true , localName = \"<STR_LIT>\" ) private String city ; } @ Data @ JsonIgnoreProperties ( ignoreUnknown = true ) public static class StreamVideo { @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String streamVideoUrl ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String streamVideoThumbUrl ; @ JacksonXmlProperty ( localName = \"<STR_LIT>\" ) private String streamVideoWebUrl ; } }"}, {"input": "package org . springblade . config . util ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import javax . servlet . http . HttpServletRequest ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . sql . Date ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j public class ConvertUtils { public static boolean isEmpty ( Object object ) { if ( object == null ) { return ( true ) ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } if ( \"<STR_LIT>\" . equals ( object ) ) { return true ; } return false ; } public static boolean isNotEmpty ( Object object ) { if ( object != null && ! object . equals ( \"<STR_LIT>\" ) && ! object . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } public static String decode ( String strIn , String sourceCode , String targetCode ) { String temp = code2code ( strIn , sourceCode , targetCode ) ; return temp ; } public static String StrToUTF ( String strIn , String sourceCode , String targetCode ) { strIn = \"<STR_LIT>\" ; try { strIn = new String ( strIn . getBytes ( \"<STR_LIT>\" ) , \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return strIn ; } private static String code2code ( String strIn , String sourceCode , String targetCode ) { String strOut = null ; if ( strIn == null || ( strIn . trim ( ) ) . equals ( \"<STR_LIT>\" ) ) { return strIn ; } try { byte [ ] b = strIn . getBytes ( sourceCode ) ; for ( int i = <NUM_LIT> ; i < b . length ; i ++ ) { System . out . print ( b [ i ] + \"<STR_LIT>\" ) ; } strOut = new String ( b , targetCode ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return strOut ; } public static int getInt ( String s , int defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static int getInt ( String s ) { if ( s == null || s == \"<STR_LIT>\" ) { return <NUM_LIT> ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static int getInt ( String s , Integer df ) { if ( s == null || s == \"<STR_LIT>\" ) { return df ; } try { return ( Integer . parseInt ( s ) ) ; } catch ( NumberFormatException e ) { return <NUM_LIT> ; } } public static Integer [ ] getInts ( String [ ] s ) { if ( s == null ) { return null ; } Integer [ ] integer = new Integer [ s . length ] ; for ( int i = <NUM_LIT> ; i < s . length ; i ++ ) { integer [ i ] = Integer . parseInt ( s [ i ] ) ; } return integer ; } public static double getDouble ( String s , double defval ) { if ( s == null || s == \"<STR_LIT>\" ) { return defval ; } try { return ( Double . parseDouble ( s ) ) ; } catch ( NumberFormatException e ) { return defval ; } } public static double getDou ( Double s , double defval ) { if ( s == null ) { return defval ; } return s ; } public static int getInt ( Object object , int defval ) { if ( isEmpty ( object ) ) { return defval ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return ( defval ) ; } } public static Integer getInt ( Object object ) { if ( isEmpty ( object ) ) { return null ; } try { return ( Integer . parseInt ( object . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } public static int getInt ( BigDecimal s , int defval ) { if ( s == null ) { return ( defval ) ; } return s . intValue ( ) ; } public static Integer [ ] getIntegerArry ( String [ ] object ) { int len = object . length ; Integer [ ] result = new Integer [ len ] ; try { for ( int i = <NUM_LIT> ; i < len ; i ++ ) { result [ i ] = new Integer ( object [ i ] . trim ( ) ) ; } return result ; } catch ( NumberFormatException e ) { return null ; } } public static String getString ( String s ) { return ( getString ( s , \"<STR_LIT>\" ) ) ; } public static String getString ( Object object ) { if ( isEmpty ( object ) ) { return \"<STR_LIT>\" ; } return ( object . toString ( ) . trim ( ) ) ; } public static String getString ( int i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( float i ) { return ( String . valueOf ( i ) ) ; } public static String getString ( String s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . trim ( ) ) ; } public static String getString ( Object s , String defval ) { if ( isEmpty ( s ) ) { return ( defval ) ; } return ( s . toString ( ) . trim ( ) ) ; } public static long stringToLong ( String str ) { Long test = new Long ( <NUM_LIT> ) ; try { test = Long . valueOf ( str ) ; } catch ( Exception e ) { } return test . longValue ( ) ; } public static String getIp ( ) { String ip = null ; try { InetAddress address = InetAddress . getLocalHost ( ) ; ip = address . getHostAddress ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } return ip ; } private static boolean isBaseDataType ( Class clazz ) throws Exception { return ( clazz . equals ( String . class ) || clazz . equals ( Integer . class ) || clazz . equals ( Byte . class ) || clazz . equals ( Long . class ) || clazz . equals ( Double . class ) || clazz . equals ( Float . class ) || clazz . equals ( Character . class ) || clazz . equals ( Short . class ) || clazz . equals ( BigDecimal . class ) || clazz . equals ( BigInteger . class ) || clazz . equals ( Boolean . class ) || clazz . equals ( Date . class ) || clazz . isPrimitive ( ) ) ; } public static String getIpAddrByRequest ( HttpServletRequest request ) { String ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( ip == null || ip . length ( ) == <NUM_LIT> || \"<STR_LIT>\" . equalsIgnoreCase ( ip ) ) { ip = request . getRemoteAddr ( ) ; } return ip ; } public static String getRealIp ( ) throws SocketException { String localip = null ; String netip = null ; Enumeration < NetworkInterface > netInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; InetAddress ip = null ; boolean finded = false ; while ( netInterfaces . hasMoreElements ( ) && ! finded ) { NetworkInterface ni = netInterfaces . nextElement ( ) ; Enumeration < InetAddress > address = ni . getInetAddresses ( ) ; while ( address . hasMoreElements ( ) ) { ip = address . nextElement ( ) ; if ( ! ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { netip = ip . getHostAddress ( ) ; finded = true ; break ; } else if ( ip . isSiteLocalAddress ( ) && ! ip . isLoopbackAddress ( ) && ip . getHostAddress ( ) . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { localip = ip . getHostAddress ( ) ; } } } if ( netip != null && ! \"<STR_LIT>\" . equals ( netip ) ) { return netip ; } else { return localip ; } } public static String replaceBlank ( String str ) { String dest = \"<STR_LIT>\" ; if ( str != null ) { Pattern p = Pattern . compile ( \"<STR_LIT>\" ) ; Matcher m = p . matcher ( str ) ; dest = m . replaceAll ( \"<STR_LIT>\" ) ; } return dest ; } public static boolean isIn ( String substring , String [ ] source ) { if ( source == null || source . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < source . length ; i ++ ) { String aSource = source [ i ] ; if ( aSource . equals ( substring ) ) { return true ; } } return false ; } public static Map < Object , Object > getHashMap ( ) { return new HashMap < Object , Object > ( ) ; } public static Map < Object , Object > SetToMap ( Set < Object > setobj ) { Map < Object , Object > map = getHashMap ( ) ; for ( Iterator < Object > iterator = setobj . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < Object , Object > entry = ( Map . Entry < Object , Object > ) iterator . next ( ) ; map . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) == null ? \"<STR_LIT>\" : entry . getValue ( ) . toString ( ) . trim ( ) ) ; } return map ; } public static boolean isInnerIP ( String ipAddress ) { boolean isInnerIp = false ; long ipNum = getIpNum ( ipAddress ) ; long aBegin = getIpNum ( \"<STR_LIT>\" ) ; long aEnd = getIpNum ( \"<STR_LIT>\" ) ; long bBegin = getIpNum ( \"<STR_LIT>\" ) ; long bEnd = getIpNum ( \"<STR_LIT>\" ) ; long cBegin = getIpNum ( \"<STR_LIT>\" ) ; long cEnd = getIpNum ( \"<STR_LIT>\" ) ; isInnerIp = isInner ( ipNum , aBegin , aEnd ) || isInner ( ipNum , bBegin , bEnd ) || isInner ( ipNum , cBegin , cEnd ) || ipAddress . equals ( \"<STR_LIT>\" ) ; return isInnerIp ; } private static long getIpNum ( String ipAddress ) { String [ ] ip = ipAddress . split ( \"<STR_LIT>\" ) ; long a = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long b = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long c = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long d = Integer . parseInt ( ip [ <NUM_LIT> ] ) ; long ipNum = a * <NUM_LIT> * <NUM_LIT> * <NUM_LIT> + b * <NUM_LIT> * <NUM_LIT> + c * <NUM_LIT> + d ; return ipNum ; } private static boolean isInner ( long userIp , long begin , long end ) { return ( userIp >= begin ) && ( userIp <= end ) ; } public static String camelName ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + name . substring ( <NUM_LIT> ) . toLowerCase ( ) ; } String camels [ ] = name . split ( \"<STR_LIT>\" ) ; for ( String camel : camels ) { if ( camel . isEmpty ( ) ) { continue ; } if ( result . length ( ) == <NUM_LIT> ) { result . append ( camel . toLowerCase ( ) ) ; } else { result . append ( camel . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) ) ; result . append ( camel . substring ( <NUM_LIT> ) . toLowerCase ( ) ) ; } }", "output": "return result . toString ( ) ; } public static String camelNames ( String names ) { if ( names == null || names . equals ( \"<STR_LIT>\" ) ) { return null ; } StringBuffer sf = new StringBuffer ( ) ; String [ ] fs = names . split ( \"<STR_LIT>\" ) ; for ( String field : fs ) { field = camelName ( field ) ; sf . append ( field + \"<STR_LIT>\" ) ; } String result = sf . toString ( ) ; return result . substring ( <NUM_LIT> , result . length ( ) - <NUM_LIT> ) ; } public static String camelNameCapFirst ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + name . substring ( <NUM_LIT> ) . toLowerCase ( ) ; } String camels [ ] = name . split ( \"<STR_LIT>\" ) ; for ( String camel : camels ) { if ( camel . isEmpty ( ) ) { continue ; } result . append ( camel . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) ) ; result . append ( camel . substring ( <NUM_LIT> ) . toLowerCase ( ) ) ; } return result . toString ( ) ; } public static String camelToUnderline ( String para ) { if ( para . length ( ) < <NUM_LIT> ) { return para . toLowerCase ( ) ; } StringBuilder sb = new StringBuilder ( para ) ; int temp = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < para . length ( ) ; i ++ ) { if ( Character . isUpperCase ( para . charAt ( i ) ) ) { sb . insert ( i + temp , \"<STR_LIT>\" ) ; temp += <NUM_LIT> ; } } return sb . toString ( ) . toLowerCase ( ) ; } public static String randomGen ( int place ) { String base = \"<STR_LIT>\" ; StringBuffer sb = new StringBuffer ( ) ; Random rd = new Random ( ) ; for ( int i = <NUM_LIT> ; i < place ; i ++ ) { sb . append ( base . charAt ( rd . nextInt ( base . length ( ) ) ) ) ; } return sb . toString ( ) ; } public static Field [ ] getAllFields ( Object object ) { Class < ? > clazz = object . getClass ( ) ; List < Field > fieldList = new ArrayList < > ( ) ; while ( clazz != null ) { fieldList . addAll ( new ArrayList < > ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ) ; clazz = clazz . getSuperclass ( ) ; } Field [ ] fields = new Field [ fieldList . size ( ) ] ; fieldList . toArray ( fields ) ; return fields ; } public static List < Map < String , Object > > toLowerCasePageList ( List < Map < String , Object > > list ) { List < Map < String , Object > > select = new ArrayList < > ( ) ; for ( Map < String , Object > row : list ) { Map < String , Object > resultMap = new HashMap < > ( ) ; Set < String > keySet = row . keySet ( ) ; for ( String key : keySet ) { String newKey = key . toLowerCase ( ) ; resultMap . put ( newKey , row . get ( key ) ) ; } select . add ( resultMap ) ; } return select ; } public static < F , T > List < T > entityListToModelList ( List < F > fromList , Class < T > tClass ) { if ( fromList . isEmpty ( ) || fromList == null ) { return null ; } List < T > tList = new ArrayList < > ( ) ; for ( F f : fromList ) { T t = entityToModel ( f , tClass ) ; tList . add ( t ) ; } return tList ; } public static < F , T > T entityToModel ( F entity , Class < T > modelClass ) { log . debug ( \"<STR_LIT>\" ) ; T model = null ; if ( entity == null || modelClass == null ) { return null ; } try { model = modelClass . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( \"<STR_LIT>\" , e ) ; } catch ( IllegalAccessException e ) { log . error ( \"<STR_LIT>\" , e ) ; } BeanUtils . copyProperties ( entity , model ) ; return model ; } public static boolean listIsEmpty ( Collection list ) { return ( list == null || list . size ( ) == <NUM_LIT> ) ; } public static boolean listIsNotEmpty ( Collection list ) { return ! listIsEmpty ( list ) ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . form . ExerciseFillAnswerFrom ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . model . vo . exercise . AnswerInfoVO ; import cn . org . alan . exam . model . vo . exercise . ExerciseRepoVO ; import cn . org . alan . exam . model . vo . exercise . QuestionSheetVO ; import cn . org . alan . exam . service . IExerciseRecordService ; import cn . org . alan . exam . service . IRepoService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Nullable ; import jakarta . annotation . Resource ; import jakarta . validation . constraints . Max ; import jakarta . validation . constraints . Min ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ Validated public class ExerciseController { @ Resource private IExerciseRecordService iExerciseRecordService ; @ Resource private IRepoService iRepoService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < QuestionSheetVO > > getQuestion ( @ PathVariable ( \"<STR_LIT>\" ) Integer repoId , @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Max ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Nullable @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Integer quType ) { return iExerciseRecordService . getQuestionSheet ( repoId , quType ) ; }", "output": "@ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < QuestionVO > fillAnswer ( @ RequestBody ExerciseFillAnswerFrom exerciseFillAnswerFrom ) { return iExerciseRecordService . fillAnswer ( exerciseFillAnswerFrom ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < ExerciseRepoVO > > getRepo ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String title ) { return iRepoService . getRepo ( pageNum , pageSize , title ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < QuestionVO > getSingle ( @ PathVariable ( \"<STR_LIT>\" ) Integer id ) { return iExerciseRecordService . getSingle ( id ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < AnswerInfoVO > getAnswerInfo ( @ PathVariable ( \"<STR_LIT>\" ) Integer repoId , @ PathVariable ( \"<STR_LIT>\" ) Integer quId ) { return iExerciseRecordService . getAnswerInfo ( repoId , quId ) ; } }"}, {"input": "package me . zhengjie ; import io . swagger . annotations . Api ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . utils . SpringContextHolder ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . boot . context . ApplicationPidFileWriter ; import org . springframework . context . annotation . Bean ; import org . springframework . scheduling . annotation . EnableAsync ; import org . springframework . transaction . annotation . EnableTransactionManagement ; import org . springframework . web . bind . annotation . RestController ; @ EnableAsync @ RestController @ Api ( hidden = true ) @ SpringBootApplication @ EnableTransactionManagement public class AppRun { public static void main ( String [ ] args ) { SpringApplication springApplication = new SpringApplication ( AppRun . class ) ; springApplication . addListeners ( new ApplicationPidFileWriter ( ) ) ; springApplication . run ( args ) ;", "output": "} @ Bean public SpringContextHolder springContextHolder ( ) { return new SpringContextHolder ( ) ; } @ AnonymousGetMapping ( \"<STR_LIT>\" ) public String index ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class ConfigServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < ConfigService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; protected ConfigServiceBeanBuilder ( ) {", "output": "super ( GlobalNacosPropertiesSource . CONFIG ) ; } @ Override protected ConfigService createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException { return nacosServiceFactory . createConfigService ( properties ) ; } }"}, {"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . ExceptionUtils ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . ToString ; import net . sf . jsqlparser . expression . BinaryExpression ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . StringValue ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . expression . operators . conditional . OrExpression ; import net . sf . jsqlparser . expression . operators . relational . EqualsTo ; import net . sf . jsqlparser . expression . operators . relational . ExpressionList ; import net . sf . jsqlparser . expression . operators . relational . ItemsList ; import net . sf . jsqlparser . expression . operators . relational . MultiExpressionList ; import net . sf . jsqlparser . schema . Column ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . delete . Delete ; import net . sf . jsqlparser . statement . insert . Insert ; import net . sf . jsqlparser . statement . select . * ; import net . sf . jsqlparser . statement . update . Update ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tenant . BladeTenantProperties ; import org . springblade . core . tool . utils . CollectionUtil ; import org . springblade . core . tool . utils . StringPool ; import java . util . * ; import java . util . stream . Collectors ; @ Data @ ToString ( callSuper = true ) @ EqualsAndHashCode ( callSuper = true ) public class MjkjTenantInterceptor extends TenantLineInnerInterceptor { private TenantLineHandler tenantLineHandler ; private BladeTenantProperties tenantProperties ; private List < String > adminTenantTables = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Override public void setTenantLineHandler ( TenantLineHandler tenantLineHandler ) { super . setTenantLineHandler ( tenantLineHandler ) ; this . tenantLineHandler = tenantLineHandler ; } @ Override protected void processInsert ( Insert insert , int index , String sql , Object obj ) { if ( ! tenantProperties . getEnhance ( ) ) { super . processInsert ( insert , index , sql , obj ) ; return ; } if ( tenantLineHandler . ignoreTable ( insert . getTable ( ) . getName ( ) ) ) { return ; } List < Column > columns = insert . getColumns ( ) ; if ( CollectionUtils . isEmpty ( columns ) ) { return ; } String tenantIdColumn = tenantLineHandler . getTenantIdColumn ( ) ; if ( columns . stream ( ) . map ( Column :: getColumnName ) . anyMatch ( i -> i . equals ( tenantIdColumn ) ) ) { return ; } columns . add ( new Column ( tenantIdColumn ) ) ; List < Expression > duplicateUpdateColumns = insert . getDuplicateUpdateExpressionList ( ) ; if ( CollectionUtils . isNotEmpty ( duplicateUpdateColumns ) ) { EqualsTo equalsTo = new EqualsTo ( ) ; equalsTo . setLeftExpression ( new StringValue ( tenantIdColumn ) ) ; equalsTo . setRightExpression ( tenantLineHandler . getTenantId ( ) ) ; duplicateUpdateColumns . add ( equalsTo ) ; } Select select = insert . getSelect ( ) ; if ( select != null ) { this . processInsertSelect ( select . getSelectBody ( ) ) ; } else if ( insert . getItemsList ( ) != null ) { ItemsList itemsList = insert . getItemsList ( ) ; if ( itemsList instanceof MultiExpressionList ) { ( ( MultiExpressionList ) itemsList ) . getExpressionLists ( ) . forEach ( el -> el . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ) ; } else { ( ( ExpressionList ) itemsList ) . getExpressions ( ) . add ( tenantLineHandler . getTenantId ( ) ) ; } } else { throw ExceptionUtils . mpe ( \"<STR_LIT>\" ) ; } } @ Override protected void processPlainSelect ( PlainSelect plainSelect ) { List < SelectItem > selectItems = plainSelect . getSelectItems ( ) ; if ( CollectionUtils . isNotEmpty ( selectItems ) ) { selectItems . forEach ( this :: processSelectItem ) ; } Expression where = plainSelect . getWhere ( ) ; processWhereSubSelect ( where ) ; FromItem fromItem = plainSelect . getFromItem ( ) ; List < Table > list = processFromItem ( fromItem ) ; List < Table > mainTables = new ArrayList < > ( list ) ; List < Join > joins = plainSelect . getJoins ( ) ; if ( CollectionUtils . isNotEmpty ( joins ) ) { mainTables = processJoins ( mainTables , joins ) ; } if ( CollectionUtils . isNotEmpty ( mainTables ) && ! doTenantFilters ( mainTables ) ) { plainSelect . setWhere ( builderExpression ( where , mainTables ) ) ; } } @ Override protected void processUpdate ( Update update , int index , String sql , Object obj ) { final Table table = update . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } update . setWhere ( this . andExpression ( table , update . getWhere ( ) ) ) ; } @ Override protected void processDelete ( Delete delete , int index , String sql , Object obj ) { final Table table = delete . getTable ( ) ; if ( tenantLineHandler . ignoreTable ( table . getName ( ) ) ) { return ; } if ( doTenantFilter ( table . getName ( ) ) ) { return ; } delete . setWhere ( this . andExpression ( table , delete . getWhere ( ) ) ) ; } @ Override protected BinaryExpression andExpression ( Table table , Expression where ) { EqualsTo equalsTo = new EqualsTo ( ) ; Expression leftExpression = this . getAliasColumn ( table ) ; Expression rightExpression = tenantLineHandler . getTenantId ( ) ; if ( doTenantFilter ( table . getName ( ) ) ) { leftExpression = rightExpression = new StringValue ( StringPool . ONE ) ; } equalsTo . setLeftExpression ( leftExpression ) ; equalsTo . setRightExpression ( rightExpression ) ; if ( null != where ) { if ( where instanceof OrExpression ) { return new AndExpression ( equalsTo , new Parenthesis ( where ) ) ; } else { return new AndExpression ( equalsTo , where ) ; } } return equalsTo ; } @ Override protected Expression builderExpression ( Expression currentExpression , List < Table > tables ) {", "output": "if ( CollectionUtils . isEmpty ( tables ) ) { return currentExpression ; } Expression tenantId = tenantLineHandler . getTenantId ( ) ; List < EqualsTo > equalsTos = tables . stream ( ) . filter ( x -> ! tenantLineHandler . ignoreTable ( x . getName ( ) ) ) . filter ( x -> ! doTenantFilter ( x . getName ( ) ) ) . map ( item -> new EqualsTo ( getAliasColumn ( item ) , tenantId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtils . isEmpty ( equalsTos ) ) { return currentExpression ; } Expression injectExpression = equalsTos . get ( <NUM_LIT> ) ; if ( equalsTos . size ( ) > <NUM_LIT> ) { for ( int i = <NUM_LIT> ; i < equalsTos . size ( ) ; i ++ ) { injectExpression = new AndExpression ( injectExpression , equalsTos . get ( i ) ) ; } } if ( currentExpression == null ) { return injectExpression ; } if ( currentExpression instanceof OrExpression ) { return new AndExpression ( new Parenthesis ( currentExpression ) , injectExpression ) ; } else { return new AndExpression ( currentExpression , injectExpression ) ; } } private List < Table > processFromItem ( FromItem fromItem ) { while ( fromItem instanceof ParenthesisFromItem ) { fromItem = ( ( ParenthesisFromItem ) fromItem ) . getFromItem ( ) ; } List < Table > mainTables = new ArrayList < > ( ) ; if ( fromItem instanceof Table ) { Table fromTable = ( Table ) fromItem ; mainTables . add ( fromTable ) ; } else if ( fromItem instanceof SubJoin ) { List < Table > tables = processSubJoin ( ( SubJoin ) fromItem ) ; mainTables . addAll ( tables ) ; } else { processOtherFromItem ( fromItem ) ; } return mainTables ; } private List < Table > processSubJoin ( SubJoin subJoin ) { List < Table > mainTables = new ArrayList < > ( ) ; if ( subJoin . getJoinList ( ) != null ) { List < Table > list = processFromItem ( subJoin . getLeft ( ) ) ; mainTables . addAll ( list ) ; mainTables = processJoins ( mainTables , subJoin . getJoinList ( ) ) ; } return mainTables ; } private List < Table > processJoins ( List < Table > mainTables , List < Join > joins ) { Table mainTable = null ; Table leftTable = null ; if ( mainTables == null ) { mainTables = new ArrayList < > ( ) ; } else if ( mainTables . size ( ) == <NUM_LIT> ) { mainTable = mainTables . get ( <NUM_LIT> ) ; leftTable = mainTable ; } Deque < List < Table > > onTableDeque = new LinkedList < > ( ) ; for ( Join join : joins ) { FromItem joinItem = join . getRightItem ( ) ; List < Table > joinTables = null ; if ( joinItem instanceof Table ) { joinTables = new ArrayList < > ( ) ; joinTables . add ( ( Table ) joinItem ) ; } else if ( joinItem instanceof SubJoin ) { joinTables = processSubJoin ( ( SubJoin ) joinItem ) ; } if ( joinTables != null ) { if ( join . isSimple ( ) ) { mainTables . addAll ( joinTables ) ; continue ; } Table joinTable = joinTables . get ( <NUM_LIT> ) ; List < Table > onTables = null ; if ( join . isRight ( ) ) { mainTable = joinTable ; if ( leftTable != null ) { onTables = Collections . singletonList ( leftTable ) ; } } else if ( join . isLeft ( ) ) { onTables = Collections . singletonList ( joinTable ) ; } else if ( join . isInner ( ) ) { if ( mainTable == null ) { onTables = Collections . singletonList ( joinTable ) ; } else { onTables = Arrays . asList ( mainTable , joinTable ) ; } mainTable = null ; } mainTables = new ArrayList < > ( ) ; if ( mainTable != null ) { mainTables . add ( mainTable ) ; } Collection < Expression > originOnExpressions = join . getOnExpressions ( ) ; if ( originOnExpressions . size ( ) == <NUM_LIT> && onTables != null ) { List < Expression > onExpressions = new LinkedList < > ( ) ; onExpressions . add ( builderExpression ( originOnExpressions . iterator ( ) . next ( ) , onTables ) ) ; join . setOnExpressions ( onExpressions ) ; leftTable = joinTable ; continue ; } onTableDeque . push ( onTables ) ; if ( originOnExpressions . size ( ) > <NUM_LIT> ) { Collection < Expression > onExpressions = new LinkedList < > ( ) ; for ( Expression originOnExpression : originOnExpressions ) { List < Table > currentTableList = onTableDeque . poll ( ) ; if ( CollectionUtils . isEmpty ( currentTableList ) ) { onExpressions . add ( originOnExpression ) ; } else { onExpressions . add ( builderExpression ( originOnExpression , currentTableList ) ) ; } } join . setOnExpressions ( onExpressions ) ; } leftTable = joinTable ; } else { processOtherFromItem ( joinItem ) ; leftTable = null ; } } return mainTables ; } public boolean doTenantFilter ( String tableName ) { return AuthUtil . isAdministrator ( ) && ! adminTenantTables . contains ( tableName ) ; } public boolean doTenantFilters ( List < Table > tables ) { List < String > tableNames = tables . stream ( ) . map ( Table :: getName ) . collect ( Collectors . toList ( ) ) ; return AuthUtil . isAdministrator ( ) && ! CollectionUtil . containsAny ( adminTenantTables , tableNames ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) @ AllArgsConstructor @ NoArgsConstructor public class BaseIfReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > ids ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Boolean enabled ;", "output": "}"}, {"input": "package ginyi . framework . security . interceptor ; import cn . hutool . crypto . SecureUtil ; import cn . hutool . extra . servlet . ServletUtil ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Component ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . concurrent . TimeUnit ; @ Slf4j @ Component public class PreviewEnvInterceptor implements HandlerInterceptor { @ Resource private RedisCache redisCache ; @ Value ( \"<STR_LIT>\" ) private String author ; @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String clientIP = ServletUtil . getClientIP ( request ) ; String userAgent = ServletUtil . getHeader ( request , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String key = CacheConstants . API_REQUEST + SecureUtil . md5 ( clientIP + userAgent ) + \"<STR_LIT>\" + clientIP + \"<STR_LIT>\" + request . getRequestURI ( ) ; Integer count = redisCache . getCacheObject ( key , Integer . class ) ; long expire = redisCache . getExpire ( key ) ; if ( StringUtils . isNull ( count ) ) { redisCache . setCacheObject ( key , <NUM_LIT> , <NUM_LIT> , TimeUnit . SECONDS ) ;", "output": "} else { if ( count >= <NUM_LIT> ) { redisCache . setCacheObject ( key , count + <NUM_LIT> , <NUM_LIT> , TimeUnit . SECONDS ) ; throw new CommonException ( StateCode . ERROR_LIMITED , CommonMessageConstants . SYS_BED_REQUEST ) ; } else { redisCache . setCacheObject ( key , count + <NUM_LIT> , ( int ) expire , TimeUnit . SECONDS ) ; } } return true ; } }"}, {"input": "package com . youlai . system . plugin . norepeat . annotation ; import java . lang . annotation . * ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Inherited public @ interface PreventRepeatSubmit {", "output": "int expire ( ) default <NUM_LIT> ; }"}, {"input": "package org . example . ddduser . domain . user . valueobject ; import com . baomidou . mybatisplus . annotation . EnumValue ; public enum UserStatus { ENABLE ( <NUM_LIT> ) , DISABLE ( <NUM_LIT> ) ; @ EnumValue private int value ; UserStatus ( int value ) { this . value = value ;", "output": "} }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . context . SpiderContextHolder ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . io . SeleniumResponse ; import top . kangert . kspider . model . WebElements ; import org . openqa . selenium . By ; import org . openqa . selenium . JavascriptExecutor ; import org . openqa . selenium . NoSuchElementException ; import org . openqa . selenium . WebElement ; import org . openqa . selenium . support . ui . ExpectedConditions ; import org . openqa . selenium . support . ui . WebDriverWait ; import org . springframework . stereotype . Component ; import java . time . Duration ; import java . util . List ; import java . util . Map ; @ Component public class SeleniumResponseFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return SeleniumResponse . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper selector ( SeleniumResponse response , String css ) { try { return new WebElementWrapper ( response , response . getDriver ( ) . findElement ( By . cssSelector ( css ) ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElements selectors ( SeleniumResponse response , String css ) { try { return new WebElements ( response , response . getDriver ( ) . findElements ( By . cssSelector ( css ) ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElements xpaths ( SeleniumResponse response , String xpath ) { try { return new WebElements ( response , response . getDriver ( ) . findElements ( By . xpath ( xpath ) ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElement xpath ( SeleniumResponse response , String xpath ) { try { return new WebElementWrapper ( response , response . getDriver ( ) . findElement ( By . xpath ( xpath ) ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object executeScript ( SeleniumResponse response , String script ) { return executeScript ( response , script , null ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object executeScript ( SeleniumResponse response , String script , List < Object > arguments ) { JavascriptExecutor executor ; try { executor = ( JavascriptExecutor ) response . getDriver ( ) ; } catch ( Throwable e ) { throw new RuntimeException ( \"<STR_LIT>\" ) ;", "output": "} return executor . executeScript ( script , arguments ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static SeleniumResponse toUrl ( SeleniumResponse response , String newUrl ) { response . getDriver ( ) . get ( newUrl ) ; return response ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static SeleniumResponse loadCookies ( SeleniumResponse response ) { SpiderContext spiderContext = SpiderContextHolder . get ( ) ; Map < String , String > cookieContext = spiderContext . getCookieContext ( ) ; Map < String , String > cookies = response . getCookies ( ) ; if ( cookies != null && ! cookies . isEmpty ( ) ) { cookieContext . putAll ( cookies ) ; } return response ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElement elementToBeClickableTimeOut ( SeleniumResponse response , String xpath , long timeout ) { WebDriverWait webDriverWait = new WebDriverWait ( response . getDriver ( ) , Duration . ofSeconds ( timeout ) ) ; WebElement webElement = webDriverWait . until ( ExpectedConditions . elementToBeClickable ( By . xpath ( xpath ) ) ) ; return new WebElementWrapper ( response , webElement ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElement elementToBeClickable ( SeleniumResponse response , String xpath ) { WebDriverWait webDriverWait = new WebDriverWait ( response . getDriver ( ) , Duration . ofSeconds ( <NUM_LIT> ) ) ; WebElement webElement = webDriverWait . until ( ExpectedConditions . elementToBeClickable ( By . xpath ( xpath ) ) ) ; return new WebElementWrapper ( response , webElement ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElement presenceOfElementLocated ( SeleniumResponse response , String xpath ) { WebDriverWait webDriverWait = new WebDriverWait ( response . getDriver ( ) , Duration . ofSeconds ( <NUM_LIT> ) ) ; WebElement webElement = webDriverWait . until ( ExpectedConditions . presenceOfElementLocated ( By . xpath ( xpath ) ) ) ; return new WebElementWrapper ( response , webElement ) ; } }"}, {"input": "package top . kangert . kspider . service ; import lombok . extern . slf4j . Slf4j ; import top . kangert . kspider . entity . BaseEntity ; import top . kangert . kspider . exception . BaseException ; import top . kangert . kspider . exception . ExceptionCodes ; import org . springframework . data . domain . PageRequest ; import org . springframework . data . domain . Pageable ; import org . springframework . data . jpa . domain . Specification ; import cn . hutool . core . bean . BeanUtil ; import javax . persistence . criteria . Predicate ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Slf4j public abstract class BaseService { protected Pageable processPage ( Map < String , Object > params ) { Integer currentPage = ( Integer ) params . get ( \"<STR_LIT>\" ) ; Integer pageSize = ( Integer ) params . get ( \"<STR_LIT>\" ) ; return PageRequest . of ( currentPage != null ? currentPage - <NUM_LIT> : <NUM_LIT> , pageSize != null ? pageSize : <NUM_LIT> ) ; } protected < T extends Object > Specification < T > multipleConditionsBuilder ( T obj ) { return multipleConditionsBuilder ( obj , false ) ; } protected < T extends Object > Specification < T > multipleConditionsBuilder ( T obj , Boolean isOr ) { Class < ? > clazz = obj . getClass ( ) ; Specification < T > specification = ( Specification < T > ) ( root , query , criteriaBuilder ) -> { List < Predicate > list = new ArrayList < > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { Object value ; try { value = field . get ( obj ) ; if ( ! ( \"<STR_LIT>\" ) . equals ( field . getName ( ) ) && ! ( \"<STR_LIT>\" ) . equals ( field . getName ( ) ) ) { if ( null == value ) { continue ; }", "output": "if ( value instanceof String ) { Predicate p1 = criteriaBuilder . like ( root . get ( field . getName ( ) ) , \"<STR_LIT>\" + field . get ( obj ) + \"<STR_LIT>\" ) ; list . add ( p1 ) ; } else { Predicate p1 = criteriaBuilder . equal ( root . get ( field . getName ( ) ) , field . get ( obj ) ) ; list . add ( p1 ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; continue ; } } if ( isOr ) { return criteriaBuilder . or ( list . toArray ( new Predicate [ <NUM_LIT> ] ) ) ; } else { return criteriaBuilder . and ( list . toArray ( new Predicate [ <NUM_LIT> ] ) ) ; } } ; return specification ; } protected < T extends Object > Specification < T > multipleConditionsBuilder ( Map < String , Object > params ) { return multipleConditionsBuilder ( params , false ) ; } protected < T extends Object > Specification < T > multipleConditionsBuilder ( Map < String , Object > params , Boolean isOr ) { if ( null == params ) throw new BaseException ( ExceptionCodes . ERROR ) ; Specification < T > specification = ( Specification < T > ) ( root , query , criteriaBuilder ) -> { List < Predicate > list = new ArrayList < > ( ) ; params . entrySet ( ) . stream ( ) . forEach ( item -> { Object value = params . get ( item . getKey ( ) ) ; if ( ! ( \"<STR_LIT>\" ) . equals ( item . getKey ( ) ) && ! ( \"<STR_LIT>\" ) . equals ( item . getKey ( ) ) ) { if ( null != value ) { if ( value instanceof String ) { Predicate p1 = criteriaBuilder . like ( root . get ( item . getKey ( ) ) , \"<STR_LIT>\" + value + \"<STR_LIT>\" ) ; list . add ( p1 ) ; } else { Predicate p1 = criteriaBuilder . equal ( root . get ( item . getKey ( ) ) , value ) ; list . add ( p1 ) ; } } } } ) ; if ( isOr ) { return criteriaBuilder . or ( list . toArray ( new Predicate [ <NUM_LIT> ] ) ) ; } else { return criteriaBuilder . and ( list . toArray ( new Predicate [ <NUM_LIT> ] ) ) ; } } ; return specification ; } protected void checkParams ( Map < String , Object > params , String [ ] keys ) { if ( keys != null ) { Boolean isError = false ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( String key : keys ) { if ( ! params . containsKey ( key ) ) { isError = true ; stringBuffer . append ( key + \"<STR_LIT>\" ) ; } } if ( stringBuffer . length ( ) > <NUM_LIT> ) { stringBuffer . deleteCharAt ( stringBuffer . length ( ) - <NUM_LIT> ) ; } if ( isError ) { throw new BaseException ( ExceptionCodes . ERROR , \"<STR_LIT>\" + stringBuffer . toString ( ) + \"<STR_LIT>\" ) ; } } } protected < T extends BaseEntity > T transformEntity ( Map < String , Object > params , Class < T > clazz ) { T anyObj = null ; try { anyObj = BeanUtil . toBean ( params , clazz ) ; } catch ( Exception e ) { throw new BaseException ( ExceptionCodes . ENTITY_TRANFORM_ERROR ) ; } return anyObj ; } protected void copyProperties ( Map < String , Object > source , Object target ) { BeanUtil . copyProperties ( source , target , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; } }"}, {"input": "package com . oddfar . campus . common . exception . file ; import org . apache . commons . fileupload . FileUploadException ; import java . util . Arrays ; public class InvalidExtensionException extends FileUploadException { private static final long serialVersionUID = <NUM_LIT> ; private String [ ] allowedExtension ; private String extension ; private String filename ; public InvalidExtensionException ( String [ ] allowedExtension , String extension , String filename ) { super ( \"<STR_LIT>\" + filename + \"<STR_LIT>\" + extension + \"<STR_LIT>\" + Arrays . toString ( allowedExtension ) + \"<STR_LIT>\" ) ; this . allowedExtension = allowedExtension ; this . extension = extension ;", "output": "this . filename = filename ; } public String [ ] getAllowedExtension ( ) { return allowedExtension ; } public String getExtension ( ) { return extension ; } public String getFilename ( ) { return filename ; } public static class InvalidImageExtensionException extends InvalidExtensionException { private static final long serialVersionUID = <NUM_LIT> ; public InvalidImageExtensionException ( String [ ] allowedExtension , String extension , String filename ) { super ( allowedExtension , extension , filename ) ; } } public static class InvalidFlashExtensionException extends InvalidExtensionException { private static final long serialVersionUID = <NUM_LIT> ; public InvalidFlashExtensionException ( String [ ] allowedExtension , String extension , String filename ) { super ( allowedExtension , extension , filename ) ; } } public static class InvalidMediaExtensionException extends InvalidExtensionException { private static final long serialVersionUID = <NUM_LIT> ; public InvalidMediaExtensionException ( String [ ] allowedExtension , String extension , String filename ) { super ( allowedExtension , extension , filename ) ; } } public static class InvalidVideoExtensionException extends InvalidExtensionException { private static final long serialVersionUID = <NUM_LIT> ; public InvalidVideoExtensionException ( String [ ] allowedExtension , String extension , String filename ) { super ( allowedExtension , extension , filename ) ; } } }"}, {"input": "package cn . org . alan . exam . model . form ; import jakarta . validation . constraints . NotBlank ; import lombok . Data ; @ Data public class GradeForm { @ NotBlank private String gradeName ; private String code ;", "output": "}"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class UserRoleReqDTO implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > userIds ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > roleIds ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer flag ;", "output": "}"}, {"input": "package top . kangert . kspider . domain . mapper ; import top . kangert . kspider . domain . DataSource ; import top . kangert . kspider . domain . dto . DataSourceDTO ; import top . kangert . kspider . domain . mapper . EntityMapper ; import org . mapstruct . Mapper ; import org . mapstruct . ReportingPolicy ; @ Mapper ( componentModel = \"<STR_LIT>\" , unmappedTargetPolicy = ReportingPolicy . IGNORE ) public interface DataSourceMapper extends EntityMapper < DataSource , DataSourceDTO > {", "output": "}"}, {"input": "package me . zhengjie . modules . security . service ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityNotFoundException ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . service . DataService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . modules . system . service . UserService ; import org . springframework . security . core . userdetails . UserDetailsService ; import org . springframework . security . core . userdetails . UsernameNotFoundException ; import org . springframework . stereotype . Service ; @ Slf4j @ RequiredArgsConstructor @ Service ( \"<STR_LIT>\" ) public class UserDetailsServiceImpl implements UserDetailsService { private final UserService userService ; private final RoleService roleService ; private final DataService dataService ; private final UserCacheManager userCacheManager ; @ Override public JwtUserDto loadUserByUsername ( String username ) { JwtUserDto jwtUserDto = userCacheManager . getUserCache ( username ) ; if ( jwtUserDto == null ) { User user ; try { user = userService . getLoginData ( username ) ; } catch ( EntityNotFoundException e ) { throw new UsernameNotFoundException ( username , e ) ; } if ( user == null ) { throw new UsernameNotFoundException ( \"<STR_LIT>\" ) ; } else { if ( ! user . getEnabled ( ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ;", "output": "} jwtUserDto = new JwtUserDto ( user , dataService . getDeptIds ( user ) , roleService . mapToGrantedAuthorities ( user ) ) ; userCacheManager . addUserCache ( username , jwtUserDto ) ; } } return jwtUserDto ; } }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . ContactHeadImgUrl ; public interface ContactHeadImgUrlMapper extends BaseMapper < ContactHeadImgUrl > {", "output": "}"}, {"input": "package ginyi . framework . security . filter ; import com . alibaba . fastjson2 . filter . SimplePropertyPreFilter ; public class PropertyPreExcludeFilter extends SimplePropertyPreFilter { public PropertyPreExcludeFilter ( ) { } public PropertyPreExcludeFilter addExcludes ( String ... filters ) { for ( int i = <NUM_LIT> ; i < filters . length ; i ++ ) { this . getExcludes ( ) . add ( filters [ i ] ) ;", "output": "} return this ; } }"}, {"input": "package io . github . chensheng . dddboot . web . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . METHOD } ) public @ interface IgnoreResponseWrapper {", "output": "}"}, {"input": "package ginyi . common . annotation ; import ginyi . common . enums . BusinessType ; import ginyi . common . enums . OperatorType ; import java . lang . annotation . * ; @ Target ( { ElementType . PARAMETER , ElementType . METHOD } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface Log { public String title ( ) default \"<STR_LIT>\" ; public BusinessType businessType ( ) default BusinessType . OTHER ; public OperatorType operatorType ( ) default OperatorType . MANAGE ;", "output": "public boolean isSaveRequestData ( ) default true ; public boolean isSaveResponseData ( ) default true ; }"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . model . form . MenuForm ; import com . youlai . system . common . model . Option ; import com . youlai . system . model . entity . SysMenu ; import com . youlai . system . model . query . MenuQuery ; import com . youlai . system . model . vo . MenuVO ; import com . youlai . system . model . vo . RouteVO ; import java . util . List ; import java . util . Set ; public interface SysMenuService extends IService < SysMenu > { List < MenuVO > listMenus ( MenuQuery queryParams ) ; List < Option > listMenuOptions ( ) ; boolean saveMenu ( MenuForm menuForm ) ; List < RouteVO > listRoutes ( Set < String > roles ) ;", "output": "boolean updateMenuVisible ( Long menuId , Integer visible ) ; MenuForm getMenuForm ( Long id ) ; boolean deleteMenu ( Long id ) ; }"}, {"input": "package com . yf . system . modules . depart . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDepartDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer deptType ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String deptCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer deptLevel ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date createTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date updateTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String createBy ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String updateBy ;", "output": "}"}, {"input": "package com . youlai . system . security . exception ; import com . youlai . system . common . result . ResultCode ; import com . youlai . system . common . util . ResponseUtils ; import org . springframework . security . authentication . BadCredentialsException ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . web . AuthenticationEntryPoint ; import org . springframework . stereotype . Component ; import jakarta . servlet . ServletException ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Component public class MyAuthenticationEntryPoint implements AuthenticationEntryPoint { @ Override public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) throws IOException , ServletException { int status = response . getStatus ( ) ; if ( status == HttpServletResponse . SC_NOT_FOUND ) { ResponseUtils . writeErrMsg ( response , ResultCode . RESOURCE_NOT_FOUND ) ; } else { if ( authException instanceof BadCredentialsException ) { ResponseUtils . writeErrMsg ( response , ResultCode . USERNAME_OR_PASSWORD_ERROR ) ; } else {", "output": "ResponseUtils . writeErrMsg ( response , ResultCode . TOKEN_INVALID ) ; } } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . config . NacosConfigLoader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import org . springframework . core . env . MapPropertySource ; import org . springframework . core . env . PropertySource ; import org . springframework . util . StringUtils ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . buildDefaultPropertySourceName ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . toProperties ; import static java . lang . String . format ; class NacosPropertySourceBuilder { private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; private String name ; private String dataId ; private String groupId ; private String type ; private Properties properties ; private ConfigurableEnvironment environment ; private BeanFactory beanFactory ; private NacosConfigLoader nacosConfigLoader ; public NacosPropertySourceBuilder name ( String name ) { this . name = name ; return this ; } public NacosPropertySourceBuilder dataId ( String dataId ) { this . dataId = dataId ; return this ; } public NacosPropertySourceBuilder groupId ( String groupId ) { this . groupId = groupId ; return this ; } public NacosPropertySourceBuilder properties ( Properties properties ) { this . properties = properties ; return this ; } public NacosPropertySourceBuilder type ( String type ) { this . type = type ; return this ; } public NacosPropertySourceBuilder environment ( ConfigurableEnvironment environment ) { this . environment = environment ; return this ; } public NacosPropertySourceBuilder beanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; return this ; }", "output": "public PropertySource build ( ) { nacosConfigLoader = new NacosConfigLoader ( environment ) ; NacosServiceFactory nacosServiceFactory = getNacosServiceFactoryBean ( beanFactory ) ; nacosConfigLoader . setNacosServiceFactory ( nacosServiceFactory ) ; String config = nacosConfigLoader . load ( dataId , groupId , properties ) ; if ( ! StringUtils . hasText ( config ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( format ( \"<STR_LIT>\" , dataId , groupId , properties ) ) ; } return null ; } Map < String , Object > properties = toProperties ( dataId , groupId , config , type ) ; if ( ! StringUtils . hasText ( name ) ) { name = buildDefaultPropertySourceName ( dataId , groupId , properties ) ; } return new MapPropertySource ( name , properties ) ; } public NacosConfigLoader getNacosConfigLoader ( ) { return nacosConfigLoader ; } }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . model . dto . PostDto ; import ginyi . system . domain . model . dto . RoleDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . PostVo ; import java . util . Set ; public interface ISysPostService { public BaseVo < PostVo > list ( PostDto postDto , Long page , Long pageSize ) ; public PostVo getPostByPostId ( Long postId ) ; public void addPost ( PostDto postDto ) ; public void updatePost ( PostDto postDto ) ; public void removePostById ( Long postId ) ;", "output": "void removeDeptByIds ( Set < Long > ids ) ; public void updateStatus ( PostDto postDto ) ; }"}, {"input": "package top . kangert . kspider . context ; import lombok . Getter ; import lombok . Setter ; import top . kangert . kspider . concurrent . SpiderThreadPoolExecutor ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . model . SpiderOutput ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . Future ; import java . util . concurrent . LinkedBlockingQueue ; public class SpiderContext { @ Getter private String id = UUID . randomUUID ( ) . toString ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; @ Getter @ Setter private volatile boolean running = true ; @ Getter @ Setter private SpiderThreadPoolExecutor . SubThreadPoolExecutor subThreadPool ; @ Getter @ Setter private SpiderNode root ; @ Getter @ Setter private Long flowId ; @ Getter private Map < String , String > cookieContext = new HashMap < > ( ) ; @ Getter private Map < String , Object > extends_map = new ConcurrentHashMap < > ( ) ; @ Getter private LinkedBlockingQueue < Future < ? > > futureTaskQueue = new LinkedBlockingQueue < > ( ) ; public List < SpiderOutput > getOutputs ( ) { return Collections . emptyList ( ) ; } public void pause ( String nodeId , String event , String key , Object value ) { } public void resume ( ) { }", "output": "public void stop ( ) { } public void addOutput ( SpiderOutput output ) { } }"}, {"input": "package com . xcs . wx . constant ; import cn . hutool . extra . spring . SpringUtil ; import com . baomidou . dynamic . datasource . DynamicRoutingDataSource ; import com . xcs . wx . service . UserService ; import javax . sql . DataSource ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; public class DataSourceType { public static final String APPLET_DB = \"<STR_LIT>\" ; public static final String BIZ_CHAT_DB = \"<STR_LIT>\" ; public static final String BIZ_CHAT_MSG_DB = \"<STR_LIT>\" ; public static final String CHAT_MSG_DB = \"<STR_LIT>\" ; public static final String CHAT_ROOM_USER_DB = \"<STR_LIT>\" ; public static final String CLIENT_CONFIG_DB = \"<STR_LIT>\" ; public static final String CLIENT_GENERAL_DB = \"<STR_LIT>\" ; public static final String CUSTOMER_SERVICE_DB = \"<STR_LIT>\" ; public static final String EMOTION_DB = \"<STR_LIT>\" ; public static final String FAVORITE_DB = \"<STR_LIT>\" ; public static final String FTS_CONTACT_DB = \"<STR_LIT>\" ; public static final String FTS_FAVORITE_DB = \"<STR_LIT>\" ; public static final String FTS_MSG_DB = \"<STR_LIT>\" ; public static final String FUNCTION_MSG_DB = \"<STR_LIT>\" ; public static final String HARD_LINK_FILE_DB = \"<STR_LIT>\" ; public static final String HARD_LINK_IMAGE_DB = \"<STR_LIT>\" ; public static final String HARD_LINK_VIDEO_DB = \"<STR_LIT>\" ; public static final String IMAGE_TRANSLATE_DB = \"<STR_LIT>\" ; public static final String LINK_HISTORY_DB = \"<STR_LIT>\" ; public static final String MEDIA_DB = \"<STR_LIT>\" ; public static final String MICRO_MSG_DB = \"<STR_LIT>\" ; public static final String MISC_DB = \"<STR_LIT>\" ; public static final String MULTI_SEARCH_CHAT_MSG_DB = \"<STR_LIT>\" ; public static final String NEW_TIPS_DB = \"<STR_LIT>\" ; public static final String OPEN_IM_CONTACT_DB = \"<STR_LIT>\" ; public static final String OPEN_IM_MEDIA_DB = \"<STR_LIT>\" ; public static final String OPEN_IM_MSG_DB = \"<STR_LIT>\" ; public static final String OPEN_IM_RESOURCE_DB = \"<STR_LIT>\" ; public static final String PRE_DOWNLOAD_DB = \"<STR_LIT>\" ; public static final String PUBLIC_MSG_DB = \"<STR_LIT>\" ; public static final String PUBLIC_MSG_MEDIA_DB = \"<STR_LIT>\" ; public static final String SNS_DB = \"<STR_LIT>\" ; public static final String STORE_EMOTION_DB = \"<STR_LIT>\" ; public static final String VOIP_DB = \"<STR_LIT>\" ; public static final String MSG_DB = \"<STR_LIT>\" ; public static final String MSG0_DB = \"<STR_LIT>\" ; public static List < String > getMsgDb ( ) { String wxId = SpringUtil . getBean ( UserService . class ) . currentUser ( ) ; if ( wxId == null ) { return Collections . emptyList ( ) ; }", "output": "return getDb ( wxId + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } private static List < String > getDb ( String pattern ) { DynamicRoutingDataSource dynamicRoutingDataSource = SpringUtil . getBean ( DynamicRoutingDataSource . class ) ; Map < String , DataSource > dataSources = dynamicRoutingDataSource . getDataSources ( ) ; return dataSources . keySet ( ) . stream ( ) . filter ( key -> key . matches ( pattern ) ) . sorted ( Comparator . naturalOrder ( ) ) . collect ( Collectors . toList ( ) ) ; } }"}, {"input": "package com . oddfar . campus . framework . aspectj ; import cn . hutool . core . util . StrUtil ; import cn . hutool . extra . spring . SpringUtil ; import com . alibaba . fastjson2 . JSON ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . annotation . Log ; import com . oddfar . campus . common . domain . entity . SysOperLogEntity ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . enums . BusinessStatus ; import com . oddfar . campus . common . filter . PropertyPreExcludeFilter ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . ip . IpUtils ; import com . oddfar . campus . framework . api . sysconfig . ConfigExpander ; import org . aspectj . lang . JoinPoint ; import org . aspectj . lang . annotation . AfterReturning ; import org . aspectj . lang . annotation . AfterThrowing ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . aspectj . lang . reflect . MethodSignature ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . http . HttpMethod ; import org . springframework . stereotype . Component ; import org . springframework . validation . BindingResult ; import org . springframework . web . multipart . MultipartFile ; import org . springframework . web . servlet . HandlerMapping ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Collection ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Aspect @ Component public class LogAspect { private static final Logger log = LoggerFactory . getLogger ( LogAspect . class ) ; public static final String [ ] EXCLUDE_PROPERTIES = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ Value ( \"<STR_LIT>\" ) private String springApplicationName ; @ Pointcut ( \"<STR_LIT>\" ) public void webLog ( ) { } @ AfterReturning ( pointcut = \"<STR_LIT>\" , returning = \"<STR_LIT>\" ) public void doAfterReturning ( JoinPoint joinPoint , Object jsonResult ) { boolean ensureMakeLog = this . ensureMakeLog ( joinPoint ) ; if ( ! ensureMakeLog ) { return ; } Map < String , Object > annotationProp = getAnnotationProp ( joinPoint ) ; handleLog ( joinPoint , annotationProp , null , jsonResult ) ; } @ AfterThrowing ( pointcut = \"<STR_LIT>\" , throwing = \"<STR_LIT>\" ) public void doAfterThrowing ( JoinPoint joinPoint , Exception e ) { boolean ensureMakeLog = this . ensureMakeLog ( joinPoint ) ; if ( ! ensureMakeLog ) { return ; } Map < String , Object > annotationProp = getAnnotationProp ( joinPoint ) ; handleLog ( joinPoint , annotationProp , e , null ) ; } private Map < String , Object > getAnnotationProp ( JoinPoint joinPoint ) { MethodSignature methodSignature = ( MethodSignature ) joinPoint . getSignature ( ) ; Method method = methodSignature . getMethod ( ) ; Map < String , Object > propMap = new HashMap < > ( <NUM_LIT> ) ; ApiResource apiResource = method . getDeclaringClass ( ) . getAnnotation ( ApiResource . class ) ; for ( Annotation annotation : method . getAnnotations ( ) ) { if ( annotation . toString ( ) . contains ( \"<STR_LIT>\" ) ) { String name = invokeAnnotationMethod ( annotation , \"<STR_LIT>\" , String . class ) ; propMap . put ( \"<STR_LIT>\" , StringUtils . isNull ( name ) ? \"<STR_LIT>\" : name ) ; } } propMap . put ( \"<STR_LIT>\" , apiResource != null && StrUtil . isNotBlank ( apiResource . appCode ( ) ) ? apiResource . appCode ( ) : springApplicationName ) ; return propMap ; } protected void handleLog ( final JoinPoint joinPoint , Map < String , Object > annotationProp , final Exception e , Object jsonResult ) { try { SysOperLogEntity operLog = new SysOperLogEntity ( ) ; operLog . setAppName ( annotationProp . get ( \"<STR_LIT>\" ) . toString ( ) ) ; operLog . setLogName ( \"<STR_LIT>\" ) ; operLog . setLogContent ( annotationProp . get ( \"<STR_LIT>\" ) . toString ( ) ) ; operLog . setStatus ( BusinessStatus . SUCCESS . ordinal ( ) ) ; String ip = IpUtils . getIpAddr ( ServletUtils . getRequest ( ) ) ; operLog . setOperIp ( ip ) ; operLog . setOperUrl ( StringUtils . substring ( ServletUtils . getRequest ( ) . getRequestURI ( ) , <NUM_LIT> , <NUM_LIT> ) ) ; if ( SecurityUtils . isLogin ( ) ) { LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; operLog . setOperUserId ( loginUser . getUserId ( ) ) ; } if ( e != null ) { operLog . setStatus ( BusinessStatus . FAIL . ordinal ( ) ) ; operLog . setErrorMsg ( StringUtils . substring ( e . getMessage ( ) , <NUM_LIT> , <NUM_LIT> ) ) ; } String className = joinPoint . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = joinPoint . getSignature ( ) . getName ( ) ; operLog . setMethod ( className + \"<STR_LIT>\" + methodName + \"<STR_LIT>\" ) ; operLog . setRequestMethod ( ServletUtils . getRequest ( ) . getMethod ( ) ) ; getControllerMethodDescription ( joinPoint , operLog , jsonResult ) ; operLog . setOperTime ( new Date ( ) ) ; SpringUtil . getApplicationContext ( ) . publishEvent ( operLog ) ; } catch ( Exception exp ) { log . error ( \"<STR_LIT>\" ) ; log . error ( \"<STR_LIT>\" , exp . getMessage ( ) ) ; exp . printStackTrace ( ) ; } } public void getControllerMethodDescription ( JoinPoint joinPoint , SysOperLogEntity operLog , Object jsonResult ) throws Exception { setRequestValue ( joinPoint , operLog ) ; if ( StringUtils . isNotNull ( jsonResult ) ) { operLog . setJsonResult ( StringUtils . substring ( JSON . toJSONString ( jsonResult ) , <NUM_LIT> , <NUM_LIT> ) ) ; } } private void setRequestValue ( JoinPoint joinPoint , SysOperLogEntity operLog ) throws Exception { String requestMethod = operLog . getRequestMethod ( ) ; if ( HttpMethod . PUT . name ( ) . equals ( requestMethod ) || HttpMethod . POST . name ( ) . equals ( requestMethod ) ) { String params = argsArrayToString ( joinPoint . getArgs ( ) ) ; operLog . setOperParam ( StringUtils . substring ( params , <NUM_LIT> , <NUM_LIT> ) ) ; } else { Map < ? , ? > paramsMap = ( Map < ? , ? > ) ServletUtils . getRequest ( ) . getAttribute ( HandlerMapping . URI_TEMPLATE_VARIABLES_ATTRIBUTE ) ; operLog . setOperParam ( StringUtils . substring ( paramsMap . toString ( ) , <NUM_LIT> , <NUM_LIT> ) ) ; } } private String argsArrayToString ( Object [ ] paramsArray ) { String params = \"<STR_LIT>\" ; if ( paramsArray != null && paramsArray . length > <NUM_LIT> ) { for ( Object o : paramsArray ) { if ( StringUtils . isNotNull ( o ) && ! isFilterObject ( o ) ) { try { String jsonObj = JSON . toJSONString ( o , excludePropertyPreFilter ( ) ) ; params += jsonObj . toString ( ) + \"<STR_LIT>\" ; } catch ( Exception e ) { } } } } return params . trim ( ) ; } private boolean ensureMakeLog ( JoinPoint point ) { Boolean openFlag = ConfigExpander . getGlobalControllerOpenFlag ( ) ; Class < ? > controllerClass = point . getTarget ( ) . getClass ( ) ; Log businessLog = controllerClass . getAnnotation ( Log . class ) ; Log methodBusinessLog = null ; MethodSignature methodSignature = null ; if ( ! ( point . getSignature ( ) instanceof MethodSignature ) ) { return false ; } methodSignature = ( MethodSignature ) point . getSignature ( ) ; Object target = point . getTarget ( ) ; try { Method currentMethod = target . getClass ( ) . getMethod ( methodSignature . getName ( ) , methodSignature . getParameterTypes ( ) ) ; methodBusinessLog = currentMethod . getAnnotation ( Log . class ) ; } catch ( NoSuchMethodException e ) { return false ; } if ( openFlag ) { if ( businessLog != null && ! businessLog . openLog ( ) ) { return false ; } return methodBusinessLog == null || methodBusinessLog . openLog ( ) ; } else { if ( businessLog != null && businessLog . openLog ( ) ) { return true ; } return methodBusinessLog != null && methodBusinessLog . openLog ( ) ; } } private < T > T invokeAnnotationMethod ( Annotation apiResource , String methodName , Class < T > resultType ) { try { Class < ? extends Annotation > annotationType = apiResource . annotationType ( ) ;", "output": "Method method = annotationType . getMethod ( methodName ) ; return ( T ) method . invoke ( apiResource ) ; } catch ( NoSuchMethodException | IllegalAccessException | InvocationTargetException e ) { } return null ; } public PropertyPreExcludeFilter excludePropertyPreFilter ( ) { return new PropertyPreExcludeFilter ( ) . addExcludes ( EXCLUDE_PROPERTIES ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean isFilterObject ( final Object o ) { Class < ? > clazz = o . getClass ( ) ; if ( clazz . isArray ( ) ) { return clazz . getComponentType ( ) . isAssignableFrom ( MultipartFile . class ) ; } else if ( Collection . class . isAssignableFrom ( clazz ) ) { Collection collection = ( Collection ) o ; for ( Object value : collection ) { return value instanceof MultipartFile ; } } else if ( Map . class . isAssignableFrom ( clazz ) ) { Map map = ( Map ) o ; for ( Object value : map . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) value ; return entry . getValue ( ) instanceof MultipartFile ; } } return o instanceof MultipartFile || o instanceof HttpServletRequest || o instanceof HttpServletResponse || o instanceof BindingResult ; } }"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; import com . youlai . system . enums . LogModuleEnum ; import lombok . Data ; @ Data public class SysLog implements Serializable { @ TableId ( type = IdType . AUTO ) private Long id ; private LogModuleEnum module ; private String content ; private String requestUri ; private String ip ; private String province ; private String city ; private String browser ; private String browserVersion ; private String os ; private Long executionTime ; private Long createBy ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ;", "output": "}"}, {"input": "package com . xcs . wx . domain . dto ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ Data @ EqualsAndHashCode ( callSuper = true ) public class RecoverContactDTO extends PageDTO { private String nickname ; private String remark ;", "output": "}"}, {"input": "package com . youlai . system . controller ; import com . youlai . system . enums . LogModuleEnum ; import com . youlai . system . common . result . Result ; import com . youlai . system . model . dto . CaptchaResult ; import com . youlai . system . model . dto . LoginResult ; import com . youlai . system . plugin . syslog . annotation . LogAnnotation ; import com . youlai . system . service . AuthService ; import io . swagger . v3 . oas . annotations . Operation ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . web . bind . annotation . * ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor @ Slf4j public class AuthController { private final AuthService authService ; @ Operation ( summary = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ LogAnnotation ( value = \"<STR_LIT>\" , module = LogModuleEnum . LOGIN ) public Result < LoginResult > login ( @ Parameter ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ RequestParam String username , @ Parameter ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ RequestParam String password ) { LoginResult loginResult = authService . login ( username , password ) ; return Result . success ( loginResult ) ; }", "output": "@ Operation ( summary = \"<STR_LIT>\" ) @ DeleteMapping ( \"<STR_LIT>\" ) @ LogAnnotation ( value = \"<STR_LIT>\" , module = LogModuleEnum . LOGIN ) public Result logout ( ) { authService . logout ( ) ; return Result . success ( ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < CaptchaResult > getCaptcha ( ) { CaptchaResult captcha = authService . getCaptcha ( ) ; return Result . success ( captcha ) ; } }"}, {"input": "package com . yf . system . modules . depart . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . yf . ability . redis . service . RedisService ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . BeanMapper ; import com . yf . base . enums . DataScope ; import com . yf . base . utils . DeptCodeGen ; import com . yf . system . modules . depart . dto . SysDepartDTO ; import com . yf . system . modules . depart . dto . request . DepartQueryReqDTO ; import com . yf . system . modules . depart . dto . request . DepartSortReqDTO ; import com . yf . system . modules . depart . dto . response . SysDepartTreeDTO ; import com . yf . system . modules . depart . entity . SysDepart ; import com . yf . system . modules . depart . mapper . SysDepartMapper ; import com . yf . system . modules . depart . service . SysDepartService ; import com . yf . system . modules . user . UserUtils ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . ArrayList ; import java . util . List ; @ Service public class SysDepartServiceImpl extends ServiceImpl < SysDepartMapper , SysDepart > implements SysDepartService { private static final String ROOT_TAG = \"<STR_LIT>\" ; private static final String LOCK_DEPT = \"<STR_LIT>\" ; @ Autowired private RedisService redisService ; @ Transactional ( rollbackFor = Exception . class ) @ Override public void save ( SysDepartDTO reqDTO ) { boolean lock = redisService . tryLock ( LOCK_DEPT , <NUM_LIT> ) ; if ( ! lock ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } try { SysDepart entity = new SysDepart ( ) ; BeanMapper . copy ( reqDTO , entity ) ; if ( StringUtils . isBlank ( reqDTO . getId ( ) ) ) { this . fillCode ( entity ) ; } else { reqDTO . setSort ( null ) ; reqDTO . setDeptCode ( null ) ; } this . saveOrUpdate ( entity ) ; } finally { redisService . del ( LOCK_DEPT ) ; } } @ Override public List < SysDepartTreeDTO > findTree ( boolean self ) { DepartQueryReqDTO reqDTO = new DepartQueryReqDTO ( ) ; if ( self ) { this . appendDeptQuery ( reqDTO ) ; } List < SysDepartTreeDTO > treeData = baseMapper . tree ( reqDTO ) ; return treeData ; } @ Override public void sort ( DepartSortReqDTO reqDTO ) { SysDepart form = this . getById ( reqDTO . getForm ( ) ) ; SysDepart to = this . getById ( reqDTO . getTo ( ) ) ; int fromSort = form . getSort ( ) ; int toSort = to . getSort ( ) ; form . setSort ( toSort ) ; to . setSort ( fromSort ) ; this . updateById ( form ) ; this . updateById ( to ) ; } @ Override public String syncDepart ( String str ) { String [ ] arr = str . split ( \"<STR_LIT>\" ) ; List < String > subs = new ArrayList < > ( ) ; String parentId = ROOT_TAG ; String deptCode = null ; for ( int i = <NUM_LIT> ; i < arr . length ; i ++ ) { subs . add ( arr [ i ] ) ; SysDepart depart = this . findLastChild ( subs ) ; if ( depart != null ) { parentId = depart . getId ( ) ; deptCode = depart . getDeptCode ( ) ; } else { List < String > left = new ArrayList < > ( ) ; for ( int j = i ; j < arr . length ; j ++ ) { left . add ( arr [ j ] ) ; } deptCode = this . createSubs ( parentId , left ) ; break ; } } return deptCode ; } @ Transactional ( rollbackFor = Exception . class ) @ Override public void delete ( List < String > ids ) { QueryWrapper < SysDepart > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysDepart :: getParentId , ids ) ; long count = this . count ( wrapper ) ; if ( count > <NUM_LIT> ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } this . removeByIds ( ids ) ; } private SysDepart findLastChild ( List < String > list ) { String parentId = ROOT_TAG ; for ( int i = <NUM_LIT> ; i < list . size ( ) ; i ++ ) { SysDepart depart = this . findDeptByName ( parentId , list . get ( i ) ) ; if ( depart == null ) { return null ; } parentId = depart . getId ( ) ; if ( i >= list . size ( ) - <NUM_LIT> ) { return depart ; } } return null ; } private String createSubs ( String parentId , List < String > list ) { String deptCode = null ; for ( String name : list ) { SysDepart entity = new SysDepart ( ) ; entity . setDeptName ( name ) ; entity . setParentId ( parentId ) ; this . fillCode ( entity ) ; this . save ( entity ) ; parentId = entity . getId ( ) ; deptCode = entity . getDeptCode ( ) ; } return deptCode ; } public SysDepart findDeptByName ( String parentId , String name ) { QueryWrapper < SysDepart > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysDepart :: getDeptName , name ) . eq ( SysDepart :: getParentId , parentId ) ; return this . getOne ( wrapper , false ) ; } private void fillCode ( SysDepart depart ) { String code = \"<STR_LIT>\" ; if ( StringUtils . isNotBlank ( depart . getParentId ( ) ) && ! ROOT_TAG . equals ( depart . getParentId ( ) ) ) { SysDepart parent = this . getById ( depart . getParentId ( ) ) ; code = parent . getDeptCode ( ) ; } QueryWrapper < SysDepart > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysDepart :: getParentId , depart . getParentId ( ) ) . orderByDesc ( SysDepart :: getSort ) ; wrapper . last ( \"<STR_LIT>\" ) ; SysDepart max = this . getOne ( wrapper , false ) ; if ( max != null ) { code += DeptCodeGen . gen ( max . getSort ( ) + <NUM_LIT> ) ; depart . setSort ( max . getSort ( ) + <NUM_LIT> ) ; } else { code += DeptCodeGen . gen ( <NUM_LIT> ) ; depart . setSort ( <NUM_LIT> ) ; } depart . setDeptCode ( code ) ; } private void appendDeptQuery ( DepartQueryReqDTO params ) { String code = UserUtils . departCode ( ) ;", "output": "Integer scope = UserUtils . getDataScope ( ) ; if ( ! DataScope . SCOPE_ALL . equals ( scope ) ) { int length = code . length ( ) / <NUM_LIT> ; StringBuffer sb = null ; for ( int i = <NUM_LIT> ; i < length ; i ++ ) { String sub = code . substring ( <NUM_LIT> , ( i + <NUM_LIT> ) * <NUM_LIT> ) ; if ( sb == null ) { sb = new StringBuffer ( ) ; } else { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( \"<STR_LIT>\" + sub + \"<STR_LIT>\" ) ; } params . setDeptCodes ( sb . toString ( ) ) ; if ( DataScope . SCOPE_DEPT_DOWN . equals ( scope ) ) { params . setLikeCode ( code ) ; } } } }"}, {"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; public abstract class BaseExcelWriter implements ExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( BaseExcelWriter . class ) ; @ Override public void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception { if ( outputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowWritingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } try { WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doWrite ( outputStream , templateIs , rowWritingListener , workbookConfig ) ; } finally { if ( templateIs != null ) { try { templateIs . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } }", "output": "} } protected abstract void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception ; }"}, {"input": "package top . kangert . kspider . expression . parsing ; public class Token { private final TokenType type ; private final Span span ; public Token ( TokenType type , Span span ) { this . type = type ; this . span = span ; } public TokenType getType ( ) {", "output": "return type ; } public Span getSpan ( ) { return span ; } public String getText ( ) { return span . getText ( ) ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + type + \"<STR_LIT>\" + span + \"<STR_LIT>\" ; } }"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . model . entity . SysUser ; import com . youlai . system . model . form . UserForm ; import com . youlai . system . model . dto . UserAuthInfo ; import com . youlai . system . model . query . UserPageQuery ; import com . youlai . system . model . dto . UserExportDTO ; import com . youlai . system . model . vo . UserInfoVO ; import com . youlai . system . model . vo . UserPageVO ; import java . util . List ; public interface SysUserService extends IService < SysUser > { IPage < UserPageVO > listPagedUsers ( UserPageQuery queryParams ) ; UserForm getUserFormData ( Long userId ) ; boolean saveUser ( UserForm userForm ) ;", "output": "boolean updateUser ( Long userId , UserForm userForm ) ; boolean deleteUsers ( String idsStr ) ; boolean updatePassword ( Long userId , String password ) ; UserAuthInfo getUserAuthInfo ( String username ) ; List < UserExportDTO > listExportUsers ( UserPageQuery queryParams ) ; UserInfoVO getCurrentUserInfo ( ) ; }"}, {"input": "package com . youlai . system . model . form ; import com . youlai . system . enums . MenuTypeEnum ; import com . youlai . system . common . model . KeyValue ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class MenuForm { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private Long parentId ; @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private MenuTypeEnum type ; @ Schema ( description = \"<STR_LIT>\" ) private String routeName ; @ Schema ( description = \"<STR_LIT>\" ) private String routePath ; @ Schema ( description = \"<STR_LIT>\" ) private String component ; @ Schema ( description = \"<STR_LIT>\" ) private String perm ; @ Schema ( description = \"<STR_LIT>\" ) private Integer visible ; @ Schema ( description = \"<STR_LIT>\" ) private Integer sort ; @ Schema ( description = \"<STR_LIT>\" ) private String icon ; @ Schema ( description = \"<STR_LIT>\" ) private String redirect ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer keepAlive ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer alwaysShow ; @ Schema ( description = \"<STR_LIT>\" ) private List < KeyValue > params ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . aspectj ; import cn . hutool . core . util . ArrayUtil ; import com . oddfar . campus . common . annotation . RateLimiter ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . enums . LimitType ; import com . oddfar . campus . common . exception . ServiceException ; import com . oddfar . campus . common . utils . MessageUtils ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . ip . IpUtils ; import org . aspectj . lang . JoinPoint ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Before ; import org . aspectj . lang . reflect . MethodSignature ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . core . DefaultParameterNameDiscoverer ; import org . springframework . core . ParameterNameDiscoverer ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . script . RedisScript ; import org . springframework . expression . EvaluationContext ; import org . springframework . expression . Expression ; import org . springframework . expression . ExpressionParser ; import org . springframework . expression . ParserContext ; import org . springframework . expression . common . TemplateParserContext ; import org . springframework . expression . spel . standard . SpelExpressionParser ; import org . springframework . expression . spel . support . StandardEvaluationContext ; import org . springframework . stereotype . Component ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . List ; @ Aspect @ Component public class RateLimiterAspect { private static final Logger log = LoggerFactory . getLogger ( RateLimiterAspect . class ) ; private RedisTemplate < Object , Object > redisTemplate ; private RedisScript < Long > limitScript ; private final ExpressionParser parser = new SpelExpressionParser ( ) ; private final ParserContext parserContext = new TemplateParserContext ( ) ; private final EvaluationContext context = new StandardEvaluationContext ( ) ; private final ParameterNameDiscoverer pnd = new DefaultParameterNameDiscoverer ( ) ; @ Autowired public void setRedisTemplate1 ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; } @ Autowired public void setLimitScript ( RedisScript < Long > limitScript ) { this . limitScript = limitScript ; } @ Before ( \"<STR_LIT>\" ) public void doBefore ( JoinPoint point , RateLimiter rateLimiter ) throws Throwable { int time = rateLimiter . time ( ) ; int count = rateLimiter . count ( ) ; String combineKey = getCombineKey ( rateLimiter , point ) ; List < Object > keys = Collections . singletonList ( combineKey ) ; try { Long number = redisTemplate . execute ( limitScript , keys , count , time ) ; if ( StringUtils . isNull ( number ) || number . intValue ( ) > count ) { String message = rateLimiter . message ( ) ; if ( StringUtils . startsWith ( message , \"<STR_LIT>\" ) && StringUtils . endsWith ( message , \"<STR_LIT>\" ) ) { message = MessageUtils . message ( StringUtils . substring ( message , <NUM_LIT> , message . length ( ) - <NUM_LIT> ) ) ; } throw new ServiceException ( message ) ; } log . info ( \"<STR_LIT>\" , count , number . intValue ( ) , combineKey ) ; } catch ( ServiceException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } } public String getCombineKey ( RateLimiter rateLimiter , JoinPoint point ) { String key = rateLimiter . key ( ) ; MethodSignature signature = ( MethodSignature ) point . getSignature ( ) ; Method method = signature . getMethod ( ) ; if ( StringUtils . containsAny ( key , \"<STR_LIT>\" ) ) { Object [ ] args = point . getArgs ( ) ; String [ ] parameterNames = pnd . getParameterNames ( method ) ; if ( ArrayUtil . isEmpty ( parameterNames ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } for ( int i = <NUM_LIT> ; i < parameterNames . length ; i ++ ) { context . setVariable ( parameterNames [ i ] , args [ i ] ) ; } try { Expression expression ; if ( StringUtils . startsWith ( key , parserContext . getExpressionPrefix ( ) ) && StringUtils . endsWith ( key , parserContext . getExpressionSuffix ( ) ) ) { expression = parser . parseExpression ( key , parserContext ) ; } else { expression = parser . parseExpression ( key ) ; } key = expression . getValue ( context , String . class ) + \"<STR_LIT>\" ; } catch ( Exception e ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } }", "output": "StringBuffer stringBuffer = new StringBuffer ( CacheConstants . RATE_LIMIT_KEY ) ; stringBuffer . append ( ServletUtils . getRequest ( ) . getRequestURI ( ) ) . append ( \"<STR_LIT>\" ) ; if ( rateLimiter . limitType ( ) == LimitType . IP ) { stringBuffer . append ( IpUtils . getIpAddr ( ) ) . append ( \"<STR_LIT>\" ) ; } return stringBuffer . append ( key ) . toString ( ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BaseTokenReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String token ;", "output": "}"}, {"input": "package ginyi . system . domain ; import com . baomidou . mybatisplus . annotation . TableId ; import lombok . Data ; import org . apache . commons . lang3 . builder . ToStringBuilder ; import org . apache . commons . lang3 . builder . ToStringStyle ; @ Data public class SysConfig extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId private Long configId ; private String configName ; private String configKey ; private String configValue ; private String configType ;", "output": "}"}, {"input": "package com . yf . ability . redis . service . impl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . yf . ability . redis . service . RedisService ; import com . yf . base . utils . jackson . JsonHelper ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . stereotype . Service ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ Service public class RedisServiceImpl implements RedisService { private static final String lock = \"<STR_LIT>\" ; @ Autowired private RedisTemplate < String , String > redisTemplate ; @ Override public void del ( String ... keys ) { if ( keys != null && keys . length > <NUM_LIT> ) { if ( keys . length == <NUM_LIT> ) { redisTemplate . delete ( keys [ <NUM_LIT> ] ) ; } else { List < String > list = Arrays . asList ( keys ) ; redisTemplate . delete ( list ) ; } } } @ Override public Map < String , Object > getJson ( String key ) { String json = this . get ( key ) ; if ( ! StringUtils . isBlank ( json ) ) { return JsonHelper . parseObject ( json , new TypeReference < Map < String , Object > > ( ) { } ) ; } return null ; } @ Override public String getString ( String key ) { return get ( key ) ; } @ Override public boolean tryLock ( String key , Long ms , int tryCount , long tryWait ) { int hasTry = <NUM_LIT> ; Boolean hasGet = null ; while ( ( hasGet == null || ! hasGet ) && hasTry <= tryCount ) { if ( hasTry > <NUM_LIT> ) { try { Thread . sleep ( tryWait ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } hasGet = redisTemplate . opsForValue ( ) . setIfAbsent ( key , lock , ms , TimeUnit . MILLISECONDS ) ; hasTry ++ ; } return hasGet != null && hasGet ;", "output": "} @ Override public boolean tryLock ( String key , Long ms ) { return tryLock ( key , ms , <NUM_LIT> , <NUM_LIT> ) ; } @ Override public void unlock ( String key ) { redisTemplate . delete ( key ) ; } public String get ( String key ) { return redisTemplate . opsForValue ( ) . get ( key ) ; } @ Override public boolean set ( String key , String data ) { try { redisTemplate . opsForValue ( ) . set ( key , data ) ; return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } @ Override public boolean set ( String key , String value , Long time ) { try { if ( time > <NUM_LIT> ) { redisTemplate . opsForValue ( ) . set ( key , value , time , TimeUnit . SECONDS ) ; } else { this . set ( key , value ) ; } return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } @ Override public boolean putList ( String key , String value ) { redisTemplate . opsForList ( ) . leftPush ( key , value ) ; return true ; } @ Override public boolean removeList ( String key , String value ) { redisTemplate . opsForList ( ) . remove ( key , <NUM_LIT> , value ) ; return true ; } @ Override public List < String > findList ( String key ) { return redisTemplate . opsForList ( ) . range ( key , <NUM_LIT> , - <NUM_LIT> ) ; } @ Override public boolean hasKey ( String key ) { Boolean has = redisTemplate . hasKey ( key ) ; return has != null && has ; } }"}, {"input": "package com . yf . system . modules . plugin . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . base . utils . BeanMapper ; import com . yf . base . utils . jackson . JsonHelper ; import com . yf . system . modules . plugin . dto . PluginGroupDTO ; import com . yf . system . modules . plugin . entity . PluginGroup ; import com . yf . system . modules . plugin . mapper . PluginGroupMapper ; import com . yf . system . modules . plugin . service . PluginGroupService ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class PluginGroupServiceImpl extends ServiceImpl < PluginGroupMapper , PluginGroup > implements PluginGroupService { @ Override public IPage < PluginGroupDTO > paging ( PagingReqDTO < PluginGroupDTO > reqDTO ) { QueryWrapper < PluginGroup > wrapper = new QueryWrapper < > ( ) ; PluginGroupDTO params = reqDTO . getParams ( ) ; IPage < PluginGroup > page = this . page ( reqDTO . toPage ( ) , wrapper ) ; IPage < PluginGroupDTO > pageData = JsonHelper . parseObject ( page , new TypeReference < Page < PluginGroupDTO > > ( ) { } ) ; return pageData ; } @ Override public void save ( PluginGroupDTO reqDTO ) { PluginGroup entity = new PluginGroup ( ) ; BeanMapper . copy ( reqDTO , entity ) ; this . saveOrUpdate ( entity ) ; } @ Override public void delete ( List < String > ids ) { this . removeByIds ( ids ) ; } @ Override public PluginGroupDTO detail ( String id ) { PluginGroup entity = this . getById ( id ) ; PluginGroupDTO dto = new PluginGroupDTO ( ) ; BeanMapper . copy ( entity , dto ) ; return dto ;", "output": "} @ Override public List < PluginGroupDTO > list ( PluginGroupDTO reqDTO ) { QueryWrapper < PluginGroup > wrapper = new QueryWrapper < > ( ) ; List < PluginGroup > list = this . list ( wrapper ) ; List < PluginGroupDTO > dtoList = BeanMapper . mapList ( list , PluginGroupDTO . class ) ; return dtoList ; } }"}, {"input": "package ginyi . system . domain . model . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ ApiModel ( \"<STR_LIT>\" ) @ Data public class CacheDto { @ ApiModelProperty ( \"<STR_LIT>\" ) private String key ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;", "output": "}"}, {"input": "package org . example . ddduser . domain . repository ; import org . example . ddduser . domain . user . UserEntity ; public interface UserRepository { UserEntity find ( Long userId ) ; UserEntity find ( String username ) ; Long save ( UserEntity user ) ;", "output": "}"}, {"input": "package me . zhengjie . annotation ; import java . lang . annotation . * ; @ Inherited @ Documented @ Target ( { ElementType . METHOD , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface AnonymousAccess {", "output": "}"}, {"input": "package ginyi . common . utils . enums ; public enum UserStatus { OK ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DISABLE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DELETED ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private final String code ; private final String info ; UserStatus ( String code , String info ) {", "output": "this . code = code ; this . info = info ; } public String getCode ( ) { return code ; } public String getInfo ( ) { return info ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springblade . cgform . entity . CgformEnhanceSql ; import java . util . List ; import java . util . Map ; public interface CgformEnhanceSqlMapper extends BaseMapper < CgformEnhanceSql > { void executeDDL ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; List < Map < String , Object > > getListData ( @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Page < Map < String , Object > > getListDataPage ( @ Param ( \"<STR_LIT>\" ) Page < Map < String , Object > > page , Map < String , Object > params , @ Param ( \"<STR_LIT>\" ) String sqlStr ) ; Page < Map < String , Object > > executeSql ( @ Param ( \"<STR_LIT>\" ) Page < Map < String , Object > > page , @ Param ( \"<STR_LIT>\" ) String executeSql , @ Param ( \"<STR_LIT>\" ) Map < String , Object > params ) ;", "output": "}"}, {"input": "package com . yf . config ; import com . yf . system . aspect . mybatis . QueryInterceptor ; import com . yf . system . aspect . mybatis . UpdateInterceptor ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ MapperScan ( \"<STR_LIT>\" ) public class MybatisConfig { @ Bean public QueryInterceptor queryInterceptor ( ) { QueryInterceptor query = new QueryInterceptor ( ) ; query . setLimit ( - <NUM_LIT> ) ;", "output": "return query ; } @ Bean public UpdateInterceptor updateInterceptor ( ) { return new UpdateInterceptor ( ) ; } }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Question ; import cn . org . alan . exam . model . form . question . QuestionFrom ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . model . vo . exercise . QuestionSheetVO ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface QuestionConverter { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) Question fromToEntity ( QuestionFrom questionFrom ) ; List < QuestionSheetVO > listEntityToVO ( List < Question > questions ) ;", "output": "@ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) QuestionSheetVO entityToVO ( Question question ) ; QuestionVO QuestionToQuestionVO ( Question question ) ; }"}, {"input": "package me . zhengjie . utils . enums ; import lombok . AllArgsConstructor ; import lombok . Getter ; @ Getter @ AllArgsConstructor public enum CodeBiEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" ) , TWO ( <NUM_LIT> , \"<STR_LIT>\" ) ; private final Integer code ; private final String description ;", "output": "public static CodeBiEnum find ( Integer code ) { for ( CodeBiEnum value : CodeBiEnum . values ( ) ) { if ( value . getCode ( ) . equals ( code ) ) { return value ; } } return null ; } }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . lang . Opt ; import com . xcs . wx . domain . vo . * ; import com . xcs . wx . repository . * ; import com . xcs . wx . service . DashboardService ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Service ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Slf4j @ Service @ RequiredArgsConstructor public class DashboardServiceImpl implements DashboardService { private final MsgRepository msgRepository ; private final ContactRepository contactRepository ; private final ChatRoomRepository chatRoomRepository ; private final ContactHeadImgUrlRepository contactHeadImgUrlRepository ; private final FTSRecentUsedRepository recentUsedRepository ; @ Override public StatsPanelVO statsPanel ( ) { int contact = contactRepository . countContact ( ) ; int chatRoom = chatRoomRepository . countChatRoom ( ) ; int sent = msgRepository . countSent ( ) ; int received = msgRepository . countReceived ( ) ; return new StatsPanelVO ( contact , chatRoom , sent , received ) ; } @ Override public List < MsgTypeDistributionVO > msgTypeDistribution ( ) { return Opt . ofNullable ( msgRepository . msgTypeDistribution ( ) ) . map ( msgTypes -> msgTypes . stream ( ) . collect ( Collectors . groupingBy ( MsgTypeDistributionVO :: getType , Collectors . summingInt ( MsgTypeDistributionVO :: getValue ) ) ) ) . map ( summedMap -> summedMap . entrySet ( ) . stream ( ) . map ( entry -> new MsgTypeDistributionVO ( entry . getKey ( ) , entry . getValue ( ) ) ) . collect ( Collectors . toList ( ) ) ) . orElse ( Collections . emptyList ( ) ) ; } @ Override public List < CountRecentMsgsVO > countRecentMsgs ( ) { return msgRepository . countRecentMsgs ( ) ; } @ Override public List < TopContactsVO > topContacts ( ) { return Opt . ofNullable ( msgRepository . topContacts ( ) ) . map ( topContacts -> { List < String > userNames = topContacts . stream ( ) . map ( TopContactsVO :: getUserName ) . collect ( Collectors . toList ( ) ) ; Map < String , String > nicknameMap = contactRepository . getContactNickname ( userNames ) ; Map < String , String > headImgUrlMap = contactHeadImgUrlRepository . queryHeadImgUrl ( userNames ) ; for ( TopContactsVO topContact : topContacts ) { topContact . setNickName ( nicknameMap . get ( topContact . getUserName ( ) ) ) ; topContact . setHeadImgUrl ( headImgUrlMap . get ( topContact . getUserName ( ) ) ) ; } return topContacts ; }", "output": ") . orElse ( Collections . emptyList ( ) ) ; } @ Override public List < RecentUsedKeyWordVO > queryRecentUsedKeyWord ( ) { return recentUsedRepository . queryRecentUsedKeyWord ( ) . stream ( ) . map ( RecentUsedKeyWordVO :: new ) . collect ( Collectors . toList ( ) ) ; } }"}, {"input": "package top . kangert . kspider . domain ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; import org . hibernate . annotations . ColumnDefault ; import javax . persistence . * ; import java . util . Date ; @ Table ( name = \"<STR_LIT>\" ) @ Entity @ Getter @ Setter @ ToString public class DataSource { @ Id @ GeneratedValue ( strategy = GenerationType . AUTO ) @ Column ( updatable = false ) private Long id ; private String name ; @ Column ( name = \"<STR_LIT>\" ) private String driverClassName ; @ Column ( name = \"<STR_LIT>\" ) private String jdbcUrl ; private String username ; private String password ; @ Column ( name = \"<STR_LIT>\" , insertable = false , updatable = false ) @ ColumnDefault ( \"<STR_LIT>\" ) private Date createTime ;", "output": "}"}, {"input": "package com . youlai . system . model . form ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . NotEmpty ; import jakarta . validation . constraints . Pattern ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class UserForm { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String username ; @ Schema ( description = \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String nickname ; @ Schema ( description = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String mobile ; @ Schema ( description = \"<STR_LIT>\" ) private Integer gender ; @ Schema ( description = \"<STR_LIT>\" ) private String avatar ; @ Schema ( description = \"<STR_LIT>\" ) private String email ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" ) private Long deptId ; @ Schema ( description = \"<STR_LIT>\" ) @ NotEmpty ( message = \"<STR_LIT>\" ) private List < Long > roleIds ;", "output": "}"}, {"input": "package com . oddfar . campus . common . constant ; public class CacheConstants { public static final String LOGIN_TOKEN_KEY = \"<STR_LIT>\" ; public static final String LOGIN_USER_KEY = \"<STR_LIT>\" ; public static final String CAPTCHA_CODE_KEY = \"<STR_LIT>\" ; public static final String SYS_CONFIG_KEY = \"<STR_LIT>\" ; public static final String SYS_DICT_KEY = \"<STR_LIT>\" ; public static final String REPEAT_SUBMIT_KEY = \"<STR_LIT>\" ; public static final String RATE_LIMIT_KEY = \"<STR_LIT>\" ; public static final String PWD_ERR_CNT_KEY = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . config . util ; import com . alibaba . nacos . api . config . ConfigService ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigLoaderFactory { private static volatile NacosConfigLoader nacosConfigLoader ; public static NacosConfigLoader getSingleton ( NacosConfigProperties nacosConfigProperties , ConfigurableEnvironment environment , Function < Properties , ConfigService > builder ) {", "output": "if ( nacosConfigLoader == null ) { synchronized ( NacosConfigLoaderFactory . class ) { if ( nacosConfigLoader == null ) { nacosConfigLoader = new NacosConfigLoader ( nacosConfigProperties , environment , builder ) ; } } } return nacosConfigLoader ; } }"}, {"input": "package com . oddfar . campus . framework . api . file ; import com . oddfar . campus . framework . api . sysconfig . ConfigExpander ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration public class ZyFileAutoConfiguration { @ Bean @ ConditionalOnMissingBean ( FileOperatorApi . class ) public FileOperatorApi fileOperatorApi ( ) {", "output": "return new LocalFileOperator ( ConfigExpander . getFileProfile ( ) ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; import java . util . List ; @ Data public class FeedsVO { private Long feedId ; @ JsonIgnore private Integer createTime ; private String strCreateTime ; private Integer faultId ; private Integer type ; private String userName ; private String nickName ; private Integer status ; private Integer extFlag ; private Integer privFlag ; private String stringId ; @ JsonIgnore private String content ; private String contentDesc ; private List < FeedsMediaVO > medias ; private FeedsLocationVO location ; private String headImgUrl ;", "output": "}"}, {"input": "package com . yf . system . modules . dict . controller ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . yf . base . api . annon . DataProtect ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . dict . dto . SysDicDTO ; import com . yf . system . modules . dict . entity . SysDic ; import com . yf . system . modules . dict . service . SysDicService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . apache . shiro . authz . annotation . Logical ; import org . apache . shiro . authz . annotation . RequiresPermissions ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; @ Api ( tags = { \"<STR_LIT>\" } , consumes = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysDicController extends BaseController { @ Autowired private SysDicService baseService ; @ RequiresPermissions ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" } , logical = Logical . OR ) @ DataProtect ( clazz = SysDic . class , update = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody SysDicDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ;", "output": "} @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ DataProtect ( clazz = SysDic . class , delete = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest delete ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < IPage < SysDicDTO > > paging ( @ RequestBody PagingReqDTO < SysDicDTO > reqDTO ) { IPage < SysDicDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } }"}, {"input": "package ginyi . common . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( {", "output": "ElementType . FIELD } ) public @ interface UpdateTime { String value ( ) default \"<STR_LIT>\" ; }"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . annotation . Anonymous ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . model . RegisterBody ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . service . SysConfigService ; import com . oddfar . campus . framework . service . SysUserService ; import com . oddfar . campus . framework . web . service . SysRegisterService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RestController ; @ RestController public class SysRegisterController { @ Autowired private SysRegisterService registerService ; @ Autowired private SysConfigService configService ; @ Autowired private SysUserService userService ; @ PostMapping ( \"<STR_LIT>\" ) public R register ( @ RequestBody RegisterBody user ) { if ( ! ( \"<STR_LIT>\" . equals ( configService . selectConfigByKey ( \"<STR_LIT>\" ) ) ) ) { return R . error ( \"<STR_LIT>\" ) ; }", "output": "String msg = registerService . register ( user ) ; return StringUtils . isEmpty ( msg ) ? R . ok ( ) : R . error ( msg ) ; } @ Anonymous @ GetMapping ( \"<STR_LIT>\" ) public R userNameUnique ( String userName ) { SysUserEntity userEntity = new SysUserEntity ( ) ; userEntity . setUserName ( userName ) ; return R . ok ( userService . checkUserNameUnique ( userEntity ) ) ; } @ Anonymous @ GetMapping ( \"<STR_LIT>\" ) public R emailUnique ( String email ) { SysUserEntity userEntity = new SysUserEntity ( ) ; userEntity . setEmail ( email ) ; return R . ok ( userService . checkEmailUnique ( userEntity ) ) ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; import java . util . List ; @ Data public class EntrustLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" + \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String currentType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairA ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradingPairB ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String entrustType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String tradeType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leverType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String endTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isShowRevoke ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String symbolName ; private String jhwtType ;", "output": "}"}, {"input": "package com . yf . base . api . annon ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface DataProtect { boolean update ( ) default false ; boolean delete ( ) default false ;", "output": "boolean currUsr ( ) default false ; Class clazz ( ) ; }"}, {"input": "package com . yf . base . utils . jackson ; import com . fasterxml . jackson . core . JsonParser ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . core . type . TypeReference ; import com . fasterxml . jackson . databind . DeserializationFeature ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . databind . SerializationFeature ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . IOException ; public class JsonHelper { public static String toJson ( Object obj ) { ObjectMapper mapper = getMapper ( ) ; try { return mapper . writeValueAsString ( obj ) ; } catch ( JsonProcessingException e ) { throw new RuntimeException ( e ) ; } } public static < T > T parseObject ( String json , Class < T > clazz ) { ObjectMapper mapper = getMapper ( ) ; try { return mapper . readValue ( json , clazz ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static < T > T parseObject ( Object object , Class < T > clazz ) { ObjectMapper mapper = getMapper ( ) ; try { return mapper . readValue ( toJson ( object ) , clazz ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static < T > T parseObject ( Object object , TypeReference < T > typeReference ) { ObjectMapper mapper = getMapper ( ) ; try { return mapper . readValue ( toJson ( object ) , typeReference ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static < T > T parseObject ( String json , TypeReference < T > typeReference ) { ObjectMapper mapper = getMapper ( ) ; try { return mapper . readValue ( json , typeReference ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static ObjectMapper getMapper ( ) { ObjectMapper objectMapper = new ObjectMapper ( ) ; objectMapper . configure ( DeserializationFeature . ACCEPT_EMPTY_STRING_AS_NULL_OBJECT , true ) ; objectMapper . configure ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES , false ) ; objectMapper . configure ( JsonParser . Feature . ALLOW_UNQUOTED_CONTROL_CHARS , true ) ; objectMapper . configure ( JsonParser . Feature . ALLOW_SINGLE_QUOTES , true ) ; objectMapper . disable ( SerializationFeature . FAIL_ON_EMPTY_BEANS ) ; return objectMapper ; } @ Data public static class TestDD { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucket ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKeyId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKeySecret ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String endpoint ;", "output": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String url ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String project ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pipeline ; } public static void main ( String [ ] args ) { String oriResourceStr = \"<STR_LIT>\" ; TestDD oriResource = JsonHelper . parseObject ( oriResourceStr , TestDD . class ) ; System . out . println ( oriResource ) ; } }"}, {"input": "package cn . org . alan . exam . model . form ; import jakarta . validation . constraints . Max ; import jakarta . validation . constraints . Min ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . NotNull ; import lombok . Data ; @ Data public class ExerciseFillAnswerFrom { @ NotNull ( message = \"<STR_LIT>\" ) private Integer repoId ; @ NotNull ( message = \"<STR_LIT>\" ) private Integer quId ; @ NotBlank ( message = \"<STR_LIT>\" ) private String answer ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Max ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) private Integer quType ;", "output": "}"}, {"input": "package org . springblade . config . service . impl ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . apache . commons . lang . StringUtils ; public class PgTableHandle implements DbTableHandleI { public PgTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . a ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return \"<STR_LIT>\" + this . a ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . b ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . contains ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; }", "output": "else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String a ( ColumnMeta var1 , ColumnMeta var2 ) throws DBException { String var3 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { throw new DBException ( \"<STR_LIT>\" ) ; } return var3 ; } private String b ( ColumnMeta var1 , ColumnMeta var2 ) { String var3 = \"<STR_LIT>\" ; if ( ! var1 . a ( var2 ) ) { if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = var1 . getColumnName ( ) ; var3 = var3 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; } } return var3 ; } private String a ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } var2 = var2 + ( StringUtils . isNotEmpty ( var1 . getFieldDefault ( ) ) ? \"<STR_LIT>\" + var1 . getFieldDefault ( ) : \"<STR_LIT>\" ) ; return var2 ; } private String b ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" ; } return var2 ; } public String getCommentSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getTableName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" + columnMeta . getComment ( ) + \"<STR_LIT>\" ; } public String dropIndexs ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName ; } public String countIndex ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName + \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } }"}, {"input": "package org . springblade . web . config . engine . exchange ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchFactoryExchangeAll { private ConcurrentHashMap < String , CoinMatchXhExchange > matchMap ; private String symbolName = \"<STR_LIT>\" ; public CoinMatchFactoryExchangeAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; }", "output": "public void addExchangeCoinMatch ( CoinMatchXhExchange match ) { if ( ! this . containsExchangeCoinMatch ( symbolName ) ) { this . matchMap . put ( symbolName , match ) ; } } public boolean containsExchangeCoinMatch ( String symbolName ) { return this . matchMap != null && this . matchMap . containsKey ( symbolName ) ; } public Map < String , CoinMatchXhExchange > getMatchMap ( ) { return this . matchMap ; } }"}, {"input": "package ginyi . common . mysql . interceptor ; import ginyi . common . annotation . CreateBy ; import ginyi . common . annotation . CreateTime ; import ginyi . common . annotation . UpdateBy ; import ginyi . common . annotation . UpdateTime ; import ginyi . common . constant . UserConstants ; import org . apache . ibatis . binding . MapperMethod ; import org . apache . ibatis . executor . Executor ; import org . apache . ibatis . mapping . MappedStatement ; import org . apache . ibatis . mapping . SqlCommandType ; import org . apache . ibatis . plugin . Interceptor ; import org . apache . ibatis . plugin . Intercepts ; import org . apache . ibatis . plugin . Invocation ; import org . apache . ibatis . plugin . Signature ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Field ; import java . util . Date ; import java . util . Set ; @ Component @ Intercepts ( { @ Signature ( type = Executor . class , method = \"<STR_LIT>\" , args = { MappedStatement . class , Object . class } ) } ) public class MyInterceptor implements Interceptor { @ Resource private HttpServletRequest request ; @ Override public Object intercept ( Invocation invocation ) throws Throwable { MappedStatement mappedStatement = ( MappedStatement ) invocation . getArgs ( ) [ <NUM_LIT> ] ; SqlCommandType sqlCommandType = mappedStatement . getSqlCommandType ( ) ; if ( SqlCommandType . INSERT . equals ( sqlCommandType ) || SqlCommandType . UPDATE . equals ( sqlCommandType ) ) { Object parameter = invocation . getArgs ( ) [ <NUM_LIT> ] ; if ( parameter instanceof MapperMethod . ParamMap ) { MapperMethod . ParamMap map = ( MapperMethod . ParamMap ) parameter ; Set keys = map . keySet ( ) ; for ( Object key : keys ) { if ( map . get ( key ) != null ) { setParameter ( map . get ( key ) , sqlCommandType ) ; } } } else { setParameter ( parameter , sqlCommandType ) ; } } return invocation . proceed ( ) ; } public void setParameter ( Object parameter , SqlCommandType sqlCommandType ) throws Throwable { Class < ? > aClass = parameter . getClass ( ) ; Field [ ] declaredFields = aClass . getSuperclass ( ) . getDeclaredFields ( ) ; for ( Field field : declaredFields ) { if ( SqlCommandType . INSERT . equals ( sqlCommandType ) ) {", "output": "if ( field . getAnnotation ( CreateBy . class ) != null ) { field . setAccessible ( true ) ; field . set ( parameter , request . getAttribute ( UserConstants . CURRENT_USER ) ) ; } if ( field . getAnnotation ( CreateTime . class ) != null ) { field . setAccessible ( true ) ; field . set ( parameter , new Date ( ) ) ; } } if ( SqlCommandType . UPDATE . equals ( sqlCommandType ) ) { if ( field . getAnnotation ( UpdateBy . class ) != null ) { field . setAccessible ( true ) ; field . set ( parameter , request . getAttribute ( UserConstants . CURRENT_USER ) ) ; } if ( field . getAnnotation ( UpdateTime . class ) != null ) { field . setAccessible ( true ) ; field . set ( parameter , new Date ( ) ) ; } } } } }"}, {"input": "package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . mapper . RoleMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import me . zhengjie . utils . * ; import me . zhengjie . modules . system . mapper . DeptMapper ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . utils . enums . DataScopeEnum ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class DeptServiceImpl extends ServiceImpl < DeptMapper , Dept > implements DeptService { private final DeptMapper deptMapper ; private final UserMapper userMapper ; private final RedisUtils redisUtils ; private final RoleMapper roleMapper ; @ Override public List < Dept > queryAll ( DeptQueryCriteria criteria , Boolean isQuery ) throws Exception { String dataScopeType = SecurityUtils . getDataScopeType ( ) ; if ( isQuery ) { if ( dataScopeType . equals ( DataScopeEnum . ALL . getValue ( ) ) ) { criteria . setPidIsNull ( true ) ; } List < Field > fields = StringUtils . getAllFields ( criteria . getClass ( ) , new ArrayList < > ( ) ) ; List < String > fieldNames = new ArrayList < String > ( ) { { add ( \"<STR_LIT>\" ) ; add ( \"<STR_LIT>\" ) ; } } ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object val = field . get ( criteria ) ; if ( fieldNames . contains ( field . getName ( ) ) ) { continue ; } if ( ObjectUtil . isNotNull ( val ) ) { criteria . setPidIsNull ( null ) ; break ; } } } criteria . setIds ( SecurityUtils . getCurrentUserDataScope ( ) ) ; List < Dept > list = deptMapper . findAll ( criteria ) ; if ( StringUtils . isBlank ( dataScopeType ) ) { return deduplication ( list ) ; } return list ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public Dept findById ( Long id ) { return getById ( id ) ; } @ Override public List < Dept > findByPid ( long pid ) { return deptMapper . findByPid ( pid ) ; } @ Override public Set < Dept > findByRoleId ( Long id ) { return deptMapper . findByRoleId ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Dept resources ) { save ( resources ) ; updateSubCnt ( resources . getPid ( ) ) ; delCaches ( resources . getPid ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Dept resources ) { Long oldPid = findById ( resources . getId ( ) ) . getPid ( ) ; Long newPid = resources . getPid ( ) ; if ( resources . getPid ( ) != null && resources . getId ( ) . equals ( resources . getPid ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } Dept dept = getById ( resources . getId ( ) ) ; resources . setId ( dept . getId ( ) ) ; saveOrUpdate ( resources ) ; updateSubCnt ( oldPid ) ; updateSubCnt ( newPid ) ; delCaches ( resources . getId ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Dept > depts ) { for ( Dept dept : depts ) { delCaches ( dept . getId ( ) ) ; deptMapper . deleteById ( dept . getId ( ) ) ; updateSubCnt ( dept . getPid ( ) ) ; } } @ Override public void download ( List < Dept > depts , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Dept dept : depts ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , dept . getName ( ) ) ; map . put ( \"<STR_LIT>\" , dept . getEnabled ( ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , dept . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public Set < Dept > getDeleteDepts ( List < Dept > menuList , Set < Dept > deptSet ) { for ( Dept dept : menuList ) { deptSet . add ( dept ) ; List < Dept > depts = deptMapper . findByPid ( dept . getId ( ) ) ; if ( depts != null && depts . size ( ) != <NUM_LIT> ) { getDeleteDepts ( depts , deptSet ) ; } } return deptSet ; } @ Override public List < Long > getDeptChildren ( List < Dept > deptList ) { List < Long > list = new ArrayList < > ( ) ; deptList . forEach ( dept -> { if ( dept != null && dept . getEnabled ( ) ) { List < Dept > depts = deptMapper . findByPid ( dept . getId ( ) ) ; if ( depts . size ( ) != <NUM_LIT> ) { list . addAll ( getDeptChildren ( depts ) ) ; } list . add ( dept . getId ( ) ) ; } } ) ; return list ; } @ Override public List < Dept > getSuperior ( Dept dept , List < Dept > depts ) { if ( dept . getPid ( ) == null ) { depts . addAll ( deptMapper . findByPidIsNull ( ) ) ; return depts ; } depts . addAll ( deptMapper . findByPid ( dept . getPid ( ) ) ) ; return getSuperior ( findById ( dept . getPid ( ) ) , depts ) ; } @ Override public Object buildTree ( List < Dept > deptList ) { Set < Dept > trees = new LinkedHashSet < > ( ) ; Set < Dept > depts = new LinkedHashSet < > ( ) ; List < String > deptNames = deptList . stream ( ) . map ( Dept :: getName ) . collect ( Collectors . toList ( ) ) ; boolean isChild ; for ( Dept dept : deptList ) { isChild = false ; if ( dept . getPid ( ) == null ) { trees . add ( dept ) ; } for ( Dept it : deptList ) { if ( it . getPid ( ) != null && dept . getId ( ) . equals ( it . getPid ( ) ) ) { isChild = true ; if ( dept . getChildren ( ) == null ) { dept . setChildren ( new ArrayList < > ( ) ) ; } dept . getChildren ( ) . add ( it ) ; } } if ( isChild ) { depts . add ( dept ) ; } else if ( dept . getPid ( ) != null && ! deptNames . contains ( findById ( dept . getPid ( ) ) . getName ( ) ) ) { depts . add ( dept ) ; } } if ( CollectionUtil . isEmpty ( trees ) ) { trees = depts ; } Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( \"<STR_LIT>\" , depts . size ( ) ) ; map . put ( \"<STR_LIT>\" , CollectionUtil . isEmpty ( trees ) ? depts : trees ) ; return map ; } @ Override public void verification ( Set < Dept > depts ) { Set < Long > deptIds = depts . stream ( ) . map ( Dept :: getId ) . collect ( Collectors . toSet ( ) ) ; if ( userMapper . countByDepts ( deptIds ) > <NUM_LIT> ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; }", "output": "if ( roleMapper . countByDepts ( deptIds ) > <NUM_LIT> ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } private void updateSubCnt ( Long deptId ) { if ( deptId != null ) { int count = deptMapper . countByPid ( deptId ) ; deptMapper . updateSubCntById ( count , deptId ) ; } } private List < Dept > deduplication ( List < Dept > list ) { List < Dept > depts = new ArrayList < > ( ) ; for ( Dept dept : list ) { boolean flag = true ; for ( Dept dept1 : list ) { if ( dept1 . getId ( ) . equals ( dept . getPid ( ) ) ) { flag = false ; break ; } } if ( flag ) { depts . add ( dept ) ; } } return depts ; } public void delCaches ( Long id ) { List < User > users = userMapper . findByRoleDeptId ( id ) ; redisUtils . delByKeys ( CacheKey . DATA_USER , users . stream ( ) . map ( User :: getId ) . collect ( Collectors . toSet ( ) ) ) ; redisUtils . del ( CacheKey . DEPT_ID + id ) ; } }"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class RoleQueryCriteria { private String blurry ; private List < Timestamp > createTime ; private Long offset ; private Long size ;", "output": "}"}, {"input": "package com . youlai . system . security . service ; import com . youlai . system . security . model . SysUserDetails ; import com . youlai . system . model . dto . UserAuthInfo ; import com . youlai . system . service . SysUserService ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . security . core . userdetails . UserDetails ; import org . springframework . security . core . userdetails . UserDetailsService ; import org . springframework . security . core . userdetails . UsernameNotFoundException ; import org . springframework . stereotype . Service ; @ Service @ RequiredArgsConstructor @ Slf4j public class SysUserDetailsService implements UserDetailsService { private final SysUserService sysUserService ; @ Override public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException { try {", "output": "UserAuthInfo userAuthInfo = sysUserService . getUserAuthInfo ( username ) ; if ( userAuthInfo == null ) { throw new UsernameNotFoundException ( username ) ; } return new SysUserDetails ( userAuthInfo ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; throw e ; } } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class SessionVO { private String userName ; private String nickName ; private String content ; private Integer time ; private String shortTime ; private String headImgUrl ;", "output": "}"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . UserExerciseRecord ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IUserExerciseRecordService extends IService < UserExerciseRecord > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import java . util . List ; public interface DDDQueryService < R > { Page < R > page ( PageQuery query ) ; List < R > list ( ListQuery query ) ;", "output": "R detail ( Long id ) ; }"}, {"input": "package me . zhengjie . utils ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; import java . util . Objects ; public class RequestHolder { public static HttpServletRequest getHttpServletRequest ( ) { return ( ( ServletRequestAttributes ) Objects . requireNonNull ( RequestContextHolder . getRequestAttributes ( ) ) ) . getRequest ( ) ; }", "output": "}"}, {"input": "package top . kangert . kspider . constant ; import lombok . Getter ; public enum OutputType { DATABASE ( \"<STR_LIT>\" ) , CSV ( \"<STR_LIT>\" ) ; @ Getter private String variableName ; OutputType ( String variableName ) { this . variableName = variableName ;", "output": "} }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . util . List ; @ Data public class MarketGoodsModel { private String symbolName ; private String avatar ; private List < detail > leftGoodsList ; private List < detail > rightGoodsList ; @ Data public static class detail { private String marketSymbolId ; private String coinId ; private String coinSymbol ; private String periodDay ; private String profitRate ; private String minMoney ;", "output": "} }"}, {"input": "package ginyi . common . constant ; public class UserConstants { public static final String SYS_USER = \"<STR_LIT>\" ; public static final String CURRENT_USER = \"<STR_LIT>\" ; public static final String NORMAL = \"<STR_LIT>\" ; public static final String EXCEPTION = \"<STR_LIT>\" ; public static final String USER_DISABLE = \"<STR_LIT>\" ; public static final String ROLE_DISABLE = \"<STR_LIT>\" ; public static final String DEPT_NORMAL = \"<STR_LIT>\" ; public static final String DEPT_DISABLE = \"<STR_LIT>\" ; public static final String DICT_NORMAL = \"<STR_LIT>\" ; public static final String YES = \"<STR_LIT>\" ; public static final String YES_FRAME = \"<STR_LIT>\" ; public static final String NO_FRAME = \"<STR_LIT>\" ; public static final String TYPE_DIR = \"<STR_LIT>\" ; public static final String TYPE_MENU = \"<STR_LIT>\" ; public static final String TYPE_BUTTON = \"<STR_LIT>\" ; public final static String LAYOUT = \"<STR_LIT>\" ; public final static String PARENT_VIEW = \"<STR_LIT>\" ; public final static String INNER_LINK = \"<STR_LIT>\" ; public final static String UNIQUE = \"<STR_LIT>\" ; public final static String NOT_UNIQUE = \"<STR_LIT>\" ; public static final int USERNAME_MIN_LENGTH = <NUM_LIT> ; public static final int USERNAME_MAX_LENGTH = <NUM_LIT> ; public static final int PASSWORD_MIN_LENGTH = <NUM_LIT> ; public static final int PASSWORD_MAX_LENGTH = <NUM_LIT> ;", "output": "}"}, {"input": "package org . example . dddworkspace . infrastructure . config ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MD5Util ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; public class MicroserviceSecurityInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String requestUri = request . getRequestURI ( ) ; if ( ! requestUri . startsWith ( \"<STR_LIT>\" ) ) { return true ; } String accessKey = request . getHeader ( \"<STR_LIT>\" ) ; long timestamp = NumberUtil . toLong ( request . getHeader ( \"<STR_LIT>\" ) , <NUM_LIT> ) ; String signature = request . getHeader ( \"<STR_LIT>\" ) ; if ( ! \"<STR_LIT>\" . equals ( accessKey ) ) { return false ; } if ( System . currentTimeMillis ( ) - timestamp > <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) { return false ; } if ( TextUtil . isBlank ( signature ) ) { return false ; } String secretKey = \"<STR_LIT>\" ; String calculatedSignature = MD5Util . md5With32 ( secretKey + \"<STR_LIT>\" + timestamp + \"<STR_LIT>\" + requestUri ) ; if ( ! signature . equals ( calculatedSignature ) ) {", "output": "return false ; } return true ; } }"}, {"input": "package ginyi . common . utils . ip ; import com . alibaba . fastjson2 . JSON ; import com . alibaba . fastjson2 . JSONObject ; import ginyi . common . utils . Constants ; import ginyi . common . utils . StringUtils ; import ginyi . common . utils . http . HttpUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class AddressUtils { private static final Logger log = LoggerFactory . getLogger ( AddressUtils . class ) ; public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { if ( IpUtils . internalIp ( ip ) ) { return \"<STR_LIT>\" ;", "output": "} try { String rspStr = HttpUtils . sendGet ( IP_URL , \"<STR_LIT>\" + ip + \"<STR_LIT>\" , Constants . GBK ) ; if ( StringUtils . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; } JSONObject obj = JSON . parseObject ( rspStr ) ; String region = obj . getString ( \"<STR_LIT>\" ) ; String city = obj . getString ( \"<STR_LIT>\" ) ; return String . format ( \"<STR_LIT>\" , region , city ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , ip ) ; } return UNKNOWN ; } }"}, {"input": "package org . springblade . cgform . model ; public class FieldSlotType { public static final String FILE = \"<STR_LIT>\" ; public static final String IMAGE = \"<STR_LIT>\" ; public static final String EDITOR = \"<STR_LIT>\" ; public static final String DATE = \"<STR_LIT>\" ; public static final String PCA = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import org . apache . commons . codec . binary . Base64 ; import javax . crypto . Cipher ; import java . io . ByteArrayOutputStream ; import java . security . * ; import java . security . interfaces . RSAPrivateKey ; import java . security . interfaces . RSAPublicKey ; import java . security . spec . PKCS8EncodedKeySpec ; import java . security . spec . X509EncodedKeySpec ; public class RsaUtils { private static final String SRC = \"<STR_LIT>\" ; public static void main ( String [ ] args ) throws Exception { System . out . println ( \"<STR_LIT>\" ) ; RsaKeyPair keyPair = generateKeyPair ( ) ; System . out . println ( \"<STR_LIT>\" + keyPair . getPublicKey ( ) ) ; System . out . println ( \"<STR_LIT>\" + keyPair . getPrivateKey ( ) ) ; System . out . println ( \"<STR_LIT>\" ) ; test1 ( keyPair ) ; System . out . println ( \"<STR_LIT>\" ) ; test2 ( keyPair ) ; System . out . println ( \"<STR_LIT>\" ) ; } private static void test1 ( RsaKeyPair keyPair ) throws Exception { System . out . println ( \"<STR_LIT>\" ) ; String text1 = encryptByPublicKey ( keyPair . getPublicKey ( ) , RsaUtils . SRC ) ; String text2 = decryptByPrivateKey ( keyPair . getPrivateKey ( ) , text1 ) ; System . out . println ( \"<STR_LIT>\" + RsaUtils . SRC ) ; System . out . println ( \"<STR_LIT>\" + text1 ) ; System . out . println ( \"<STR_LIT>\" + text2 ) ; if ( RsaUtils . SRC . equals ( text2 ) ) { System . out . println ( \"<STR_LIT>\" ) ; } else { System . out . println ( \"<STR_LIT>\" ) ; } System . out . println ( \"<STR_LIT>\" ) ; }", "output": "private static void test2 ( RsaKeyPair keyPair ) throws Exception { System . out . println ( \"<STR_LIT>\" ) ; String text1 = encryptByPrivateKey ( keyPair . getPrivateKey ( ) , RsaUtils . SRC ) ; String text2 = decryptByPublicKey ( keyPair . getPublicKey ( ) , text1 ) ; System . out . println ( \"<STR_LIT>\" + RsaUtils . SRC ) ; System . out . println ( \"<STR_LIT>\" + text1 ) ; System . out . println ( \"<STR_LIT>\" + text2 ) ; if ( RsaUtils . SRC . equals ( text2 ) ) { System . out . println ( \"<STR_LIT>\" ) ; } else { System . out . println ( \"<STR_LIT>\" ) ; } System . out . println ( \"<STR_LIT>\" ) ; } public static String decryptByPublicKey ( String publicKeyText , String text ) throws Exception { X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec ( Base64 . decodeBase64 ( publicKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( \"<STR_LIT>\" ) ; PublicKey publicKey = keyFactory . generatePublic ( x509EncodedKeySpec ) ; Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . DECRYPT_MODE , publicKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . DECRYPT_MODE , cipher , Base64 . decodeBase64 ( text ) ) ; return new String ( result ) ; } public static String encryptByPrivateKey ( String privateKeyText , String text ) throws Exception { PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec ( Base64 . decodeBase64 ( privateKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( \"<STR_LIT>\" ) ; PrivateKey privateKey = keyFactory . generatePrivate ( pkcs8EncodedKeySpec ) ; Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . ENCRYPT_MODE , privateKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . ENCRYPT_MODE , cipher , text . getBytes ( ) ) ; return Base64 . encodeBase64String ( result ) ; } public static String decryptByPrivateKey ( String privateKeyText , String text ) throws Exception { PKCS8EncodedKeySpec pkcs8EncodedKeySpec5 = new PKCS8EncodedKeySpec ( Base64 . decodeBase64 ( privateKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( \"<STR_LIT>\" ) ; PrivateKey privateKey = keyFactory . generatePrivate ( pkcs8EncodedKeySpec5 ) ; Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . DECRYPT_MODE , privateKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . DECRYPT_MODE , cipher , Base64 . decodeBase64 ( text ) ) ; return new String ( result ) ; } public static String encryptByPublicKey ( String publicKeyText , String text ) throws Exception { X509EncodedKeySpec x509EncodedKeySpec2 = new X509EncodedKeySpec ( Base64 . decodeBase64 ( publicKeyText ) ) ; KeyFactory keyFactory = KeyFactory . getInstance ( \"<STR_LIT>\" ) ; PublicKey publicKey = keyFactory . generatePublic ( x509EncodedKeySpec2 ) ; Cipher cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; cipher . init ( Cipher . ENCRYPT_MODE , publicKey ) ; byte [ ] result = doLongerCipherFinal ( Cipher . ENCRYPT_MODE , cipher , text . getBytes ( ) ) ; return Base64 . encodeBase64String ( result ) ; } private static byte [ ] doLongerCipherFinal ( int opMode , Cipher cipher , byte [ ] source ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; if ( opMode == Cipher . DECRYPT_MODE ) { out . write ( cipher . doFinal ( source ) ) ; } else { int offset = <NUM_LIT> ; int totalSize = source . length ; while ( totalSize - offset > <NUM_LIT> ) { int size = Math . min ( cipher . getOutputSize ( <NUM_LIT> ) - <NUM_LIT> , totalSize - offset ) ; out . write ( cipher . doFinal ( source , offset , size ) ) ; offset += size ; } } out . close ( ) ; return out . toByteArray ( ) ; } public static RsaKeyPair generateKeyPair ( ) throws NoSuchAlgorithmException { KeyPairGenerator keyPairGenerator = KeyPairGenerator . getInstance ( \"<STR_LIT>\" ) ; keyPairGenerator . initialize ( <NUM_LIT> ) ; KeyPair keyPair = keyPairGenerator . generateKeyPair ( ) ; RSAPublicKey rsaPublicKey = ( RSAPublicKey ) keyPair . getPublic ( ) ; RSAPrivateKey rsaPrivateKey = ( RSAPrivateKey ) keyPair . getPrivate ( ) ; String publicKeyString = Base64 . encodeBase64String ( rsaPublicKey . getEncoded ( ) ) ; String privateKeyString = Base64 . encodeBase64String ( rsaPrivateKey . getEncoded ( ) ) ; return new RsaKeyPair ( publicKeyString , privateKeyString ) ; } public static class RsaKeyPair { private final String publicKey ; private final String privateKey ; public RsaKeyPair ( String publicKey , String privateKey ) { this . publicKey = publicKey ; this . privateKey = privateKey ; } public String getPublicKey ( ) { return publicKey ; } public String getPrivateKey ( ) { return privateKey ; } } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; @ Data public class AddProxyParam { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String commissionRate ;", "output": "}"}, {"input": "package ginyi . framework . security . aspectj ; import cn . hutool . core . date . DateUtil ; import com . alibaba . fastjson2 . JSON ; import ginyi . common . annotation . Log ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . enums . BusinessStatus ; import ginyi . common . enums . HttpMethod ; import ginyi . common . exception . CommonException ; import ginyi . common . exception . UnPermissionException ; import ginyi . common . exception . UserPasswordNotMatchException ; import ginyi . common . exception . UserPasswordRetryLimitExceedException ; import ginyi . common . result . StateCode ; import ginyi . common . utils . ServletUtils ; import ginyi . common . utils . StringUtils ; import ginyi . common . utils . ip . IpUtils ; import ginyi . framework . security . filter . PropertyPreExcludeFilter ; import ginyi . framework . security . manager . AsyncManager ; import ginyi . framework . security . manager . factory . AsyncFactory ; import ginyi . framework . security . utils . SecurityUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . SysLogOperation ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . JoinPoint ; import org . aspectj . lang . annotation . AfterReturning ; import org . aspectj . lang . annotation . AfterThrowing ; import org . aspectj . lang . annotation . Aspect ; import org . fusesource . jansi . Ansi ; import org . springframework . http . converter . HttpMessageNotReadableException ; import org . springframework . stereotype . Component ; import org . springframework . validation . BindingResult ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . multipart . MaxUploadSizeExceededException ; import org . springframework . web . multipart . MultipartException ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . * ; @ Aspect @ Component @ Slf4j public class LogAspect { public static final String [ ] EXCLUDE_PROPERTIES = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; @ AfterReturning ( pointcut = \"<STR_LIT>\" , returning = \"<STR_LIT>\" ) public void doAfterReturning ( JoinPoint joinPoint , Log controllerLog , Object jsonResult ) { handleLog ( joinPoint , controllerLog , null , jsonResult ) ; } @ AfterThrowing ( value = \"<STR_LIT>\" , throwing = \"<STR_LIT>\" ) public void doAfterThrowing ( JoinPoint joinPoint , Log controllerLog , Exception e ) { handleLog ( joinPoint , controllerLog , e , null ) ; } protected void handleLog ( final JoinPoint joinPoint , Log controllerLog , final Exception e , Object jsonResult ) { try { LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; SysLogOperation operationLog = new SysLogOperation ( ) ; operationLog . setStatus ( BusinessStatus . SUCCESS . ordinal ( ) ) ; String ip = IpUtils . getIpAddr ( ServletUtils . getRequest ( ) ) ; operationLog . setOperationIp ( ip ) ; operationLog . setOperationUrl ( StringUtils . substring ( ServletUtils . getRequest ( ) . getRequestURI ( ) , <NUM_LIT> , <NUM_LIT> ) ) ; operationLog . setCreateTime ( new Date ( ) ) ; if ( loginUser != null ) { operationLog . setOperationName ( loginUser . getUsername ( ) ) ; } String className = joinPoint . getTarget ( ) . getClass ( ) . getName ( ) ; String methodName = joinPoint . getSignature ( ) . getName ( ) ; operationLog . setMethod ( className + \"<STR_LIT>\" + methodName + \"<STR_LIT>\" ) ; operationLog . setRequestMethod ( ServletUtils . getRequest ( ) . getMethod ( ) ) ; getControllerMethodDescription ( joinPoint , controllerLog , operationLog , jsonResult ) ; log . info ( \"<STR_LIT>\" , operationLog . getOperationName ( ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getOperationIp ( ) ) ; log . info ( \"<STR_LIT>\" , DateUtil . date ( System . currentTimeMillis ( ) ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getTitle ( ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getOperationUrl ( ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getRequestMethod ( ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getBusinessType ( ) == <NUM_LIT> ? \"<STR_LIT>\" : operationLog . getBusinessType ( ) == <NUM_LIT> ? \"<STR_LIT>\" : operationLog . getBusinessType ( ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; log . info ( \"<STR_LIT>\" , operationLog . getMethod ( ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getOperationParam ( ) ) ; if ( e != null ) { String msg = handleException ( e ) ; operationLog . setStatus ( BusinessStatus . FAIL . ordinal ( ) ) ; operationLog . setErrorMsg ( msg ) ; log . info ( \"<STR_LIT>\" , operationLog . getStatus ( ) == <NUM_LIT> ? colorPrint ( \"<STR_LIT>\" , Ansi . Color . GREEN ) : colorPrint ( \"<STR_LIT>\" , Ansi . Color . RED ) ) ; log . info ( \"<STR_LIT>\" , msg ) ; } else { log . info ( \"<STR_LIT>\" , operationLog . getStatus ( ) == <NUM_LIT> ? colorPrint ( \"<STR_LIT>\" , Ansi . Color . GREEN ) : colorPrint ( \"<STR_LIT>\" , Ansi . Color . RED ) ) ; log . info ( \"<STR_LIT>\" , operationLog . getJsonResult ( ) ) ; } AsyncManager . me ( ) . execute ( AsyncFactory . recordOper ( operationLog ) ) ; } catch ( Exception exp ) { log . error ( \"<STR_LIT>\" , exp . getMessage ( ) ) ; exp . printStackTrace ( ) ; } } private String handleException ( Exception e ) { HashMap < String , Object > map = new HashMap < > ( ) ; if ( e instanceof CommonException ) { CommonException ce = ( CommonException ) e ; map . put ( \"<STR_LIT>\" , ce . getState ( ) . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , ce . getState ( ) . getMessage ( ) ) ; map . put ( \"<STR_LIT>\" , ce . getData ( ) ) ; return JSON . toJSONString ( map ) ; } if ( e instanceof HttpMessageNotReadableException ) { HttpMessageNotReadableException he = ( HttpMessageNotReadableException ) e ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_REQUEST_PARAMS . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_REQUEST_PARAMS . getMessage ( ) ) ; map . put ( \"<STR_LIT>\" , CommonMessageConstants . SYS_REQUEST_ILLEGAL ) ; return JSON . toJSONString ( map ) ; } if ( e instanceof UserPasswordNotMatchException ) { UserPasswordNotMatchException ue = ( UserPasswordNotMatchException ) e ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_UNAUTHENTICATION . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_UNAUTHENTICATION . getMessage ( ) ) ; map . put ( \"<STR_LIT>\" , CommonMessageConstants . USER_PASSWORD_NOT_MATCH ) ; return JSON . toJSONString ( map ) ; } if ( e instanceof UserPasswordRetryLimitExceedException ) { UserPasswordRetryLimitExceedException upe = ( UserPasswordRetryLimitExceedException ) e ; map . put ( \"<STR_LIT>\" , upe . getState ( ) . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , upe . getState ( ) . getMessage ( ) ) ; map . put ( \"<STR_LIT>\" , upe . getData ( ) ) ; return JSON . toJSONString ( map ) ; } if ( e instanceof MultipartException ) { MultipartException mte = ( MultipartException ) e ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_MULTIPART . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_MULTIPART . getMessage ( ) ) ; if ( mte instanceof MaxUploadSizeExceededException ) { map . put ( \"<STR_LIT>\" , CommonMessageConstants . UPLOAD_SIZE_EXCEED ) ; return JSON . toJSONString ( map ) ; } map . put ( \"<STR_LIT>\" , CommonMessageConstants . UPLOAD_FILE_ERROR ) ; return JSON . toJSONString ( map ) ; } if ( e instanceof UnPermissionException ) { UnPermissionException upe = ( UnPermissionException ) e ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_NOT_PERMISSION . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_NOT_PERMISSION . getMessage ( ) ) ; map . put ( \"<STR_LIT>\" , CommonMessageConstants . SYS_ERROR ) ; return JSON . toJSONString ( map ) ; } map . put ( \"<STR_LIT>\" , StateCode . ERROR_SYSTEM . getCode ( ) ) ; map . put ( \"<STR_LIT>\" , StateCode . ERROR_SYSTEM . getMessage ( ) ) ; map . put ( \"<STR_LIT>\" , CommonMessageConstants . SYS_ERROR ) ; return JSON . toJSONString ( map ) ; } public void getControllerMethodDescription ( JoinPoint joinPoint , Log log , SysLogOperation operationLog , Object jsonResult ) throws Exception { operationLog . setBusinessType ( log . businessType ( ) . ordinal ( ) ) ; operationLog . setTitle ( log . title ( ) ) ; operationLog . setOperatorType ( log . operatorType ( ) . ordinal ( ) ) ; if ( log . isSaveRequestData ( ) ) { setRequestValue ( joinPoint , operationLog ) ; } if ( log . isSaveResponseData ( ) && StringUtils . isNotNull ( jsonResult ) ) { operationLog . setJsonResult ( JSON . toJSONString ( jsonResult ) ) ; } } private void setRequestValue ( JoinPoint joinPoint , SysLogOperation operationLog ) throws Exception { String requestMethod = operationLog . getRequestMethod ( ) ; if ( HttpMethod . PUT . name ( ) . equals ( requestMethod ) || HttpMethod . POST . name ( ) . equals ( requestMethod ) ) { String params = argsArrayToString ( joinPoint . getArgs ( ) ) ; operationLog . setOperationParam ( params ) ; } else { Map < ? , ? > paramsMap = ServletUtils . getParamMap ( ServletUtils . getRequest ( ) ) ; operationLog . setOperationParam ( StringUtils . substring ( JSON . toJSONString ( paramsMap , excludePropertyPreFilter ( ) ) , <NUM_LIT> , <NUM_LIT> ) ) ; } } private String argsArrayToString ( Object [ ] paramsArray ) { String params = \"<STR_LIT>\" ; if ( paramsArray != null && paramsArray . length > <NUM_LIT> ) { for ( Object o : paramsArray ) { if ( StringUtils . isNotNull ( o ) && ! isFilterObject ( o ) ) { try { String jsonObj = JSON . toJSONString ( o , excludePropertyPreFilter ( ) ) ; params += jsonObj . toString ( ) + \"<STR_LIT>\" ; } catch ( Exception e ) { } } } } return params . trim ( ) ; } public PropertyPreExcludeFilter excludePropertyPreFilter ( ) { return new PropertyPreExcludeFilter ( ) . addExcludes ( EXCLUDE_PROPERTIES ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public boolean isFilterObject ( final Object o ) { Class < ? > clazz = o . getClass ( ) ; if ( clazz . isArray ( ) ) { return clazz . getComponentType ( ) . isAssignableFrom ( MultipartFile . class ) ; } else if ( Collection . class . isAssignableFrom ( clazz ) ) { Collection collection = ( Collection ) o ; for ( Object value : collection ) { return value instanceof MultipartFile ; } } else if ( Map . class . isAssignableFrom ( clazz ) ) { Map map = ( Map ) o ; for ( Object value : map . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) value ; return entry . getValue ( ) instanceof MultipartFile ; } }", "output": "return o instanceof MultipartFile || o instanceof HttpServletRequest || o instanceof HttpServletResponse || o instanceof BindingResult ; } public static String colorPrint ( String s , Ansi . Color color ) { return Ansi . ansi ( ) . eraseScreen ( ) . fg ( color ) . a ( s ) . reset ( ) . toString ( ) ; } }"}, {"input": "package com . yf . system . aspect . dict ; import com . fasterxml . jackson . core . JsonGenerator ; import com . fasterxml . jackson . databind . JsonSerializer ; import com . fasterxml . jackson . databind . SerializerProvider ; import com . yf . base . utils . SpringUtils ; import com . yf . system . modules . dict . service . SysDicValueService ; import lombok . Data ; import lombok . extern . log4j . Log4j2 ; import org . apache . commons . lang3 . StringUtils ; import java . io . IOException ; @ Data @ Log4j2 public class DataDictFilter extends JsonSerializer < Object > { private static final String DICT_APPEND = \"<STR_LIT>\" ; private String fieldName ; private String dicCode ; private String dictTable ; private String dicText ; public DataDictFilter ( String fieldName , String dicCode , String dictTable , String dicText ) { this . fieldName = fieldName ; this . dicCode = dicCode ; this . dictTable = dictTable ; this . dicText = dicText ; } private SysDicValueService sysDicValueService = SpringUtils . getBean ( \"<STR_LIT>\" , SysDicValueService . class ) ; @ Override public void serialize ( Object o , JsonGenerator gen , SerializerProvider serializerProvider ) throws IOException { String value = String . valueOf ( o ) ; gen . writeObject ( o ) ; if ( StringUtils . isNotBlank ( value ) ) { String newField = fieldName + DICT_APPEND ; String trans = this . translate ( value ) ; if ( StringUtils . isNotBlank ( trans ) ) { gen . writeObjectField ( newField , trans ) ; } } } private String translate ( String fieldValue ) { if ( StringUtils . isEmpty ( fieldValue ) ) { return \"<STR_LIT>\" ; } try {", "output": "String dictText ; if ( StringUtils . isEmpty ( dictTable ) ) { dictText = sysDicValueService . findDictText ( dicCode , fieldValue ) ; } else { dictText = sysDicValueService . findTableText ( dictTable , dicText , dicCode , fieldValue ) ; } if ( ! StringUtils . isEmpty ( dictText ) ) { return dictText ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return \"<STR_LIT>\" ; } }"}, {"input": "package com . oddfar . campus . common . utils . web ; import javax . servlet . ServletRequest ; import javax . servlet . http . HttpServletRequest ; public class WebFrameworkUtils { private static final String REQUEST_ATTRIBUTE_LOGIN_USER_ID = \"<STR_LIT>\" ; public static void setLoginUserId ( ServletRequest request , Long userId ) { request . setAttribute ( REQUEST_ATTRIBUTE_LOGIN_USER_ID , userId ) ; }", "output": "public static Long getLoginUserId ( HttpServletRequest request ) { if ( request == null ) { return null ; } return ( Long ) request . getAttribute ( REQUEST_ATTRIBUTE_LOGIN_USER_ID ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . security ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import io . github . chensheng . dddboot . tools . text . Charsets ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . Mac ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . security . GeneralSecurityException ; import java . security . SecureRandom ; import java . util . Arrays ; public class CryptoUtil { private static final String AES_ALG = \"<STR_LIT>\" ; private static final String AES_CBC_ALG = \"<STR_LIT>\" ; private static final String HMACSHA1_ALG = \"<STR_LIT>\" ; private static final int DEFAULT_HMACSHA1_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_AES_KEYSIZE = <NUM_LIT> ; private static final int DEFAULT_IVSIZE = <NUM_LIT> ; private static SecureRandom random = RandomUtil . secureRandom ( ) ; public static byte [ ] hmacSha1 ( byte [ ] input , byte [ ] key ) { try { SecretKey secretKey = new SecretKeySpec ( key , HMACSHA1_ALG ) ; Mac mac = Mac . getInstance ( HMACSHA1_ALG ) ; mac . init ( secretKey ) ; return mac . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static boolean isMacValid ( byte [ ] expected , byte [ ] input , byte [ ] key ) { byte [ ] actual = hmacSha1 ( input , key ) ; return Arrays . equals ( expected , actual ) ; } public static byte [ ] generateHmacSha1Key ( ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( HMACSHA1_ALG ) ; keyGenerator . init ( DEFAULT_HMACSHA1_KEYSIZE ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key ) { return aes ( input , key , Cipher . ENCRYPT_MODE ) ; } public static byte [ ] aesEncrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { return aes ( input , key , iv , Cipher . ENCRYPT_MODE ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key ) { byte [ ] decryptResult = aes ( input , key , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } public static String aesDecrypt ( byte [ ] input , byte [ ] key , byte [ ] iv ) { byte [ ] decryptResult = aes ( input , key , iv , Cipher . DECRYPT_MODE ) ; return new String ( decryptResult , Charsets . UTF_8 ) ; } private static byte [ ] aes ( byte [ ] input , byte [ ] key , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; Cipher cipher = Cipher . getInstance ( AES_ALG ) ; cipher . init ( mode , secretKey ) ; return cipher . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } private static byte [ ] aes ( byte [ ] input , byte [ ] key , byte [ ] iv , int mode ) { try { SecretKey secretKey = new SecretKeySpec ( key , AES_ALG ) ; IvParameterSpec ivSpec = new IvParameterSpec ( iv ) ; Cipher cipher = Cipher . getInstance ( AES_CBC_ALG ) ; cipher . init ( mode , secretKey , ivSpec ) ; return cipher . doFinal ( input ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] generateAesKey ( ) { return generateAesKey ( DEFAULT_AES_KEYSIZE ) ; }", "output": "public static byte [ ] generateAesKey ( int keysize ) { try { KeyGenerator keyGenerator = KeyGenerator . getInstance ( AES_ALG ) ; keyGenerator . init ( keysize ) ; SecretKey secretKey = keyGenerator . generateKey ( ) ; return secretKey . getEncoded ( ) ; } catch ( GeneralSecurityException e ) { throw ExceptionUtil . unchecked ( e ) ; } } public static byte [ ] generateIV ( ) { byte [ ] bytes = new byte [ DEFAULT_IVSIZE ] ; random . nextBytes ( bytes ) ; return bytes ; } }"}, {"input": "package cn . org . alan . exam . model . vo ; import lombok . Data ; @ Data public class GradeVO { private static final long serialVersionUID = <NUM_LIT> ; private Integer id ; private String gradeName ; private Integer userId ; private String userName ; private String code ; private Integer gradeCount ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDict extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer type ;", "output": "}"}, {"input": "package com . oddfar . campus . common . validator ; import javax . validation . Constraint ; import javax . validation . Payload ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( value = { ElementType . METHOD , ElementType . FIELD , ElementType . CONSTRUCTOR , ElementType . PARAMETER } ) @ Constraint ( validatedBy = { XssValidator . class }", "output": ") public @ interface Xss { String message ( ) default \"<STR_LIT>\" ; Class < ? > [ ] groups ( ) default { } ; Class < ? extends Payload > [ ] payload ( ) default { } ; }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class UserExamsScore implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer examId ; private Integer totalTime ; private Integer userTime ; private Integer userScore ; private LocalDateTime limitTime ; private Integer count ; private Integer state ; private Integer whetherMark ; public Integer getWhetherMark ( ) { return whetherMark ; } public void setWhetherMark ( Integer whetherMark ) { this . whetherMark = whetherMark ; } @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getExamId ( ) { return examId ; } public void setExamId ( Integer examId ) { this . examId = examId ; } public Integer getTotalTime ( ) { return totalTime ; } public void setTotalTime ( Integer totalTime ) { this . totalTime = totalTime ; } public Integer getUserTime ( ) { return userTime ; } public void setUserTime ( Integer userTime ) { this . userTime = userTime ; } public Integer getUserScore ( ) { return userScore ; } public void setUserScore ( Integer userScore ) { this . userScore = userScore ; } public LocalDateTime getLimitTime ( ) { return limitTime ; } public void setLimitTime ( LocalDateTime limitTime ) {", "output": "this . limitTime = limitTime ; } public Integer getCount ( ) { return count ; } public void setCount ( Integer count ) { this . count = count ; } public Integer getState ( ) { return state ; } public void setState ( Integer state ) { this . state = state ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + totalTime + \"<STR_LIT>\" + userTime + \"<STR_LIT>\" + userScore + \"<STR_LIT>\" + limitTime + \"<STR_LIT>\" + count + \"<STR_LIT>\" + state + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . collect . Iterables ; import com . google . common . collect . Iterators ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . type . Pair ; import java . util . * ; public class CollectionUtil { public static boolean isEmpty ( Collection < ? > collection ) { return ( collection == null ) || collection . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > collection ) { return ( collection != null ) && ! ( collection . isEmpty ( ) ) ; } public static < T > T getFirst ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { return ( ( List < T > ) collection ) . get ( <NUM_LIT> ) ; } return collection . iterator ( ) . next ( ) ; } public static < T > T getLast ( Collection < T > collection ) { if ( isEmpty ( collection ) ) { return null ; } if ( collection instanceof List ) { List < T > list = ( List < T > ) collection ; return list . get ( list . size ( ) - <NUM_LIT> ) ; } return Iterators . getLast ( collection . iterator ( ) ) ; } public static boolean elementsEqual ( Iterable < ? > iterable1 , Iterable < ? > iterable2 ) { return Iterables . elementsEqual ( iterable1 , iterable2 ) ; } public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > coll ) { return Collections . min ( coll ) ; } public static < T > T min ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . min ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > coll ) { return Collections . max ( coll ) ; } public static < T > T max ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { return Collections . max ( coll , comp ) ; } public static < T extends Object & Comparable < ? super T > > Pair < T , T > minAndMax ( Collection < ? extends T > coll ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( next . compareTo ( minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( next . compareTo ( maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T > Pair < T , T > minAndMax ( Collection < ? extends T > coll , Comparator < ? super T > comp ) { Iterator < ? extends T > i = coll . iterator ( ) ; T minCandidate = i . next ( ) ; T maxCandidate = minCandidate ; while ( i . hasNext ( ) ) { T next = i . next ( ) ; if ( comp . compare ( next , minCandidate ) < <NUM_LIT> ) { minCandidate = next ; } else if ( comp . compare ( next , maxCandidate ) > <NUM_LIT> ) { maxCandidate = next ; } } return Pair . of ( minCandidate , maxCandidate ) ; } public static < T extends Comparable < ? > > List < T > topN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . greatestOf ( coll , n ) ; } public static < T > List < T > topN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) { return Ordering . from ( comp ) . greatestOf ( coll , n ) ; } public static < T extends Comparable < ? > > List < T > bottomN ( Iterable < T > coll , int n ) { return Ordering . natural ( ) . leastOf ( coll , n ) ; } public static < T > List < T > bottomN ( Iterable < T > coll , int n , Comparator < ? super T > comp ) { return Ordering . from ( comp ) . leastOf ( coll , n ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . model . vo . record ; import cn . org . alan . exam . model . entity . Option ; import lombok . Data ; import java . util . List ; @ Data public class ExamRecordDetailVO { private String title ; private String image ; private List < Option > option ; private String myOption ; private String rightOption ; private Integer isRight ; private String analyse ; private Integer quType ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . util . ClassUtils ; import java . lang . annotation . * ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . * ; import static java . lang . String . valueOf ; import static java . util . Arrays . asList ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getDefaultValue ; import static org . springframework . util . ClassUtils . resolveClassName ; import static org . springframework . util . CollectionUtils . arrayToList ; import static org . springframework . util . CollectionUtils . isEmpty ; import static org . springframework . util . ObjectUtils . nullSafeEquals ; import static org . springframework . util . ReflectionUtils . findMethod ; import static org . springframework . util . ReflectionUtils . invokeMethod ; import static org . springframework . util . StringUtils . trimWhitespace ; public abstract class AnnotationUtils { public static final String ANNOTATED_ELEMENT_UTILS_CLASS_NAME = \"<STR_LIT>\" ; public static < A extends Annotation > boolean isPresent ( Method method , Class < A > annotationClass ) { Map < ElementType , List < A > > annotationsMap = findAnnotations ( method , annotationClass ) ; return ! annotationsMap . isEmpty ( ) ; } public static < A extends Annotation > Map < ElementType , List < A > > findAnnotations ( Method method , Class < A > annotationClass ) { Retention retention = annotationClass . getAnnotation ( Retention . class ) ; RetentionPolicy retentionPolicy = retention . value ( ) ; if ( ! RetentionPolicy . RUNTIME . equals ( retentionPolicy ) ) { return Collections . emptyMap ( ) ; } Map < ElementType , List < A > > annotationsMap = new LinkedHashMap < ElementType , List < A > > ( ) ; Target target = annotationClass . getAnnotation ( Target . class ) ; ElementType [ ] elementTypes = target . value ( ) ; for ( ElementType elementType : elementTypes ) { List < A > annotationsList = new LinkedList < A > ( ) ; switch ( elementType ) { case PARAMETER : Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; for ( Annotation [ ] annotations : parameterAnnotations ) { for ( Annotation annotation : annotations ) { if ( annotationClass . equals ( annotation . annotationType ( ) ) ) { annotationsList . add ( ( A ) annotation ) ; } } } break ; case METHOD : A annotation = findAnnotation ( method , annotationClass ) ; if ( annotation != null ) { annotationsList . add ( annotation ) ; } break ; case TYPE : Class < ? > beanType = method . getDeclaringClass ( ) ; A annotation2 = findAnnotation ( beanType , annotationClass ) ; if ( annotation2 != null ) { annotationsList . add ( annotation2 ) ; } break ; } if ( ! annotationsList . isEmpty ( ) ) { annotationsMap . put ( elementType , annotationsList ) ; } } return Collections . unmodifiableMap ( annotationsMap ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static Map < String , Object > getAttributes ( Map < String , Object > annotationAttributes , PropertyResolver propertyResolver , String ... ignoreAttributeNames ) { Set < String > ignoreAttributeNamesSet = new HashSet < String > ( asList ( ignoreAttributeNames ) ) ; Map < String , Object > actualAttributes = new LinkedHashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( ignoreAttributeNamesSet . contains ( attributeName ) ) { continue ; } if ( attributeValue instanceof String ) { attributeValue = resolvePlaceholders ( valueOf ( attributeValue ) , propertyResolver ) ; } else if ( attributeValue instanceof String [ ] ) { String [ ] values = ( String [ ] ) attributeValue ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { values [ i ] = resolvePlaceholders ( values [ i ] , propertyResolver ) ; } attributeValue = values ; } actualAttributes . put ( attributeName , attributeValue ) ; } return actualAttributes ; } public static Map < String , Object > getAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Map < String , Object > annotationAttributes = org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation , classValuesAsString , nestedAnnotationsAsMap ) ; String [ ] actualIgnoreAttributeNames = ignoreAttributeNames ; if ( ignoreDefaultValue && ! isEmpty ( annotationAttributes ) ) { List < String > attributeNamesToIgnore = new LinkedList < String > ( asList ( ignoreAttributeNames ) ) ; for ( Map . Entry < String , Object > annotationAttribute : annotationAttributes . entrySet ( ) ) { String attributeName = annotationAttribute . getKey ( ) ; Object attributeValue = annotationAttribute . getValue ( ) ; if ( nullSafeEquals ( attributeValue , getDefaultValue ( annotation , attributeName ) ) ) { attributeNamesToIgnore . add ( attributeName ) ; } } actualIgnoreAttributeNames = attributeNamesToIgnore . toArray ( new String [ attributeNamesToIgnore . size ( ) ] ) ; } return getAttributes ( annotationAttributes , propertyResolver , actualIgnoreAttributeNames ) ; } private static String resolvePlaceholders ( String attributeValue , PropertyResolver propertyResolver ) { String resolvedValue = attributeValue ; if ( propertyResolver != null ) { resolvedValue = propertyResolver . resolvePlaceholders ( resolvedValue ) ; resolvedValue = trimWhitespace ( resolvedValue ) ; } return resolvedValue ; } public static < T > T getAttribute ( Annotation annotation , String attributeName ) { return getAttribute ( org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ( annotation ) , attributeName ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , false ) ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , boolean required ) { T value = getAttribute ( attributes , attributeName , null ) ; if ( required && value == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + attributeName + \"<STR_LIT>\" ) ; } return value ; } public static < T > T getAttribute ( Map < String , Object > attributes , String attributeName , T defaultValue ) { T value = ( T ) attributes . get ( attributeName ) ; return value == null ? defaultValue : value ; } public static < T > T getRequiredAttribute ( Map < String , Object > attributes , String attributeName ) { return getAttribute ( attributes , attributeName , true ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotation , null , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return fromMap ( getAttributes ( annotation , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ) ; } public static AnnotationAttributes getAnnotationAttributes ( Annotation annotation , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotation , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return getAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Annotation annotation = annotatedElement . getAnnotation ( annotationType ) ; return annotation == null ? null : getAnnotationAttributes ( annotation , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , boolean tryMergedAnnotation , String ... ignoreAttributeNames ) {", "output": "return getAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , false , false , ignoreDefaultValue , tryMergedAnnotation , ignoreAttributeNames ) ; } public static AnnotationAttributes getAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , boolean tryMergedAnnotation , String ... ignoreAttributeNames ) { AnnotationAttributes attributes = null ; if ( tryMergedAnnotation ) { attributes = tryGetMergedAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } if ( attributes == null ) { attributes = getAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } return attributes ; } public static Annotation tryGetMergedAnnotation ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType ) { return tryGetMergedAnnotation ( annotatedElement , annotationType , false , false ) ; } public static Annotation tryGetMergedAnnotation ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , boolean classValuesAsString , boolean nestedAnnotationsAsMap ) { Annotation mergedAnnotation = null ; ClassLoader classLoader = annotationType . getClassLoader ( ) ; if ( ClassUtils . isPresent ( ANNOTATED_ELEMENT_UTILS_CLASS_NAME , classLoader ) ) { Class < ? > annotatedElementUtilsClass = resolveClassName ( ANNOTATED_ELEMENT_UTILS_CLASS_NAME , classLoader ) ; Method getMergedAnnotationMethod = findMethod ( annotatedElementUtilsClass , \"<STR_LIT>\" , AnnotatedElement . class , Class . class , boolean . class , boolean . class ) ; if ( getMergedAnnotationMethod != null ) { mergedAnnotation = ( Annotation ) invokeMethod ( getMergedAnnotationMethod , null , annotatedElement , annotationType , classValuesAsString , nestedAnnotationsAsMap ) ; } } return mergedAnnotation ; } public static AnnotationAttributes tryGetMergedAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { return tryGetMergedAnnotationAttributes ( annotatedElement , annotationType , propertyResolver , false , false , ignoreDefaultValue , ignoreAttributeNames ) ; } public static AnnotationAttributes tryGetMergedAnnotationAttributes ( AnnotatedElement annotatedElement , Class < ? extends Annotation > annotationType , PropertyResolver propertyResolver , boolean classValuesAsString , boolean nestedAnnotationsAsMap , boolean ignoreDefaultValue , String ... ignoreAttributeNames ) { Annotation annotation = tryGetMergedAnnotation ( annotatedElement , annotationType , classValuesAsString , nestedAnnotationsAsMap ) ; return annotation == null ? null : getAnnotationAttributes ( annotation , propertyResolver , classValuesAsString , nestedAnnotationsAsMap , ignoreDefaultValue , ignoreAttributeNames ) ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . vo . stat . AllStatsVO ; import cn . org . alan . exam . model . vo . stat . DailyVO ; import cn . org . alan . exam . model . vo . stat . GradeExamVO ; import cn . org . alan . exam . model . vo . stat . GradeStudentVO ; import cn . org . alan . exam . service . IStatService ; import jakarta . annotation . Resource ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class StatController { @ Resource private IStatService statService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < GradeStudentVO > > getStudentGradeCount ( ) { return statService . getStudentGradeCount ( ) ;", "output": "} @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < GradeExamVO > > getExamGradeCount ( ) { return statService . getExamGradeCount ( ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < AllStatsVO > getAllCount ( ) { return statService . getAllCount ( ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < DailyVO > > getDaily ( ) { return statService . getDaily ( ) ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . Feeds ; import com . xcs . wx . domain . vo . FeedsVO ; import org . mapstruct . Mapper ; import java . util . List ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface FeedsMapping { List < FeedsVO > convert ( List < Feeds > feeds ) ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . controller ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdReqDTO ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . plugin . dto . PluginGroupDTO ; import com . yf . system . modules . plugin . service . PluginGroupService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class PluginGroupController extends BaseController { @ Autowired private PluginGroupService baseService ;", "output": "@ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody PluginGroupDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest delete ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < PluginGroupDTO > detail ( @ RequestBody BaseIdReqDTO reqDTO ) { PluginGroupDTO dto = baseService . detail ( reqDTO . getId ( ) ) ; return super . success ( dto ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < IPage < PluginGroupDTO > > paging ( @ RequestBody PagingReqDTO < PluginGroupDTO > reqDTO ) { IPage < PluginGroupDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < List < PluginGroupDTO > > list ( @ RequestBody PluginGroupDTO reqDTO ) { List < PluginGroupDTO > dtoList = baseService . list ( reqDTO ) ; return super . success ( dtoList ) ; } }"}, {"input": "package com . xcs . wx . msg . impl ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import org . springframework . stereotype . Service ; @ Service public class TextMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ;", "output": "} @ Override public void process ( MsgVO msgVO ) { } }"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . BooleanUtils ; public class BooleanUtil { public static boolean toBoolean ( String str ) { return Boolean . parseBoolean ( str ) ; } public static Boolean toBooleanObject ( String str ) { return str != null ? Boolean . valueOf ( str ) : null ; } public static Boolean toBooleanObject ( String str , Boolean defaultValue ) { return str != null ? Boolean . valueOf ( str ) : defaultValue ; } public static Boolean parseGeneralString ( String str ) { return BooleanUtils . toBooleanObject ( str ) ; } public static Boolean parseGeneralString ( String str , Boolean defaultValue ) { return BooleanUtils . toBooleanDefaultIfNull ( BooleanUtils . toBooleanObject ( str ) , defaultValue ) ; } public static boolean negate ( final boolean bool ) { return ! bool ; } public static Boolean negate ( final Boolean bool ) { return BooleanUtils . negate ( bool ) ; }", "output": "public static boolean and ( final boolean ... array ) { return BooleanUtils . and ( array ) ; } public static boolean or ( final boolean ... array ) { return BooleanUtils . or ( array ) ; } }"}, {"input": "package com . youlai . system . security . util ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . json . JSONObject ; import cn . hutool . jwt . JWTPayload ; import cn . hutool . jwt . JWTUtil ; import com . youlai . system . common . constant . JwtClaimConstants ; import com . youlai . system . security . model . SysUserDetails ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . security . core . authority . SimpleGrantedAuthority ; import org . springframework . stereotype . Component ; import java . util . * ; import java . util . stream . Collectors ; @ Component public class JwtUtils { private static byte [ ] key ; private static int ttl ; @ Value ( \"<STR_LIT>\" ) public void setKey ( String key ) { JwtUtils . key = key . getBytes ( ) ; } @ Value ( \"<STR_LIT>\" ) public void setTtl ( Integer ttl ) { JwtUtils . ttl = ttl ; } public static String createToken ( Authentication authentication ) { SysUserDetails userDetails = ( SysUserDetails ) authentication . getPrincipal ( ) ; Map < String , Object > payload = new HashMap < > ( ) ; payload . put ( JwtClaimConstants . USER_ID , userDetails . getUserId ( ) ) ; payload . put ( JwtClaimConstants . DEPT_ID , userDetails . getDeptId ( ) ) ; payload . put ( JwtClaimConstants . DATA_SCOPE , userDetails . getDataScope ( ) ) ; Set < String > roles = userDetails . getAuthorities ( ) . stream ( ) . map ( GrantedAuthority :: getAuthority ) . collect ( Collectors . toSet ( ) ) ; payload . put ( JwtClaimConstants . AUTHORITIES , roles ) ; Date now = new Date ( ) ; Date expiration = DateUtil . offsetSecond ( now , ttl ) ; payload . put ( JWTPayload . ISSUED_AT , now ) ; payload . put ( JWTPayload . EXPIRES_AT , expiration ) ; payload . put ( JWTPayload . SUBJECT , authentication . getName ( ) ) ; payload . put ( JWTPayload . JWT_ID , IdUtil . simpleUUID ( ) ) ; return JWTUtil . createToken ( payload , key ) ; } public static UsernamePasswordAuthenticationToken getAuthentication ( JSONObject payloads ) { SysUserDetails userDetails = new SysUserDetails ( ) ; userDetails . setUserId ( payloads . getLong ( JwtClaimConstants . USER_ID ) ) ; userDetails . setDeptId ( payloads . getLong ( JwtClaimConstants . DEPT_ID ) ) ; userDetails . setDataScope ( payloads . getInt ( JwtClaimConstants . DATA_SCOPE ) ) ; userDetails . setUsername ( payloads . getStr ( JWTPayload . SUBJECT ) ) ; Set < SimpleGrantedAuthority > authorities = payloads . getJSONArray ( JwtClaimConstants . AUTHORITIES ) . stream ( ) . map ( authority -> new SimpleGrantedAuthority ( Convert . toStr ( authority ) ) ) . collect ( Collectors . toSet ( ) ) ; return new UsernamePasswordAuthenticationToken ( userDetails , \"<STR_LIT>\" , authorities ) ;", "output": "} }"}, {"input": "package org . springblade . web . config . engine . contract ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . web . model . ForceModelContractAll ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Slf4j public class CoinMatchContractFactoryAll { private ConcurrentHashMap < String , CoinMatchContractAll > matchMap ; public CoinMatchContractFactoryAll ( ) { this . matchMap = new ConcurrentHashMap < > ( ) ; } public void addExchangeCoinMatch ( String contractTypeStr , CoinMatchContractAll match ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { this . matchMap . put ( contractTypeStr , match ) ; } } public boolean containsExchangeCoinMatch ( String contractTypeStr ) {", "output": "contractTypeStr = contractTypeStr . toUpperCase ( ) ; return this . matchMap != null && this . matchMap . containsKey ( contractTypeStr ) ; } public ForceModelContractAll reset ( String memberId , String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; ForceModelContractAll reset = match . reset ( memberId , baseSqlService ) ; return reset ; } public void resetAll ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { try { contractTypeStr = contractTypeStr . toUpperCase ( ) ; CoinMatchContractAll match = this . getExchangeCoinMatchAuto ( contractTypeStr , baseSqlService ) ; match . resetAll ( baseSqlService ) ; } catch ( Exception e ) { } } public CoinMatchContractAll getExchangeCoinMatchAuto ( String contractTypeStr , IMjkjBaseSqlService baseSqlService ) { contractTypeStr = contractTypeStr . toUpperCase ( ) ; if ( ! this . containsExchangeCoinMatch ( contractTypeStr ) ) { CoinMatchContractAll match = new CoinMatchContractAll ( ) ; match . init ( baseSqlService ) ; this . matchMap . put ( contractTypeStr , match ) ; } return this . matchMap . get ( contractTypeStr ) ; } public Map < String , CoinMatchContractAll > getMatchMap ( ) { return this . matchMap ; } }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . service . MsgService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class MsgController { private final MsgService msgService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < MsgVO > > list ( @ RequestParam String talker , @ RequestParam Long nextSequence ) { return ResponseVO . ok ( msgService . queryMsg ( talker , nextSequence ) ) ; }", "output": "@ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < String > export ( @ RequestParam String talker ) { return ResponseVO . ok ( msgService . exportMsg ( talker ) ) ; } }"}, {"input": "package org . springblade . cgform . model . file ; import lombok . Data ; @ Data public class FileLogModel { private Long file_id ; private String type ; private String file_title ; private String remark ; private Long operate_user_id ; private String operate_user_name ; private String tenant_id ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class Category extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long pid ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pstr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hasChild ;", "output": "}"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SendYxParam { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ip ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . CopyOnWriteArrayList ; public class SystemPropertiesUtil { public static Boolean getBoolean ( String name ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult ) ; } public static Boolean getBoolean ( String name , Boolean defaultValue ) { String stringResult = System . getProperty ( name ) ; return BooleanUtil . toBooleanObject ( stringResult , defaultValue ) ; } public static String getString ( String name ) { return System . getProperty ( name ) ; } public static String getString ( String name , String defaultValue ) {", "output": "return System . getProperty ( name , defaultValue ) ; } public static Integer getInteger ( String name ) { return Integer . getInteger ( name ) ; } public static Integer getInteger ( String name , Integer defaultValue ) { return Integer . getInteger ( name , defaultValue ) ; } public static Long getLong ( String name ) { return Long . getLong ( name ) ; } public static Long getLong ( String name , Long defaultValue ) { return Long . getLong ( name , defaultValue ) ; } public static Double getDouble ( String propertyName ) { return NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; } public static Double getDouble ( String propertyName , Double defaultValue ) { Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } public static String getString ( String propertyName , String envName , String defaultValue ) { checkEnvName ( envName ) ; String propertyValue = System . getProperty ( propertyName ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = System . getenv ( envName ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Integer getInteger ( String propertyName , String envName , Integer defaultValue ) { checkEnvName ( envName ) ; Integer propertyValue = NumberUtil . toIntObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toIntObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Long getLong ( String propertyName , String envName , Long defaultValue ) { checkEnvName ( envName ) ; Long propertyValue = NumberUtil . toLongObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toLongObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Double getDouble ( String propertyName , String envName , Double defaultValue ) { checkEnvName ( envName ) ; Double propertyValue = NumberUtil . toDoubleObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = NumberUtil . toDoubleObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } public static Boolean getBoolean ( String propertyName , String envName , Boolean defaultValue ) { checkEnvName ( envName ) ; Boolean propertyValue = BooleanUtil . toBooleanObject ( System . getProperty ( propertyName ) , null ) ; if ( propertyValue != null ) { return propertyValue ; } else { propertyValue = BooleanUtil . toBooleanObject ( System . getenv ( envName ) , null ) ; return propertyValue != null ? propertyValue : defaultValue ; } } private static void checkEnvName ( String envName ) { if ( envName == null || envName . indexOf ( '<STR_LIT>' ) != - <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + envName + \"<STR_LIT>\" ) ; } } public static synchronized void registerSystemPropertiesListener ( PropertiesListener listener ) { Properties currentProperties = System . getProperties ( ) ; if ( ! ( currentProperties instanceof ListenableProperties ) ) { ListenableProperties newProperties = new ListenableProperties ( currentProperties ) ; System . setProperties ( newProperties ) ; currentProperties = newProperties ; } ( ( ListenableProperties ) currentProperties ) . register ( listener ) ; } public static class ListenableProperties extends Properties { private static final long serialVersionUID = - <NUM_LIT> ; protected transient List < PropertiesListener > listeners = new CopyOnWriteArrayList < PropertiesListener > ( ) ; public ListenableProperties ( Properties properties ) { super ( properties ) ; } public void register ( PropertiesListener listener ) { listeners . add ( listener ) ; } @ Override public synchronized Object setProperty ( String key , String value ) { Object result = put ( key , value ) ; for ( PropertiesListener listener : listeners ) { if ( listener . propertyName . equals ( key ) ) { listener . onChange ( key , value ) ; } } return result ; } } public abstract static class PropertiesListener { protected String propertyName ; public PropertiesListener ( String propertyName ) { this . propertyName = propertyName ; } public abstract void onChange ( String propertyName , String value ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . stat ; import lombok . Data ; @ Data public class AllStatsVO { private Integer classCount ; private Integer examCount ; private Integer questionCount ;", "output": "}"}, {"input": "package com . xcs . wx . msg . impl ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import org . springframework . stereotype . Service ; @ Service public class MapMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ; } @ Override public void process ( MsgVO msgVO ) {", "output": "msgVO . setStrContent ( \"<STR_LIT>\" ) ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . FlowForm ; public interface FlowFormMapper extends BaseMapper < FlowForm > {", "output": "}"}, {"input": "package com . xcs . wx . config ; import com . baomidou . mybatisplus . annotation . DbType ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ MapperScan ( { \"<STR_LIT>\" } ) public class MybatisPlusConfig { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; interceptor . addInnerInterceptor ( new PaginationInnerInterceptor ( DbType . SQLITE ) ) ; return interceptor ;", "output": "} }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . Session ; import com . xcs . wx . domain . vo . SessionVO ; import java . util . List ; public interface SessionMapper extends BaseMapper < Session > {", "output": "List < SessionVO > querySession ( ) ; }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . toolkit . DynamicDataSourceContextHolder ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . Msg ; import com . xcs . wx . domain . vo . CountRecentMsgsVO ; import com . xcs . wx . domain . vo . MsgTypeDistributionVO ; import com . xcs . wx . domain . vo . TopContactsVO ; import com . xcs . wx . mapper . MsgMapper ; import com . xcs . wx . repository . MsgRepository ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Repository ; import java . util . * ; import java . util . stream . Collectors ; @ Slf4j @ Repository @ RequiredArgsConstructor public class MsgRepositoryImpl extends ServiceImpl < MsgMapper , Msg > implements MsgRepository { @ Override public List < Msg > queryMsgByTalker ( String talker , Long nextSequence ) { List < Msg > msgList = new ArrayList < > ( ) ; List < String > msgDbList = DataSourceType . getMsgDb ( ) . stream ( ) . sorted ( Comparator . reverseOrder ( ) ) . collect ( Collectors . toList ( ) ) ; int offset = <NUM_LIT> ; for ( String poolName : msgDbList ) { if ( offset <= <NUM_LIT> ) break ; DynamicDataSourceContextHolder . push ( poolName ) ; List < Msg > queryResultList = super . list ( Wrappers . < Msg > lambdaQuery ( ) . eq ( Msg :: getStrTalker , talker ) . orderByDesc ( Msg :: getSequence ) . lt ( ( nextSequence != null && nextSequence > <NUM_LIT> ) , Msg :: getSequence , nextSequence ) . last ( \"<STR_LIT>\" + offset ) ) ; DynamicDataSourceContextHolder . clear ( ) ; offset -= queryResultList . size ( ) ; msgList . addAll ( queryResultList ) ; } return msgList ; } @ Override public List < Msg > exportMsg ( String talker ) { List < Msg > msgList = new ArrayList < > ( ) ; List < String > msgDbList = DataSourceType . getMsgDb ( ) ; for ( String poolName : msgDbList ) { DynamicDataSourceContextHolder . push ( poolName ) ; List < Msg > queryResultList = super . list ( Wrappers . < Msg > lambdaQuery ( ) . eq ( Msg :: getStrTalker , talker ) . orderByDesc ( Msg :: getSequence ) ) ; DynamicDataSourceContextHolder . clear ( ) ; msgList . addAll ( queryResultList ) ; } return msgList ; } @ Override public List < MsgTypeDistributionVO > msgTypeDistribution ( ) { Optional < String > poolNameOptional = DataSourceType . getMsgDb ( ) . stream ( ) . max ( Comparator . naturalOrder ( ) ) ; if ( poolNameOptional . isPresent ( ) ) { DynamicDataSourceContextHolder . push ( poolNameOptional . get ( ) ) ; List < MsgTypeDistributionVO > currentMsgsList = super . getBaseMapper ( ) . msgTypeDistribution ( ) ; DynamicDataSourceContextHolder . clear ( ) ; return currentMsgsList ; } return Collections . emptyList ( ) ; } @ Override public List < CountRecentMsgsVO > countRecentMsgs ( ) { Optional < String > poolNameOptional = DataSourceType . getMsgDb ( ) . stream ( ) . max ( Comparator . naturalOrder ( ) ) ; if ( poolNameOptional . isPresent ( ) ) { DynamicDataSourceContextHolder . push ( poolNameOptional . get ( ) ) ; List < CountRecentMsgsVO > currentMsgsList = super . getBaseMapper ( ) . countRecentMsgs ( ) ; DynamicDataSourceContextHolder . clear ( ) ; return currentMsgsList . stream ( ) . sorted ( Comparator . comparing ( CountRecentMsgsVO :: getType ) . reversed ( ) ) . collect ( Collectors . toList ( ) ) ; } return Collections . emptyList ( ) ; } @ Override public List < TopContactsVO > topContacts ( ) { Optional < String > poolNameOptional = DataSourceType . getMsgDb ( ) . stream ( ) . max ( Comparator . naturalOrder ( ) ) ; if ( poolNameOptional . isPresent ( ) ) { DynamicDataSourceContextHolder . push ( poolNameOptional . get ( ) ) ; List < TopContactsVO > currentContactsList = super . getBaseMapper ( ) . topContacts ( ) ; DynamicDataSourceContextHolder . clear ( ) ; return currentContactsList . stream ( ) . sorted ( Comparator . comparing ( TopContactsVO :: getTotal ) . reversed ( ) ) . limit ( <NUM_LIT> ) . collect ( Collectors . toList ( ) ) ; } return Collections . emptyList ( ) ; } @ Override public int countSent ( ) { Optional < String > poolNameOptional = DataSourceType . getMsgDb ( ) . stream ( ) . max ( Comparator . naturalOrder ( ) ) ; if ( poolNameOptional . isPresent ( ) ) {", "output": "DynamicDataSourceContextHolder . push ( poolNameOptional . get ( ) ) ; int count = getBaseMapper ( ) . countSent ( ) ; DynamicDataSourceContextHolder . clear ( ) ; return count ; } return <NUM_LIT> ; } @ Override public int countReceived ( ) { Optional < String > poolNameOptional = DataSourceType . getMsgDb ( ) . stream ( ) . max ( Comparator . naturalOrder ( ) ) ; if ( poolNameOptional . isPresent ( ) ) { DynamicDataSourceContextHolder . push ( poolNameOptional . get ( ) ) ; int count = getBaseMapper ( ) . countReceived ( ) ; DynamicDataSourceContextHolder . clear ( ) ; return count ; } return <NUM_LIT> ; } }"}, {"input": "package ginyi . common . constant ; public class HttpStatus { public static final int SUCCESS = <NUM_LIT> ; public static final int CREATED = <NUM_LIT> ; public static final int ACCEPTED = <NUM_LIT> ; public static final int NO_CONTENT = <NUM_LIT> ; public static final int MOVED_PERM = <NUM_LIT> ; public static final int SEE_OTHER = <NUM_LIT> ; public static final int NOT_MODIFIED = <NUM_LIT> ; public static final int BAD_REQUEST = <NUM_LIT> ; public static final int UNAUTHORIZED = <NUM_LIT> ; public static final int FORBIDDEN = <NUM_LIT> ; public static final int NOT_FOUND = <NUM_LIT> ; public static final int BAD_METHOD = <NUM_LIT> ; public static final int CONFLICT = <NUM_LIT> ; public static final int UNSUPPORTED_TYPE = <NUM_LIT> ; public static final int ERROR = <NUM_LIT> ; public static final int NOT_IMPLEMENTED = <NUM_LIT> ; public static final int WARN = <NUM_LIT> ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . concurrent . atomic . AtomicLong ; public class LongAdder extends Striped64 implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; final long fn ( long v , long x ) { return v + x ; } public LongAdder ( ) { } public void add ( long x ) { Cell [ ] as ; long b , v ; int [ ] hc ; Cell a ; int n ; if ( ( as = cells ) != null || ! casBase ( b = base , b + x ) ) { boolean uncontended = true ; if ( ( hc = threadHashCode . get ( ) ) == null || as == null || ( n = as . length ) < <NUM_LIT> || ( a = as [ ( n - <NUM_LIT> ) & hc [ <NUM_LIT> ] ] ) == null || ! ( uncontended = a . cas ( v = a . value , v + x ) ) ) retryUpdate ( x , hc , uncontended ) ; } } public void increment ( ) { add ( <NUM_LIT> ) ; } public void decrement ( ) { add ( - <NUM_LIT> ) ; } public long sum ( ) { long sum = base ; Cell [ ] as = cells ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ;", "output": "++ i ) { Cell a = as [ i ] ; if ( a != null ) sum += a . value ; } } return sum ; } public void reset ( ) { internalReset ( <NUM_LIT> ) ; } public long sumThenReset ( ) { long sum = base ; Cell [ ] as = cells ; base = <NUM_LIT> ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) { sum += a . value ; a . value = <NUM_LIT> ; } } } return sum ; } public String toString ( ) { return Long . toString ( sum ( ) ) ; } public long longValue ( ) { return sum ( ) ; } public int intValue ( ) { return ( int ) sum ( ) ; } public float floatValue ( ) { return ( float ) sum ( ) ; } public double doubleValue ( ) { return ( double ) sum ( ) ; } private void writeObject ( ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; s . writeLong ( sum ( ) ) ; } private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; busy = <NUM_LIT> ; cells = null ; base = s . readLong ( ) ; } }"}, {"input": "package com . yf . system . modules . dict . controller ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdRespDTO ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . system . modules . dict . dto . SysDicValueDTO ; import com . yf . system . modules . dict . dto . ext . DicValueTreeDTO ; import com . yf . system . modules . dict . dto . request . SysDicValueReqDTO ; import com . yf . system . modules . dict . service . SysDicValueService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . apache . shiro . authz . annotation . Logical ; import org . apache . shiro . authz . annotation . RequiresPermissions ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysDicValueController extends BaseController { @ Autowired private SysDicValueService baseService ; @ RequiresPermissions ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" } , logical = Logical . OR ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < BaseIdRespDTO > save ( @ RequestBody SysDicValueDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest edit ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . removeByIds ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = {", "output": "RequestMethod . POST } ) public ApiRest < List < DicValueTreeDTO > > tree ( @ RequestBody SysDicValueReqDTO reqDTO ) { List < DicValueTreeDTO > dtoList = baseService . findTree ( reqDTO ) ; return super . success ( dtoList ) ; } }"}, {"input": "package com . yf . system . modules . config . controller ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . utils . BeanMapper ; import com . yf . system . modules . config . dto . CfgBaseDTO ; import com . yf . system . modules . config . service . CfgBaseService ; import com . yf . system . modules . config . service . CfgSwitchService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import java . util . HashMap ; import java . util . Map ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class CfgBaseController extends BaseController { @ Autowired private CfgBaseService baseService ; @ Autowired private CfgSwitchService cfgSwitchService ; @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody CfgBaseDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < Map < String , Object > > detail ( ) { Map < String , Object > resMap = new HashMap < > ( <NUM_LIT> ) ; CfgBaseDTO dto = baseService . findSimple ( ) ; BeanMapper . copy ( dto , resMap ) ; Map < String , Object > props = cfgSwitchService . allMap ( ) ; resMap . putAll ( props ) ; resMap . put ( \"<STR_LIT>\" , props ) ; return super . success ( resMap ) ;", "output": "} }"}, {"input": "package top . kangert . kspider . listener ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . listener . SpiderListener ; import top . kangert . kspider . util . SeleniumResponseHolder ; import org . springframework . stereotype . Component ; @ Component public class SeleniumListener implements SpiderListener { @ Override public void beforeStart ( SpiderContext context ) { } @ Override public void afterEnd ( SpiderContext context ) { SeleniumResponseHolder . clear ( context ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . model . vo . record ; import cn . org . alan . exam . model . entity . Option ; import lombok . Data ; import java . util . List ; @ Data public class ExerciseRecordDetailVO { private String title ; private List < Option > option ; private String myOption ; private String rightOption ; private Integer isRight ; private String analyse ; private String image ; private Integer quType ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Pattern ; @ Data public class AntiCodeParam { @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String antiCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String emailCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String googleCode ;", "output": "}"}, {"input": "package com . xcs . wx . domain . dto ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ Data @ EqualsAndHashCode ( callSuper = true ) public class ContactDTO extends PageDTO { private String remark ; private String nickName ; private String labels ; private String describe ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class TimeoutNacosConfigListener extends AbstractListener { private static AtomicInteger id = new AtomicInteger ( <NUM_LIT> ) ; private static ExecutorService executorService = Executors . newScheduledThreadPool ( <NUM_LIT> , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( r ) ; t . setDaemon ( true ) ; t . setName ( \"<STR_LIT>\" + id . incrementAndGet ( ) ) ; return t ; } } ) ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ;", "output": "private final String dataId ; private final String groupId ; private final long timeout ; public TimeoutNacosConfigListener ( String dataId , String groupId , long timeout ) { this . dataId = dataId ; this . groupId = groupId ; this . timeout = timeout ; } @ Override public void receiveConfigInfo ( final String content ) { Future future = executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { onReceived ( content ) ; } } ) ; try { future . get ( timeout , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( e ) ; } catch ( TimeoutException e ) { future . cancel ( true ) ; logger . warn ( \"<STR_LIT>\" + \"<STR_LIT>\" , timeout , dataId , groupId , content ) ; } } protected abstract void onReceived ( String content ) ; public long getTimeout ( ) { return timeout ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class SortListParam { private List < Map < String , Object > > sortList ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; public class PaymentParam implements Serializable { private Integer checkType ; private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String owner_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pay_method_id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String country_id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bank ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String branch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String qrCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private boolean is_deleted ; private static final long serialVersionUID = <NUM_LIT> ; public String getOwnerId ( ) { return owner_id ; } public void setOwnerId ( String ownerId ) { this . owner_id = ownerId ; } public String getPayMethodId ( ) { return pay_method_id ; } public void setPay_method_id ( String pay_method_id ) { this . pay_method_id = pay_method_id ; } public String getSurname ( ) { return surname ; } public String getOwner_id ( ) { return owner_id ; } public void setOwner_id ( String owner_id ) { this . owner_id = owner_id ; } public String getPay_method_id ( ) { return pay_method_id ; } public String getCountryId ( ) { return country_id ; } public void setCountry_id ( String country_id ) { this . country_id = country_id ; } public void setQrCode ( String qrCode ) { this . qrCode = qrCode ; } public boolean isIs_deleted ( ) { return is_deleted ; } public void setIs_deleted ( boolean is_deleted ) { this . is_deleted = is_deleted ; } public void setSurname ( String surname ) { this . surname = surname ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getAccount ( ) { return account ; } public void setAccount ( String account ) { this . account = account ; } public String getBank ( ) { return bank ; } public void setBank ( String bank ) { this . bank = bank ; } public String getBranch ( ) { return branch ; } public void setBranch ( String branch ) { this . branch = branch ; } public String getQrCode ( ) { return qrCode ; } public void setQr_code ( String qrCode ) { this . qrCode = qrCode ; } public boolean isDeleted ( ) { return is_deleted ; } public void setDeleted ( boolean deleted ) { is_deleted = deleted ; } public Integer getCheckType ( ) { return checkType ; } public void setCheckType ( Integer checkType ) { this . checkType = checkType ; } public String getCode ( ) { return code ;", "output": "} public void setCode ( String code ) { this . code = code ; } public String getCountry_id ( ) { return country_id ; } }"}, {"input": "package com . xcs . wx . repository ; import com . xcs . wx . domain . FTSContactContent ; import com . xcs . wx . domain . dto . RecoverContactDTO ; import java . util . List ; public interface FTSContactContentRepository { List < FTSContactContent > queryContactContent ( RecoverContactDTO recoverContactDTO ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class ExamDetailVO { private Integer id ; private String username ; private String title ; private Integer examDuration ; private Integer passedScore ; private Integer grossScore ; private Integer maxCount ; private Integer userId ; private Integer certificateId ; private Integer radioCount ; private Integer radioScore ; private Integer multiCount ; private Integer multiScore ; private Integer judgeCount ; private Integer judgeScore ; private Integer saqCount ; private Integer saqScore ; private LocalDateTime startTime ; private LocalDateTime endTime ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . core ; public class HeaderCellConfig { private int index ; private String name ; private CellStyleConfig style = CellStyleConfig . DEFAULT_HEADER_CELL_STYLE ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ;", "output": "} public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public CellStyleConfig getStyle ( ) { return style ; } public void setStyle ( CellStyleConfig style ) { this . style = style ; } }"}, {"input": "package com . oddfar . campus . common . domain . vo ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . oddfar . campus . common . utils . MetaVo ; import java . util . List ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) public class RouterVo { private String name ; private String path ; private boolean hidden ; private String redirect ; private String component ; private String query ; private Boolean alwaysShow ; private MetaVo meta ; private List < RouterVo > children ; public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public String getPath ( ) { return path ; } public void setPath ( String path ) { this . path = path ; } public boolean getHidden ( ) { return hidden ; } public void setHidden ( boolean hidden ) { this . hidden = hidden ; } public String getRedirect ( ) { return redirect ; } public void setRedirect ( String redirect ) { this . redirect = redirect ; } public String getComponent ( ) { return component ; }", "output": "public void setComponent ( String component ) { this . component = component ; } public String getQuery ( ) { return query ; } public void setQuery ( String query ) { this . query = query ; } public Boolean getAlwaysShow ( ) { return alwaysShow ; } public void setAlwaysShow ( Boolean alwaysShow ) { this . alwaysShow = alwaysShow ; } public MetaVo getMeta ( ) { return meta ; } public void setMeta ( MetaVo meta ) { this . meta = meta ; } public List < RouterVo > getChildren ( ) { return children ; } public void setChildren ( List < RouterVo > children ) { this . children = children ; } }"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class DetailMessageModel { private String contractType ; private String symbolName ; private BigDecimal amount ; private BigDecimal open ; private BigDecimal close ; private BigDecimal high ; private BigDecimal count ; private BigDecimal low ; private BigDecimal vol ; private BigDecimal tradeTurnover ;", "output": "}"}, {"input": "package top . kangert . kspider . dao ; import org . springframework . data . jpa . repository . JpaRepository ; import org . springframework . data . jpa . repository . JpaSpecificationExecutor ; import top . kangert . kspider . domain . Variable ; public interface VariableRepository extends JpaRepository < Variable , Long > , JpaSpecificationExecutor < Variable > { Variable findByName ( String variableName ) ; Variable findVariableByVarId ( Long varId ) ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class QuotesParam implements Serializable {", "output": "}"}, {"input": "package com . oddfar . campus . common . domain ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . fasterxml . jackson . annotation . JsonIgnore ; import com . fasterxml . jackson . annotation . JsonInclude ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class BaseEntity implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ TableField ( fill = FieldFill . INSERT ) private Long createUser ; @ TableField ( fill = FieldFill . UPDATE ) private Date updateTime ; @ TableField ( fill = FieldFill . UPDATE ) private Long updateUser ; @ TableLogic @ TableField ( fill = FieldFill . INSERT ) @ JsonIgnore private Integer delFlag ; @ TableField ( exist = false ) @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private Map < String , Object > params = new HashMap < > ( ) ; ;", "output": "}"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . oddfar . campus . common . domain . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; import java . util . ArrayList ; import java . util . List ; @ Data @ EqualsAndHashCode ( callSuper = true ) @ TableName ( \"<STR_LIT>\" ) public class SysMenuEntity extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long menuId ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String menuName ; @ TableField ( exist = false ) private String parentName ; private Long parentId ; @ NotNull ( message = \"<STR_LIT>\" ) private Integer orderNum ; @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String path ; @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String component ; private String query ; private String isFrame ; private String isCache ; @ NotBlank ( message = \"<STR_LIT>\" ) private String menuType ; private String visible ; private String status ; @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String perms ; private String icon ; private String remark ; @ TableField ( exist = false ) private List < SysMenuEntity > children = new ArrayList < SysMenuEntity > ( ) ;", "output": "}"}, {"input": "package com . yf . system . modules . dict . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysDic extends Model < SysDic > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; private String code ; private Integer type ; private String title ; private String remark ;", "output": "}"}, {"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformFieldService extends BaseService < CgformField > {", "output": "Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) ; List < CgformField > queryFormFieldsByTableName ( String field1 ) ; }"}, {"input": "package com . xcs . wx ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . context . annotation . EnableAspectJAutoProxy ; import org . springframework . scheduling . annotation . EnableScheduling ; import org . springframework . transaction . annotation . EnableTransactionManagement ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Date ; @ SpringBootApplication @ EnableTransactionManagement public class WxDumpApplication { public static void main ( String [ ] args ) throws UnknownHostException { long startTime = System . currentTimeMillis ( ) ; ConfigurableApplicationContext context = SpringApplication . run ( WxDumpApplication . class , args ) ; long endTime = System . currentTimeMillis ( ) ; String port = context . getEnvironment ( ) . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String contextPath = context . getEnvironment ( ) . getProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String localHostAddress = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; String localUrl = \"<STR_LIT>\" + port + contextPath ; String networkUrl = \"<STR_LIT>\" + localHostAddress + \"<STR_LIT>\" + port + contextPath ; System . out . println ( \"<STR_LIT>\" + ( endTime - startTime ) + \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" + new Date ( ) ) ; System . out . println ( \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" + localUrl + \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" + networkUrl + \"<STR_LIT>\" ) ;", "output": "System . out . println ( \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" ) ; } }"}, {"input": "package cn . org . alan . exam . util ; import cn . org . alan . exam . model . entity . User ; import cn . org . alan . exam . security . SysUserDetails ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import lombok . extern . java . Log ; import lombok . extern . slf4j . Slf4j ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . security . core . context . SecurityContextHolder ; import java . util . List ; @ Slf4j public class SecurityUtil { private SecurityUtil ( ) { } public static Integer getUserId ( ) { SysUserDetails user = ( SysUserDetails ) ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) . getPrincipal ( ) ) ; return user . getUser ( ) . getId ( ) ; } public static String getRole ( ) { List < ? extends GrantedAuthority > list = SecurityContextHolder . getContext ( ) . getAuthentication ( ) . getAuthorities ( ) . stream ( ) . toList ( ) ; return list . get ( <NUM_LIT> ) . toString ( ) ; } public static Integer getGradeId ( ) { SysUserDetails user = ( SysUserDetails ) ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) . getPrincipal ( ) ) ; return user . getUser ( ) . getGradeId ( ) ;", "output": "} }"}, {"input": "package ginyi . common . utils ; import ginyi . common . utils . text . StrFormatter ; public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final String NULLSTR = \"<STR_LIT>\" ; public static boolean isEmpty ( String str ) { return isNull ( str ) || NULLSTR . equals ( str . trim ( ) ) ; } public static boolean isNull ( Object object ) { return object == null ; } public static boolean isNotNull ( Object object ) { return ! isNull ( object ) ; } public static < T > T nvl ( T value , T defaultValue ) { return value != null ? value : defaultValue ; } public static boolean inStringIgnoreCase ( String str , String ... strs ) { if ( str != null && strs != null ) { for ( String s : strs ) { if ( str . equalsIgnoreCase ( trim ( s ) ) ) { return true ; } } } return false ; } public static String trim ( String str ) { return ( str == null ? \"<STR_LIT>\" : str . trim ( ) ) ; } public static String format ( String template , Object ... params ) { if ( isEmpty ( params ) || isEmpty ( template ) ) { return template ; } return StrFormatter . format ( template , params ) ; } public static boolean isEmpty ( Object [ ] objects ) { return isNull ( objects ) || ( objects . length == <NUM_LIT> ) ; } public static boolean isNotEmpty ( Object [ ] objects ) { return ! isEmpty ( objects ) ; }", "output": "}"}, {"input": "package top . kangert . kspider . expression . parsing ; import java . util . Arrays ; import java . util . Comparator ; public enum TokenType { TextBlock ( \"<STR_LIT>\" ) , Period ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Lambda ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Comma ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Semicolon ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Colon ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Plus ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Minus ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Asterisk ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ForwardSlash ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , PostSlash ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Percentage ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , LeftParantheses ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , RightParantheses ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , LeftBracket ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , RightBracket ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , LeftCurly ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , RightCurly ( \"<STR_LIT>\" ) , Less ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Greater ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , LessEqual ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , GreaterEqual ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Equal ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , NotEqual ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Assignment ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , And ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Or ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Xor ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Not ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , Questionmark ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DoubleQuote ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SingleQuote ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , BooleanLiteral ( \"<STR_LIT>\" ) , DoubleLiteral ( \"<STR_LIT>\" ) , FloatLiteral ( \"<STR_LIT>\" ) , LongLiteral ( \"<STR_LIT>\" ) , IntegerLiteral ( \"<STR_LIT>\" ) , ShortLiteral ( \"<STR_LIT>\" ) , ByteLiteral ( \"<STR_LIT>\" ) , CharacterLiteral ( \"<STR_LIT>\" ) , StringLiteral ( \"<STR_LIT>\" ) , NullLiteral ( \"<STR_LIT>\" ) , Identifier ( \"<STR_LIT>\" ) ; private static TokenType [ ] values ; static { values = TokenType . values ( ) ; Arrays . sort ( values , new Comparator < TokenType > ( ) { @ Override public int compare ( TokenType o1 , TokenType o2 ) { if ( o1 . literal == null && o2 . literal == null ) { return <NUM_LIT> ; } if ( o1 . literal == null && o2 . literal != null ) { return <NUM_LIT> ; } if ( o1 . literal != null && o2 . literal == null ) { return - <NUM_LIT> ; } return o2 . literal . length ( ) - o1 . literal . length ( ) ; } } ) ; } private final String literal ; private final String error ; TokenType ( String error ) { this . literal = null ; this . error = error ;", "output": "} TokenType ( String literal , String error ) { this . literal = literal ; this . error = error ; } public String getLiteral ( ) { return literal ; } public String getError ( ) { return error ; } public static TokenType [ ] getSortedValues ( ) { return values ; } }"}, {"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class SelDepartFieldCommentConverter extends FieldFieldCommentConverter { public SelDepartFieldCommentConverter ( CgformField onlCgformField ) { IDictService sysBaseApi = SpringContextUtils . getBean ( IDictService . class ) ; String sysDepart = \"<STR_LIT>\" ; String departName = \"<STR_LIT>\" ; String id = \"<STR_LIT>\" ; this . dictList = sysBaseApi . queryTableDictItemsByCode ( sysDepart , departName , id ) ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) {", "output": "return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToTxt ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } }"}, {"input": "package me . zhengjie . utils ; public interface CallBack {", "output": "void executor ( ) ; default String getCallBackName ( ) { return Thread . currentThread ( ) . getId ( ) + \"<STR_LIT>\" + this . getClass ( ) . getName ( ) ; } }"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; @ Data public class DictQueryCriteria { private String blurry ; private Long offset ; private Long size ;", "output": "}"}, {"input": "package com . yf . system . modules . user . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . jackson . JsonHelper ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . system . modules . role . service . SysRoleService ; import com . yf . system . modules . user . UserUtils ; import com . yf . system . modules . user . dto . SysUserRoleDTO ; import com . yf . system . modules . user . dto . request . UserRoleReqDTO ; import com . yf . system . modules . user . entity . SysUserRole ; import com . yf . system . modules . user . mapper . SysUserRoleMapper ; import com . yf . system . modules . user . service . SysUserRoleService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . CollectionUtils ; import java . util . ArrayList ; import java . util . List ; @ Service public class SysUserRoleServiceImpl extends ServiceImpl < SysUserRoleMapper , SysUserRole > implements SysUserRoleService { @ Autowired private SysRoleService sysRoleService ; @ Override public IPage < SysUserRoleDTO > paging ( PagingReqDTO < SysUserRoleDTO > reqDTO ) { IPage < SysUserRole > query = reqDTO . toPage ( ) ; QueryWrapper < SysUserRole > wrapper = new QueryWrapper < > ( ) ; IPage < SysUserRole > page = this . page ( query , wrapper ) ; IPage < SysUserRoleDTO > pageData = JsonHelper . parseObject ( page , new TypeReference < Page < SysUserRoleDTO > > ( ) { } ) ; return pageData ; } @ Override public List < SysRole > listRoles ( String userId ) { return baseMapper . listByUser ( userId ) ; } @ Transactional ( rollbackFor = Exception . class ) @ Override public void saveRoles ( String userId , List < String > ids , boolean check ) { if ( check ) { this . checkRoles ( ids ) ; } QueryWrapper < SysUserRole > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysUserRole :: getUserId , userId ) ; this . remove ( wrapper ) ; if ( ! CollectionUtils . isEmpty ( ids ) ) { List < SysUserRole > list = new ArrayList < > ( ) ; for ( String item : ids ) { SysUserRole role = new SysUserRole ( ) ; role . setRoleId ( item ) ; role . setUserId ( userId ) ; list . add ( role ) ; } this . saveBatch ( list ) ; } } @ Transactional ( rollbackFor = Exception . class ) @ Override public void batchRole ( UserRoleReqDTO reqDTO ) { for ( String userId : reqDTO . getUserIds ( ) ) { for ( String roleId : reqDTO . getRoleIds ( ) ) { QueryWrapper < SysUserRole > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysUserRole :: getUserId , userId ) . eq ( SysUserRole :: getRoleId , roleId ) ;", "output": "this . remove ( wrapper ) ; } } if ( reqDTO . getFlag ( ) . equals ( <NUM_LIT> ) ) { List < SysUserRole > list = new ArrayList < > ( ) ; for ( String userId : reqDTO . getUserIds ( ) ) { for ( String roleId : reqDTO . getRoleIds ( ) ) { SysUserRole item = new SysUserRole ( ) ; item . setUserId ( userId ) ; item . setRoleId ( roleId ) ; list . add ( item ) ; } } this . saveBatch ( list ) ; } } @ Override public void removeByUserIds ( List < String > ids ) { QueryWrapper < SysUserRole > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysUserRole :: getUserId , ids ) ; this . remove ( wrapper ) ; } @ Override public SysUserRole findMaxRole ( String userId ) { return baseMapper . findMaxRole ( userId ) ; } @ Override public int countWithLevel ( List < String > userIds , Integer roleLevel ) { return baseMapper . countWithLevel ( userIds , roleLevel ) ; } @ Override public int findMaxLevel ( String userId ) { return baseMapper . findMaxLevel ( userId ) ; } @ Override public List < String > findUserPermission ( String userId ) { return baseMapper . findUserPermission ( userId ) ; } @ Override public List < String > listRoleIds ( String userId ) { List < SysRole > roles = this . listRoles ( userId ) ; List < String > ids = new ArrayList < > ( ) ; for ( SysRole role : roles ) { ids . add ( role . getId ( ) ) ; } return ids ; } private void checkRoles ( List < String > ids ) { Integer level = UserUtils . getRoleLevel ( ) ; QueryWrapper < SysRole > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysRole :: getId , ids ) . le ( SysRole :: getRoleLevel , level ) ; long count = sysRoleService . count ( wrapper ) ; if ( count != ids . size ( ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . GradeExercise ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IGradeExerciseService extends IService < GradeExercise > {", "output": "}"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; import java . util . List ; @ Data public class CalculationModel { private String rule ; private BigDecimal triggerPrice ;", "output": "}"}, {"input": "package me . zhengjie . modules . quartz . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class QuartzJob extends BaseEntity implements Serializable { public static final String JOB_KEY = \"<STR_LIT>\" ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ NotNull ( groups = { Update . class } ) private Long id ; @ TableField ( exist = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String uuid ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String jobName ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String beanName ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String methodName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String params ;", "output": "@ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cronExpression ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean isPause = false ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String personInCharge ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String email ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTask ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean pauseAfterFailure ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ; }"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . BeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . core . ResolvableType ; import org . springframework . util . ClassUtils ; import java . beans . PropertyDescriptor ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . Arrays ; import java . util . List ; public class BeanUtil { private static final Logger log = LoggerFactory . getLogger ( BeanUtil . class ) ; public static void copyProperties ( Object source , Object target ) { copyProperties ( source , target , null ) ; } public static void copyNotNullProperties ( Object source , Object target ) { copyNotNullProperties ( source , target , null ) ; } public static void copyNotBlankProperties ( Object source , Object target ) { copyNotBlankProperties ( source , target , null ) ; } public static void copyProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , false , false , ignores ) ; } public static void copyNotNullProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , false , ignores ) ; } public static void copyNotBlankProperties ( Object source , Object target , String [ ] ignores ) { doCopyProperties ( source , target , true , true , ignores ) ; } public static void copyProperty ( Object target , String name , Object value ) { if ( target == null || name == null ) { return ; } try { PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( target . getClass ( ) , name ) ; if ( propertyDescriptor == null ) { return ; } Method writeMethod = propertyDescriptor . getWriteMethod ( ) ; if ( writeMethod == null ) { return ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable e ) { log . debug ( \"<STR_LIT>\" + name , e ) ; } } private static boolean isValidValue ( Object value , boolean notNull , boolean notBlank ) { if ( notNull && value == null ) { return false ;", "output": "} if ( notBlank ) { if ( value == null ) { return false ; } if ( value . getClass ( ) == String . class ) { String valueStr = ( String ) value ; if ( TextUtil . isBlank ( valueStr ) ) { return false ; } } } return true ; } private static void doCopyProperties ( Object source , Object target , boolean notNull , boolean notBlank , String ... ignoreProperties ) { if ( source == null || target == null ) { return ; } Class < ? > actualEditable = target . getClass ( ) ; List < String > ignoreList = ( ignoreProperties != null ? Arrays . asList ( ignoreProperties ) : null ) ; PropertyDescriptor [ ] targetPds ; try { targetPds = BeanUtils . getPropertyDescriptors ( actualEditable ) ; } catch ( BeansException e ) { log . debug ( \"<STR_LIT>\" , e ) ; return ; } for ( PropertyDescriptor targetPd : targetPds ) { try { Method writeMethod = targetPd . getWriteMethod ( ) ; if ( writeMethod == null || ( ignoreList != null && ignoreList . contains ( targetPd . getName ( ) ) ) ) { continue ; } PropertyDescriptor sourcePd = BeanUtils . getPropertyDescriptor ( source . getClass ( ) , targetPd . getName ( ) ) ; if ( sourcePd == null ) { continue ; } Method readMethod = sourcePd . getReadMethod ( ) ; if ( readMethod == null ) { continue ; } ResolvableType sourceResolvableType = ResolvableType . forMethodReturnType ( readMethod ) ; ResolvableType targetResolvableType = ResolvableType . forMethodParameter ( writeMethod , <NUM_LIT> ) ; boolean isAssignable = ( sourceResolvableType . hasUnresolvableGenerics ( ) || targetResolvableType . hasUnresolvableGenerics ( ) ? ClassUtils . isAssignable ( writeMethod . getParameterTypes ( ) [ <NUM_LIT> ] , readMethod . getReturnType ( ) ) : targetResolvableType . isAssignableFrom ( sourceResolvableType ) ) ; if ( ! isAssignable ) { continue ; } if ( ! Modifier . isPublic ( readMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { readMethod . setAccessible ( true ) ; } Object value = readMethod . invoke ( source ) ; if ( ! isValidValue ( value , notNull , notBlank ) ) { continue ; } if ( ! Modifier . isPublic ( writeMethod . getDeclaringClass ( ) . getModifiers ( ) ) ) { writeMethod . setAccessible ( true ) ; } writeMethod . invoke ( target , value ) ; } catch ( Throwable ex ) { log . debug ( \"<STR_LIT>\" + targetPd . getName ( ) + \"<STR_LIT>\" , ex ) ; } } } }"}, {"input": "package ginyi . system . domain . model . dto ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotEmpty ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; import java . util . List ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class NoticeDto extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = UpdateGroup . class , message = \"<STR_LIT>\" ) private Long noticeId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String title ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotEmpty ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > userIds ;", "output": "@ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > userReadIds ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String status ; }"}, {"input": "package me . zhengjie . modules . quartz . utils ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . utils . SpringContextHolder ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . reflect . Method ; import java . util . concurrent . Callable ; @ Slf4j public class QuartzRunnable implements Callable < Object > { private final Object target ; private final Method method ; private final String params ; QuartzRunnable ( String beanName , String methodName , String params ) throws NoSuchMethodException , SecurityException { this . target = SpringContextHolder . getBean ( beanName ) ; this . params = params ; if ( StringUtils . isNotBlank ( params ) ) { this . method = target . getClass ( ) . getDeclaredMethod ( methodName , String . class ) ; } else { this . method = target . getClass ( ) . getDeclaredMethod ( methodName ) ; } } @ Override @ SuppressWarnings ( \"<STR_LIT>\" ) public Object call ( ) throws Exception {", "output": "ReflectionUtils . makeAccessible ( method ) ; if ( StringUtils . isNotBlank ( params ) ) { method . invoke ( target , params ) ; } else { method . invoke ( target ) ; } return null ; } }"}, {"input": "package top . kangert . kspider . expression . parsing ; import java . util . ArrayList ; import java . util . List ; import top . kangert . kspider . expression . ExpressionError ; import top . kangert . kspider . expression . ExpressionError . * ; public class Tokenizer { public List < Token > tokenize ( String source ) { List < Token > tokens = new ArrayList < Token > ( ) ; if ( source . length ( ) == <NUM_LIT> ) { return tokens ; } CharacterStream stream = new CharacterStream ( source ) ; stream . startSpan ( ) ; RuntimeException re = null ; while ( stream . hasMore ( ) ) { if ( stream . match ( \"<STR_LIT>\" , false ) ) { if ( ! stream . isSpanEmpty ( ) ) { tokens . add ( new Token ( TokenType . TextBlock , stream . endSpan ( ) ) ) ; } stream . startSpan ( ) ; boolean isContinue = false ; do { while ( ! stream . match ( \"<STR_LIT>\" , true ) ) { if ( ! stream . hasMore ( ) ) { ExpressionError . error ( \"<STR_LIT>\" , stream . endSpan ( ) ) ; } stream . consume ( ) ; } try { tokens . addAll ( tokenizeCodeSpan ( stream . endSpan ( ) ) ) ; isContinue = false ; re = null ; } catch ( TemplateException e ) { re = e ; if ( e . getCause ( ) != null || stream . hasMore ( ) ) { isContinue = true ; } } } while ( isContinue ) ; if ( re != null ) { throw re ; } stream . startSpan ( ) ; } else { stream . consume ( ) ; } } if ( ! stream . isSpanEmpty ( ) ) { tokens . add ( new Token ( TokenType . TextBlock , stream . endSpan ( ) ) ) ; } return tokens ; } private static List < Token > tokenizeCodeSpan ( Span span ) { String source = span . getSource ( ) ; CharacterStream stream = new CharacterStream ( source , span . getStart ( ) , span . getEnd ( ) ) ; List < Token > tokens = new ArrayList < Token > ( ) ; if ( ! stream . match ( \"<STR_LIT>\" , true ) ) { ExpressionError . error ( \"<STR_LIT>\" , new Span ( source , stream . getPosition ( ) , stream . getPosition ( ) + <NUM_LIT> ) ) ; } int leftCount = <NUM_LIT> ; int rightCount = <NUM_LIT> ; outer : while ( stream . hasMore ( ) ) { stream . skipWhiteSpace ( ) ; if ( stream . matchDigit ( false ) ) { TokenType type = TokenType . IntegerLiteral ; stream . startSpan ( ) ; while ( stream . matchDigit ( true ) ) { ; } if ( stream . match ( TokenType . Period . getLiteral ( ) , true ) ) { type = TokenType . FloatLiteral ; while ( stream . matchDigit ( true ) ) { ; } } if ( stream . match ( \"<STR_LIT>\" , true ) || stream . match ( \"<STR_LIT>\" , true ) ) { if ( type == TokenType . FloatLiteral ) { ExpressionError . error ( \"<STR_LIT>\" , stream . endSpan ( ) ) ; } type = TokenType . ByteLiteral ; } else if ( stream . match ( \"<STR_LIT>\" , true ) || stream . match ( \"<STR_LIT>\" , true ) ) { if ( type == TokenType . FloatLiteral ) { ExpressionError . error ( \"<STR_LIT>\" , stream . endSpan ( ) ) ; } type = TokenType . ShortLiteral ; } else if ( stream . match ( \"<STR_LIT>\" , true ) || stream . match ( \"<STR_LIT>\" , true ) ) { if ( type == TokenType . FloatLiteral ) { ExpressionError . error ( \"<STR_LIT>\" , stream . endSpan ( ) ) ; } type = TokenType . LongLiteral ; } else if ( stream . match ( \"<STR_LIT>\" , true ) || stream . match ( \"<STR_LIT>\" , true ) ) { type = TokenType . FloatLiteral ; } else if ( stream . match ( \"<STR_LIT>\" , true ) || stream . match ( \"<STR_LIT>\" , true ) ) { type = TokenType . DoubleLiteral ; } Span numberSpan = stream . endSpan ( ) ;", "output": "tokens . add ( new Token ( type , numberSpan ) ) ; continue ; } if ( stream . match ( TokenType . SingleQuote . getLiteral ( ) , true ) ) { stream . startSpan ( ) ; boolean matchedEndQuote = false ; while ( stream . hasMore ( ) ) { if ( stream . match ( \"<STR_LIT>\" , true ) ) { stream . consume ( ) ; } if ( stream . match ( TokenType . SingleQuote . getLiteral ( ) , true ) ) { matchedEndQuote = true ; break ; } stream . consume ( ) ; } if ( ! matchedEndQuote ) { ExpressionError . error ( \"<STR_LIT>\" , stream . endSpan ( ) , new StringLiteralException ( ) ) ; } Span stringSpan = stream . endSpan ( ) ; stringSpan = new Span ( stringSpan . getSource ( ) , stringSpan . getStart ( ) - <NUM_LIT> , stringSpan . getEnd ( ) ) ; tokens . add ( new Token ( TokenType . StringLiteral , stringSpan ) ) ; continue ; } if ( stream . match ( TokenType . DoubleQuote . getLiteral ( ) , true ) ) { stream . startSpan ( ) ; boolean matchedEndQuote = false ; while ( stream . hasMore ( ) ) { if ( stream . match ( \"<STR_LIT>\" , true ) ) { stream . consume ( ) ; } if ( stream . match ( TokenType . DoubleQuote . getLiteral ( ) , true ) ) { matchedEndQuote = true ; break ; } stream . consume ( ) ; } if ( ! matchedEndQuote ) { ExpressionError . error ( \"<STR_LIT>\" , stream . endSpan ( ) , new StringLiteralException ( ) ) ; } Span stringSpan = stream . endSpan ( ) ; stringSpan = new Span ( stringSpan . getSource ( ) , stringSpan . getStart ( ) - <NUM_LIT> , stringSpan . getEnd ( ) ) ; tokens . add ( new Token ( TokenType . StringLiteral , stringSpan ) ) ; continue ; } if ( stream . matchIdentifierStart ( true ) ) { stream . startSpan ( ) ; while ( stream . matchIdentifierPart ( true ) ) { ; } Span identifierSpan = stream . endSpan ( ) ; identifierSpan = new Span ( identifierSpan . getSource ( ) , identifierSpan . getStart ( ) - <NUM_LIT> , identifierSpan . getEnd ( ) ) ; if ( \"<STR_LIT>\" . equals ( identifierSpan . getText ( ) ) || \"<STR_LIT>\" . equals ( identifierSpan . getText ( ) ) ) { tokens . add ( new Token ( TokenType . BooleanLiteral , identifierSpan ) ) ; } else if ( \"<STR_LIT>\" . equals ( identifierSpan . getText ( ) ) ) { tokens . add ( new Token ( TokenType . NullLiteral , identifierSpan ) ) ; } else { tokens . add ( new Token ( TokenType . Identifier , identifierSpan ) ) ; } continue ; } for ( TokenType t : TokenType . getSortedValues ( ) ) { if ( t . getLiteral ( ) != null ) { if ( stream . match ( t . getLiteral ( ) , true ) ) { if ( t == TokenType . LeftCurly ) { leftCount ++ ; } tokens . add ( new Token ( t , new Span ( source , stream . getPosition ( ) - t . getLiteral ( ) . length ( ) , stream . getPosition ( ) ) ) ) ; continue outer ; } } } if ( leftCount != rightCount && stream . match ( \"<STR_LIT>\" , true ) ) { rightCount ++ ; tokens . add ( new Token ( TokenType . RightCurly , new Span ( source , stream . getPosition ( ) - <NUM_LIT> , stream . getPosition ( ) ) ) ) ; continue outer ; } if ( stream . match ( \"<STR_LIT>\" , false ) ) { break ; } ExpressionError . error ( \"<STR_LIT>\" , new Span ( source , stream . getPosition ( ) , stream . getPosition ( ) + <NUM_LIT> ) ) ; } if ( ! stream . match ( \"<STR_LIT>\" , true ) ) { ExpressionError . error ( \"<STR_LIT>\" , new Span ( source , stream . getPosition ( ) , stream . getPosition ( ) + <NUM_LIT> ) ) ; } return tokens ; } }"}, {"input": "package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DeptService extends IService < Dept > { List < Dept > queryAll ( DeptQueryCriteria criteria , Boolean isQuery ) throws Exception ; Dept findById ( Long id ) ; void create ( Dept resources ) ; void update ( Dept resources ) ; void delete ( Set < Dept > depts ) ;", "output": "List < Dept > findByPid ( long pid ) ; Set < Dept > findByRoleId ( Long id ) ; void download ( List < Dept > depts , HttpServletResponse response ) throws IOException ; Set < Dept > getDeleteDepts ( List < Dept > deptList , Set < Dept > depts ) ; List < Dept > getSuperior ( Dept dept , List < Dept > depts ) ; Object buildTree ( List < Dept > depts ) ; List < Long > getDeptChildren ( List < Dept > deptList ) ; void verification ( Set < Dept > depts ) ; }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class AddWalletParam { private String tableName ; private String walletId ; private BigDecimal addBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private BigDecimal borrowBalance = BigDecimal . ZERO ; private String contractSymbolName ; private boolean messageRefreshFlag = true ;", "output": "}"}, {"input": "package me . zhengjie . config ; import org . springframework . boot . web . servlet . MultipartConfigFactory ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . servlet . MultipartConfigElement ; import java . io . File ; @ Configuration public class MultipartConfig { @ Bean MultipartConfigElement multipartConfigElement ( ) { MultipartConfigFactory factory = new MultipartConfigFactory ( ) ; String location = System . getProperty ( \"<STR_LIT>\" ) + \"<STR_LIT>\" ; File tmpFile = new File ( location ) ; if ( ! tmpFile . exists ( ) ) { if ( ! tmpFile . mkdirs ( ) ) { System . out . println ( \"<STR_LIT>\" ) ; } } factory . setLocation ( location ) ; return factory . createMultipartConfig ( ) ;", "output": "} }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . constant . UserConstants ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . TreeSelect ; import com . oddfar . campus . common . domain . entity . SysMenuEntity ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysRoleMenuEntity ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import com . oddfar . campus . common . domain . vo . RouterVo ; import com . oddfar . campus . common . utils . MetaVo ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . mapper . SysMenuMapper ; import com . oddfar . campus . framework . mapper . SysRoleMapper ; import com . oddfar . campus . framework . mapper . SysRoleMenuMapper ; import com . oddfar . campus . framework . service . SysMenuService ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . * ; import java . util . stream . Collectors ; @ Service public class SysMenuServiceImpl implements SysMenuService { @ Resource private SysMenuMapper menuMapper ; @ Resource private SysRoleMapper roleMapper ; @ Resource private SysRoleMenuMapper roleMenuMapper ; @ Override public List < SysMenuEntity > selectMenuList ( Long userId ) { return selectMenuList ( new SysMenuEntity ( ) , userId ) ; } @ Override public List < SysMenuEntity > selectMenuList ( SysMenuEntity menu , Long userId ) { List < SysMenuEntity > menuList = null ; if ( SysUserEntity . isAdmin ( userId ) ) { menuList = menuMapper . selectMenuList ( menu ) ; } else { menu . getParams ( ) . put ( \"<STR_LIT>\" , userId ) ; menuList = menuMapper . selectMenuListByUserId ( menu ) ; } return menuList ; } @ Override public List < SysMenuEntity > selectMenuTreeByUserId ( Long userId ) { List < SysMenuEntity > menus = null ; if ( SecurityUtils . isAdmin ( userId ) ) { menus = menuMapper . selectMenuTreeAll ( ) ; } else { menus = menuMapper . selectMenuTreeByUserId ( userId ) ; } return getChildPerms ( menus , <NUM_LIT> ) ; } @ Override public List < Long > selectMenuListByRoleId ( Long roleId ) { SysRoleEntity role = roleMapper . selectRoleById ( roleId ) ; return menuMapper . selectMenuListByRoleId ( roleId , role . isMenuCheckStrictly ( ) ) ; } @ Override public SysMenuEntity selectMenuById ( Long menuId ) { return menuMapper . selectById ( menuId ) ; } @ Override public List < RouterVo > buildMenus ( List < SysMenuEntity > menus ) { List < RouterVo > routers = new LinkedList < RouterVo > ( ) ; for ( SysMenuEntity menu : menus ) { RouterVo router = new RouterVo ( ) ; router . setHidden ( \"<STR_LIT>\" . equals ( menu . getVisible ( ) ) ) ; router . setName ( getRouteName ( menu ) ) ; router . setPath ( getRouterPath ( menu ) ) ; router . setComponent ( getComponent ( menu ) ) ; router . setQuery ( menu . getQuery ( ) ) ; router . setMeta ( new MetaVo ( menu . getMenuName ( ) , menu . getIcon ( ) , StringUtils . equals ( \"<STR_LIT>\" , menu . getIsCache ( ) ) , menu . getPath ( ) ) ) ; List < SysMenuEntity > cMenus = menu . getChildren ( ) ; if ( ! cMenus . isEmpty ( ) && cMenus . size ( ) > <NUM_LIT> && UserConstants . TYPE_DIR . equals ( menu . getMenuType ( ) ) ) { router . setAlwaysShow ( true ) ; router . setRedirect ( \"<STR_LIT>\" ) ; router . setChildren ( buildMenus ( cMenus ) ) ; } else if ( isMenuFrame ( menu ) ) { router . setMeta ( null ) ; List < RouterVo > childrenList = new ArrayList < RouterVo > ( ) ; RouterVo children = new RouterVo ( ) ; children . setPath ( menu . getPath ( ) ) ; children . setComponent ( menu . getComponent ( ) ) ; children . setName ( StringUtils . capitalize ( menu . getPath ( ) ) ) ; children . setMeta ( new MetaVo ( menu . getMenuName ( ) , menu . getIcon ( ) , StringUtils . equals ( \"<STR_LIT>\" , menu . getIsCache ( ) ) , menu . getPath ( ) ) ) ; children . setQuery ( menu . getQuery ( ) ) ; childrenList . add ( children ) ; router . setChildren ( childrenList ) ; } else if ( menu . getParentId ( ) . intValue ( ) == <NUM_LIT> && isInnerLink ( menu ) ) { router . setMeta ( new MetaVo ( menu . getMenuName ( ) , menu . getIcon ( ) ) ) ; router . setPath ( \"<STR_LIT>\" ) ; List < RouterVo > childrenList = new ArrayList < RouterVo > ( ) ; RouterVo children = new RouterVo ( ) ; String routerPath = innerLinkReplaceEach ( menu . getPath ( ) ) ; children . setPath ( routerPath ) ; children . setComponent ( UserConstants . INNER_LINK ) ; children . setName ( StringUtils . capitalize ( routerPath ) ) ; children . setMeta ( new MetaVo ( menu . getMenuName ( ) , menu . getIcon ( ) , menu . getPath ( ) ) ) ; childrenList . add ( children ) ; router . setChildren ( childrenList ) ; } routers . add ( router ) ; } return routers ; } @ Override public List < TreeSelect > buildMenuTreeSelect ( List < SysMenuEntity > menus ) { List < SysMenuEntity > menuTrees = buildMenuTree ( menus ) ; return menuTrees . stream ( ) . map ( TreeSelect :: new ) . collect ( Collectors . toList ( ) ) ; } @ Override public List < SysMenuEntity > buildMenuTree ( List < SysMenuEntity > menus ) { List < SysMenuEntity > returnList = new ArrayList < SysMenuEntity > ( ) ; List < Long > tempList = new ArrayList < Long > ( ) ; for ( SysMenuEntity dept : menus ) { tempList . add ( dept . getMenuId ( ) ) ; } for ( Iterator < SysMenuEntity > iterator = menus . iterator ( ) ; iterator . hasNext ( ) ;", "output": ") { SysMenuEntity menu = ( SysMenuEntity ) iterator . next ( ) ; if ( ! tempList . contains ( menu . getParentId ( ) ) ) { recursionFn ( menus , menu ) ; returnList . add ( menu ) ; } } if ( returnList . isEmpty ( ) ) { returnList = menus ; } return returnList ; } @ Override public Set < String > selectMenuPermsByRoleId ( Long roleId ) { List < String > perms = menuMapper . selectMenuPermsByRoleId ( roleId ) ; Set < String > permsSet = new HashSet < > ( ) ; for ( String perm : perms ) { if ( StringUtils . isNotEmpty ( perm ) ) { permsSet . addAll ( Arrays . asList ( perm . trim ( ) . split ( \"<STR_LIT>\" ) ) ) ; } } return permsSet ; } @ Override public Map < Long , List < SysRoleAuth > > selectMenuPermsAll ( ) { List < SysRoleAuth > sysRolePerms = menuMapper . getMenuPermsAll ( ) ; return sysRolePerms . stream ( ) . collect ( Collectors . groupingBy ( SysRoleAuth :: getRoleID ) ) ; } @ Override public Set < String > selectMenuPermsByUserId ( Long userId ) { List < String > perms = menuMapper . selectMenuPermsByUserId ( userId ) ; Set < String > permsSet = new HashSet < > ( ) ; for ( String perm : perms ) { if ( StringUtils . isNotEmpty ( perm ) ) { permsSet . addAll ( Arrays . asList ( perm . trim ( ) . split ( \"<STR_LIT>\" ) ) ) ; } } return permsSet ; } @ Override public int insertMenu ( SysMenuEntity menu ) { return menuMapper . insert ( menu ) ; } @ Override public int updateMenu ( SysMenuEntity menu ) { return menuMapper . updateById ( menu ) ; } @ Override public int deleteMenuById ( Long menuId ) { return menuMapper . deleteById ( menuId ) ; } @ Override public boolean checkMenuExistRole ( Long menuId ) { Long result = roleMenuMapper . selectCount ( new QueryWrapper < SysRoleMenuEntity > ( ) . eq ( \"<STR_LIT>\" , menuId ) ) ; return result > <NUM_LIT> ; } @ Override public boolean hasChildByMenuId ( Long menuId ) { Long result = menuMapper . selectCount ( new LambdaQueryWrapperX < SysMenuEntity > ( ) . eq ( SysMenuEntity :: getParentId , menuId ) ) ; return result > <NUM_LIT> ; } @ Override public boolean checkMenuNameUnique ( SysMenuEntity menu ) { Long menuId = StringUtils . isNull ( menu . getMenuId ( ) ) ? - <NUM_LIT> : menu . getMenuId ( ) ; SysMenuEntity info = menuMapper . checkMenuNameUnique ( menu ) ; if ( StringUtils . isNotNull ( info ) && info . getMenuId ( ) . longValue ( ) != menuId . longValue ( ) ) { return false ; } return true ; } public String getRouterPath ( SysMenuEntity menu ) { String routerPath = menu . getPath ( ) ; if ( menu . getParentId ( ) . intValue ( ) != <NUM_LIT> && isInnerLink ( menu ) ) { routerPath = innerLinkReplaceEach ( routerPath ) ; } if ( <NUM_LIT> == menu . getParentId ( ) . intValue ( ) && UserConstants . TYPE_DIR . equals ( menu . getMenuType ( ) ) && UserConstants . NO_FRAME . equals ( menu . getIsFrame ( ) ) ) { routerPath = \"<STR_LIT>\" + menu . getPath ( ) ; } else if ( isMenuFrame ( menu ) ) { routerPath = \"<STR_LIT>\" ; } return routerPath ; } public boolean isInnerLink ( SysMenuEntity menu ) { return menu . getIsFrame ( ) . equals ( UserConstants . NO_FRAME ) && StringUtils . ishttp ( menu . getPath ( ) ) ; } public String getComponent ( SysMenuEntity menu ) { String component = UserConstants . LAYOUT ; if ( StringUtils . isNotEmpty ( menu . getComponent ( ) ) && ! isMenuFrame ( menu ) ) { component = menu . getComponent ( ) ; } else if ( StringUtils . isEmpty ( menu . getComponent ( ) ) && menu . getParentId ( ) . intValue ( ) != <NUM_LIT> && isInnerLink ( menu ) ) { component = UserConstants . INNER_LINK ; } else if ( StringUtils . isEmpty ( menu . getComponent ( ) ) && isParentView ( menu ) ) { component = UserConstants . PARENT_VIEW ; } return component ; } public boolean isParentView ( SysMenuEntity menu ) { return menu . getParentId ( ) . intValue ( ) != <NUM_LIT> && UserConstants . TYPE_DIR . equals ( menu . getMenuType ( ) ) ; } public String getRouteName ( SysMenuEntity menu ) { String routerName = StringUtils . capitalize ( menu . getPath ( ) ) ; if ( isMenuFrame ( menu ) ) { routerName = StringUtils . EMPTY ; } return routerName ; } public boolean isMenuFrame ( SysMenuEntity menu ) { return menu . getParentId ( ) . intValue ( ) == <NUM_LIT> && UserConstants . TYPE_MENU . equals ( menu . getMenuType ( ) ) && menu . getIsFrame ( ) . equals ( UserConstants . NO_FRAME ) ; } public List < SysMenuEntity > getChildPerms ( List < SysMenuEntity > list , int parentId ) { List < SysMenuEntity > returnList = new ArrayList < SysMenuEntity > ( ) ; for ( Iterator < SysMenuEntity > iterator = list . iterator ( ) ; iterator . hasNext ( ) ; ) { SysMenuEntity t = ( SysMenuEntity ) iterator . next ( ) ; if ( t . getParentId ( ) == parentId ) { recursionFn ( list , t ) ; returnList . add ( t ) ; } } return returnList ; } private void recursionFn ( List < SysMenuEntity > list , SysMenuEntity t ) { List < SysMenuEntity > childList = getChildList ( list , t ) ; t . setChildren ( childList ) ; for ( SysMenuEntity tChild : childList ) { if ( hasChild ( list , tChild ) ) { recursionFn ( list , tChild ) ; } } } private boolean hasChild ( List < SysMenuEntity > list , SysMenuEntity t ) { return getChildList ( list , t ) . size ( ) > <NUM_LIT> ; } private List < SysMenuEntity > getChildList ( List < SysMenuEntity > list , SysMenuEntity t ) { List < SysMenuEntity > tlist = new ArrayList < SysMenuEntity > ( ) ; Iterator < SysMenuEntity > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { SysMenuEntity n = ( SysMenuEntity ) it . next ( ) ; if ( n . getParentId ( ) . longValue ( ) == t . getMenuId ( ) . longValue ( ) ) { tlist . add ( n ) ; } } return tlist ; } public String innerLinkReplaceEach ( String path ) { return StringUtils . replaceEach ( path , new String [ ] { Constants . HTTP , Constants . HTTPS , Constants . WWW , \"<STR_LIT>\" } , new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) ; } }"}, {"input": "package com . oddfar . campus . common . exception ; public class UtilException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; public UtilException ( Throwable e ) { super ( e . getMessage ( ) , e ) ; }", "output": "public UtilException ( String message ) { super ( message ) ; } public UtilException ( String message , Throwable throwable ) { super ( message , throwable ) ; } }"}, {"input": "package org . example . application . example . dto . command ; import lombok . Data ; import javax . validation . constraints . NotNull ; @ Data public class ExampleModifyAddressCommand { @ NotNull ( message = \"<STR_LIT>\" ) private Double longitude ; @ NotNull ( message = \"<STR_LIT>\" ) private Double latitude ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class DatabaseVO { private String filePath ; private String fileSize ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; import java . util . List ; @ Data public class ChatRoomDetailVO { private String chatRoomName ; private String chatRoomTitle ; private String selfDisplayName ; private String createBy ; private String headImgUrl ; @ JsonIgnore private String reserved2 ; @ JsonIgnore private byte [ ] roomData ; private ChatRoomInfoVO chatRoomInfo ; private List < ChatRoomMemberVO > members ;", "output": "}"}, {"input": "package org . example . dddworkspace . infrastructure . config ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . servlet . config . annotation . InterceptorRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurationSupport ; @ Configuration public class AppConfig extends WebMvcConfigurationSupport { @ Override protected void addInterceptors ( InterceptorRegistry registry ) {", "output": "super . addInterceptors ( registry ) ; registry . addInterceptor ( new MicroserviceSecurityInterceptor ( ) ) ; } }"}, {"input": "package ginyi . system . domain . model . dto ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class MenuDto extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = UpdateGroup . class , message = \"<STR_LIT>\" ) private Long menuId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String menuName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private Integer sort = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String component ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String menuType ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = {", "output": "AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String visible ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String query ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isFrame ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String isCache ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String perms ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String icon ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String filterButton ; }"}, {"input": "package com . yf . base . utils ; import java . text . SimpleDateFormat ; import java . util . Date ; public class CronUtils { private static final String DATE_FORMAT = \"<STR_LIT>\" ; public static String dateToCron ( final Date date ) { SimpleDateFormat fmt = new SimpleDateFormat ( DATE_FORMAT ) ; String formatTimeStr = \"<STR_LIT>\" ;", "output": "if ( date != null ) { formatTimeStr = fmt . format ( date ) ; } return formatTimeStr ; } }"}, {"input": "package org . springblade . config . db ; import org . springblade . core . tool . utils . Func ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component ( \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class DataBaseConfig { private String url ; private String username ; private String password ; private String driverClassName ; public DataBaseConfig ( ) { } public String getUrl ( ) {", "output": "return this . url ; } public void setUrl ( String url ) { this . url = url ; } public String getUsername ( ) { return this . username ; } public void setUsername ( String username ) { this . username = username ; } public String getPassword ( ) { return this . password ; } public void setPassword ( String password ) { this . password = password ; } public String getDriverClassName ( ) { return this . driverClassName ; } public void setDriverClassName ( String driverClassName ) { if ( Func . isEmpty ( driverClassName ) ) { driverClassName = \"<STR_LIT>\" ; } this . driverClassName = driverClassName ; } }"}, {"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . apache . ibatis . session . ExecutorType ; import org . apache . ibatis . session . SqlSession ; import org . mybatis . spring . SqlSessionTemplate ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformEnhanceSql ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceSqlMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . pool . AccumulatorRecursiveAction ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . config . util . converter . ConverterUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . List ; import java . util . Map ; import java . util . Properties ; import java . util . concurrent . ForkJoinPool ; @ Service @ Slf4j public class CgformEnhanceSqlServiceImpl extends BaseServiceImpl < CgformEnhanceSqlMapper , CgformEnhanceSql > implements ICgformEnhanceSqlService { @ Autowired private SqlSessionTemplate sqlSessionTemplate ; @ Autowired private ICgformEnhanceJavaService javaService ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private ICgformFieldService cgformFieldService ; @ Override public void executeEnhanceSqlList ( CgformHead head , String buttonCode , Map < String , Object > params ) { LambdaQueryWrapper < CgformEnhanceSql > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceSql :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceSql :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceSql > cgformEnhanceSqlList = baseMapper . selectList ( wrapper ) ; Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceSql enhanceSql = null ; for ( CgformEnhanceSql enhance : cgformEnhanceSqlList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceSql = enhance ; break ; } } if ( Func . isEmpty ( enhanceSql ) || Func . isEmpty ( enhanceSql . getCgbSql ( ) ) ) { return ; } LambdaQueryWrapper < CgformField > fieldWrapper = new LambdaQueryWrapper < > ( ) ; fieldWrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; fieldWrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = cgformFieldService . list ( fieldWrapper ) ; String cgbSql = enhanceSql . getCgbSql ( ) ; String sql = SqlSymbolUtil . getEnhanceByDataType ( fieldList , params , null ) ; if ( cgbSql . contains ( \"<STR_LIT>\" ) ) { cgbSql = cgbSql . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" + AuthUtil . getUserId ( ) + \"<STR_LIT>\" ) ; } String executeSql = cgbSql . replaceAll ( \"<STR_LIT>\" , sql ) ; Page page = MjkjUtils . getPage ( params ) ; params . put ( \"<STR_LIT>\" , executeSql ) ; Page pages = baseMapper . executeSql ( page , executeSql , params ) ; MjkjUtils . setPageResult ( params , pages ) ; } @ Override public void saveBatchCodeOnlineTable ( CgformHead head , List < CgformField > fieldList , List < Map < String , Object > > dataList , String batchCode ) { SqlSession sqlSession = null ; try { ConverterUtil . converter ( <NUM_LIT> , dataList , fieldList ) ; sqlSession = this . sqlSessionTemplate . getSqlSessionFactory ( ) . openSession ( ExecutorType . BATCH , false ) ; SqlMapper sqlMapper = ( SqlMapper ) sqlSession . getMapper ( SqlMapper . class ) ; short len = <NUM_LIT> ; if ( len >= dataList . size ( ) ) { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ; ++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; } } else { for ( int i = <NUM_LIT> ; i < dataList . size ( ) ;", "output": "++ i ) { String jsonStr = JSON . toJSONString ( dataList . get ( i ) ) ; this . executeBatchSql ( jsonStr , head , fieldList , sqlMapper , batchCode ) ; if ( i % len == <NUM_LIT> ) { sqlSession . commit ( ) ; sqlSession . clearCache ( ) ; } } } sqlSession . commit ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { sqlSession . close ( ) ; } } private void executeSql ( String jsonStr , CgformHead head , List < CgformField > fieldList , SqlMapper sqlMapper ) throws BusinessException { JSONObject jsonObject = JSONObject . parseObject ( jsonStr ) ; int cou = javaService . executeEnhanceJava ( MjkjConstant . ENHANCE_IMPORT , MjkjConstant . ENHANCE_START , head , jsonObject ) ; String tableName = head . getTableName ( ) ; if ( ! Func . equals ( head . getFormCategory ( ) , \"<STR_LIT>\" ) ) { if ( <NUM_LIT> == cou ) { Map < String , Object > map = SqlSymbolUtil . getInsertSql ( tableName , fieldList , jsonObject ) ; sqlMapper . executeInsertSQL ( map ) ; } else if ( <NUM_LIT> == cou ) { Map < String , Object > map = SqlSymbolUtil . getUpdateSql ( tableName , fieldList , jsonObject ) ; sqlMapper . executeUpdatetSQL ( map ) ; } } } private void executeBatchSql ( String jsonStr , CgformHead head , List < CgformField > fieldList , SqlMapper sqlMapper , String batchCode ) throws BusinessException { JSONObject jsonObject = JSONObject . parseObject ( jsonStr ) ; int cou = javaService . executeEnhanceJava ( MjkjConstant . ENHANCE_IMPORT , MjkjConstant . ENHANCE_START , head , jsonObject ) ; String tableName = head . getTableName ( ) ; jsonObject . put ( \"<STR_LIT>\" , batchCode ) ; if ( <NUM_LIT> == cou ) { Map < String , Object > map = SqlSymbolUtil . getInsertSql ( tableName , fieldList , jsonObject ) ; sqlMapper . executeInsertSQL ( map ) ; } else if ( <NUM_LIT> == cou ) { Map < String , Object > map = SqlSymbolUtil . getUpdateSql ( tableName , fieldList , jsonObject ) ; sqlMapper . executeUpdatetSQL ( map ) ; } } }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . dto . RecoverContactDTO ; import com . xcs . wx . domain . vo . RecoverContactVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . service . RecoverContactService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class RecoverContactController { private final RecoverContactService recoverContactService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < RecoverContactVO > > list ( RecoverContactDTO recoverContactDTO ) {", "output": "return ResponseVO . ok ( recoverContactService . queryRecoverContact ( recoverContactDTO ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < String > export ( ) { return ResponseVO . ok ( recoverContactService . exportRecoverContact ( ) ) ; } }"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . form . UserForm ; import com . youlai . system . plugin . mybatis . annotation . DataPermission ; import com . youlai . system . model . bo . UserBO ; import com . youlai . system . model . entity . SysUser ; import com . youlai . system . model . dto . UserAuthInfo ; import com . youlai . system . model . query . UserPageQuery ; import com . youlai . system . model . dto . UserExportDTO ; import org . apache . ibatis . annotations . Mapper ; import java . util . List ; @ Mapper public interface SysUserMapper extends BaseMapper < SysUser > { @ DataPermission ( deptAlias = \"<STR_LIT>\" ) Page < UserBO > listPagedUsers ( Page < UserBO > page , UserPageQuery queryParams ) ; UserForm getUserFormData ( Long userId ) ; UserAuthInfo getUserAuthInfo ( String username ) ;", "output": "@ DataPermission ( deptAlias = \"<STR_LIT>\" ) List < UserExportDTO > listExportUsers ( UserPageQuery queryParams ) ; }"}, {"input": "package me . zhengjie . modules . security . config ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . AnonymousAccess ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . security . * ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . utils . enums . RequestMethodEnum ; import org . springframework . context . ApplicationContext ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpMethod ; import org . springframework . security . config . annotation . method . configuration . EnableGlobalMethodSecurity ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . config . annotation . web . configuration . EnableWebSecurity ; import org . springframework . security . config . annotation . web . configuration . WebSecurityConfigurerAdapter ; import org . springframework . security . config . core . GrantedAuthorityDefaults ; import org . springframework . security . config . http . SessionCreationPolicy ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . mvc . method . RequestMappingInfo ; import org . springframework . web . servlet . mvc . method . annotation . RequestMappingHandlerMapping ; import java . util . * ; @ Configuration @ EnableWebSecurity @ RequiredArgsConstructor @ EnableGlobalMethodSecurity ( prePostEnabled = true , securedEnabled = true ) public class SpringSecurityConfig extends WebSecurityConfigurerAdapter { private final TokenProvider tokenProvider ; private final CorsFilter corsFilter ; private final JwtAuthenticationEntryPoint authenticationErrorHandler ; private final JwtAccessDeniedHandler jwtAccessDeniedHandler ; private final ApplicationContext applicationContext ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; @ Bean GrantedAuthorityDefaults grantedAuthorityDefaults ( ) { return new GrantedAuthorityDefaults ( \"<STR_LIT>\" ) ; } @ Bean public PasswordEncoder passwordEncoder ( ) { return new BCryptPasswordEncoder ( ) ; } @ Override protected void configure ( HttpSecurity httpSecurity ) throws Exception { RequestMappingHandlerMapping requestMappingHandlerMapping = ( RequestMappingHandlerMapping ) applicationContext . getBean ( \"<STR_LIT>\" ) ; Map < RequestMappingInfo , HandlerMethod > handlerMethodMap = requestMappingHandlerMapping . getHandlerMethods ( ) ; Map < String , Set < String > > anonymousUrls = getAnonymousUrl ( handlerMethodMap ) ; httpSecurity . csrf ( ) . disable ( ) . addFilterBefore ( corsFilter , UsernamePasswordAuthenticationFilter . class ) . exceptionHandling ( ) . authenticationEntryPoint ( authenticationErrorHandler ) . accessDeniedHandler ( jwtAccessDeniedHandler ) . and ( ) . headers ( ) . frameOptions ( ) . disable ( ) . and ( ) . sessionManagement ( ) . sessionCreationPolicy ( SessionCreationPolicy . STATELESS ) . and ( ) . authorizeRequests ( ) . antMatchers ( HttpMethod . GET , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( HttpMethod . OPTIONS , \"<STR_LIT>\" ) . permitAll ( ) . antMatchers ( HttpMethod . GET , anonymousUrls . get ( RequestMethodEnum . GET . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . POST , anonymousUrls . get ( RequestMethodEnum . POST . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . PUT , anonymousUrls . get ( RequestMethodEnum . PUT . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . PATCH , anonymousUrls . get ( RequestMethodEnum . PATCH . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( HttpMethod . DELETE , anonymousUrls . get ( RequestMethodEnum . DELETE . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . antMatchers ( anonymousUrls . get ( RequestMethodEnum . ALL . getType ( ) ) . toArray ( new String [ <NUM_LIT> ] ) ) . permitAll ( ) . anyRequest ( ) . authenticated ( ) . and ( ) . apply ( securityConfigurerAdapter ( ) ) ; } private TokenConfigurer securityConfigurerAdapter ( ) { return new TokenConfigurer ( tokenProvider , properties , onlineUserService , userCacheManager ) ; } private Map < String , Set < String > > getAnonymousUrl ( Map < RequestMappingInfo , HandlerMethod > handlerMethodMap ) { Map < String , Set < String > > anonymousUrls = new HashMap < > ( <NUM_LIT> ) ; Set < String > get = new HashSet < > ( ) ; Set < String > post = new HashSet < > ( ) ; Set < String > put = new HashSet < > ( ) ; Set < String > patch = new HashSet < > ( ) ; Set < String > delete = new HashSet < > ( ) ; Set < String > all = new HashSet < > ( ) ; for ( Map . Entry < RequestMappingInfo , HandlerMethod > infoEntry : handlerMethodMap . entrySet ( ) ) { HandlerMethod handlerMethod = infoEntry . getValue ( ) ; AnonymousAccess anonymousAccess = handlerMethod . getMethodAnnotation ( AnonymousAccess . class ) ; if ( null != anonymousAccess ) { List < RequestMethod > requestMethods = new ArrayList < > ( infoEntry . getKey ( ) . getMethodsCondition ( ) . getMethods ( ) ) ; RequestMethodEnum request = RequestMethodEnum . find ( requestMethods . size ( ) == <NUM_LIT> ? RequestMethodEnum . ALL . getType ( ) : requestMethods . get ( <NUM_LIT> ) . name ( ) ) ; switch ( Objects . requireNonNull ( request ) ) { case GET : get . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case POST : post . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case PUT : put . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case PATCH : patch . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; case DELETE : delete . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ;", "output": "default : all . addAll ( infoEntry . getKey ( ) . getPatternsCondition ( ) . getPatterns ( ) ) ; break ; } } } anonymousUrls . put ( RequestMethodEnum . GET . getType ( ) , get ) ; anonymousUrls . put ( RequestMethodEnum . POST . getType ( ) , post ) ; anonymousUrls . put ( RequestMethodEnum . PUT . getType ( ) , put ) ; anonymousUrls . put ( RequestMethodEnum . PATCH . getType ( ) , patch ) ; anonymousUrls . put ( RequestMethodEnum . DELETE . getType ( ) , delete ) ; anonymousUrls . put ( RequestMethodEnum . ALL . getType ( ) , all ) ; return anonymousUrls ; } }"}, {"input": "package me . zhengjie . utils ; import java . sql . Timestamp ; import java . time . * ; import java . time . format . DateTimeFormatter ; import java . util . Date ; public class DateUtil { public static final DateTimeFormatter DFY_MD_HMS = DateTimeFormatter . ofPattern ( \"<STR_LIT>\" ) ; public static final DateTimeFormatter DFY_MD = DateTimeFormatter . ofPattern ( \"<STR_LIT>\" ) ; public static Long getTimeStamp ( LocalDateTime localDateTime ) { return localDateTime . atZone ( ZoneId . systemDefault ( ) ) . toEpochSecond ( ) ; } public static LocalDateTime fromTimeStamp ( Long timeStamp ) { return LocalDateTime . ofEpochSecond ( timeStamp , <NUM_LIT> , OffsetDateTime . now ( ) . getOffset ( ) ) ; } public static Date toDate ( LocalDateTime localDateTime ) { return Date . from ( localDateTime . atZone ( ZoneId . systemDefault ( ) ) . toInstant ( ) ) ; } public static Date toDate ( LocalDate localDate ) { return toDate ( localDate . atTime ( LocalTime . now ( ZoneId . systemDefault ( ) ) ) ) ; } public static LocalDateTime toLocalDateTime ( Date date ) { return LocalDateTime . ofInstant ( date . toInstant ( ) , ZoneId . systemDefault ( ) ) ; } public static String localDateTimeFormat ( LocalDateTime localDateTime , String patten ) { DateTimeFormatter df = DateTimeFormatter . ofPattern ( patten ) ; return df . format ( localDateTime ) ; } public static String localDateTimeFormat ( LocalDateTime localDateTime , DateTimeFormatter df ) { return df . format ( localDateTime ) ; } public static String localDateTimeFormatyMdHms ( LocalDateTime localDateTime ) { return DFY_MD_HMS . format ( localDateTime ) ; } public static Timestamp getTimeStamp ( ) { return Timestamp . valueOf ( LocalDateTime . now ( ) ) ; } public String localDateTimeFormatyMd ( LocalDateTime localDateTime ) { return DFY_MD . format ( localDateTime ) ; } public static LocalDateTime parseLocalDateTimeFormat ( String localDateTime , String pattern ) { DateTimeFormatter dateTimeFormatter = DateTimeFormatter . ofPattern ( pattern ) ; return LocalDateTime . from ( dateTimeFormatter . parse ( localDateTime ) ) ; } public static LocalDateTime parseLocalDateTimeFormat ( String localDateTime , DateTimeFormatter dateTimeFormatter ) { return LocalDateTime . from ( dateTimeFormatter . parse ( localDateTime ) ) ; } public static LocalDateTime parseLocalDateTimeFormatyMdHms ( String localDateTime ) { return LocalDateTime . from ( DFY_MD_HMS . parse ( localDateTime ) ) ;", "output": "} }"}, {"input": "package org . springblade . cgform . enums ; public enum CgformValidPatternEnum { ONLY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUM6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , STRING6_16 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER6_18 ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , URL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MOBILE ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , POSTAL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , LETTER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NUMBER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTEGER ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , NOTNULL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MONEY ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String type ; String pattern ; String msg ; private CgformValidPatternEnum ( String type , String pattern , String msg ) { this . pattern = pattern ; this . msg = msg ; this . type = type ; } public String getType ( ) { return this . type ; } public void setType ( String type ) { this . type = type ; } public String getPattern ( ) { return this . pattern ; } public void setPattern ( String pattern ) { this . pattern = pattern ; } public String getMsg ( ) { return this . msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public static CgformValidPatternEnum getPatternInfoByType ( String type ) { CgformValidPatternEnum [ ] var1 = values ( ) ; int var2 = var1 . length ; for ( int var3 = <NUM_LIT> ; var3 < var2 ; ++ var3 ) { CgformValidPatternEnum var4 = var1 [ var3 ] ;", "output": "if ( var4 . type . equals ( type ) ) { return var4 ; } } return null ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import io . github . chensheng . dddboot . tools . text . EncodeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . imageio . ImageIO ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String logoImgPath , boolean needCompress ) throws WriterException , IOException { InputStream logoImg = null ; if ( TextUtil . isNotBlank ( logoImgPath ) ) { logoImg = new FileInputStream ( logoImgPath ) ; } return createImage ( content , logoImg , needCompress ) ; } private static BufferedImage createImage ( String content , InputStream logoImg , boolean needCompress ) throws WriterException , IOException { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( logoImg == null ) { return image ; } QRCodeUtil . insertImage ( image , logoImg , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , InputStream logoImg , boolean needCompress ) throws IOException { if ( logoImg == null ) { return ; } Image src = ImageIO . read ( logoImg ) ; int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ;", "output": "} public static void encode ( String content , InputStream logoImg , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static void encode ( String content , String logoImgPath , String destPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; File file = new File ( destPath ) ; File fileParent = file . getParentFile ( ) ; if ( ! fileParent . exists ( ) ) { fileParent . mkdirs ( ) ; } file . createNewFile ( ) ; ImageIO . write ( image , FORMAT_NAME , new File ( destPath ) ) ; } public static byte [ ] encode ( String content , InputStream logoImg , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImg , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] encode ( String content , String logoImgPath , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ImageIO . write ( image , FORMAT_NAME , out ) ; return out . toByteArray ( ) ; } public static byte [ ] imageToBytes ( BufferedImage bImage , String format ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; try { ImageIO . write ( bImage , format , out ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return out . toByteArray ( ) ; } public static void encode ( String content , String destPath ) throws Exception { QRCodeUtil . encode ( content , \"<STR_LIT>\" , destPath , false ) ; } public static void encode ( String content , String logoImgPath , OutputStream output , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , logoImgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; } public static void encode ( String content , OutputStream output ) throws Exception { QRCodeUtil . encode ( content , null , output , false ) ; } public static String decode ( File file ) throws Exception { BufferedImage image ; image = ImageIO . read ( file ) ; if ( image == null ) { return null ; } BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ; BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ; Result result ; Hashtable < DecodeHintType , Object > hints = new Hashtable < DecodeHintType , Object > ( ) ; hints . put ( DecodeHintType . CHARACTER_SET , CHARSET ) ; result = new MultiFormatReader ( ) . decode ( bitmap , hints ) ; String resultStr = result . getText ( ) ; return resultStr ; } public static String decodeBase64Image ( String base64Image ) { byte [ ] imgBytes = EncodeUtil . decodeBase64 ( base64Image ) ; if ( imgBytes == null ) { return null ; } try { ByteArrayInputStream in = new ByteArrayInputStream ( imgBytes ) ; BufferedImage image = ImageIO . read ( in ) ; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ; BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ; Result result ; Hashtable < DecodeHintType , Object > hints = new Hashtable < DecodeHintType , Object > ( ) ; hints . put ( DecodeHintType . CHARACTER_SET , CHARSET ) ; result = new MultiFormatReader ( ) . decode ( bitmap , hints ) ; String resultStr = result . getText ( ) ; return resultStr ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( NotFoundException e ) { e . printStackTrace ( ) ; } return null ; } public static String decode ( String path ) throws Exception { return QRCodeUtil . decode ( new File ( path ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; public interface NacosConfigConstants { String ENDPOINT_PREFIX = \"<STR_LIT>\" ; String ENABLED = EnableNacosConfig . CONFIG_PREFIX + \"<STR_LIT>\" ; String PREFIX = \"<STR_LIT>\" ;", "output": "String NACOS_BOOTSTRAP = PREFIX + \"<STR_LIT>\" ; String NACOS_LOG_BOOTSTRAP = PREFIX + \"<STR_LIT>\" ; }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . hutool . captcha . CaptchaUtil ; import cn . hutool . captcha . LineCaptcha ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . UserConverter ; import cn . org . alan . exam . mapper . RoleMapper ; import cn . org . alan . exam . mapper . UserDailyLoginDurationMapper ; import cn . org . alan . exam . mapper . UserMapper ; import cn . org . alan . exam . model . entity . User ; import cn . org . alan . exam . model . entity . UserDailyLoginDuration ; import cn . org . alan . exam . model . form . Auth . LoginForm ; import cn . org . alan . exam . model . form . UserForm ; import cn . org . alan . exam . security . SysUserDetails ; import cn . org . alan . exam . service . IAuthService ; import cn . org . alan . exam . util . DateTimeUtil ; import cn . org . alan . exam . util . JwtUtil ; import cn . org . alan . exam . util . SecretUtils ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import jakarta . annotation . Resource ; import jakarta . servlet . ServletOutputStream ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . servlet . http . HttpServletResponse ; import jakarta . servlet . http . HttpSession ; import lombok . SneakyThrows ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . authority . SimpleGrantedAuthority ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . core . userdetails . UsernameNotFoundException ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; import org . springframework . security . web . authentication . WebAuthenticationDetailsSource ; import org . springframework . stereotype . Service ; import java . io . IOException ; import java . time . Duration ; import java . time . LocalDate ; import java . time . LocalDateTime ; import java . time . ZoneOffset ; import java . util . ArrayList ; import java . util . List ; import java . util . Objects ; import java . util . concurrent . TimeUnit ; @ Service public class AuthServiceImpl implements IAuthService { private static final String HEARTBEAT_KEY_PREFIX = \"<STR_LIT>\" ; private static final long HEARTBEAT_INTERVAL_MILLIS = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; @ Resource private StringRedisTemplate stringRedisTemplate ; @ Resource private UserMapper userMapper ; @ Resource private RoleMapper roleMapper ; @ Resource private UserConverter userConverter ; @ Resource private ObjectMapper objectMapper ; @ Resource private JwtUtil jwtUtil ; @ Resource private UserDailyLoginDurationMapper userDailyLoginDurationMapper ; @ SneakyThrows ( JsonProcessingException . class ) @ Override public Result < String > login ( HttpServletRequest request , LoginForm loginForm ) { String s = stringRedisTemplate . opsForValue ( ) . get ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) ) ; if ( StringUtils . isBlank ( s ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } LambdaQueryWrapper < User > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( User :: getUserName , loginForm . getUsername ( ) ) ; User user = userMapper . selectOne ( wrapper ) ; if ( Objects . isNull ( user ) ) { throw new UsernameNotFoundException ( \"<STR_LIT>\" ) ; } if ( user . getIsDeleted ( ) == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } BCryptPasswordEncoder encoder = new BCryptPasswordEncoder ( ) ; if ( ! encoder . matches ( SecretUtils . desEncrypt ( loginForm . getPassword ( ) ) , user . getPassword ( ) ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } user . setPassword ( null ) ; List < String > permissions = roleMapper . selectCodeById ( user . getRoleId ( ) ) ; List < SimpleGrantedAuthority > userPermissions = permissions . stream ( ) . map ( permission -> new SimpleGrantedAuthority ( \"<STR_LIT>\" + permission ) ) . toList ( ) ; SysUserDetails sysUserDetails = new SysUserDetails ( user ) ;", "output": "sysUserDetails . setPermissions ( userPermissions ) ; String userInfo = objectMapper . writeValueAsString ( user ) ; String token = jwtUtil . createJwt ( userInfo , userPermissions . stream ( ) . map ( String :: valueOf ) . toList ( ) ) ; stringRedisTemplate . opsForValue ( ) . set ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) , token , <NUM_LIT> , TimeUnit . MINUTES ) ; UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken ( sysUserDetails , user . getPassword ( ) , userPermissions ) ; usernamePasswordAuthenticationToken . setDetails ( new WebAuthenticationDetailsSource ( ) . buildDetails ( request ) ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( usernamePasswordAuthenticationToken ) ; stringRedisTemplate . delete ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) ) ; return Result . success ( \"<STR_LIT>\" , token ) ; } @ Override public Result < String > logout ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; if ( session != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + session . getId ( ) ) ; session . invalidate ( ) ; } return Result . success ( \"<STR_LIT>\" ) ; } @ SneakyThrows ( IOException . class ) @ Override public void getCaptcha ( HttpServletRequest request , HttpServletResponse response ) { LineCaptcha captcha = CaptchaUtil . createLineCaptcha ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; String code = captcha . getCode ( ) ; String key = \"<STR_LIT>\" + request . getSession ( ) . getId ( ) ; stringRedisTemplate . opsForValue ( ) . set ( key , code , <NUM_LIT> , TimeUnit . MINUTES ) ; response . setContentType ( \"<STR_LIT>\" ) ; ServletOutputStream os = response . getOutputStream ( ) ; captcha . write ( os ) ; os . close ( ) ; } @ Override public Result < String > verifyCode ( HttpServletRequest request , String code ) { String key = \"<STR_LIT>\" + request . getSession ( ) . getId ( ) ; String rightCode = stringRedisTemplate . opsForValue ( ) . get ( key ) ; if ( StringUtils . isBlank ( rightCode ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } if ( ! rightCode . equalsIgnoreCase ( code ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } stringRedisTemplate . delete ( key ) ; stringRedisTemplate . opsForValue ( ) . set ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) , \"<STR_LIT>\" , <NUM_LIT> , TimeUnit . MINUTES ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override public Result < String > register ( HttpServletRequest request , UserForm userForm ) { String s = stringRedisTemplate . opsForValue ( ) . get ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) ) ; if ( StringUtils . isBlank ( s ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } if ( ! SecretUtils . desEncrypt ( userForm . getPassword ( ) ) . equals ( SecretUtils . desEncrypt ( userForm . getCheckedPassword ( ) ) ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } User user = userConverter . fromToEntity ( userForm ) ; user . setPassword ( new BCryptPasswordEncoder ( ) . encode ( SecretUtils . desEncrypt ( user . getPassword ( ) ) ) ) ; user . setRoleId ( <NUM_LIT> ) ; userMapper . insert ( user ) ; stringRedisTemplate . delete ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ SneakyThrows ( value = JsonProcessingException . class ) public Result < String > sendHeartbeat ( HttpServletRequest request ) { String key = HEARTBEAT_KEY_PREFIX + SecurityUtil . getUserId ( ) ; String lastHeartbeatStr = stringRedisTemplate . opsForValue ( ) . getAndDelete ( key ) ; LocalDateTime now = LocalDateTime . now ( ZoneOffset . UTC ) ; stringRedisTemplate . opsForValue ( ) . set ( key , now . toString ( ) ) ; if ( lastHeartbeatStr != null ) { LocalDateTime lastHeartbeat = LocalDateTime . parse ( lastHeartbeatStr ) ; Duration durationSinceLastHeartbeat = Duration . between ( lastHeartbeat , LocalDateTime . now ( ZoneOffset . UTC ) ) ; LocalDate date = DateTimeUtil . getDate ( ) ; LambdaQueryWrapper < UserDailyLoginDuration > userDailyLoginDurationLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; userDailyLoginDurationLambdaQueryWrapper . eq ( UserDailyLoginDuration :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( UserDailyLoginDuration :: getLoginDate , date ) ; List < UserDailyLoginDuration > userDailyLoginDurations = userDailyLoginDurationMapper . selectList ( userDailyLoginDurationLambdaQueryWrapper ) ; if ( userDailyLoginDurations . isEmpty ( ) ) { UserDailyLoginDuration userDailyLoginDuration = new UserDailyLoginDuration ( ) ; userDailyLoginDuration . setUserId ( SecurityUtil . getUserId ( ) ) ; userDailyLoginDuration . setLoginDate ( date ) ; userDailyLoginDuration . setTotalSeconds ( <NUM_LIT> ) ; userDailyLoginDurationMapper . insert ( userDailyLoginDuration ) ; } else { UserDailyLoginDuration userDailyLoginDuration = new UserDailyLoginDuration ( ) ; userDailyLoginDuration . setTotalSeconds ( userDailyLoginDurations . get ( <NUM_LIT> ) . getTotalSeconds ( ) + ( int ) durationSinceLastHeartbeat . getSeconds ( ) ) ; userDailyLoginDuration . setId ( userDailyLoginDurations . get ( <NUM_LIT> ) . getId ( ) ) ; userDailyLoginDurationMapper . updateById ( userDailyLoginDuration ) ; } } ArrayList < String > permissions = new ArrayList < > ( ) ; permissions . add ( SecurityUtil . getRole ( ) ) ; SysUserDetails principal = ( SysUserDetails ) ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) . getPrincipal ( ) ) ; User user = principal . getUser ( ) ; String string = objectMapper . writeValueAsString ( user ) ; String jwt = jwtUtil . createJwt ( string , permissions ) ; stringRedisTemplate . opsForValue ( ) . set ( \"<STR_LIT>\" + request . getSession ( ) . getId ( ) , jwt , <NUM_LIT> , TimeUnit . MINUTES ) ; return Result . success ( \"<STR_LIT>\" , jwt ) ; } }"}, {"input": "package com . xcs . wx . msg . impl ; import cn . hutool . core . lang . Opt ; import cn . hutool . core . util . ReUtil ; import com . xcs . wx . domain . bo . MsgBO ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import com . xcs . wx . util . XmlUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . stereotype . Service ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Slf4j @ Service public class ImageMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ; } @ Override public void process ( MsgVO msgVO ) { Opt . ofNullable ( msgVO . getBytesExtra ( ) ) . map ( xmlContent -> new String ( msgVO . getBytesExtra ( ) ) ) . ifPresent ( extra -> {", "output": "String thumb = ReUtil . getGroup0 ( \"<STR_LIT>\" , extra ) ; String image = ReUtil . getGroup0 ( \"<STR_LIT>\" , extra ) ; msgVO . setImage ( image ) ; msgVO . setThumb ( thumb ) ; msgVO . setStrContent ( \"<STR_LIT>\" ) ; } ) ; } }"}, {"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . mapper . DictMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . cgform . model . query . QueryGenerator ; import org . springblade . cgform . service . IDictService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tenant . annotation . TenantIgnore ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Service public class DictServiceImpl extends BaseServiceImpl < DictMapper , SysDict > implements IDictService { @ Override public List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) { if ( table . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { table = QueryGenerator . getSqlRuleValue ( table ) ; } return baseMapper . queryTableDictItemsByCode ( table , text , code ) ; } @ Override public List < DictModel > queryDictItemsByCode ( String code ) {", "output": "return baseMapper . queryDictItemsByCode ( code ) ; } @ Override public List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) { if ( Func . isEmpty ( keys ) ) { return null ; } String [ ] keyArray = keys . split ( \"<STR_LIT>\" ) ; List < DictModel > dictsList = baseMapper . queryTableDictByKeys ( table , text , code , keyArray ) ; List < String > resultList = new ArrayList < > ( dictsList . size ( ) ) ; for ( String key : keyArray ) { for ( DictModel dict : dictsList ) { if ( key . equals ( dict . getValue ( ) ) ) { resultList . add ( dict . getText ( ) ) ; break ; } } } return resultList ; } @ Override public List < DictModel > queryTableDictItemsByCodeAndFilter ( String table , String text , String code , String filterSql ) { return baseMapper . queryTableDictItemsByCodeAndFilter ( table , text , code , filterSql ) ; } @ Deprecated public List < DictModel > queryTableDictItems ( String table , String text , String code , String keyword ) { return baseMapper . queryTableDictItems ( table , text , code , \"<STR_LIT>\" + keyword + \"<STR_LIT>\" ) ; } public Long duplicateCheckCountSql ( DuplicateCheckVo duplicateCheckVo ) { return baseMapper . duplicateCheckCountSql ( duplicateCheckVo ) ; } public Long duplicateCheckCountSqlNoDataId ( DuplicateCheckVo duplicateCheckVo ) { return baseMapper . duplicateCheckCountSqlNoDataId ( duplicateCheckVo ) ; } @ Override public List < DictModel > queryFilterTableDictInfo ( String table , String text , String code , String filterSql ) { return baseMapper . queryTableDictItemsByCodeAndFilter ( table , text , code , filterSql ) ; } }"}, {"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformEnhanceJavaService extends BaseService < CgformEnhanceJava > { void executeEnhanceList ( CgformHead onlcgformhead , String buttonCode , List < Map < String , Object > > list , Map < String , Object > params ) throws BusinessException ; int executeEnhanceJava ( String buttonCode , String eventType , CgformHead onlcgformhead , JSONObject jsonobject ) throws BusinessException ;", "output": "Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) ; }"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . youlai . system . model . entity . SysDictItem ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface SysDictItemMapper extends BaseMapper < SysDictItem > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . EscapeUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . List ; public class ServletExcelUtil { public static void write ( HttpServletResponse response , List < ? > models , String fileName ) throws IOException { write ( response , models , fileName , null ) ; } public static void write ( HttpServletResponse response , List < ? > models , String fileName , File templateFile ) throws IOException { if ( response == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( models ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isEmpty ( fileName ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; }", "output": "ServletOutputStream outputStream = response . getOutputStream ( ) ; response . setContentType ( \"<STR_LIT>\" ) ; response . setCharacterEncoding ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" + EscapeUtil . urlEncode ( fileName ) + \"<STR_LIT>\" ) ; InputStream templateIs = null ; if ( templateFile != null ) { templateIs = new FileInputStream ( templateFile ) ; } ExcelUtil . write ( outputStream , models , templateIs ) ; outputStream . flush ( ) ; } }"}, {"input": "package ginyi . framework . security . service ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . mysql . MyPage ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import ginyi . system . domain . SysMenu ; import ginyi . system . domain . SysPost ; import ginyi . system . domain . model . dto . PostDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . PostVo ; import ginyi . system . mapper . SysPostMapper ; import ginyi . system . service . ISysPostService ; import org . springframework . beans . BeanUtils ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . List ; import java . util . Set ; @ Service public class SysPostServiceImpl implements ISysPostService { @ Resource private SysPostMapper postMapper ; @ Resource private RedisCache redisCache ; @ Override public BaseVo < PostVo > list ( PostDto postDto , Long page , Long pageSize ) { IPage < PostVo > list = postMapper . list ( postDto , new MyPage ( page , pageSize ) . getPage ( ) ) ; BaseVo < PostVo > baseVo = new BaseVo < > ( ) ; baseVo . setList ( list . getRecords ( ) ) ; baseVo . setCount ( ( int ) list . getTotal ( ) ) ; return baseVo ; } @ Override public PostVo getPostByPostId ( Long postId ) { if ( redisCache . hasKey ( CacheConstants . POST_NOT_EXIST_KEY + postId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , postId + CommonMessageConstants . POST_NOT_EXIST ) ; } PostVo postVo = new PostVo ( ) ; SysPost post = redisCache . getCacheObject ( CacheConstants . POST_DETAILS_BY_POSTID_KEY + postId , SysPost . class ) ; if ( StringUtils . isNotNull ( post ) ) { BeanUtils . copyProperties ( post , postVo ) ; return postVo ; } LambdaQueryWrapper < SysPost > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostId , postId ) ; post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( post ) ) { redisCache . setCacheObject ( CacheConstants . POST_NOT_EXIST_KEY + postId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , postId + CommonMessageConstants . POST_NOT_EXIST ) ; } redisCache . setCacheObject ( CacheConstants . POST_DETAILS_BY_POSTID_KEY + postId , post ) ; BeanUtils . copyProperties ( post , postVo ) ; return postVo ; } @ Override public void addPost ( PostDto postDto ) { if ( redisCache . hasKey ( CacheConstants . ROLE_NAME_USED_KEY + postDto . getPostName ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . POST_NAME_USED ) ; } if ( redisCache . hasKey ( CacheConstants . ROLE_CODE_USED_KEY + postDto . getPostCode ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . POST_CODE_USED ) ; } LambdaQueryWrapper < SysPost > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostName , postDto . getPostName ( ) ) ; SysPost post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( post ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NAME_USED_KEY + postDto . getPostName ( ) , null ) ;", "output": "throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . POST_NAME_USED ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostCode , postDto . getPostCode ( ) ) ; post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( post ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_CODE_USED_KEY + postDto . getPostCode ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . POST_CODE_USED ) ; } postMapper . insertPost ( postDto ) ; redisCache . removeCacheObject ( CacheConstants . POST_KEY_PREFIX ) ; redisCache . removeCacheObject ( CacheConstants . ROLE_KEY_PREFIX ) ; } @ Override public void updatePost ( PostDto postDto ) { if ( redisCache . hasKey ( CacheConstants . POST_NOT_EXIST_KEY + postDto . getPostId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , postDto . getPostId ( ) + CommonMessageConstants . POST_NOT_EXIST ) ; } LambdaQueryWrapper < SysPost > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostId , postDto . getPostId ( ) ) ; SysPost post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( post ) ) { redisCache . setCacheObject ( CacheConstants . POST_NOT_EXIST_KEY + postDto . getPostId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , postDto . getPostId ( ) + CommonMessageConstants . POST_NOT_EXIST ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostName , postDto . getPostName ( ) ) ; post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( post ) && ! post . getPostId ( ) . equals ( postDto . getPostId ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . POST_NAME_USED ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostCode , postDto . getPostCode ( ) ) ; post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( post ) && ! post . getPostId ( ) . equals ( postDto . getPostId ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . POST_CODE_USED ) ; } postMapper . updatePost ( postDto ) ; redisCache . removeCacheObject ( CacheConstants . POST_KEY_PREFIX ) ; } @ Override public void removePostById ( Long postId ) { if ( redisCache . hasKey ( CacheConstants . POST_NOT_EXIST_KEY + postId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , postId + CommonMessageConstants . POST_NOT_EXIST ) ; } LambdaQueryWrapper < SysPost > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostId , postId ) ; SysPost post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( post ) ) { redisCache . setCacheObject ( CacheConstants . POST_NOT_EXIST_KEY + postId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , postId + CommonMessageConstants . POST_NOT_EXIST ) ; } postMapper . deleteById ( postId ) ; redisCache . removeCacheObject ( CacheConstants . POST_KEY_PREFIX ) ; } @ Override public void removeDeptByIds ( Set < Long > ids ) { if ( ids . size ( ) > <NUM_LIT> ) { List < SysPost > postList ; postList = redisCache . getCacheList ( CacheConstants . POST_LIST_KEY , SysPost . class ) ; if ( StringUtils . isNull ( postList ) || postList . size ( ) == <NUM_LIT> ) { LambdaQueryWrapper < SysPost > queryWrapper = new LambdaQueryWrapper < > ( ) ; postList = postMapper . selectList ( queryWrapper ) ; redisCache . setCacheList ( CacheConstants . POST_LIST_KEY , postList ) ; } for ( Long postId : ids ) { if ( redisCache . hasKey ( CacheConstants . POST_NOT_EXIST_KEY + postId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , postId + CommonMessageConstants . POST_NOT_EXIST ) ; } boolean exist = postList . stream ( ) . anyMatch ( post -> postId . equals ( post . getPostId ( ) ) ) ; if ( ! exist ) { redisCache . setCacheObject ( CacheConstants . POST_NOT_EXIST_KEY + postId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , postId + CommonMessageConstants . POST_NOT_EXIST ) ; } } postMapper . deleteBatchIds ( ids ) ; redisCache . removeCacheObject ( CacheConstants . POST_KEY_PREFIX ) ; } else { throw new CommonException ( StateCode . ERROR_REQUEST_PARAMS , CommonMessageConstants . SYS_REQUEST_ILLEGAL ) ; } } @ Override public void updateStatus ( PostDto postDto ) { if ( StringUtils . isNull ( postDto . getPostId ( ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . POST_ID_NOT_FOUND ) ; } if ( ! ( \"<STR_LIT>\" . equals ( postDto . getStatus ( ) ) || \"<STR_LIT>\" . equals ( postDto . getStatus ( ) ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . POST_STATUS_ILLEGAL ) ; } if ( redisCache . hasKey ( CacheConstants . USER_NOT_EXIST_KEY + postDto . getPostId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , postDto . getPostId ( ) + CommonMessageConstants . POST_NOT_EXIST ) ; } LambdaQueryWrapper < SysPost > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysPost :: getPostId , postDto . getPostId ( ) ) ; SysPost post = postMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( post ) ) { redisCache . setCacheObject ( CacheConstants . POST_NOT_EXIST_KEY + postDto . getPostId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , postDto . getPostId ( ) + CommonMessageConstants . POST_NOT_EXIST ) ; } postMapper . updatePostStatus ( postDto ) ; } }"}, {"input": "package ginyi . framework . security . service ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import ginyi . common . constant . CacheConstants ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . utils . StringUtils ; import ginyi . common . utils . text . Convert ; import ginyi . system . domain . SysConfig ; import ginyi . system . mapper . SysConfigMapper ; import ginyi . system . service . ISysConfigService ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; @ Service public class SysConfigServiceImpl implements ISysConfigService { @ Resource private RedisCache redisCache ; @ Resource private SysConfigMapper configMapper ; @ Override public boolean selectCaptchaEnabled ( ) { String captchaEnabled = selectConfigByKey ( \"<STR_LIT>\" ) ; if ( StringUtils . isEmpty ( captchaEnabled ) ) { return true ; } return Convert . toBool ( captchaEnabled ) ; } @ Override public String selectConfigByKey ( String configKey ) { String configValue = Convert . toStr ( redisCache . getCacheObject ( getCacheKey ( configKey ) , String . class ) ) ; if ( StringUtils . isNotEmpty ( configValue ) ) { return configValue ; } LambdaQueryWrapper < SysConfig > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysConfig :: getConfigKey , configKey ) ; SysConfig sysConfig = configMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( sysConfig ) ) { redisCache . setCacheObject ( getCacheKey ( configKey ) , sysConfig . getConfigValue ( ) ) ; return sysConfig . getConfigValue ( ) ; } return StringUtils . EMPTY ; }", "output": "private String getCacheKey ( String configKey ) { return CacheConstants . SYS_CONFIG_KEY + configKey ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . Role ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IRoleService extends IService < Role > {", "output": "}"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustExchangeApiParam { private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinId ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . net . InetAddresses ; import io . github . chensheng . dddboot . tools . number . NumberUtil ; import io . github . chensheng . dddboot . tools . text . MoreStringUtil ; import java . net . Inet4Address ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . List ; public class IPUtil { public static int toInt ( InetAddress address ) { return InetAddresses . coerceToInteger ( address ) ; } public static String toIpString ( InetAddress address ) { return InetAddresses . toAddrString ( address ) ; } public static Inet4Address fromInt ( int address ) { return InetAddresses . fromInteger ( address ) ; } public static InetAddress fromIpString ( String address ) { return InetAddresses . forString ( address ) ; } public static Inet4Address fromIpv4String ( String address ) { byte [ ] bytes = ip4StringToBytes ( address ) ;", "output": "if ( bytes == null ) { return null ; } else { try { return ( Inet4Address ) Inet4Address . getByAddress ( bytes ) ; } catch ( UnknownHostException e ) { throw new AssertionError ( e ) ; } } } public static String intToIpv4String ( int i ) { return new StringBuilder ( <NUM_LIT> ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( ( i > > <NUM_LIT> ) & <NUM_LIT> ) . append ( '<STR_LIT>' ) . append ( i & <NUM_LIT> ) . toString ( ) ; } public static int ipv4StringToInt ( String ipv4Str ) { byte [ ] byteAddress = ip4StringToBytes ( ipv4Str ) ; if ( byteAddress == null ) { return <NUM_LIT> ; } else { return NumberUtil . toInt ( byteAddress ) ; } } private static byte [ ] ip4StringToBytes ( String ipv4Str ) { if ( ipv4Str == null ) { return null ; } List < String > it = MoreStringUtil . split ( ipv4Str , '<STR_LIT>' , <NUM_LIT> ) ; if ( it . size ( ) != <NUM_LIT> ) { return null ; } byte [ ] byteAddress = new byte [ <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int tempInt = Integer . parseInt ( it . get ( i ) ) ; if ( tempInt > <NUM_LIT> ) { return null ; } byteAddress [ i ] = ( byte ) tempInt ; } return byteAddress ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class ShortConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Short . class == fieldType || short . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; try { return Short . parseShort ( cellContent ) ; } catch ( NumberFormatException e ) { return Short . class == fieldType ? null : ( short ) <NUM_LIT> ; } }", "output": "@ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Short value = ( Short ) cellValue ; cell . setCellType ( CellType . NUMERIC ) ; cell . setCellValue ( value ) ; } }"}, {"input": "package com . yf . config ; import com . yf . ability . shiro . CNFilterFactoryBean ; import com . yf . ability . shiro . MyShiroRealm ; import com . yf . ability . shiro . aop . JwtFilter ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang3 . StringUtils ; import org . apache . shiro . mgt . DefaultSessionStorageEvaluator ; import org . apache . shiro . mgt . DefaultSubjectDAO ; import org . apache . shiro . mgt . SecurityManager ; import org . apache . shiro . spring . LifecycleBeanPostProcessor ; import org . apache . shiro . spring . security . interceptor . AuthorizationAttributeSourceAdvisor ; import org . apache . shiro . spring . web . ShiroFilterFactoryBean ; import org . apache . shiro . web . mgt . DefaultWebSecurityManager ; import org . crazycake . shiro . RedisCacheManager ; import org . crazycake . shiro . RedisManager ; import org . springframework . aop . framework . autoproxy . DefaultAdvisorAutoProxyCreator ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . DependsOn ; import javax . servlet . Filter ; import java . util . HashMap ; import java . util . LinkedHashMap ; import java . util . Map ; @ Slf4j @ Configuration public class ShiroConfig { @ Value ( \"<STR_LIT>\" ) private String redisPort ; @ Value ( \"<STR_LIT>\" ) private String redisHost ; @ Value ( \"<STR_LIT>\" ) private String redisPass ; @ Value ( \"<STR_LIT>\" ) private Integer database ; @ Bean ( \"<STR_LIT>\" ) public ShiroFilterFactoryBean shiroFilter ( SecurityManager securityManager ) { ShiroFilterFactoryBean shiroFilterFactoryBean = new CNFilterFactoryBean ( ) ; shiroFilterFactoryBean . setSecurityManager ( securityManager ) ; Map < String , String > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Map < String , Filter > filterMap = new HashMap < > ( <NUM_LIT> ) ; filterMap . put ( \"<STR_LIT>\" , new JwtFilter ( ) ) ; shiroFilterFactoryBean . setFilters ( filterMap ) ; map . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; shiroFilterFactoryBean . setFilterChainDefinitionMap ( map ) ; return shiroFilterFactoryBean ; } @ Bean ( \"<STR_LIT>\" ) public DefaultWebSecurityManager securityManager ( MyShiroRealm myRealm ) { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager ( ) ; DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO ( ) ; DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator ( ) ; defaultSessionStorageEvaluator . setSessionStorageEnabled ( false ) ; subjectDAO . setSessionStorageEvaluator ( defaultSessionStorageEvaluator ) ; securityManager . setSubjectDAO ( subjectDAO ) ; securityManager . setCacheManager ( redisCacheManager ( ) ) ; securityManager . setRealm ( myRealm ) ; return securityManager ; } @ Bean @ DependsOn ( \"<STR_LIT>\" ) public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator ( ) { DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator ( ) ; defaultAdvisorAutoProxyCreator . setProxyTargetClass ( true ) ; defaultAdvisorAutoProxyCreator . setUsePrefix ( true ) ;", "output": "return defaultAdvisorAutoProxyCreator ; } @ Bean public static LifecycleBeanPostProcessor lifecycleBeanPostProcessor ( ) { return new LifecycleBeanPostProcessor ( ) ; } @ Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor ( DefaultWebSecurityManager securityManager ) { AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor ( ) ; advisor . setSecurityManager ( securityManager ) ; return advisor ; } public RedisCacheManager redisCacheManager ( ) { log . info ( \"<STR_LIT>\" ) ; RedisCacheManager redisCacheManager = new RedisCacheManager ( ) ; redisCacheManager . setRedisManager ( redisManager ( ) ) ; redisCacheManager . setPrincipalIdFieldName ( \"<STR_LIT>\" ) ; redisCacheManager . setExpire ( Integer . MAX_VALUE ) ; return redisCacheManager ; } @ Bean public RedisManager redisManager ( ) { log . info ( \"<STR_LIT>\" + redisHost + \"<STR_LIT>\" + redisPort ) ; RedisManager redisManager = new RedisManager ( ) ; redisManager . setHost ( redisHost + \"<STR_LIT>\" + redisPort ) ; redisManager . setDatabase ( database ) ; redisManager . setTimeout ( <NUM_LIT> ) ; if ( ! StringUtils . isEmpty ( redisPass ) ) { redisManager . setPassword ( redisPass ) ; } return redisManager ; } }"}, {"input": "package com . oddfar . campus . common . utils . spring ; import lombok . extern . slf4j . Slf4j ; import org . springframework . aop . framework . AdvisedSupport ; import org . springframework . aop . framework . AopProxy ; import org . springframework . aop . support . AopUtils ; import java . lang . reflect . Field ; @ Slf4j public class AopTargetUtils { public static Object getTarget ( Object proxy ) { if ( ! AopUtils . isAopProxy ( proxy ) ) { return proxy ; } try {", "output": "if ( AopUtils . isJdkDynamicProxy ( proxy ) ) { return getJdkDynamicProxyTargetObject ( proxy ) ; } else { return getCglibProxyTargetObject ( proxy ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; return null ; } } private static Object getCglibProxyTargetObject ( Object proxy ) throws Exception { Field h = proxy . getClass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ; h . setAccessible ( true ) ; Object dynamicAdvisedInterceptor = h . get ( proxy ) ; Field advised = dynamicAdvisedInterceptor . getClass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ; advised . setAccessible ( true ) ; return ( ( AdvisedSupport ) advised . get ( dynamicAdvisedInterceptor ) ) . getTargetSource ( ) . getTarget ( ) ; } private static Object getJdkDynamicProxyTargetObject ( Object proxy ) throws Exception { Field h = proxy . getClass ( ) . getSuperclass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ; h . setAccessible ( true ) ; AopProxy aopProxy = ( AopProxy ) h . get ( proxy ) ; Field advised = aopProxy . getClass ( ) . getDeclaredField ( \"<STR_LIT>\" ) ; advised . setAccessible ( true ) ; return ( ( AdvisedSupport ) advised . get ( aopProxy ) ) . getTargetSource ( ) . getTarget ( ) ; } }"}, {"input": "package me . zhengjie . service . impl ; import cn . hutool . extra . mail . Mail ; import cn . hutool . extra . mail . MailAccount ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . EmailConfig ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . EmailConfigMapper ; import me . zhengjie . service . EmailService ; import me . zhengjie . utils . EncryptUtils ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CachePut ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class EmailServiceImpl extends ServiceImpl < EmailConfigMapper , EmailConfig > implements EmailService { @ Override @ CachePut ( key = \"<STR_LIT>\" ) @ Transactional ( rollbackFor = Exception . class ) public EmailConfig config ( EmailConfig emailConfig , EmailConfig old ) throws Exception { emailConfig . setId ( <NUM_LIT> ) ; if ( ! emailConfig . getPass ( ) . equals ( old . getPass ( ) ) ) { emailConfig . setPass ( EncryptUtils . desEncrypt ( emailConfig . getPass ( ) ) ) ; } saveOrUpdate ( emailConfig ) ; return emailConfig ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public EmailConfig find ( ) { EmailConfig emailConfig = getById ( <NUM_LIT> ) ; return emailConfig == null ? new EmailConfig ( ) : emailConfig ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void send ( EmailVo emailVo , EmailConfig emailConfig ) { if ( emailConfig . getId ( ) == null ) {", "output": "throw new BadRequestException ( \"<STR_LIT>\" ) ; } MailAccount account = new MailAccount ( ) ; String user = emailConfig . getFromUser ( ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; account . setUser ( user ) ; account . setHost ( emailConfig . getHost ( ) ) ; account . setPort ( Integer . parseInt ( emailConfig . getPort ( ) ) ) ; account . setAuth ( true ) ; try { account . setPass ( EncryptUtils . desDecrypt ( emailConfig . getPass ( ) ) ) ; } catch ( Exception e ) { throw new BadRequestException ( e . getMessage ( ) ) ; } account . setFrom ( emailConfig . getUser ( ) + \"<STR_LIT>\" + emailConfig . getFromUser ( ) + \"<STR_LIT>\" ) ; account . setSslEnable ( true ) ; account . setStarttlsEnable ( true ) ; account . setSslProtocols ( \"<STR_LIT>\" ) ; String content = emailVo . getContent ( ) ; try { int size = emailVo . getTos ( ) . size ( ) ; Mail . create ( account ) . setTos ( emailVo . getTos ( ) . toArray ( new String [ size ] ) ) . setTitle ( emailVo . getSubject ( ) ) . setContent ( content ) . setHtml ( true ) . setUseGlobalSession ( false ) . send ( ) ; } catch ( Exception e ) { throw new BadRequestException ( e . getMessage ( ) ) ; } } }"}, {"input": "package com . oddfar . campus . common . domain ; import lombok . Data ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; @ Data public final class PageResult < T > implements Serializable { private List < T > rows ; private long total ; public PageResult ( ) { } public PageResult ( List < T > rows , long total ) { this . rows = rows ; this . total = total ; } public PageResult ( int total ) { this . rows = new ArrayList < > ( ) ; this . total = total ; } public static < T > PageResult < T > empty ( ) { return new PageResult < > ( <NUM_LIT> ) ;", "output": "} public static < T > PageResult < T > empty ( int total ) { return new PageResult < > ( total ) ; } }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . springframework . stereotype . Component ; import cn . hutool . core . date . DateUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import java . util . Date ; @ Component public class DateFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return Date . class ;", "output": "} @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String format ( Date date ) { return format ( date , \"<STR_LIT>\" ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String format ( Date date , String pattern ) { return DateUtil . format ( date , pattern ) ; } }"}, {"input": "package ginyi . framework . security . handle ; import com . alibaba . fastjson2 . JSON ; import ginyi . common . result . CommonResult ; import ginyi . common . result . StateCode ; import ginyi . common . utils . Constants ; import ginyi . common . utils . ServletUtils ; import ginyi . common . utils . StringUtils ; import ginyi . framework . security . manager . AsyncManager ; import ginyi . framework . security . manager . factory . AsyncFactory ; import ginyi . system . domain . LoginUser ; import ginyi . system . service . ITokenService ; import org . springframework . context . annotation . Configuration ; import org . springframework . security . core . Authentication ; import org . springframework . security . web . authentication . logout . LogoutSuccessHandler ; import javax . annotation . Resource ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Configuration public class LogoutSuccessHandlerImpl implements LogoutSuccessHandler { @ Resource private ITokenService tokenService ; @ Override public void onLogoutSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) throws IOException , ServletException { LoginUser loginUser = tokenService . getLoginUser ( request ) ; if ( StringUtils . isNull ( loginUser ) ) { ServletUtils . renderString ( response , JSON . toJSONString ( CommonResult . error ( StateCode . ERROR_TIMEOUT_TOKEN ) ) ) ; } String userName = loginUser . getUsername ( ) ; tokenService . delLoginUser ( loginUser . getToken ( ) ) ; AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( userName , Constants . LOGOUT , \"<STR_LIT>\" ) ) ;", "output": "ServletUtils . renderString ( response , JSON . toJSONString ( CommonResult . success ( ) ) ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class CountRecentMsgsVO { private String type ; private Long value ; private String category ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . security . properties ; import cn . hutool . extra . spring . SpringUtil ; import com . oddfar . campus . common . annotation . Anonymous ; import org . apache . commons . lang3 . RegExUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . stereotype . Component ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . mvc . method . RequestMappingInfo ; import org . springframework . web . servlet . mvc . method . annotation . RequestMappingHandlerMapping ; import java . util . * ; import java . util . regex . Pattern ; @ Component public class PermitAllUrlProperties implements InitializingBean { private static final Pattern PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; private List < String > urls = new ArrayList < > ( ) ; public String ASTERISK = \"<STR_LIT>\" ; @ Override public void afterPropertiesSet ( ) { RequestMappingHandlerMapping mapping = SpringUtil . getBean ( \"<STR_LIT>\" , RequestMappingHandlerMapping . class ) ; Map < RequestMappingInfo , HandlerMethod > map = mapping . getHandlerMethods ( ) ; map . keySet ( ) . forEach ( info -> { HandlerMethod handlerMethod = map . get ( info ) ; Anonymous method = AnnotationUtils . findAnnotation ( handlerMethod . getMethod ( ) , Anonymous . class ) ; Optional . ofNullable ( method ) . ifPresent ( anonymous -> info . getPatternsCondition ( ) . getPatterns ( ) . forEach ( url -> urls . add ( RegExUtils . replaceAll ( url , PATTERN , ASTERISK ) ) ) ) ; Anonymous controller = AnnotationUtils . findAnnotation ( handlerMethod . getBeanType ( ) , Anonymous . class ) ; Optional . ofNullable ( controller ) . ifPresent ( anonymous -> info . getPatternsCondition ( ) . getPatterns ( ) . forEach ( url -> urls . add ( RegExUtils . replaceAll ( url , PATTERN , ASTERISK ) ) ) ) ; } ) ;", "output": "} public List < String > getUrls ( ) { return urls ; } public void setUrls ( List < String > urls ) { this . urls = urls ; } }"}, {"input": "package com . oddfar . campus . framework . service ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysOperLogEntity ; import java . util . List ; public interface SysOperLogService { public void insertOperlog ( SysOperLogEntity operLog ) ; PageResult < SysOperLogEntity > selectOperLogPage ( SysOperLogEntity operLog ) ; public int deleteOperLogByIds ( Long [ ] operIds ) ; public SysOperLogEntity selectOperLogById ( Long operId ) ; public void cleanOperLog ( ) ; List < SysOperLogEntity > selectOperLogList ( SysOperLogEntity operLog ) ;", "output": "}"}, {"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import org . springframework . web . multipart . MultipartFile ; import java . io . Serializable ; @ Data public class FileCreateModel implements Serializable { private Integer type ; private Long id ; private String source ; private String target ; private String action ; private MultipartFile upload ; private String upload_fullpath ;", "output": "}"}, {"input": "package top . kangert . kspider . driver ; import org . openqa . selenium . WebDriver ; import org . openqa . selenium . firefox . FirefoxOptions ; import org . openqa . selenium . firefox . FirefoxProfile ; import org . openqa . selenium . remote . Browser ; import org . openqa . selenium . remote . RemoteWebDriver ; import org . springframework . stereotype . Component ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . util . StrUtil ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . model . SpiderNode ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Arrays ; @ Component public class FireFoxDriverProvider implements DriverProvider { @ Override public String support ( ) { return Browser . FIREFOX . browserName ( ) ; } @ Override public WebDriver getWebDriver ( SpiderNode node , String proxyStr ) throws MalformedURLException { FirefoxOptions options = new FirefoxOptions ( ) ; FirefoxProfile profile = new FirefoxProfile ( ) ; if ( StrUtil . isNotBlank ( proxyStr ) ) { String [ ] hp = proxyStr . split ( \"<STR_LIT>\" ) ; profile . setPreference ( \"<STR_LIT>\" , <NUM_LIT> ) ; profile . setPreference ( \"<STR_LIT>\" , hp [ <NUM_LIT> ] ) ; profile . setPreference ( \"<STR_LIT>\" , Convert . toInt ( hp [ <NUM_LIT> ] , <NUM_LIT> ) ) ; } String userAgent = node . getJsonProperty ( USER_AGENT ) ; if ( StrUtil . isNotBlank ( userAgent ) ) { profile . setPreference ( \"<STR_LIT>\" , userAgent ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( HEADLESS ) ) ) { options . setHeadless ( true ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( IMAGE_DISABLED ) ) ) { profile . setPreference ( \"<STR_LIT>\" , <NUM_LIT> ) ; } String windowSize = node . getJsonProperty ( WINDOW_SIZE ) ; if ( StrUtil . isNotBlank ( windowSize ) ) { options . addArguments ( \"<STR_LIT>\" + windowSize ) ; } String arguments = node . getJsonProperty ( ARGUMENTS ) ; if ( StrUtil . isNotBlank ( arguments ) ) {", "output": "options . addArguments ( Arrays . asList ( arguments . split ( \"<STR_LIT>\" ) ) ) ; } String preferences = node . getJsonProperty ( \"<STR_LIT>\" ) ; if ( StrUtil . isNotBlank ( preferences ) ) { Arrays . asList ( preferences . split ( \"<STR_LIT>\" ) ) . forEach ( preference -> { int index = preference . indexOf ( \"<STR_LIT>\" ) ; if ( index > - <NUM_LIT> && preference . length ( ) > index + <NUM_LIT> ) { String key = preference . substring ( <NUM_LIT> , index ) ; String value = preference . substring ( index + <NUM_LIT> ) ; if ( StrUtil . isNotBlank ( value ) ) { if ( \"<STR_LIT>\" . equalsIgnoreCase ( value ) || \"<STR_LIT>\" . equalsIgnoreCase ( value ) ) { profile . setPreference ( key , \"<STR_LIT>\" . equalsIgnoreCase ( value ) ) ; } else if ( \"<STR_LIT>\" . equals ( value ) || Convert . toInt ( value , <NUM_LIT> ) != <NUM_LIT> ) { profile . setPreference ( key , Convert . toInt ( value , <NUM_LIT> ) ) ; } else { profile . setPreference ( key , value ) ; } } } } ) ; } options . setProfile ( profile ) ; String remoteWebdriverUrl = node . getJsonProperty ( REMOTE_WEBDRIVER_URL , DEFAULT_REMOTE_WEBDRIVER_URL ) ; WebDriver webDriver = new RemoteWebDriver ( new URL ( remoteWebdriverUrl ) , options ) ; if ( Constants . YES . equals ( node . getJsonProperty ( MAXIMIZED ) ) ) { webDriver . manage ( ) . window ( ) . maximize ( ) ; } return webDriver ; } }"}, {"input": "package me . zhengjie . service . impl ; import cn . hutool . core . lang . Dict ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . SysLog ; import me . zhengjie . mapper . SysLogMapper ; import me . zhengjie . service . SysLogService ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import me . zhengjie . utils . * ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . reflect . MethodSignature ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . lang . reflect . Method ; import java . lang . reflect . Parameter ; import java . util . * ; @ Service @ RequiredArgsConstructor public class SysLogServiceImpl extends ServiceImpl < SysLogMapper , SysLog > implements SysLogService { private final SysLogMapper sysLogMapper ; @ Override public PageResult < SysLog > queryAll ( SysLogQueryCriteria criteria , Page < SysLog > page ) { return PageUtil . toPage ( sysLogMapper . queryAll ( criteria , page ) ) ; } @ Override public List < SysLog > queryAll ( SysLogQueryCriteria criteria ) { return sysLogMapper . queryAll ( criteria ) ; }", "output": "@ Override public PageResult < SysLog > queryAllByUser ( SysLogQueryCriteria criteria , Page < SysLog > page ) { return PageUtil . toPage ( sysLogMapper . queryAllByUser ( criteria , page ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void save ( String username , String browser , String ip , ProceedingJoinPoint joinPoint , SysLog sysLog ) { if ( sysLog == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } MethodSignature signature = ( MethodSignature ) joinPoint . getSignature ( ) ; Method method = signature . getMethod ( ) ; me . zhengjie . annotation . Log aopLog = method . getAnnotation ( me . zhengjie . annotation . Log . class ) ; String methodName = joinPoint . getTarget ( ) . getClass ( ) . getName ( ) + \"<STR_LIT>\" + signature . getName ( ) + \"<STR_LIT>\" ; sysLog . setDescription ( aopLog . value ( ) ) ; sysLog . setRequestIp ( ip ) ; sysLog . setAddress ( StringUtils . getCityInfo ( sysLog . getRequestIp ( ) ) ) ; sysLog . setMethod ( methodName ) ; sysLog . setUsername ( username ) ; sysLog . setParams ( getParameter ( method , joinPoint . getArgs ( ) ) ) ; if ( signature . getName ( ) . equals ( \"<STR_LIT>\" ) && StringUtils . isNotEmpty ( sysLog . getParams ( ) ) ) { JSONObject obj = JSON . parseObject ( sysLog . getParams ( ) ) ; sysLog . setUsername ( obj . getString ( \"<STR_LIT>\" ) ) ; sysLog . setParams ( JSON . toJSONString ( Dict . create ( ) . set ( \"<STR_LIT>\" , sysLog . getUsername ( ) ) ) ) ; } sysLog . setBrowser ( browser ) ; save ( sysLog ) ; } private String getParameter ( Method method , Object [ ] args ) { List < Object > argList = new ArrayList < > ( ) ; Parameter [ ] parameters = method . getParameters ( ) ; for ( int i = <NUM_LIT> ; i < parameters . length ; i ++ ) { if ( args [ i ] instanceof MultipartFile ) { continue ; } RequestBody requestBody = parameters [ i ] . getAnnotation ( RequestBody . class ) ; if ( requestBody != null ) { argList . add ( args [ i ] ) ; } RequestParam requestParam = parameters [ i ] . getAnnotation ( RequestParam . class ) ; if ( requestParam != null ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; String key = parameters [ i ] . getName ( ) ; if ( ! StringUtils . isEmpty ( requestParam . value ( ) ) ) { key = requestParam . value ( ) ; } map . put ( key , args [ i ] ) ; argList . add ( map ) ; } } if ( argList . isEmpty ( ) ) { return \"<STR_LIT>\" ; } return argList . size ( ) == <NUM_LIT> ? JSON . toJSONString ( argList . get ( <NUM_LIT> ) ) : JSON . toJSONString ( argList ) ; } @ Override public Object findByErrDetail ( Long id ) { String details = sysLogMapper . getExceptionDetails ( id ) ; return Dict . create ( ) . set ( \"<STR_LIT>\" , details ) ; } @ Override public void download ( List < SysLog > sysLogs , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( SysLog sysLog : sysLogs ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , sysLog . getUsername ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getRequestIp ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getAddress ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getDescription ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getBrowser ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getTime ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getExceptionDetail ( ) ) ; map . put ( \"<STR_LIT>\" , sysLog . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delAllByError ( ) { sysLogMapper . deleteByLevel ( \"<STR_LIT>\" ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delAllByInfo ( ) { sysLogMapper . deleteByLevel ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . yf . system . modules . dict . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . dict . dto . SysDicDTO ; import com . yf . system . modules . dict . entity . SysDic ; import java . util . List ; public interface SysDicService extends IService < SysDic > { IPage < SysDicDTO > paging ( PagingReqDTO < SysDicDTO > reqDTO ) ; void save ( SysDicDTO reqDTO ) ;", "output": "void delete ( List < String > ids ) ; }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) public class BludeUser extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; private String code ; private Integer userType ; private String account ; private String password ; private String name ; private String realName ; private String avatar ; private String email ; private String phone ; private Date birthday ; private Integer sex ; private String roleId ; private String deptId ; private String postId ;", "output": "}"}, {"input": "package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . * ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; @ Getter @ Setter @ NoArgsConstructor @ TableName ( \"<STR_LIT>\" ) public class LocalStorage extends BaseEntity implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String realName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String suffix ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String size ; public LocalStorage ( String realName , String name , String suffix , String path , String type , String size ) { this . realName = realName ; this . name = name ; this . suffix = suffix ; this . path = path ; this . type = type ;", "output": "this . size = size ; } public void copy ( LocalStorage source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } }"}, {"input": "package com . youlai . system . service . impl . oss ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . io . FileUtil ; import cn . hutool . core . lang . Assert ; import cn . hutool . core . util . IdUtil ; import com . aliyun . oss . OSS ; import com . aliyun . oss . OSSClientBuilder ; import com . aliyun . oss . model . ObjectMetadata ; import com . aliyun . oss . model . PutObjectRequest ; import com . youlai . system . model . dto . FileInfo ; import com . youlai . system . service . OssService ; import jakarta . annotation . PostConstruct ; import lombok . Data ; import lombok . RequiredArgsConstructor ; import lombok . SneakyThrows ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; import org . springframework . web . multipart . MultipartFile ; import java . io . InputStream ; import java . time . LocalDateTime ; @ Component @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" ) @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) @ RequiredArgsConstructor @ Data public class AliyunOssService implements OssService { private String endpoint ; private String accessKeyId ; private String accessKeySecret ; private String bucketName ; private OSS aliyunOssClient ; @ PostConstruct public void init ( ) { aliyunOssClient = new OSSClientBuilder ( ) . build ( endpoint , accessKeyId , accessKeySecret ) ; } @ Override @ SneakyThrows public FileInfo uploadFile ( MultipartFile file ) { String suffix = FileUtil . getSuffix ( file . getOriginalFilename ( ) ) ;", "output": "String uuid = IdUtil . simpleUUID ( ) ; String fileName = DateUtil . format ( LocalDateTime . now ( ) , \"<STR_LIT>\" ) + \"<STR_LIT>\" + uuid + \"<STR_LIT>\" + suffix ; try ( InputStream inputStream = file . getInputStream ( ) ) { ObjectMetadata metadata = new ObjectMetadata ( ) ; metadata . setContentType ( file . getContentType ( ) ) ; PutObjectRequest putObjectRequest = new PutObjectRequest ( bucketName , fileName , inputStream , metadata ) ; aliyunOssClient . putObject ( putObjectRequest ) ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } String fileUrl = \"<STR_LIT>\" + bucketName + \"<STR_LIT>\" + endpoint + \"<STR_LIT>\" + fileName ; FileInfo fileInfo = new FileInfo ( ) ; fileInfo . setName ( fileName ) ; fileInfo . setUrl ( fileUrl ) ; return fileInfo ; } @ Override public boolean deleteFile ( String filePath ) { Assert . notBlank ( filePath , \"<STR_LIT>\" ) ; String fileHost = \"<STR_LIT>\" + bucketName + \"<STR_LIT>\" + endpoint ; String fileName = filePath . substring ( fileHost . length ( ) + <NUM_LIT> ) ; aliyunOssClient . deleteObject ( bucketName , fileName ) ; return true ; } }"}, {"input": "package org . example . ddduser . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class DataObjectHandler implements MetaObjectHandler { @ Autowired private SecurityRepository securityRepository ; @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . findLoginUserQuietly ( ) ) ; } @ Override public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ; this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . findLoginUserQuietly ( ) ) ;", "output": "} }"}, {"input": "package com . oddfar . campus . common . utils ; import cn . hutool . core . text . StrFormatter ; import com . oddfar . campus . common . constant . Constants ; import org . springframework . util . AntPathMatcher ; import java . util . * ; public class StringUtils extends org . apache . commons . lang3 . StringUtils { private static final String NULLSTR = \"<STR_LIT>\" ; private static final char SEPARATOR = '<STR_LIT>' ; public static < T > T nvl ( T value , T defaultValue ) { return value != null ? value : defaultValue ; } public static boolean isEmpty ( Collection < ? > coll ) { return isNull ( coll ) || coll . isEmpty ( ) ; } public static boolean isNotEmpty ( Collection < ? > coll ) { return ! isEmpty ( coll ) ; } public static boolean isEmpty ( Object [ ] objects ) { return isNull ( objects ) || ( objects . length == <NUM_LIT> ) ; } public static boolean isNotEmpty ( Object [ ] objects ) { return ! isEmpty ( objects ) ; } public static boolean isEmpty ( Map < ? , ? > map ) { return isNull ( map ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( Map < ? , ? > map ) { return ! isEmpty ( map ) ; } public static boolean isEmpty ( String str ) { return isNull ( str ) || NULLSTR . equals ( str . trim ( ) ) ; } public static boolean isNotEmpty ( String str ) { return ! isEmpty ( str ) ; } public static boolean isNull ( Object object ) { return object == null ; } public static boolean isNotNull ( Object object ) { return ! isNull ( object ) ; } public static boolean isArray ( Object object ) { return isNotNull ( object ) && object . getClass ( ) . isArray ( ) ; } public static String trim ( String str ) { return ( str == null ? \"<STR_LIT>\" : str . trim ( ) ) ; } public static String substring ( final String str , int start ) { if ( str == null ) { return NULLSTR ; } if ( start < <NUM_LIT> ) { start = str . length ( ) + start ; } if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } if ( start > str . length ( ) ) { return NULLSTR ; } return str . substring ( start ) ; } public static String substring ( final String str , int start , int end ) { if ( str == null ) { return NULLSTR ; } if ( end < <NUM_LIT> ) { end = str . length ( ) + end ; } if ( start < <NUM_LIT> ) { start = str . length ( ) + start ; } if ( end > str . length ( ) ) { end = str . length ( ) ; } if ( start > end ) { return NULLSTR ; } if ( start < <NUM_LIT> ) { start = <NUM_LIT> ; } if ( end < <NUM_LIT> ) { end = <NUM_LIT> ; } return str . substring ( start , end ) ; } public static String format ( String template , Object ... params ) { if ( isEmpty ( params ) || isEmpty ( template ) ) { return template ; } return StrFormatter . format ( template , params ) ; } public static boolean ishttp ( String link ) { return StringUtils . startsWithAny ( link , Constants . HTTP , Constants . HTTPS ) ; } public static final Set < String > str2Set ( String str , String sep ) { return new HashSet < String > ( str2List ( str , sep , true , false ) ) ; } public static final List < String > str2List ( String str , String sep , boolean filterBlank , boolean trim ) { List < String > list = new ArrayList < String > ( ) ; if ( StringUtils . isEmpty ( str ) ) { return list ; } if ( filterBlank && StringUtils . isBlank ( str ) ) { return list ; } String [ ] split = str . split ( sep ) ; for ( String string : split ) { if ( filterBlank && StringUtils . isBlank ( string ) ) { continue ; } if ( trim ) { string = string . trim ( ) ; } list . add ( string ) ; } return list ; } public static boolean containsAny ( Collection < String > collection , String ... array ) { if ( isEmpty ( collection ) || isEmpty ( array ) ) { return false ; } else { for ( String str : array ) { if ( collection . contains ( str ) ) { return true ; } } return false ; } } public static boolean containsAnyIgnoreCase ( CharSequence cs , CharSequence ... searchCharSequences ) { if ( isEmpty ( cs ) || isEmpty ( searchCharSequences ) ) { return false ; } for ( CharSequence testStr : searchCharSequences ) { if ( containsIgnoreCase ( cs , testStr ) ) { return true ; } } return false ; } public static String toUnderScoreCase ( String str ) { if ( str == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; boolean preCharIsUpperCase = true ; boolean curreCharIsUpperCase = true ; boolean nexteCharIsUpperCase = true ; for ( int i = <NUM_LIT> ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( i > <NUM_LIT> ) { preCharIsUpperCase = Character . isUpperCase ( str . charAt ( i - <NUM_LIT> ) ) ; } else { preCharIsUpperCase = false ; } curreCharIsUpperCase = Character . isUpperCase ( c ) ; if ( i < ( str . length ( ) - <NUM_LIT> ) ) { nexteCharIsUpperCase = Character . isUpperCase ( str . charAt ( i + <NUM_LIT> ) ) ; }", "output": "if ( preCharIsUpperCase && curreCharIsUpperCase && ! nexteCharIsUpperCase ) { sb . append ( SEPARATOR ) ; } else if ( ( i != <NUM_LIT> && ! preCharIsUpperCase ) && curreCharIsUpperCase ) { sb . append ( SEPARATOR ) ; } sb . append ( Character . toLowerCase ( c ) ) ; } return sb . toString ( ) ; } public static boolean inStringIgnoreCase ( String str , String ... strs ) { if ( str != null && strs != null ) { for ( String s : strs ) { if ( str . equalsIgnoreCase ( trim ( s ) ) ) { return true ; } } } return false ; } public static String convertToCamelCase ( String name ) { StringBuilder result = new StringBuilder ( ) ; if ( name == null || name . isEmpty ( ) ) { return \"<STR_LIT>\" ; } else if ( ! name . contains ( \"<STR_LIT>\" ) ) { return name . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + name . substring ( <NUM_LIT> ) ; } String [ ] camels = name . split ( \"<STR_LIT>\" ) ; for ( String camel : camels ) { if ( camel . isEmpty ( ) ) { continue ; } result . append ( camel . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) ) ; result . append ( camel . substring ( <NUM_LIT> ) . toLowerCase ( ) ) ; } return result . toString ( ) ; } public static String toCamelCase ( String s ) { if ( s == null ) { return null ; } s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( s . length ( ) ) ; boolean upperCase = false ; for ( int i = <NUM_LIT> ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == SEPARATOR ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( c ) ) ; upperCase = false ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } public static boolean matches ( String str , List < String > strs ) { if ( isEmpty ( str ) || isEmpty ( strs ) ) { return false ; } for ( String pattern : strs ) { if ( isMatch ( pattern , str ) ) { return true ; } } return false ; } public static boolean isMatch ( String pattern , String url ) { AntPathMatcher matcher = new AntPathMatcher ( ) ; return matcher . match ( pattern , url ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T cast ( Object obj ) { return ( T ) obj ; } public static final String padl ( final Number num , final int size ) { return padl ( num . toString ( ) , size , '<STR_LIT>' ) ; } public static final String padl ( final String s , final int size , final char c ) { final StringBuilder sb = new StringBuilder ( size ) ; if ( s != null ) { final int len = s . length ( ) ; if ( s . length ( ) <= size ) { for ( int i = size - len ; i > <NUM_LIT> ; i -- ) { sb . append ( c ) ; } sb . append ( s ) ; } else { return s . substring ( len - size , len ) ; } } else { for ( int i = size ; i > <NUM_LIT> ; i -- ) { sb . append ( c ) ; } } return sb . toString ( ) ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class UserExerciseRecord implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer repoId ; private Integer totalCount ; private Integer exerciseCount ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getRepoId ( ) { return repoId ; } public void setRepoId ( Integer repoId ) { this . repoId = repoId ; } public Integer getTotalCount ( ) { return totalCount ; } public void setTotalCount ( Integer totalCount ) { this . totalCount = totalCount ; } public Integer getExerciseCount ( ) { return exerciseCount ; } public void setExerciseCount ( Integer exerciseCount ) { this . exerciseCount = exerciseCount ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; }", "output": "@ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + repoId + \"<STR_LIT>\" + totalCount + \"<STR_LIT>\" + exerciseCount + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" ; } }"}, {"input": "package me . zhengjie . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . mapper . GenConfigMapper ; import me . zhengjie . service . GenConfigService ; import org . springframework . stereotype . Service ; import java . io . File ; @ Service @ RequiredArgsConstructor @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class GenConfigServiceImpl extends ServiceImpl < GenConfigMapper , GenConfig > implements GenConfigService { private final GenConfigMapper genConfigMapper ; @ Override public GenConfig find ( String tableName ) { GenConfig genConfig = genConfigMapper . findByTableName ( tableName ) ; if ( genConfig == null ) { return new GenConfig ( tableName ) ; } return genConfig ; } @ Override public GenConfig update ( String tableName , GenConfig genConfig ) { String separator = File . separator ; String [ ] paths ; String symbol = \"<STR_LIT>\" ; if ( symbol . equals ( separator ) ) { paths = genConfig . getPath ( ) . split ( \"<STR_LIT>\" ) ; } else { paths = genConfig . getPath ( ) . split ( File . separator ) ; } StringBuilder api = new StringBuilder ( ) ; for ( String path : paths ) { api . append ( path ) ; api . append ( separator ) ; if ( \"<STR_LIT>\" . equals ( path ) ) { api . append ( \"<STR_LIT>\" ) ; break ; } } genConfig . setApiPath ( api . toString ( ) ) ; saveOrUpdate ( genConfig ) ;", "output": "return genConfig ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . io ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; public class URLResourceUtil { private static final String CLASSPATH_PREFIX = \"<STR_LIT>\" ; private static final String URL_PROTOCOL_FILE = \"<STR_LIT>\" ; public static File asFile ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return getFileByURL ( ResourceUtil . asUrl ( resourceName ) ) ; } try { return getFileByURL ( new URL ( generalPath ) ) ; } catch ( MalformedURLException ex ) { return new File ( generalPath ) ; } } public static InputStream asStream ( String generalPath ) throws IOException { if ( StringUtils . startsWith ( generalPath , CLASSPATH_PREFIX ) ) { String resourceName = StringUtils . substringAfter ( generalPath , CLASSPATH_PREFIX ) ; return ResourceUtil . asStream ( resourceName ) ; } try { return FileUtil . asInputStream ( getFileByURL ( new URL ( generalPath ) ) ) ; } catch ( MalformedURLException ex ) { return FileUtil . asInputStream ( generalPath ) ; } } private static File getFileByURL ( URL fileUrl ) throws FileNotFoundException { Validate . notNull ( fileUrl , \"<STR_LIT>\" ) ; if ( ! URL_PROTOCOL_FILE . equals ( fileUrl . getProtocol ( ) ) ) {", "output": "throw new FileNotFoundException ( \"<STR_LIT>\" + \"<STR_LIT>\" + fileUrl ) ; } try { return new File ( toURI ( fileUrl . toString ( ) ) . getSchemeSpecificPart ( ) ) ; } catch ( URISyntaxException ex ) { return new File ( fileUrl . getFile ( ) ) ; } } public static URI toURI ( String location ) throws URISyntaxException { return new URI ( StringUtils . replace ( location , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; } }"}, {"input": "package com . youlai . system . model . form ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class GeneratorConfigForm { @ Schema ( description = \"<STR_LIT>\" ) private String tableName ; @ Schema ( description = \"<STR_LIT>\" ) private String entityName ; @ Schema ( description = \"<STR_LIT>\" ) private String packageName ; @ Schema ( description = \"<STR_LIT>\" ) private String moduleName ; @ Schema ( description = \"<STR_LIT>\" ) private String author ; @ Schema ( description = \"<STR_LIT>\" ) private List < FieldConfig > fieldConfigs ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public static class FieldConfig { @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private String type ; @ Schema ( description = \"<STR_LIT>\" ) private String description ; @ Schema ( description = \"<STR_LIT>\" ) private Boolean showInList ; @ Schema ( description = \"<STR_LIT>\" ) private Boolean showInForm ; @ Schema ( description = \"<STR_LIT>\" ) private Boolean showInQuery ; @ Schema ( description = \"<STR_LIT>\" ) private String formType ; @ Schema ( description = \"<STR_LIT>\" ) private String queryMethod ; }", "output": "}"}, {"input": "package top . kangert . kspider . executor . node ; import cn . hutool . core . lang . TypeReference ; import cn . hutool . json . JSONUtil ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . driver . DriverProvider ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . io . SeleniumResponse ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . model . ConfigItem . ComponentType ; import top . kangert . kspider . model . ConfigItem . DataType ; import top . kangert . kspider . model . ConfigItem . SelectItem ; import top . kangert . kspider . support . ExpressionEngine ; import top . kangert . kspider . util . SeleniumResponseHolder ; import top . kangert . kspider . websocket . WebSocketEvent ; import lombok . extern . slf4j . Slf4j ; import org . openqa . selenium . Cookie ; import org . openqa . selenium . WebDriver ; import org . openqa . selenium . remote . RemoteWebDriver ; import org . springframework . stereotype . Component ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . exceptions . ExceptionUtil ; import cn . hutool . core . util . StrUtil ; import javax . annotation . PostConstruct ; import java . net . URL ; import java . time . Duration ; import java . util . ArrayList ; import java . util . Calendar ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Slf4j @ Component public class SeleniumExecutor implements NodeExecutor { public static final String NODE_VARIABLE_NAME = \"<STR_LIT>\" ; public static final String DRIVER_TYPE = \"<STR_LIT>\" ; private static final String REQUEST_SESSION = \"<STR_LIT>\" ; public static final String URL = \"<STR_LIT>\" ; public static final String PAGE_LOAD_TIMEOUT = \"<STR_LIT>\" ; public static final String IMPLICITLY_WAIT_TIMEOUT = \"<STR_LIT>\" ; public static final String PROXY = \"<STR_LIT>\" ; public static final String COOKIE_AUTO_SET = \"<STR_LIT>\" ; private final List < DriverProvider > driverProviders ; private Map < String , DriverProvider > providerMap ; private ExpressionEngine expressionEngine ; public SeleniumExecutor ( List < DriverProvider > driverProviders , ExpressionEngine expressionEngine ) { this . driverProviders = driverProviders ; this . expressionEngine = expressionEngine ; } @ PostConstruct private void init ( ) { providerMap = driverProviders . stream ( ) . filter ( provider -> provider . support ( ) != null ) . collect ( Collectors . toMap ( DriverProvider :: support , value -> value ) ) ; } @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { String proxy = node . getJsonProperty ( PROXY ) ; String driverType = node . getJsonProperty ( DRIVER_TYPE ) ; String nodeVariableName = node . getJsonProperty ( NODE_VARIABLE_NAME , Constants . RESPONSE_VARIABLE ) ; boolean cookieAutoSet = Constants . YES . equals ( node . getJsonProperty ( COOKIE_AUTO_SET ) ) ; List < Map < String , String > > headers = node . getJsonArrayProperty ( REQUEST_SESSION ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , DRIVER_TYPE , driverType ) ; if ( StrUtil . isBlank ( driverType ) || ! providerMap . containsKey ( driverType ) ) { log . error ( \"<STR_LIT>\" , driverType ) ; return ; } if ( StrUtil . isNotBlank ( proxy ) ) { try { proxy = expressionEngine . execute ( proxy , variables ) . toString ( ) ; log . info ( \"<STR_LIT>\" , proxy ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } } Object oldResp = variables . get ( nodeVariableName ) ; if ( oldResp instanceof SeleniumResponse ) { SeleniumResponse oldResponse = ( SeleniumResponse ) oldResp ; oldResponse . quit ( ) ; } WebDriver driver = null ; try { String url = expressionEngine . execute ( node . getJsonProperty ( URL ) , variables ) . toString ( ) ; log . info ( \"<STR_LIT>\" , url ) ; driver = providerMap . get ( driverType ) . getWebDriver ( node , proxy ) ; driver . manage ( ) . timeouts ( ) . pageLoadTimeout ( Duration . ofMillis ( Convert . toInt ( node . getJsonProperty ( PAGE_LOAD_TIMEOUT ) , <NUM_LIT> * <NUM_LIT> ) ) ) ; driver . manage ( ) . timeouts ( ) . implicitlyWait ( Duration . ofMillis ( Convert . toInt ( node . getJsonProperty ( IMPLICITLY_WAIT_TIMEOUT ) , <NUM_LIT> * <NUM_LIT> ) ) ) ; driver . get ( url ) ; Map < String , String > cookieContext = context . getCookieContext ( ) ; if ( cookieAutoSet ) { driver . manage ( ) . deleteAllCookies ( ) ; java . net . URL tempUrl = new URL ( url ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . add ( Calendar . MONTH , <NUM_LIT> ) ; for ( Map . Entry < String , String > item : cookieContext . entrySet ( ) ) { Cookie cookie = new Cookie ( item . getKey ( ) , item . getValue ( ) , tempUrl . getHost ( ) , \"<STR_LIT>\" , calendar . getTime ( ) , false , false ) ; driver . manage ( ) . addCookie ( cookie ) ; } log . debug ( \"<STR_LIT>\" , cookieContext ) ; } String headerKey = null ; String headerValue = null ; Object value = null ; for ( Map < String , String > header : headers ) { String headerName = header . get ( REQUEST_SESSION ) ; if ( StrUtil . isNotBlank ( headerName ) ) { Map < String , String > headerMap = JSONUtil . toBean ( headerName , new TypeReference < Map < String , String > > ( ) { } , false ) ; headerKey = headerMap . get ( \"<STR_LIT>\" ) ; int i = header . size ( ) ; headerValue = headerMap . get ( \"<STR_LIT>\" ) ; value = expressionEngine . execute ( headerValue , variables ) ; ( ( RemoteWebDriver ) driver ) . executeScript ( String . format ( \"<STR_LIT>\" , headerKey , value ) ) ; } } driver . get ( url ) ; SeleniumResponse response = new SeleniumResponse ( driver ) ; SeleniumResponseHolder . add ( context , response ) ; if ( cookieAutoSet ) { Map < String , String > cookies = response . getCookies ( ) ; cookieContext . putAll ( cookies ) ; } variables . put ( nodeVariableName , response ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; if ( driver != null ) { try { driver . quit ( ) ; } catch ( Exception ignored ) { } } ExceptionUtil . wrapAndThrow ( e ) ; } } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { Shape shape = new Shape ( ) ; shape . setIcon ( \"<STR_LIT>\" ) ; shape . setName ( supportType ( ) ) ; shape . setTitle ( \"<STR_LIT>\" ) ; shape . setLabel ( \"<STR_LIT>\" ) ; return shape ; } @ Override public List < ConfigItem > configItems ( ) { List < ConfigItem > configItemList = new ArrayList < > ( ) ; ConfigItem nodeVariableName = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_INPUT , ConfigItem . DataType . STRING , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , null , null ) ; configItemList . add ( nodeVariableName ) ; ConfigItem cookieAutoSet = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_SWITCH , ConfigItem . DataType . BOOLEAN , COOKIE_AUTO_SET , null , true , null , null ) ; configItemList . add ( cookieAutoSet ) ; List < SelectItem > selectItemList = new ArrayList < SelectItem > ( ) ; SelectItem startMaximized = new SelectItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , DataType . STRING ) ; selectItemList . add ( startMaximized ) ; SelectItem headless = new SelectItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , DataType . STRING ) ; selectItemList . add ( headless ) ; ConfigItem extConfig = new ConfigItem ( \"<STR_LIT>\" , ComponentType . CUSTOM_MULT_KEY_VALUE , DataType . LIST_MAP , \"<STR_LIT>\" , \"<STR_LIT>\" , new ArrayList < > ( ) , null , selectItemList ) ; configItemList . add ( extConfig ) ; ConfigItem loopVariableName = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_INPUT , ConfigItem . DataType . STRING , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , null , null ) ; configItemList . add ( loopVariableName ) ; Map < String , Object > loopCountAttrs = new HashMap < > ( ) ; loopCountAttrs . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; ConfigItem loopCount = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_NUMBER_INPUT , ConfigItem . DataType . INT , \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> , loopCountAttrs , null ) ; configItemList . add ( loopCount ) ; ConfigItem pageLoadTimeout = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_INPUT , ConfigItem . DataType . INT , \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> , null , null ) ; configItemList . add ( pageLoadTimeout ) ; ConfigItem implicitlyWaitTimeout = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_INPUT , ConfigItem . DataType . INT , \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> , null , null ) ; configItemList . add ( implicitlyWaitTimeout ) ; List < ConfigItem . SelectItem > driverTypeSelectItem = new ArrayList < > ( ) ; ConfigItem . SelectItem chromeItem = new ConfigItem . SelectItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , ConfigItem . DataType . STRING ) ; ConfigItem . SelectItem firefoxItem = new ConfigItem . SelectItem ( \"<STR_LIT>\" , \"<STR_LIT>\" , ConfigItem . DataType . STRING ) ; driverTypeSelectItem . add ( chromeItem ) ;", "output": "driverTypeSelectItem . add ( firefoxItem ) ; ConfigItem driverType = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_SELECT , ConfigItem . DataType . STRING , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , null , driverTypeSelectItem ) ; configItemList . add ( driverType ) ; ConfigItem requestUrl = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_INPUT , ConfigItem . DataType . STRING , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , null , null ) ; configItemList . add ( requestUrl ) ; ConfigItem reheadernameitem = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . CUSTOM_MULT_KEY_VALUE , ConfigItem . DataType . LIST_MAP , SeleniumExecutor . REQUEST_SESSION , \"<STR_LIT>\" , new ArrayList < > ( ) , null , null ) ; configItemList . add ( reheadernameitem ) ; ConfigItem remoteWebdriverUrl = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_INPUT , ConfigItem . DataType . STRING , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , null , null ) ; configItemList . add ( remoteWebdriverUrl ) ; return configItemList ; } }"}, {"input": "package com . oddfar . campus . framework . handler ; import com . fasterxml . jackson . core . JsonGenerator ; import com . fasterxml . jackson . databind . SerializerProvider ; import com . fasterxml . jackson . databind . annotation . JacksonStdImpl ; import com . fasterxml . jackson . databind . ser . std . NumberSerializer ; import java . io . IOException ; @ JacksonStdImpl public class BigNumberSerializer extends NumberSerializer { private static final long MAX_SAFE_INTEGER = <NUM_LIT> ; private static final long MIN_SAFE_INTEGER = - <NUM_LIT> ; public static final BigNumberSerializer INSTANCE = new BigNumberSerializer ( Number . class ) ; public BigNumberSerializer ( Class < ? extends Number > rawType ) { super ( rawType ) ; } @ Override public void serialize ( Number value , JsonGenerator gen , SerializerProvider provider ) throws IOException {", "output": "if ( value . longValue ( ) > MIN_SAFE_INTEGER && value . longValue ( ) < MAX_SAFE_INTEGER ) { super . serialize ( value , gen , provider ) ; } else { gen . writeString ( value . toString ( ) ) ; } } }"}, {"input": "package org . example . ddduser . domain . user . valueobject ; import com . baomidou . mybatisplus . annotation . EnumValue ; public enum Gender { FEMALE ( <NUM_LIT> ) , MALE ( <NUM_LIT> ) , UNKNOWN ( - <NUM_LIT> ) ; @ EnumValue private int value ; Gender ( int value ) {", "output": "this . value = value ; } }"}, {"input": "package cn . org . alan . exam . common . result ; import lombok . Data ; import java . io . Serializable ; @ Data public class Result < T > implements Serializable { private Integer code ; private T data ; private String msg ; public static < T > Result < T > success ( ) { return success ( null ) ; } public static < T > Result < T > success ( String msg , T data ) { Result < T > result = new Result < > ( ) ; result . setCode ( <NUM_LIT> ) ; result . setMsg ( msg ) ; result . setData ( data ) ; return result ; } public static < T > Result < T > success ( String msg ) { Result < T > result = new Result < > ( ) ;", "output": "result . setCode ( <NUM_LIT> ) ; result . setMsg ( msg ) ; result . setData ( null ) ; return result ; } public static < T > Result < T > failed ( String msg ) { return result ( <NUM_LIT> , msg , null ) ; } private static < T > Result < T > result ( Integer code , String msg , T data ) { Result < T > result = new Result < > ( ) ; result . setCode ( code ) ; result . setData ( data ) ; result . setMsg ( msg ) ; return result ; } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import org . apache . ibatis . type . ByteArrayTypeHandler ; @ Data @ TableName ( \"<STR_LIT>\" ) public class ContactHeadImg { @ TableId ( \"<STR_LIT>\" ) private String usrName ; @ TableField ( \"<STR_LIT>\" ) private Integer createTime ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] smallHeadBuf ; @ TableField ( \"<STR_LIT>\" ) private String headImgMd5 ;", "output": "}"}, {"input": "package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . QiniuConfig ; import me . zhengjie . domain . QiniuContent ; import me . zhengjie . domain . vo . QiniuQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; public interface QiniuContentService extends IService < QiniuContent > { PageResult < QiniuContent > queryAll ( QiniuQueryCriteria criteria , Page < Object > page ) ; List < QiniuContent > queryAll ( QiniuQueryCriteria criteria ) ; QiniuContent upload ( MultipartFile file , QiniuConfig qiniuConfig ) ; String download ( QiniuContent content , QiniuConfig config ) ; void delete ( QiniuContent content , QiniuConfig config ) ; void synchronize ( QiniuConfig config ) ; void deleteAll ( Long [ ] ids , QiniuConfig config ) ; void downloadList ( List < QiniuContent > queryAll , HttpServletResponse response ) throws IOException ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . api . mail ; import com . oddfar . campus . framework . api . mail . Impl . MailServiceImpl ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration public class ZyMailAutoConfig { @ Bean @ ConditionalOnMissingBean ( MailSendApi . class ) public MailSendApi mailSenderApi ( ) { return new MailServiceImpl ( ) ; }", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Database extends BaseEntity implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String jdbcUrl ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pwd ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String userName ; public void copy ( Database source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; }", "output": "}"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class DeptQueryCriteria { private List < Long > ids ; private String name ; private Boolean enabled ; private Long pid ; private Boolean pidIsNull ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelSheet { int index ( ) default - <NUM_LIT> ; String name ( ) default \"<STR_LIT>\" ; int dataRowStartIndex ( ) default <NUM_LIT> ; boolean writeHeader ( ) default true ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . jsr166e ; import java . util . Random ; public abstract class Striped64 extends Number { static final class Cell { volatile long p0 , p1 , p2 , p3 , p4 , p5 , p6 ; volatile long value ; volatile long q0 , q1 , q2 , q3 , q4 , q5 , q6 ; Cell ( long x ) { value = x ; } final boolean cas ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , valueOffset , cmp , val ) ; } private static final sun . misc . Unsafe UNSAFE ; private static final long valueOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > ak = Cell . class ; valueOffset = UNSAFE . objectFieldOffset ( ak . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } } static final ThreadLocal < int [ ] > threadHashCode = new ThreadLocal < int [ ] > ( ) ; static final Random rng = new Random ( ) ; static final int NCPU = Runtime . getRuntime ( ) . availableProcessors ( ) ; transient volatile Cell [ ] cells ; transient volatile long base ; transient volatile int busy ; Striped64 ( ) { } final boolean casBase ( long cmp , long val ) { return UNSAFE . compareAndSwapLong ( this , baseOffset , cmp , val ) ; } final boolean casBusy ( ) { return UNSAFE . compareAndSwapInt ( this , busyOffset , <NUM_LIT> , <NUM_LIT> ) ; } abstract long fn ( long currentValue , long newValue ) ; final void retryUpdate ( long x , int [ ] hc , boolean wasUncontended ) { int h ; if ( hc == null ) { threadHashCode . set ( hc = new int [ <NUM_LIT> ] ) ; int r = rng . nextInt ( ) ; h = hc [ <NUM_LIT> ] = ( r == <NUM_LIT> ) ? <NUM_LIT> : r ; } else h = hc [ <NUM_LIT> ] ; boolean collide = false ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > <NUM_LIT> ) { if ( ( a = as [ ( n - <NUM_LIT> ) & h ] ) == null ) { if ( busy == <NUM_LIT> ) { Cell r = new Cell ( x ) ; if ( busy == <NUM_LIT> && casBusy ( ) ) { boolean created = false ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > <NUM_LIT> && rs [ j = ( m - <NUM_LIT> ) & h ] == null ) { rs [ j ] = r ; created = true ; } } finally { busy = <NUM_LIT> ; } if ( created ) break ; continue ; } } collide = false ; } else if ( ! wasUncontended ) wasUncontended = true ; else if ( a . cas ( v = a . value , fn ( v , x ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = false ; else if ( ! collide ) collide = true ; else if ( busy == <NUM_LIT> && casBusy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << <NUM_LIT> ] ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { busy = <NUM_LIT> ; } collide = false ; continue ; } h ^= h << <NUM_LIT> ; h ^= h > > > <NUM_LIT> ; h ^= h << <NUM_LIT> ; hc [ <NUM_LIT> ] = h ; } else if ( busy == <NUM_LIT> && cells == as && casBusy ( ) ) { boolean init = false ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ <NUM_LIT> ] ; rs [ h & <NUM_LIT> ] = new Cell ( x ) ; cells = rs ; init = true ; } } finally { busy = <NUM_LIT> ; } if ( init ) break ; } else if ( casBase ( v = base , fn ( v , x ) ) ) break ; } } final void internalReset ( long initialValue ) { Cell [ ] as = cells ; base = initialValue ; if ( as != null ) { int n = as . length ; for ( int i = <NUM_LIT> ; i < n ; ++ i ) { Cell a = as [ i ] ; if ( a != null ) a . value = initialValue ; } } } private static final sun . misc . Unsafe UNSAFE ; private static final long baseOffset ; private static final long busyOffset ; static { try { UNSAFE = getUnsafe ( ) ; Class < ? > sk = Striped64 . class ; baseOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( \"<STR_LIT>\" ) ) ; busyOffset = UNSAFE . objectFieldOffset ( sk . getDeclaredField ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { throw new Error ( e ) ;", "output": "} } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) return k . cast ( x ) ; } throw new NoSuchFieldError ( \"<STR_LIT>\" ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( \"<STR_LIT>\" , e . getCause ( ) ) ; } } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import org . apache . ibatis . type . ByteArrayTypeHandler ; @ Data @ TableName ( value = \"<STR_LIT>\" , autoResultMap = true ) public class Contact { @ TableId ( value = \"<STR_LIT>\" ) private String userName ; @ TableField ( \"<STR_LIT>\" ) private String alias ; @ TableField ( \"<STR_LIT>\" ) private String encryptUserName ; @ TableField ( \"<STR_LIT>\" ) private Integer delFlag ; @ TableField ( \"<STR_LIT>\" ) private Integer type ; @ TableField ( \"<STR_LIT>\" ) private Integer verifyFlag ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved1 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved2 ; @ TableField ( \"<STR_LIT>\" ) private String reserved3 ; @ TableField ( \"<STR_LIT>\" ) private String reserved4 ; @ TableField ( \"<STR_LIT>\" ) private String remark ; @ TableField ( \"<STR_LIT>\" ) private String nickName ; @ TableField ( \"<STR_LIT>\" ) private String labelIdList ; @ TableField ( \"<STR_LIT>\" ) private String domainList ; @ TableField ( \"<STR_LIT>\" ) private Integer chatRoomType ; @ TableField ( \"<STR_LIT>\" ) private String pyInitial ; @ TableField ( \"<STR_LIT>\" ) private String quanPin ; @ TableField ( \"<STR_LIT>\" ) private String remarkPyInitial ; @ TableField ( \"<STR_LIT>\" ) private String remarkQuanPin ; @ TableField ( \"<STR_LIT>\" ) private String bigHeadImgUrl ; @ TableField ( \"<STR_LIT>\" ) private String smallHeadImgUrl ; @ TableField ( \"<STR_LIT>\" ) private String headImgMd5 ; @ TableField ( \"<STR_LIT>\" ) private Integer chatRoomNotify ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved5 ; @ TableField ( \"<STR_LIT>\" ) private String reserved6 ; @ TableField ( \"<STR_LIT>\" ) private String reserved7 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved8 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved9 ; @ TableField ( \"<STR_LIT>\" ) private String reserved10 ; @ TableField ( \"<STR_LIT>\" ) private String reserved11 ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] extraBuf ;", "output": "}"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . model . dto . LoginDto ; import ginyi . system . domain . model . dto . RegisterDto ; import ginyi . system . domain . model . vo . LoginVo ; public interface ISysLoginService { public LoginVo login ( LoginDto loginDto ) ; public void register ( RegisterDto registerDto ) ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import com . alibaba . excel . annotation . ExcelProperty ; import com . alibaba . excel . annotation . write . style . ColumnWidth ; import com . alibaba . excel . annotation . write . style . ContentStyle ; import com . alibaba . excel . enums . poi . HorizontalAlignmentEnum ; import lombok . Data ; @ Data @ ContentStyle ( horizontalAlignment = HorizontalAlignmentEnum . CENTER ) public class ExportMsgVO { @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String msgSvrId ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String wxId ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private Integer type ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private Integer subType ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private Integer isSender ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String strCreateTime ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String strContent ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class ServerQueryCriteria { private String blurry ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package com . yf . ability . excel ; import cn . hutool . core . exceptions . DependencyException ; import cn . hutool . core . util . ObjectUtil ; import cn . hutool . poi . excel . BigExcelWriter ; import org . apache . poi . xssf . streaming . SXSSFSheet ; public class MyExcelWriter extends BigExcelWriter { public static MyExcelWriter getBigWriter ( ) { try { return new MyExcelWriter ( ) ; } catch ( NoClassDefFoundError var1 ) { throw new DependencyException ( ( Throwable ) ObjectUtil . defaultIfNull ( var1 . getCause ( ) , var1 ) , \"<STR_LIT>\" , new Object [ <NUM_LIT> ] ) ; }", "output": "} @ Override public BigExcelWriter autoSizeColumnAll ( ) { final SXSSFSheet sheet = ( SXSSFSheet ) this . sheet ; sheet . trackAllColumnsForAutoSizing ( ) ; super . autoSizeColumnAll ( ) ; for ( int i = <NUM_LIT> ; i < sheet . getRow ( sheet . getLastRowNum ( ) ) . getPhysicalNumberOfCells ( ) ; i ++ ) { int colWidth = sheet . getColumnWidth ( i ) ; if ( colWidth < <NUM_LIT> * <NUM_LIT> ) { sheet . setColumnWidth ( i , colWidth < <NUM_LIT> ? <NUM_LIT> : colWidth ) ; } else { sheet . setColumnWidth ( i , <NUM_LIT> ) ; } } sheet . untrackAllColumnsForAutoSizing ( ) ; return this ; } }"}, {"input": "package org . springblade . gateway . filter ; import com . alibaba . nacos . common . utils . MapUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . ObjectMapper ; import io . jsonwebtoken . Claims ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . core . jwt . props . JwtProperties ; import org . springblade . core . launch . constant . TokenConstant ; import org . springblade . core . tool . utils . Func ; import org . springblade . gateway . mapper . MemberMapper ; import org . springblade . gateway . props . AuthProperties ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springblade . gateway . provider . ResponseProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . stereotype . Component ; import org . springframework . util . AntPathMatcher ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . charset . StandardCharsets ; import java . util . Map ; @ Slf4j @ Component @ AllArgsConstructor public class AuthFilter implements GlobalFilter , Ordered { private final AuthProperties authProperties ; private final ObjectMapper objectMapper ; private final JwtProperties jwtProperties ; private final AntPathMatcher antPathMatcher = new AntPathMatcher ( ) ; private final MemberMapper memberMapper ; public static final String SIGNATURE_JSON = \"<STR_LIT>\" ; public static final String SIGNATURE_FORM = \"<STR_LIT>\" ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { String originalRequestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; String path = exchange . getRequest ( ) . getURI ( ) . getPath ( ) ; if ( isSkip ( path ) || isSkip ( originalRequestUrl ) ) { return chain . filter ( exchange ) ; } ServerHttpResponse resp = exchange . getResponse ( ) ; if ( path . matches ( AuthProvider . API_PATH_REG ) ) { String parameters ; String signature = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_SECRET_KEY ) ; if ( HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { String param = exchange . getAttribute ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS ) ; if ( StringUtils . isBlank ( param ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } int startIndex = param . indexOf ( SIGNATURE_JSON ) ; if ( startIndex == - <NUM_LIT> ) { startIndex = param . indexOf ( SIGNATURE_FORM ) ; } int endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; if ( endIndex == - <NUM_LIT> ) { endIndex = param . indexOf ( \"<STR_LIT>\" , startIndex ) ; } String signSub = \"<STR_LIT>\" ; if ( startIndex != - <NUM_LIT> ) { signSub = param . substring ( startIndex , endIndex == - <NUM_LIT> ? param . length ( ) - <NUM_LIT> : endIndex ) ; } signature = Func . isNotEmpty ( signature ) ? signature : signSub . replace ( SIGNATURE_JSON , \"<STR_LIT>\" ) . replace ( SIGNATURE_FORM , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; parameters = param . replace ( signSub , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } else { MultiValueMap < String , String > queryParams = exchange . getRequest ( ) . getQueryParams ( ) ; signature = Func . isNotEmpty ( signature ) ? signature : queryParams . getFirst ( AuthProvider . API_SECRET_KEY ) ; StringBuilder params = new StringBuilder ( ) ; queryParams . forEach ( ( key , value ) -> { if ( key . equals ( AuthProvider . API_KEY ) || key . equals ( AuthProvider . API_SECRET_KEY ) ) return ; params . append ( key ) . append ( \"<STR_LIT>\" ) . append ( value . get ( <NUM_LIT> ) ) . append ( \"<STR_LIT>\" ) ; } ) ; if ( params . length ( ) > <NUM_LIT> ) params . deleteCharAt ( params . length ( ) - <NUM_LIT> ) ; parameters = params . toString ( ) ; } String paramApiKey = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . API_KEY ) ; String headerApiKey = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . API_KEY ) ; String apiKey = StringUtils . isBlank ( headerApiKey ) ? paramApiKey : headerApiKey ; Map < String , Object > member = memberMapper . getMember ( apiKey ) ; if ( MapUtil . isEmpty ( member ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String secretKey = String . valueOf ( member . get ( \"<STR_LIT>\" ) ) ; String sha256Hex = Func . hmacSha256Hex ( parameters , secretKey ) ; if ( ! sha256Hex . equalsIgnoreCase ( signature ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; if ( accessToken . equals ( \"<STR_LIT>\" ) ) { JwtUtil . addRefreshToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , <NUM_LIT> ) ; accessToken = JwtUtil . getAccessToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , Func . toStr ( member . get ( \"<STR_LIT>\" ) ) , JwtUtil . getToken ( Func . toStr ( member . get ( \"<STR_LIT>\" ) ) ) ) ; } ServerHttpRequest request = exchange . getRequest ( ) ; request . mutate ( ) . header ( AuthProvider . AUTH_KEY , accessToken ) ; return chain . filter ( exchange . mutate ( ) . request ( request ) . build ( ) ) ; } String headerToken = exchange . getRequest ( ) . getHeaders ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; String paramToken = exchange . getRequest ( ) . getQueryParams ( ) . getFirst ( AuthProvider . AUTH_KEY ) ; if ( StringUtils . isBlank ( headerToken ) && StringUtils . isBlank ( paramToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } String auth = StringUtils . isBlank ( headerToken ) ? paramToken : headerToken ; String token = JwtUtil . getToken ( auth ) ; Claims claims = JwtUtil . parseJWT ( token ) ; if ( token == null || claims == null ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } if ( jwtProperties . getState ( ) ) { String tenantId = String . valueOf ( claims . get ( TokenConstant . TENANT_ID ) ) ; String userId = String . valueOf ( claims . get ( TokenConstant . USER_ID ) ) ; String accessToken = JwtUtil . getAccessToken ( tenantId , userId , token ) ; if ( ! token . equalsIgnoreCase ( accessToken ) ) { return unAuth ( resp , \"<STR_LIT>\" ) ; } } return chain . filter ( exchange ) ; } private boolean isSkip ( String path ) { return AuthProvider . getDefaultSkipUrl ( ) . stream ( ) . anyMatch ( pattern -> antPathMatcher . match ( pattern , path ) ) || authProperties . getSkipUrl ( ) . stream ( ) . anyMatch ( pattern -> antPathMatcher . match ( pattern , path ) ) ; } private Mono < Void > unAuth ( ServerHttpResponse resp , String msg ) { resp . setStatusCode ( HttpStatus . UNAUTHORIZED ) ; resp . getHeaders ( ) . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String result = \"<STR_LIT>\" ; try { result = objectMapper . writeValueAsString ( ResponseProvider . unAuth ( msg ) ) ; }", "output": "catch ( JsonProcessingException e ) { log . error ( e . getMessage ( ) , e ) ; } DataBuffer buffer = resp . bufferFactory ( ) . wrap ( result . getBytes ( StandardCharsets . UTF_8 ) ) ; return resp . writeWith ( Flux . just ( buffer ) ) ; } @ Override public int getOrder ( ) { return - <NUM_LIT> ; } }"}, {"input": "package com . xcs . wx . domain . bo ; import lombok . AllArgsConstructor ; import lombok . Data ; @ Data @ AllArgsConstructor public class DecryptBO { private String input ; private String output ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public interface Converter { boolean support ( Field field , CellValueType type ) ; Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) ;", "output": "void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) ; }"}, {"input": "package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface ServerMapper extends BaseMapper < Server > {", "output": "Server findByIp ( @ Param ( \"<STR_LIT>\" ) String ip ) ; IPage < Server > findAll ( @ Param ( \"<STR_LIT>\" ) ServerQueryCriteria criteria , Page < Object > page ) ; List < Server > findAll ( @ Param ( \"<STR_LIT>\" ) ServerQueryCriteria criteria ) ; }"}, {"input": "package cn . org . alan . exam . common . exception ; public class AppException extends RuntimeException { public AppException ( String msg ) { super ( msg ) ; }", "output": "}"}, {"input": "package com . yf . system . modules . role . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysRoleMenu extends Model < SysRoleMenu > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String roleId ; @ TableField ( \"<STR_LIT>\" ) private String menuId ;", "output": "}"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . ExamQuAnswer ; import cn . org . alan . exam . model . vo . exam . ExamQuAnswerExtVO ; import cn . org . alan . exam . model . vo . score . QuestionAnalyseVO ; import com . baomidou . mybatisplus . extension . service . IService ; import org . apache . poi . ss . formula . functions . T ; import java . util . List ; public interface IExamQuAnswerService extends IService < ExamQuAnswer > {", "output": "Result < QuestionAnalyseVO > questionAnalyse ( Integer examId , Integer questionId ) ; }"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . * ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; import javax . validation . constraints . Max ; import javax . validation . constraints . Min ; import javax . validation . constraints . NotNull ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysOperLogEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long operId ; private String appName ; private String logName ; private String logContent ; private String method ; private String requestMethod ; private Long operUserId ; private String operUrl ; private String operIp ; private String operParam ; private String jsonResult ; private Integer status ; private String errorMsg ; @ JsonFormat ( pattern = \"<STR_LIT>\" , timezone = \"<STR_LIT>\" ) private Date operTime ; private static final Integer PAGE_NUM = <NUM_LIT> ; private static final Integer PAGE_SIZE = <NUM_LIT> ; @ TableField ( exist = false ) private Map < String , Object > params ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ TableField ( exist = false ) @ JsonIgnore private Integer pageNum = PAGE_NUM ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Max ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ TableField ( exist = false ) @ JsonIgnore private Integer pageSize = PAGE_SIZE ; public Map < String , Object > getParams ( ) {", "output": "if ( params == null ) { params = new HashMap < > ( ) ; } return params ; } }"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . constant . UserConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . exception . UserPasswordNotMatchException ; import ginyi . common . exception . UserPasswordRetryLimitExceedException ; import ginyi . common . result . StateCode ; import ginyi . common . utils . Constants ; import ginyi . common . utils . DateUtils ; import ginyi . common . utils . ServletUtils ; import ginyi . common . utils . ip . IpUtils ; import ginyi . framework . security . context . AuthenticationContextHolder ; import ginyi . framework . security . manager . AsyncManager ; import ginyi . framework . security . manager . factory . AsyncFactory ; import ginyi . framework . security . utils . SecurityUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . LoginDto ; import ginyi . system . domain . model . dto . RegisterDto ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . LoginVo ; import ginyi . system . service . * ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . security . authentication . AuthenticationManager ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . AuthenticationException ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; @ Service public class SysLoginServiceImpl implements ISysLoginService { @ Value ( \"<STR_LIT>\" ) private String tokenPrefix ; @ Value ( \"<STR_LIT>\" ) private String tokenHeader ; @ Resource private ISysConfigService configService ; @ Resource private AuthenticationManager authenticationManager ; @ Resource private ISysUserService userService ; @ Resource private ITokenService tokenService ; @ Resource private IVerifyService verifyService ; @ Override public LoginVo login ( LoginDto loginDto ) { String username = loginDto . getUsername ( ) ; String password = loginDto . getPassword ( ) ; String code = loginDto . getCode ( ) ; boolean captchaEnabled = configService . selectCaptchaEnabled ( ) ; if ( captchaEnabled ) { verifyService . checkImgCode ( code ) ; } Authentication authentication = null ; try { UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( username , password ) ; AuthenticationContextHolder . setContext ( authenticationToken ) ; authentication = authenticationManager . authenticate ( authenticationToken ) ; LoginUser loginUser = ( LoginUser ) authentication . getPrincipal ( ) ; recordLoginInfo ( loginUser . getUserId ( ) ) ; String token = tokenService . createToken ( loginUser ) ; LoginVo loginVo = new LoginVo ( ) ; loginVo . setToken ( tokenPrefix + \"<STR_LIT>\" + token ) ; loginVo . setTokenHeader ( tokenHeader ) ; AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( username , Constants . LOGIN_SUCCESS , CommonMessageConstants . LOGIN_SUCCESS ) ) ; return loginVo ; } catch ( Exception e ) { if ( e instanceof AuthenticationException ) { if ( e . getCause ( ) instanceof UserPasswordRetryLimitExceedException ) { UserPasswordRetryLimitExceedException userPasswordRetryLimitExceedException = ( UserPasswordRetryLimitExceedException ) e . getCause ( ) ; AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( username , Constants . LOGIN_FAIL , CommonMessageConstants . USER_IS_LOCKED ) ) ; throw new UserPasswordRetryLimitExceedException ( userPasswordRetryLimitExceedException . getState ( ) , userPasswordRetryLimitExceedException . getData ( ) ) ; } if ( e . getCause ( ) instanceof UserPasswordNotMatchException ) { AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( username , Constants . LOGIN_FAIL , CommonMessageConstants . USER_PASSWORD_NOT_MATCH ) ) ; throw new UserPasswordNotMatchException ( ) ; } if ( e . getCause ( ) instanceof CommonException ) { CommonException commonException = ( CommonException ) e . getCause ( ) ; AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( username , Constants . LOGIN_FAIL , String . valueOf ( commonException . getData ( ) ) ) ) ; throw new CommonException ( commonException . getState ( ) , commonException . getData ( ) ) ; } } else { AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( username , Constants . LOGIN_FAIL , e . getMessage ( ) ) ) ; throw new CommonException ( StateCode . ERROR_SYSTEM ) ; } } finally { AuthenticationContextHolder . clearContext ( ) ; } return null ; } @ Override public void register ( RegisterDto registerDto ) { boolean captchaEnabled = configService . selectCaptchaEnabled ( ) ; if ( captchaEnabled ) { verifyService . checkImgCode ( registerDto . getCode ( ) ) ;", "output": "} SysUser sysUser = new SysUser ( ) ; sysUser . setUserName ( registerDto . getUsername ( ) ) ; if ( UserConstants . NOT_UNIQUE . equals ( userService . checkUserNameUnique ( sysUser ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . USER_EXIST ) ; } else { sysUser . setNickName ( registerDto . getUsername ( ) ) ; sysUser . setPassword ( SecurityUtils . encryptPassword ( registerDto . getPassword ( ) ) ) ; boolean regFlag = userService . registerUser ( sysUser ) ; if ( ! regFlag ) { throw new CommonException ( StateCode . ERROR_SYSTEM ) ; } else { AsyncManager . me ( ) . execute ( AsyncFactory . recordLogininfor ( registerDto . getUsername ( ) , Constants . REGISTER , CommonMessageConstants . REGISTER_SUCCESS ) ) ; } } } public void recordLoginInfo ( Long userId ) { UserDto userDto = new UserDto ( ) ; userDto . setUserId ( userId ) ; userDto . setLoginIp ( IpUtils . getIpAddr ( ServletUtils . getRequest ( ) ) ) ; userDto . setLoginDate ( DateUtils . getNowDate ( ) ) ; userService . updateUser ( userDto ) ; } }"}, {"input": "package top . kangert . kspider . domain ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; import top . kangert . kspider . entity . BaseEntity ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . GenerationType ; import javax . persistence . Id ; import javax . persistence . Table ; @ Table ( name = \"<STR_LIT>\" ) @ Entity @ Getter @ Setter @ ToString public class SpiderFlow extends BaseEntity { @ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) @ Column ( updatable = false ) private Long flowId ; private String name ; @ Column ( columnDefinition = \"<STR_LIT>\" ) private String json ;", "output": "}"}, {"input": "package com . yf . system . modules . dict . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . BeanMapper ; import com . yf . ability . redis . service . RedisService ; import com . yf . system . modules . dict . dto . SysDicValueDTO ; import com . yf . system . modules . dict . dto . ext . DicValueTreeDTO ; import com . yf . system . modules . dict . dto . request . SysDicValueReqDTO ; import com . yf . system . modules . dict . entity . SysDicValue ; import com . yf . system . modules . dict . mapper . SysDicValueMapper ; import com . yf . system . modules . dict . service . SysDicValueService ; import com . yf . base . utils . CacheKey ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . util . CollectionUtils ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Service public class SysDicValueServiceImpl extends ServiceImpl < SysDicValueMapper , SysDicValue > implements SysDicValueService { private static final String ROOT_TAG = \"<STR_LIT>\" ; @ Autowired private RedisService redisService ; @ Override public List < DicValueTreeDTO > findTree ( SysDicValueReqDTO reqDTO ) { String dicCode = reqDTO . getDicCode ( ) ; QueryWrapper < SysDicValue > wrapper = new QueryWrapper ( ) ; wrapper . lambda ( ) . eq ( SysDicValue :: getDicCode , dicCode ) ; if ( ! CollectionUtils . isEmpty ( reqDTO . getExcludes ( ) ) ) { wrapper . lambda ( ) . notIn ( SysDicValue :: getValue , reqDTO . getExcludes ( ) ) ; } List < SysDicValue > list = this . list ( wrapper ) ; List < DicValueTreeDTO > dtoList = BeanMapper . mapList ( list , DicValueTreeDTO . class ) ;", "output": "Map < String , List < DicValueTreeDTO > > map = new HashMap < > ( <NUM_LIT> ) ; for ( DicValueTreeDTO item : dtoList ) { if ( map . containsKey ( item . getParentId ( ) ) ) { map . get ( item . getParentId ( ) ) . add ( item ) ; continue ; } List < DicValueTreeDTO > a = new ArrayList < > ( ) ; a . add ( item ) ; map . put ( item . getParentId ( ) , a ) ; } List < DicValueTreeDTO > topList = map . get ( ROOT_TAG ) ; if ( ! CollectionUtils . isEmpty ( topList ) ) { for ( DicValueTreeDTO item : topList ) { this . fillChildren ( map , item ) ; } } return topList ; } @ CacheEvict ( value = CacheKey . DICT , key = \"<STR_LIT>\" ) @ Override public void save ( SysDicValueDTO reqDTO ) { if ( ! StringUtils . isBlank ( reqDTO . getValue ( ) ) ) { QueryWrapper < SysDicValue > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysDicValue :: getDicCode , reqDTO . getDicCode ( ) ) . eq ( SysDicValue :: getValue , reqDTO . getValue ( ) ) ; if ( ! StringUtils . isBlank ( reqDTO . getId ( ) ) ) { wrapper . lambda ( ) . ne ( SysDicValue :: getId , reqDTO . getId ( ) ) ; } long count = this . count ( wrapper ) ; if ( count > <NUM_LIT> ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } } else { reqDTO . setId ( IdWorker . getIdStr ( ) ) ; reqDTO . setValue ( reqDTO . getId ( ) ) ; } SysDicValue entity = new SysDicValue ( ) ; BeanMapper . copy ( reqDTO , entity ) ; this . saveOrUpdate ( entity ) ; } @ Override public Map < String , String > findDictMap ( String dictCode ) { QueryWrapper < SysDicValue > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . eq ( SysDicValue :: getDicCode , dictCode ) ; List < SysDicValue > list = this . list ( wrapper ) ; Map < String , String > map = new HashMap < > ( <NUM_LIT> ) ; if ( ! CollectionUtils . isEmpty ( list ) ) { for ( SysDicValue item : list ) { map . put ( item . getTitle ( ) , item . getValue ( ) ) ; } } return map ; } @ Override public void removeByDict ( List < String > codes ) { QueryWrapper < SysDicValue > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysDicValue :: getDicCode , codes ) ; this . remove ( wrapper ) ; } private void fillChildren ( Map < String , List < DicValueTreeDTO > > map , DicValueTreeDTO item ) { if ( map . containsKey ( item . getId ( ) ) ) { List < DicValueTreeDTO > children = map . get ( item . getId ( ) ) ; if ( ! CollectionUtils . isEmpty ( children ) ) { for ( DicValueTreeDTO sub : children ) { this . fillChildren ( map , sub ) ; } } item . setChildren ( children ) ; } } @ Override @ Cacheable ( value = CacheKey . DICT , key = \"<STR_LIT>\" ) public String findDictText ( String dicCode , String value ) { String text = baseMapper . findDictText ( dicCode , value ) ; return StringUtils . isBlank ( text ) ? \"<STR_LIT>\" : text ; } @ Override public String findTableText ( String dicTable , String dicText , String dicCode , String value ) { String key = MessageFormat . format ( \"<STR_LIT>\" , CacheKey . DICT , dicTable , dicText , dicCode , value ) ; String result = redisService . getString ( key ) ; if ( result != null ) { return result ; } String text = baseMapper . findTableText ( dicTable , dicText , dicCode , value ) ; if ( StringUtils . isBlank ( text ) ) { text = \"<STR_LIT>\" ; } redisService . set ( key , text , <NUM_LIT> ) ; return text ; } }"}, {"input": "package org . springblade . cgform . model ; import java . io . Serializable ; import java . util . List ; public class TreeSelectModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String key ; private String title ; private boolean isLeaf ; private String icon ; private String parentId ; private String value ; private String code ; public String getValue ( ) { return value ; } public void setValue ( String value ) { this . value = value ; } public String getParentId ( ) { return parentId ; } public void setParentId ( String parentId ) { this . parentId = parentId ; } public String getKey ( ) { return key ; } public void setKey ( String key ) { this . key = key ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ;", "output": "} public boolean isLeaf ( ) { return isLeaf ; } public void setLeaf ( boolean isLeaf ) { this . isLeaf = isLeaf ; } public String getIcon ( ) { return icon ; } public void setIcon ( String icon ) { this . icon = icon ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } private List < TreeSelectModel > children ; public List < TreeSelectModel > getChildren ( ) { return children ; } public void setChildren ( List < TreeSelectModel > children ) { this . children = children ; } }"}, {"input": "package org . springblade . web . feign ; import cn . hutool . core . bean . BeanUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . AllArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . EmailTemplateUtils ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . feign . IMjkjWebClient ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . CancelExchangeParam ; import org . springblade . web . model . param . EntrustParam ; import org . springblade . web . service . * ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import springfox . documentation . annotations . ApiIgnore ; import javax . transaction . Transactional ; import java . math . BigDecimal ; import java . util . * ; @ ApiIgnore @ RestController @ AllArgsConstructor public class WebClient implements IMjkjWebClient { @ Override public R < Map < String , Object > > getWalletInfo ( WalletGetParam param ) { return null ; } @ Override public R < Map < String , Object > > getMemberAssert ( String memberId ) { return null ; } @ Override public R < Map < String , Object > > createWallet ( String id ) { return null ; } @ Override public R addWallet ( AddWalletParam param ) { return null ; } @ Override public R subWallet ( SubWalletParam param ) { return null ; } @ Override public R addFrozenWallet ( AddFrozenWalletParam param ) { return null ; } @ Override public R subFrozenWallet ( SubFrozenWalletParam param ) { return null ; } @ Override public R removeFrozenWallet ( RemoveWalletParam param ) { return null ; } @ Override public R walletBuySell ( BuySellWalletParam param ) { return null ; } @ Override public Boolean sendYx ( SendYxParam param ) { return null ; } @ Override public Boolean sendEmail ( SendEmailParam param ) { return null ; } @ Override public Boolean sendPhone ( SendPhoneParam param ) { return null ; } @ Override public void orderTimeOutJobHandler ( ) { } @ Override public void orderAppealTimeOutJobHandler ( ) { }", "output": "@ Override public void resetMath ( ) { } @ Override public void marketProfit ( ) { } @ Override public void inviteReward ( ) { } @ Override public void contractProfit ( String param ) { } @ Override public void resetMemberLevel ( String operateMemberI ) { } @ Override public R changeOrderStatus ( String id , String status ) { return null ; } @ Override public void wealthCbsxProfit ( ) { } @ Override public void changeCbsxGoodsStatus ( ) { } @ Override public void appeal ( Appeal appeal ) { } @ Override public void handleNightFee ( ) { } @ Override public R handleContractRg ( String logContractId , String type ) { return null ; } @ Override public R entrust ( EntrustParamApi param ) { return null ; } @ Override public R cancelEntrust ( CancelExchangeParamDTO param ) { return null ; } @ Override public R queryEntrust ( String entrustType , String entrustFlag , String symbol ) { return null ; } @ Override public R < Map < String , Object > > getApiKey ( String apiKey ) { return null ; } }"}, {"input": "package ginyi . server . admin . controller ; import ginyi . common . annotation . Log ; import ginyi . common . result . CommonResult ; import ginyi . system . domain . SysServer ; import ginyi . system . domain . model . dto . CacheDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . CacheKeyVo ; import ginyi . system . domain . model . vo . CacheVo ; import ginyi . system . service . ISysMonitorService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysMonitorController { @ Resource private ISysMonitorService monitorService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < SysServer > getServerInfo ( ) throws InterruptedException { SysServer server = monitorService . getServerInfo ( ) ; return CommonResult . success ( server ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < BaseVo < CacheKeyVo > > getCacheList ( ) { BaseVo < CacheKeyVo > baseVo = monitorService . getCacheList ( ) ; return CommonResult . success ( baseVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < CacheVo > getCacheDetails ( @ RequestBody CacheDto cacheDto ) {", "output": "CacheVo cacheVo = monitorService . getCacheDetails ( cacheDto ) ; return CommonResult . success ( cacheVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult removeCache ( @ PathVariable String key ) { monitorService . removeCache ( key ) ; return CommonResult . success ( ) ; } }"}, {"input": "package com . yf . base . utils . download . temp ; import java . util . List ; public class DownloadTemp { private String url ; private long fileLength ; private List < DownloadTempThread > threads ; public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public long getFileLength ( ) { return fileLength ;", "output": "} public void setFileLength ( long fileLength ) { this . fileLength = fileLength ; } public List < DownloadTempThread > getThreads ( ) { return threads ; } public void setThreads ( List < DownloadTempThread > threads ) { this . threads = threads ; } }"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; public interface DDDConvertor < E extends DDDEntity , D extends IDataObject , R > { E toEntity ( D dataObject ) ; D toDataObject ( E entity ) ; R toResult ( E entity ) ; R toResult ( D dataObject ) ;", "output": "}"}, {"input": "package top . kangert . kspider . controller ; import java . util . Map ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import top . kangert . kspider . controller . BaseController ; import top . kangert . kspider . domain . SpiderTask ; import top . kangert . kspider . service . SpiderTaskService ; import top . kangert . kspider . util . BaseResponse ; import top . kangert . kspider . util . PageInfo ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SpiderTaskController extends BaseController { @ Autowired private SpiderTaskService spiderTaskService ; @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse queryTaskList ( @ RequestBody Map < String , Object > params ) { PageInfo < SpiderTask > queryItem = spiderTaskService . queryItems ( params ) ; return successResponse ( queryItem ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse addTask ( @ RequestBody Map < String , Object > params ) {", "output": "SpiderTask spiderTask = spiderTaskService . add ( params ) ; return successResponse ( spiderTask ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse editTask ( @ RequestBody Map < String , Object > params ) { spiderTaskService . edit ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse deleteTask ( @ RequestBody Map < String , Object > params ) { spiderTaskService . deleteItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse run ( @ RequestBody Map < String , Object > params ) { spiderTaskService . run ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse stop ( @ RequestBody Map < String , Object > params ) { spiderTaskService . stop ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public void download ( @ RequestBody Map < String , Object > params ) { spiderTaskService . download ( params , response ) ; } }"}, {"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . SysDict ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . model . DuplicateCheckVo ; import org . springblade . cgform . model . TreeSelectModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface IDictService extends BaseService < SysDict > { List < String > queryTableDictByKeys ( String table , String text , String code , String keys ) ; @ Deprecated List < DictModel > queryTableDictItemsByCodeAndFilter ( String table , String text , String code , String filterSql ) ; List < DictModel > queryTableDictItemsByCode ( String table , String text , String code ) ; public List < DictModel > queryDictItemsByCode ( String code ) ;", "output": "public List < DictModel > queryFilterTableDictInfo ( String table , String text , String code , String filterSql ) ; }"}, {"input": "package org . example . infrastructure . repository . example . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; import org . example . domain . example . valueobject . ExampleStatus ; @ Data public class Example extends DataObject { private String username ; private String password ; private ExampleStatus status ;", "output": "}"}, {"input": "package com . yf . base . api . api . dto ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BaseIdReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ JsonIgnore private String userId ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . dao . VariableRepository ; import top . kangert . kspider . domain . Variable ; import top . kangert . kspider . executor . FunctionExecutor ; import top . kangert . kspider . service . VariableService ; import java . util . HashMap ; import java . util . Map ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component @ Comment ( \"<STR_LIT>\" ) public class GlobalVariableFunctionExecutor implements FunctionExecutor { private static VariableService variableService ; @ Autowired private static VariableRepository variableRepository ; @ Autowired public void setVariableService ( VariableService variableService ) { GlobalVariableFunctionExecutor . variableService = variableService ; } @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void update ( String variableName , String variableValue ) { Variable var = variableRepository . findByName ( variableName ) ;", "output": "Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( \"<STR_LIT>\" , var . getVarId ( ) ) ; params . put ( \"<STR_LIT>\" , variableName ) ; params . put ( \"<STR_LIT>\" , variableValue ) ; variableService . editItem ( params ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import java . util . regex . Pattern ; public class TextValidator { private static final String REGEX_MOBILE_SIMPLE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_SIMPLE = Pattern . compile ( REGEX_MOBILE_SIMPLE ) ; public static final String REGEX_MOBILE_EXACT = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_MOBILE_EXACT = Pattern . compile ( REGEX_MOBILE_EXACT ) ; private static final String REGEX_TEL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_TEL = Pattern . compile ( REGEX_TEL ) ; private static final String REGEX_ID_CARD15 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD15 = Pattern . compile ( REGEX_ID_CARD15 ) ; private static final String REGEX_ID_CARD18 = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_ID_CARD18 = Pattern . compile ( REGEX_ID_CARD18 ) ; private static final String REGEX_EMAIL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_EMAIL = Pattern . compile ( REGEX_EMAIL ) ; private static final String REGEX_URL = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_URL = Pattern . compile ( REGEX_URL ) ; private static final String REGEX_DATE = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_DATE = Pattern . compile ( REGEX_DATE ) ; private static final String REGEX_IP = \"<STR_LIT>\" ; private static final Pattern PATTERN_REGEX_IP = Pattern . compile ( REGEX_IP ) ; public static boolean isMobileSimple ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_SIMPLE , input ) ; } public static boolean isMobileExact ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_MOBILE_EXACT , input ) ; } public static boolean isTel ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_TEL , input ) ; } public static boolean isIdCard ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_ID_CARD15 , input ) || isMatch ( PATTERN_REGEX_ID_CARD18 , input ) ; } public static boolean isEmail ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_EMAIL , input ) ; } public static boolean isUrl ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_URL , input ) ;", "output": "} public static boolean isDate ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_DATE , input ) ; } public static boolean isIp ( @ Nullable CharSequence input ) { return isMatch ( PATTERN_REGEX_IP , input ) ; } public static boolean isMatch ( Pattern pattern , CharSequence input ) { return StringUtils . isNotEmpty ( input ) && pattern . matcher ( input ) . matches ( ) ; } }"}, {"input": "package me . zhengjie . config ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . socket . server . standard . ServerEndpointExporter ; @ Configuration public class WebSocketConfig { @ Bean public ServerEndpointExporter serverEndpointExporter ( ) { return new ServerEndpointExporter ( ) ;", "output": "} }"}, {"input": "package com . yf . system . modules . role . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . role . entity . SysRoleMenu ; public interface SysRoleMenuMapper extends BaseMapper < SysRoleMenu > {", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema ; import java . io . Serializable ; import java . util . List ; public class JsonSchemaDescrip implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String $schema = \"<STR_LIT>\" ; private String title ; private String description ; private String type ; private List < String > required ; public List < String > getRequired ( ) { return required ; } public void setRequired ( List < String > required ) { this . required = required ; } public String get$schema ( ) { return $schema ; } public void set$schema ( String $schema ) { this . $schema = $schema ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getDescription ( ) { return description ; } public void setDescription ( String description ) { this . description = description ; } public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; }", "output": "public JsonSchemaDescrip ( ) { } public JsonSchemaDescrip ( List < String > required ) { this . description = \"<STR_LIT>\" ; this . title = \"<STR_LIT>\" ; this . type = \"<STR_LIT>\" ; this . required = required ; } }"}, {"input": "package me . zhengjie . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . QiniuConfig ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . QiniuConfigMapper ; import me . zhengjie . service . QiNiuConfigService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class QiNiuConfigServiceImpl extends ServiceImpl < QiniuConfigMapper , QiniuConfig > implements QiNiuConfigService { @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public QiniuConfig getConfig ( ) { QiniuConfig qiniuConfig = getById ( <NUM_LIT> ) ; return qiniuConfig == null ? new QiniuConfig ( ) : qiniuConfig ; } @ Override @ CacheEvict ( key = \"<STR_LIT>\" ) @ Transactional ( rollbackFor = Exception . class ) public void saveConfig ( QiniuConfig qiniuConfig ) { qiniuConfig . setId ( <NUM_LIT> ) ; String http = \"<STR_LIT>\" , https = \"<STR_LIT>\" ; if ( ! ( qiniuConfig . getHost ( ) . toLowerCase ( ) . startsWith ( http ) || qiniuConfig . getHost ( ) . toLowerCase ( ) . startsWith ( https ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } saveOrUpdate ( qiniuConfig ) ; } @ Override @ CacheEvict ( key = \"<STR_LIT>\" ) @ Transactional ( rollbackFor = Exception . class ) public void updateType ( String type ) { QiniuConfig qiniuConfig = getById ( <NUM_LIT> ) ;", "output": "qiniuConfig . setType ( type ) ; saveOrUpdate ( qiniuConfig ) ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . ExamRepo ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; public interface ExamRepoMapper extends BaseMapper < ExamRepo > {", "output": "}"}, {"input": "package top . kangert . kspider . dao ; import org . springframework . data . jpa . repository . JpaRepository ; import org . springframework . data . jpa . repository . JpaSpecificationExecutor ; import org . springframework . data . jpa . repository . Modifying ; import org . springframework . data . jpa . repository . Query ; import org . springframework . data . repository . query . Param ; import top . kangert . kspider . domain . SpiderTask ; import java . util . Date ; import java . util . List ; public interface SpiderTaskRepository extends JpaRepository < SpiderTask , Long > , JpaSpecificationExecutor < SpiderTask > { @ Query ( value = \"<STR_LIT>\" , nativeQuery = true ) Integer countByFlowIdAndupdateTimeIsNull ( Long flowId ) ; List < SpiderTask > findByJobEnabled ( Boolean jobEnabled ) ; @ Modifying @ Query ( value = \"<STR_LIT>\" ) void clearNextExecuteTime ( ) ; @ Modifying @ Query ( value = \"<STR_LIT>\" ) void updateCronAndNextExecuteTime ( @ Param ( \"<STR_LIT>\" ) Long taskId , @ Param ( \"<STR_LIT>\" ) String cron , @ Param ( \"<STR_LIT>\" ) Date fireTimeAfter ) ; @ Query ( value = \"<STR_LIT>\" ) List < Long > findTaskIdByFlowIdOrderByupdateTimeDesc ( @ Param ( \"<STR_LIT>\" ) Long flowId ) ;", "output": "@ Modifying @ Query ( value = \"<STR_LIT>\" , nativeQuery = true ) void executeCountIncrement ( @ Param ( \"<STR_LIT>\" ) Date lastExecuteTime , @ Param ( \"<STR_LIT>\" ) Long taskId ) ; @ Modifying @ Query ( value = \"<STR_LIT>\" , nativeQuery = true ) void executeCountIncrementAndExecuteNextTime ( Date lastExecuteTime , Date nextExecuteTime , Long taskId ) ; @ Modifying @ Query ( value = \"<STR_LIT>\" ) void updateNextExecuteTime ( @ Param ( \"<STR_LIT>\" ) Date nextExecuteTime , @ Param ( \"<STR_LIT>\" ) Long taskId ) ; @ Modifying @ Query ( value = \"<STR_LIT>\" , nativeQuery = true ) void updateJobEnabled ( @ Param ( \"<STR_LIT>\" ) Long taskId , @ Param ( \"<STR_LIT>\" ) boolean enabled ) ; }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . UserBookConverter ; import cn . org . alan . exam . mapper . ExamQuAnswerMapper ; import cn . org . alan . exam . mapper . OptionMapper ; import cn . org . alan . exam . mapper . QuestionMapper ; import cn . org . alan . exam . mapper . UserBookMapper ; import cn . org . alan . exam . model . entity . * ; import cn . org . alan . exam . model . form . userbook . ReUserBookForm ; import cn . org . alan . exam . model . vo . userbook . * ; import cn . org . alan . exam . service . IOptionService ; import cn . org . alan . exam . service . IQuestionService ; import cn . org . alan . exam . service . IUserBookService ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . util . CollectionUtils ; import java . util . * ; import java . util . stream . Collectors ; @ Service public class UserBookServiceImpl extends ServiceImpl < UserBookMapper , UserBook > implements IUserBookService { @ Resource private UserBookMapper userBookMapper ; @ Resource private QuestionMapper questionMapper ; @ Resource private OptionMapper optionMapper ; @ Resource private ExamQuAnswerMapper examQuAnswerMapper ; @ Resource private UserBookConverter userBookConverter ; @ Resource private IQuestionService questionService ; @ Resource private IOptionService optionService ; @ Override public Result < IPage < UserPageBookVO > > getPage ( Integer pageNum , Integer pageSize , String examName ) { Page < UserPageBookVO > page = new Page < > ( pageNum , pageSize ) ; String role = SecurityUtil . getRole ( ) ; int roleId = <NUM_LIT> ; if ( \"<STR_LIT>\" . equals ( role ) ) { roleId = <NUM_LIT> ; } else if ( \"<STR_LIT>\" . equals ( role ) ) { roleId = <NUM_LIT> ; } else { roleId = <NUM_LIT> ; } Page < UserPageBookVO > userPageBookVOPage = userBookMapper . selectPageVo ( page , examName , SecurityUtil . getUserId ( ) , roleId ) ; return Result . success ( \"<STR_LIT>\" , userPageBookVOPage ) ; } @ Override public Result < List < ReUserExamBookVO > > getReUserExamBook ( Integer examId ) { LambdaQueryWrapper < UserBook > userBookLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; userBookLambdaQueryWrapper . eq ( UserBook :: getExamId , examId ) . eq ( UserBook :: getUserId , SecurityUtil . getUserId ( ) ) ; List < UserBook > userBook = userBookMapper . selectList ( userBookLambdaQueryWrapper ) ; List < ReUserExamBookVO > reUserExamBookVOS = userBookConverter . listEntityToVo ( userBook ) ; return Result . success ( \"<STR_LIT>\" , reUserExamBookVOS ) ; } @ Override public Result < BookOneQuVO > getBookOne ( Integer quId ) { BookOneQuVO bookOneQuVO = new BookOneQuVO ( ) ; Question quById = questionService . getById ( quId ) ; if ( quById == null ) { return Result . failed ( \"<STR_LIT>\" ) ; } bookOneQuVO . setImage ( quById . getImage ( ) ) ; bookOneQuVO . setContent ( quById . getContent ( ) ) ; bookOneQuVO . setQuType ( quById . getQuType ( ) ) ; LambdaQueryWrapper < Option > optionLambdaQuery = new LambdaQueryWrapper < > ( ) ; optionLambdaQuery . eq ( Option :: getQuId , quId ) ; List < Option > list = optionMapper . selectList ( optionLambdaQuery ) ; bookOneQuVO . setAnswerList ( list ) ; return Result . success ( \"<STR_LIT>\" , bookOneQuVO ) ; } @ Override public Result < AddBookAnswerVO > addBookAnswer ( ReUserBookForm reUserBookForm ) { AddBookAnswerVO addBookAnswerVO = new AddBookAnswerVO ( ) ; if ( StringUtils . isBlank ( reUserBookForm . getAnswer ( ) ) ) { return Result . success ( \"<STR_LIT>\" ) ; } LambdaQueryWrapper < Question > QuWrapper = new LambdaQueryWrapper < > ( ) ; QuWrapper . eq ( Question :: getId , reUserBookForm . getQuId ( ) ) ; Question qu = questionMapper . selectOne ( QuWrapper ) ; Integer quType = qu . getQuType ( ) ; addBookAnswerVO . setAnalysis ( qu . getAnalysis ( ) ) ; LambdaQueryWrapper < Option > opWrapper = new LambdaQueryWrapper < > ( ) ; opWrapper . eq ( Option :: getQuId , reUserBookForm . getQuId ( ) ) ; List < Option > options = optionMapper . selectList ( opWrapper ) ; String current = \"<STR_LIT>\" ; ArrayList < Integer > strings = new ArrayList < > ( ) ; for ( Option temp : options ) { if ( temp . getIsRight ( ) == <NUM_LIT> ) { strings . add ( temp . getSort ( ) ) ; } } List < String > stringList = strings . stream ( ) . map ( String :: valueOf ) . collect ( Collectors . toList ( ) ) ; String result = String . join ( \"<STR_LIT>\" , stringList ) ; if ( quType == <NUM_LIT> ) { addBookAnswerVO . setRightAnswers ( options . get ( <NUM_LIT> ) . getContent ( ) ) ; } else { addBookAnswerVO . setRightAnswers ( result ) ; } return switch ( quType ) { case <NUM_LIT> -> { Option byId = optionService . getById ( reUserBookForm . getAnswer ( ) ) ; if ( byId . getIsRight ( ) == <NUM_LIT> ) { LambdaQueryWrapper < UserBook > userBookLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; userBookLambdaQueryWrapper . eq ( UserBook :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( UserBook :: getExamId , reUserBookForm . getExamId ( ) ) . eq ( UserBook :: getQuId , reUserBookForm . getQuId ( ) ) ; int row = userBookMapper . delete ( userBookLambdaQueryWrapper ) ; addBookAnswerVO . setCorrect ( <NUM_LIT> ) ; yield Result . success ( \"<STR_LIT>\" , addBookAnswerVO ) ; } else { addBookAnswerVO . setCorrect ( <NUM_LIT> ) ; yield Result . success ( \"<STR_LIT>\" , addBookAnswerVO ) ; } } case <NUM_LIT> -> { LambdaQueryWrapper < Option > optionWrapper = new LambdaQueryWrapper < > ( ) ; optionWrapper . eq ( Option :: getIsRight , <NUM_LIT> ) . eq ( Option :: getQuId , reUserBookForm . getQuId ( ) ) ; List < Option > examQuAnswers = optionMapper . selectList ( optionWrapper ) ; List < Integer > quIds = Arrays . stream ( reUserBookForm . getAnswer ( ) . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; for ( Option temp : examQuAnswers ) { boolean containsBanana = quIds . contains ( temp . getId ( ) ) ; if ( containsBanana ) { yield Result . success ( \"<STR_LIT>\" ) ; } } LambdaQueryWrapper < UserBook > userBookWrapper = new LambdaQueryWrapper < > ( ) ; userBookWrapper . eq ( UserBook :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( UserBook :: getExamId , reUserBookForm . getExamId ( ) ) . eq ( UserBook :: getQuId , reUserBookForm . getQuId ( ) ) ; userBookMapper . delete ( userBookWrapper ) ; yield Result . success ( \"<STR_LIT>\" ) ; } case <NUM_LIT> -> { Option byId = optionService . getById ( reUserBookForm . getAnswer ( ) ) ; if ( byId . getIsRight ( ) == <NUM_LIT> ) { LambdaQueryWrapper < UserBook > userBookLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; userBookLambdaQueryWrapper . eq ( UserBook :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( UserBook :: getExamId , reUserBookForm . getExamId ( ) ) . eq ( UserBook :: getQuId , reUserBookForm . getQuId ( ) ) ; userBookMapper . delete ( userBookLambdaQueryWrapper ) ; addBookAnswerVO . setCorrect ( <NUM_LIT> ) ; yield Result . success ( \"<STR_LIT>\" , addBookAnswerVO ) ; } else { addBookAnswerVO . setCorrect ( <NUM_LIT> ) ; yield Result . success ( \"<STR_LIT>\" , addBookAnswerVO ) ; } } case <NUM_LIT> -> { if ( \"<STR_LIT>\" . equals ( reUserBookForm . getAnswer ( ) ) ) { LambdaQueryWrapper < UserBook > userBookLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; userBookLambdaQueryWrapper . eq ( UserBook :: getUserId , SecurityUtil . getUserId ( ) ) . eq ( UserBook :: getExamId , reUserBookForm . getExamId ( ) ) . eq ( UserBook :: getQuId , reUserBookForm . getQuId ( ) ) ; userBookMapper . delete ( userBookLambdaQueryWrapper ) ; yield Result . success ( \"<STR_LIT>\" , addBookAnswerVO ) ; } addBookAnswerVO . setCorrect ( <NUM_LIT> ) ;", "output": "yield Result . success ( \"<STR_LIT>\" , addBookAnswerVO ) ; } default -> { yield Result . failed ( \"<STR_LIT>\" ) ; } } ; } }"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . lang . Assert ; import cn . hutool . core . util . StrUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . common . constant . SystemConstants ; import com . youlai . system . enums . StatusEnum ; import com . youlai . system . converter . DeptConverter ; import com . youlai . system . mapper . SysDeptMapper ; import com . youlai . system . model . entity . SysDept ; import com . youlai . system . model . form . DeptForm ; import com . youlai . system . model . query . DeptQuery ; import com . youlai . system . model . vo . DeptVO ; import com . youlai . system . common . model . Option ; import com . youlai . system . service . SysDeptService ; import lombok . RequiredArgsConstructor ; import org . springframework . stereotype . Service ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor public class SysDeptServiceImpl extends ServiceImpl < SysDeptMapper , SysDept > implements SysDeptService { private final DeptConverter deptConverter ; @ Override public List < DeptVO > getDeptList ( DeptQuery queryParams ) { String keywords = queryParams . getKeywords ( ) ; Integer status = queryParams . getStatus ( ) ; List < SysDept > deptList = this . list ( new LambdaQueryWrapper < SysDept > ( ) . like ( StrUtil . isNotBlank ( keywords ) , SysDept :: getName , keywords ) . eq ( status != null , SysDept :: getStatus , status ) . orderByAsc ( SysDept :: getSort ) ) ; if ( CollectionUtil . isEmpty ( deptList ) ) { return Collections . EMPTY_LIST ; } Set < Long > deptIds = deptList . stream ( ) . map ( SysDept :: getId ) . collect ( Collectors . toSet ( ) ) ; Set < Long > parentIds = deptList . stream ( ) . map ( SysDept :: getParentId ) . collect ( Collectors . toSet ( ) ) ; List < Long > rootIds = CollectionUtil . subtractToList ( parentIds , deptIds ) ; return rootIds . stream ( ) . flatMap ( rootId -> recurDeptList ( rootId , deptList ) . stream ( ) ) . toList ( ) ; } public List < DeptVO > recurDeptList ( Long parentId , List < SysDept > deptList ) { return deptList . stream ( ) . filter ( dept -> dept . getParentId ( ) . equals ( parentId ) ) . map ( dept -> { DeptVO deptVO = deptConverter . convertToVo ( dept ) ; List < DeptVO > children = recurDeptList ( dept . getId ( ) , deptList ) ; deptVO . setChildren ( children ) ; return deptVO ; } ) . toList ( ) ; } @ Override public List < Option > listDeptOptions ( ) { List < SysDept > deptList = this . list ( new LambdaQueryWrapper < SysDept > ( ) . eq ( SysDept :: getStatus , StatusEnum . ENABLE . getValue ( ) ) . select ( SysDept :: getId , SysDept :: getParentId , SysDept :: getName ) . orderByAsc ( SysDept :: getSort ) ) ; if ( CollectionUtil . isEmpty ( deptList ) ) { return Collections . EMPTY_LIST ; } Set < Long > deptIds = deptList . stream ( ) . map ( SysDept :: getId ) . collect ( Collectors . toSet ( ) ) ; Set < Long > parentIds = deptList . stream ( ) . map ( SysDept :: getParentId ) . collect ( Collectors . toSet ( ) ) ; List < Long > rootIds = CollectionUtil . subtractToList ( parentIds , deptIds ) ; return rootIds . stream ( ) . flatMap ( rootId -> recurDeptTreeOptions ( rootId , deptList ) . stream ( ) ) . toList ( ) ; } @ Override public Long saveDept ( DeptForm formData ) { String code = formData . getCode ( ) ; long count = this . count ( new LambdaQueryWrapper < SysDept > ( ) . eq ( SysDept :: getCode , code ) ) ; Assert . isTrue ( count == <NUM_LIT> , \"<STR_LIT>\" ) ; SysDept entity = deptConverter . toEntity ( formData ) ; String treePath = generateDeptTreePath ( formData . getParentId ( ) ) ; entity . setTreePath ( treePath ) ; boolean result = this . save ( entity ) ; Assert . isTrue ( result , \"<STR_LIT>\" ) ; return entity . getId ( ) ; }", "output": "@ Override public DeptForm getDeptForm ( Long deptId ) { SysDept entity = this . getById ( deptId ) ; return deptConverter . toForm ( entity ) ; } @ Override public Long updateDept ( Long deptId , DeptForm formData ) { String code = formData . getCode ( ) ; long count = this . count ( new LambdaQueryWrapper < SysDept > ( ) . ne ( SysDept :: getId , deptId ) . eq ( SysDept :: getCode , code ) ) ; Assert . isTrue ( count == <NUM_LIT> , \"<STR_LIT>\" ) ; SysDept entity = deptConverter . toEntity ( formData ) ; entity . setId ( deptId ) ; String treePath = generateDeptTreePath ( formData . getParentId ( ) ) ; entity . setTreePath ( treePath ) ; boolean result = this . updateById ( entity ) ; Assert . isTrue ( result , \"<STR_LIT>\" ) ; return entity . getId ( ) ; } public static List < Option > recurDeptTreeOptions ( long parentId , List < SysDept > deptList ) { return CollectionUtil . emptyIfNull ( deptList ) . stream ( ) . filter ( dept -> dept . getParentId ( ) . equals ( parentId ) ) . map ( dept -> { Option option = new Option ( dept . getId ( ) , dept . getName ( ) ) ; List < Option > children = recurDeptTreeOptions ( dept . getId ( ) , deptList ) ; if ( CollectionUtil . isNotEmpty ( children ) ) { option . setChildren ( children ) ; } return option ; } ) . collect ( Collectors . toList ( ) ) ; } @ Override public boolean deleteByIds ( String ids ) { if ( StrUtil . isNotBlank ( ids ) ) { String [ ] menuIds = ids . split ( \"<STR_LIT>\" ) ; for ( String deptId : menuIds ) { this . remove ( new LambdaQueryWrapper < SysDept > ( ) . eq ( SysDept :: getId , deptId ) . or ( ) . apply ( \"<STR_LIT>\" , deptId ) ) ; } } return true ; } private String generateDeptTreePath ( Long parentId ) { String treePath = null ; if ( SystemConstants . ROOT_NODE_ID . equals ( parentId ) ) { treePath = String . valueOf ( parentId ) ; } else { SysDept parent = this . getById ( parentId ) ; if ( parent != null ) { treePath = parent . getTreePath ( ) + \"<STR_LIT>\" + parent . getId ( ) ; } } return treePath ; } }"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserLoginReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String password ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String captchaKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String captchaValue ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . domain ; import com . alibaba . fastjson . annotation . JSONField ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . List ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Dept extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ JSONField ( serialize = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Set < Role > roles ; @ TableField ( exist = false ) private List < Dept > children ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptSort ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean enabled ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long pid ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Integer subCount = <NUM_LIT> ; @ Override public boolean equals ( Object o ) { if ( this == o ) {", "output": "return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Dept dept = ( Dept ) o ; return Objects . equals ( id , dept . id ) && Objects . equals ( name , dept . name ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id , name ) ; } public Boolean getHasChildren ( ) { return subCount > <NUM_LIT> ; } public Boolean getLeaf ( ) { return subCount <= <NUM_LIT> ; } public String getLabel ( ) { return name ; } }"}, {"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import feign . * ; import feign . codec . Decoder ; import feign . codec . Encoder ; import feign . codec . ErrorDecoder ; import org . springframework . beans . factory . FactoryBean ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; public class FeignClientFactoryBean implements FactoryBean < Object > { private static final ConcurrentHashMap < Class < ? extends Encoder > , Encoder > encoderCache = new ConcurrentHashMap < Class < ? extends Encoder > , Encoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends Decoder > , Decoder > decoderCache = new ConcurrentHashMap < Class < ? extends Decoder > , Decoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > errorDecoderCache = new ConcurrentHashMap < Class < ? extends ErrorDecoder > , ErrorDecoder > ( ) ; private static final ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > interceptorCache = new ConcurrentHashMap < Class < ? extends RequestInterceptor > , RequestInterceptor > ( ) ; private static final ConcurrentHashMap < Class < ? extends Retryer > , Retryer > retryerCache = new ConcurrentHashMap < Class < ? extends Retryer > , Retryer > ( ) ; private static final ConcurrentHashMap < Class < ? extends Contract > , Contract > contractCache = new ConcurrentHashMap < Class < ? extends Contract > , Contract > ( ) ; private Class < ? > type ; private String url ; private Class < ? extends Encoder > encoderType ; private Class < ? extends Decoder > decoderType ; private Class < ? extends ErrorDecoder > errorDecoderType ; private Class < ? extends RequestInterceptor > [ ] interceptorTypes ; private Class < ? extends Retryer > [ ] retryerTypes ; private Class < ? extends Contract > [ ] contractTypes ; private Client client ; @ Override public Object getObject ( ) throws Exception { Feign . Builder builder = Feign . builder ( ) ; Encoder encoder = getOrCreateEncoder ( encoderType ) ; if ( encoder != null ) { builder . encoder ( encoder ) ; } Decoder decoder = getOrCreateDecoder ( decoderType ) ; if ( decoder != null ) { builder . decoder ( decoder ) ; } ErrorDecoder errorDecoder = getOrCreateErrorDecoder ( errorDecoderType ) ; if ( errorDecoder != null ) { builder . errorDecoder ( errorDecoder ) ; } List < RequestInterceptor > interceptors = getOrCreateInterceptors ( interceptorTypes ) ; if ( CollectionUtil . isNotEmpty ( interceptors ) ) { builder . requestInterceptors ( interceptors ) ; } Retryer retryer = getOrCreateRetryer ( retryerTypes ) ; if ( retryer != null ) { builder . retryer ( retryer ) ; } Contract contract = getOrCreateContract ( contractTypes ) ; if ( contract != null ) { builder . contract ( contract ) ; } return builder . client ( client ) . target ( type , url ) ; } @ Override public Class < ? > getObjectType ( ) { return type ; } private Encoder getOrCreateEncoder ( Class < ? extends Encoder > encoderType ) { return getOrCreate ( encoderCache , encoderType ) ; } private Decoder getOrCreateDecoder ( Class < ? extends Decoder > decoderType ) { return getOrCreate ( decoderCache , decoderType ) ; } private ErrorDecoder getOrCreateErrorDecoder ( Class < ? extends ErrorDecoder > errorDecoderType ) { if ( errorDecoderType == null || errorDecoderType == ErrorDecoder . class ) { return null ; } return getOrCreate ( errorDecoderCache , errorDecoderType ) ; } private List < RequestInterceptor > getOrCreateInterceptors ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { if ( interceptorTypes == null || interceptorTypes . length == <NUM_LIT> ) { return null ; } List < RequestInterceptor > interceptors = new ArrayList < RequestInterceptor > ( ) ; for ( Class < ? extends RequestInterceptor > interceptorType : interceptorTypes ) { RequestInterceptor interceptor = getOrCreate ( interceptorCache , interceptorType ) ; interceptors . add ( interceptor ) ; } return interceptors ; } private Retryer getOrCreateRetryer ( Class < ? extends Retryer > [ ] retryerTypes ) { if ( retryerTypes == null || retryerTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( retryerCache , retryerTypes [ <NUM_LIT> ] ) ; } private Contract getOrCreateContract ( Class < ? extends Contract > [ ] contractTypes ) { if ( contractTypes == null || contractTypes . length == <NUM_LIT> ) { return null ; } return getOrCreate ( contractCache , contractTypes [ <NUM_LIT> ] ) ; } private < T > T getOrCreate ( ConcurrentHashMap < Class < ? extends T > , T > cache , Class < ? extends T > type ) { if ( cache == null || type == null ) { return null ; } T cachedObject = cache . get ( type ) ; if ( cachedObject != null ) { return cachedObject ; } return cache . computeIfAbsent ( type , ( aClass ) -> ReflectionUtil . invokeConstructor ( aClass ) ) ; } public Class < ? > getType ( ) { return type ; } public void setType ( Class < ? > type ) { this . type = type ; } public String getUrl ( ) { return url ; } public void setUrl ( String url ) { this . url = url ; } public Class < ? extends Encoder > getEncoderType ( ) { return encoderType ; } public void setEncoderType ( Class < ? extends Encoder > encoderType ) { this . encoderType = encoderType ; } public Class < ? extends Decoder > getDecoderType ( ) { return decoderType ; } public void setDecoderType ( Class < ? extends Decoder > decoderType ) { this . decoderType = decoderType ; } public Class < ? extends ErrorDecoder > getErrorDecoderType ( ) { return errorDecoderType ; } public void setErrorDecoderType ( Class < ? extends ErrorDecoder > errorDecoderType ) { this . errorDecoderType = errorDecoderType ; } public Class < ? extends RequestInterceptor > [ ] getInterceptorTypes ( ) { return interceptorTypes ; } public void setInterceptorTypes ( Class < ? extends RequestInterceptor > [ ] interceptorTypes ) { this . interceptorTypes = interceptorTypes ; } public Class < ? extends Retryer > [ ] getRetryerTypes ( ) { return retryerTypes ; }", "output": "public void setRetryerTypes ( Class < ? extends Retryer > [ ] retryerTypes ) { this . retryerTypes = retryerTypes ; } public Class < ? extends Contract > [ ] getContractTypes ( ) { return contractTypes ; } public void setContractTypes ( Class < ? extends Contract > [ ] contractTypes ) { this . contractTypes = contractTypes ; } public Client getClient ( ) { return client ; } public void setClient ( Client client ) { this . client = client ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . form . GradeForm ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . service . IGradeService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . NotNull ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class GradeController { @ Resource private IGradeService gradeService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < GradeVO > > getGrade ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String gradeName ) { return gradeService . getPaging ( pageNum , pageSize , gradeName ) ; } @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > addGrade ( @ Validated @ RequestBody GradeForm gradeForm ) { return gradeService . addGrade ( gradeForm ) ;", "output": "} @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > updateGrade ( @ PathVariable ( \"<STR_LIT>\" ) @ NotNull Integer id , @ Validated @ RequestBody GradeForm gradeForm ) { return gradeService . updateGrade ( id , gradeForm ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > deleteGrade ( @ PathVariable ( \"<STR_LIT>\" ) @ NotNull Integer id ) { return gradeService . deleteGrade ( id ) ; } @ PatchMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > removeUserGrade ( @ PathVariable ( \"<STR_LIT>\" ) @ NotBlank String ids ) { return gradeService . removeUserGrade ( ids ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < List < GradeVO > > getAllGrade ( ) { return gradeService . getAllGrade ( ) ; } }"}, {"input": "package ginyi . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import ginyi . system . domain . SysMenu ; import ginyi . system . domain . model . dto . MenuDto ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysMenuMapper extends BaseMapper < SysMenu > { public List < String > selectMenuPermsByUserId ( Long userId ) ; public List < String > selectMenuPermsByRoleId ( Long roleId ) ; public List < SysMenu > selectMenuListByUserId ( Long userId ) ; public List < SysMenu > selectMenuListByAdmin ( @ Param ( \"<STR_LIT>\" ) MenuDto menuDto ) ; public boolean insertMenu ( @ Param ( \"<STR_LIT>\" ) MenuDto menuDto ) ; public void updateMenu ( @ Param ( \"<STR_LIT>\" ) MenuDto menuDto ) ; public void updateMenuStatus ( @ Param ( \"<STR_LIT>\" ) MenuDto menuDto ) ;", "output": "}"}, {"input": "package top . kangert . kspider . expression ; import java . util . List ; public interface DynamicMethod { Object execute ( String methodName , List < Object > parameters ) ;", "output": "}"}, {"input": "package com . youlai . system . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . mapper . SysDictItemMapper ; import com . youlai . system . model . entity . SysDictItem ; import com . youlai . system . service . SysDictItemService ; import lombok . RequiredArgsConstructor ; import org . springframework . stereotype . Service ; @ Service @ RequiredArgsConstructor public class SysDictItemServiceImpl extends ServiceImpl < SysDictItemMapper , SysDictItem > implements SysDictItemService {", "output": "}"}, {"input": "package ginyi . framework . security . service ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import ginyi . framework . security . utils . SecurityUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . SysMenu ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . MenuDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . mapper . SysMenuMapper ; import ginyi . system . service . ISysMenuService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . annotation . Resource ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Slf4j @ Service public class SysMenuServiceImpl implements ISysMenuService { @ Resource private SysMenuMapper menuMapper ; @ Resource private RedisCache redisCache ; @ Override public Set < String > selectMenuPermsByRoleId ( Long roleId ) { List < String > perms = menuMapper . selectMenuPermsByRoleId ( roleId ) ; Set < String > permsSet = new HashSet < > ( ) ; for ( String perm : perms ) { if ( StringUtils . isNotEmpty ( perm ) ) { permsSet . addAll ( Arrays . asList ( perm . trim ( ) . split ( \"<STR_LIT>\" ) ) ) ; } } return permsSet ; } @ Override public Set < String > selectMenuPermsByUserId ( Long userId ) { List < String > perms = menuMapper . selectMenuPermsByUserId ( userId ) ; Set < String > permsSet = new HashSet < > ( ) ; for ( String perm : perms ) { if ( StringUtils . isNotEmpty ( perm ) ) { permsSet . addAll ( Arrays . asList ( perm . trim ( ) . split ( \"<STR_LIT>\" ) ) ) ; } } return permsSet ; } @ Override public BaseVo < SysMenu > selectMenuList ( ) { List < SysMenu > menuList ; BaseVo < SysMenu > baseVo = new BaseVo < > ( ) ; LoginUser user = SecurityUtils . getLoginUser ( ) ; menuList = redisCache . getCacheList ( CacheConstants . MENU_USER_LIST_KEY + user . getUsername ( ) , SysMenu . class ) ; if ( menuList . size ( ) > <NUM_LIT> ) { baseVo . setList ( menuList ) ; baseVo . setCount ( menuList . size ( ) ) ; return baseVo ; } boolean isAdmin = SysUser . isAdmin ( user . getUserId ( ) ) ; LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysMenu :: getMenuType , \"<STR_LIT>\" ) . or ( ) . eq ( SysMenu :: getMenuType , \"<STR_LIT>\" ) ; List < SysMenu > list = isAdmin ? menuMapper . selectList ( queryWrapper ) : menuMapper . selectMenuListByUserId ( user . getUserId ( ) ) ; menuList = list . stream ( ) . filter ( menu -> menu . getParentId ( ) . equals ( <NUM_LIT> ) ) . map ( menu -> convertToMenuTree ( menu , list ) ) . collect ( Collectors . toList ( ) ) ; redisCache . setCacheList ( CacheConstants . MENU_USER_LIST_KEY + user . getUsername ( ) , menuList ) ; baseVo . setList ( menuList ) ; baseVo . setCount ( menuList . size ( ) ) ; return baseVo ; } @ Override public BaseVo < SysMenu > list ( MenuDto menuDto ) { List < SysMenu > list = menuMapper . selectMenuListByAdmin ( menuDto ) ; List < SysMenu > menuList = list . stream ( ) . filter ( menu -> menu . getParentId ( ) . equals ( <NUM_LIT> ) ) . map ( menu -> convertToMenuTree ( menu , list ) ) . collect ( Collectors . toList ( ) ) ; BaseVo < SysMenu > baseVo = new BaseVo < > ( ) ; baseVo . setList ( menuList ) ; baseVo . setCount ( menuList . size ( ) ) ; return baseVo ; } public SysMenu convertToMenuTree ( SysMenu menu , List < SysMenu > list ) { SysMenu sysMenu = new SysMenu ( ) ; BeanUtils . copyProperties ( menu , sysMenu ) ; List < SysMenu > children = list . stream ( ) . filter ( subMenu -> menu . getMenuId ( ) . equals ( subMenu . getParentId ( ) ) ) . map ( subMenu -> convertToMenuTree ( subMenu , list ) ) . collect ( Collectors . toList ( ) ) ; sysMenu . setChildren ( children ) ; return sysMenu ; } @ Override public void addMenu ( MenuDto menuDto ) { if ( \"<STR_LIT>\" . equalsIgnoreCase ( menuDto . getMenuType ( ) ) ) { if ( menuDto . getComponent ( ) . isEmpty ( ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . MENU_COMPONENT_NOT_EXIST ) ; } if ( menuDto . getPath ( ) . isEmpty ( ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . MENU_PATH_NOT_EXIST ) ; } } LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysMenu :: getMenuName , menuDto . getMenuName ( ) ) ; SysMenu result = menuMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( result ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . MENU_NAME_USED ) ; } menuMapper . insertMenu ( menuDto ) ; redisCache . removeCacheObject ( CacheConstants . MENU_KEY_PREFIX ) ; } @ Override public SysMenu getMenuById ( Long menuId ) { SysMenu menu ; if ( redisCache . hasKey ( CacheConstants . MENU_NOT_EXIST_KEY + menuId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . MENU_NOT_EXIST ) ; } menu = redisCache . getCacheObject ( CacheConstants . MENU_DETAILS_BY_ID_KEY + menuId , SysMenu . class ) ; if ( StringUtils . isNotNull ( menu ) ) { return menu ; } LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysMenu :: getMenuId , menuId ) ; menu = menuMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( menu ) ) { redisCache . setCacheObject ( CacheConstants . MENU_NOT_EXIST_KEY + menuId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . MENU_NOT_EXIST ) ; } redisCache . setCacheObject ( CacheConstants . MENU_DETAILS_BY_ID_KEY + menuId , menu ) ; return menu ; } @ Override public void updateMenu ( MenuDto menuDto ) { if ( \"<STR_LIT>\" . equalsIgnoreCase ( menuDto . getMenuType ( ) ) ) { if ( StringUtils . isNull ( menuDto . getComponent ( ) ) || menuDto . getComponent ( ) . isEmpty ( ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . MENU_COMPONENT_NOT_EXIST ) ; } if ( StringUtils . isNull ( menuDto . getPath ( ) ) || menuDto . getPath ( ) . isEmpty ( ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . MENU_PATH_NOT_EXIST ) ; } } LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysMenu :: getMenuId , menuDto . getMenuId ( ) ) ; SysMenu result = menuMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( result ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . MENU_NOT_EXIST ) ; } Long parentId = StringUtils . isNull ( menuDto . getParentId ( ) ) ? <NUM_LIT> : menuDto . getParentId ( ) ; queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( parentId != <NUM_LIT> , SysMenu :: getMenuId , parentId ) ; List < SysMenu > menuList = menuMapper . selectList ( queryWrapper ) ; if ( menuList . size ( ) == <NUM_LIT> ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . MENU_PARENT_NOT_EXIST ) ; } menuMapper . updateMenu ( menuDto ) ; redisCache . removeCacheObject ( CacheConstants . MENU_KEY_PREFIX ) ; } @ Override public void removeMenuById ( Long menuId ) { if ( redisCache . hasKey ( CacheConstants . MENU_NOT_EXIST_KEY + menuId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuId + CommonMessageConstants . MENU_NOT_EXIST ) ; } LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysMenu :: getMenuId , menuId ) ; SysMenu menu = menuMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( menu ) ) { redisCache . setCacheObject ( CacheConstants . MENU_NOT_EXIST_KEY + menuId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuId + CommonMessageConstants . MENU_NOT_EXIST ) ; } menuMapper . deleteById ( menuId ) ; redisCache . removeCacheObject ( CacheConstants . MENU_KEY_PREFIX ) ; } @ Override @ Transactional public void removeMenuByIds ( Set < Long > ids ) { if ( ids . size ( ) > <NUM_LIT> ) { List < SysMenu > menuList ; menuList = redisCache . getCacheList ( CacheConstants . MENU_LIST_KEY , SysMenu . class ) ; if ( StringUtils . isNull ( menuList ) || menuList . size ( ) == <NUM_LIT> ) { LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; menuList = menuMapper . selectList ( queryWrapper ) ; } for ( Long menuId : ids ) { if ( redisCache . hasKey ( CacheConstants . MENU_NOT_EXIST_KEY + menuId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuId + CommonMessageConstants . MENU_NOT_EXIST ) ; }", "output": "boolean exist = menuList . stream ( ) . anyMatch ( menu -> menuId . equals ( menu . getMenuId ( ) ) ) ; if ( ! exist ) { redisCache . setCacheObject ( CacheConstants . MENU_NOT_EXIST_KEY + menuId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuId + CommonMessageConstants . MENU_NOT_EXIST ) ; } } menuMapper . deleteBatchIds ( ids ) ; redisCache . removeCacheObject ( CacheConstants . MENU_KEY_PREFIX ) ; } else { throw new CommonException ( StateCode . ERROR_REQUEST_PARAMS , CommonMessageConstants . SYS_REQUEST_ILLEGAL ) ; } } @ Override public void updateStatus ( MenuDto menuDto ) { if ( StringUtils . isNull ( menuDto . getMenuId ( ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . MENU_ID_NOT_FOUND ) ; } if ( ! ( \"<STR_LIT>\" . equals ( menuDto . getStatus ( ) ) || \"<STR_LIT>\" . equals ( menuDto . getStatus ( ) ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . MENU_STATUS_ILLEGAL ) ; } if ( redisCache . hasKey ( CacheConstants . MENU_NOT_EXIST_KEY + menuDto . getMenuId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuDto . getMenuId ( ) + CommonMessageConstants . MENU_NOT_EXIST ) ; } LambdaQueryWrapper < SysMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysMenu :: getMenuId , menuDto . getMenuId ( ) ) ; SysMenu menu = menuMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( menu ) ) { redisCache . setCacheObject ( CacheConstants . MENU_NOT_EXIST_KEY + menuDto . getMenuId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuDto . getMenuId ( ) + CommonMessageConstants . MENU_NOT_EXIST ) ; } menuMapper . updateMenuStatus ( menuDto ) ; } }"}, {"input": "package me . zhengjie . modules . mnt . service . impl ; import cn . hutool . core . util . IdUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . mapper . DatabaseMapper ; import me . zhengjie . modules . mnt . service . DatabaseService ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import me . zhengjie . modules . mnt . util . SqlUtils ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Slf4j @ Service @ RequiredArgsConstructor public class DatabaseServiceImpl extends ServiceImpl < DatabaseMapper , Database > implements DatabaseService { private final DatabaseMapper databaseMapper ; @ Override public PageResult < Database > queryAll ( DatabaseQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( databaseMapper . findAll ( criteria , page ) ) ; } @ Override public List < Database > queryAll ( DatabaseQueryCriteria criteria ) { return databaseMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Database resources ) { resources . setId ( IdUtil . simpleUUID ( ) ) ; save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Database resources ) { Database database = getById ( resources . getId ( ) ) ; database . copy ( resources ) ; saveOrUpdate ( database ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < String > ids ) { removeBatchByIds ( ids ) ;", "output": "} @ Override public boolean testConnection ( Database resources ) { try { return SqlUtils . testConnection ( resources . getJdbcUrl ( ) , resources . getUserName ( ) , resources . getPwd ( ) ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; return false ; } } @ Override public void download ( List < Database > databases , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Database database : databases ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , database . getName ( ) ) ; map . put ( \"<STR_LIT>\" , database . getJdbcUrl ( ) ) ; map . put ( \"<STR_LIT>\" , database . getUserName ( ) ) ; map . put ( \"<STR_LIT>\" , database . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } }"}, {"input": "package com . oddfar . campus . framework . web . service ; import cn . hutool . extra . spring . SpringUtil ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . constant . UserConstants ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . event . LogininforEvent ; import com . oddfar . campus . common . domain . model . RegisterBody ; import com . oddfar . campus . common . exception . user . CaptchaException ; import com . oddfar . campus . common . exception . user . CaptchaExpireException ; import com . oddfar . campus . common . utils . MessageUtils ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . service . SysConfigService ; import com . oddfar . campus . framework . service . SysUserService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; @ Component public class SysRegisterService { @ Autowired private SysUserService userService ; @ Autowired private SysConfigService configService ; @ Autowired private RedisCache redisCache ; public String register ( RegisterBody registerBody ) { String msg = \"<STR_LIT>\" , username = registerBody . getUsername ( ) , password = registerBody . getPassword ( ) ;", "output": "SysUserEntity sysUser = new SysUserEntity ( ) ; sysUser . setUserName ( username ) ; boolean captchaEnabled = configService . selectCaptchaEnabled ( ) ; if ( captchaEnabled ) { validateCaptcha ( username , registerBody . getCode ( ) , registerBody . getUuid ( ) ) ; } if ( StringUtils . isEmpty ( username ) ) { msg = \"<STR_LIT>\" ; } else if ( StringUtils . isEmpty ( password ) ) { msg = \"<STR_LIT>\" ; } else if ( username . length ( ) < UserConstants . USERNAME_MIN_LENGTH || username . length ( ) > UserConstants . USERNAME_MAX_LENGTH ) { msg = \"<STR_LIT>\" ; } else if ( password . length ( ) < UserConstants . PASSWORD_MIN_LENGTH || password . length ( ) > UserConstants . PASSWORD_MAX_LENGTH ) { msg = \"<STR_LIT>\" ; } else if ( ! ( userService . checkUserNameUnique ( sysUser ) ) ) { msg = \"<STR_LIT>\" + username + \"<STR_LIT>\" ; } else { sysUser . setNickName ( username ) ; sysUser . setPassword ( SecurityUtils . encryptPassword ( password ) ) ; boolean regFlag = userService . registerUser ( sysUser ) ; if ( ! regFlag ) { msg = \"<STR_LIT>\" ; } else { LogininforEvent logininforEvent = new LogininforEvent ( ) ; logininforEvent . setUsername ( username ) ; logininforEvent . setStatus ( Constants . REGISTER ) ; logininforEvent . setMessage ( MessageUtils . message ( \"<STR_LIT>\" ) ) ; logininforEvent . setRequest ( ServletUtils . getRequest2 ( ) ) ; SpringUtil . getApplicationContext ( ) . publishEvent ( logininforEvent ) ; } } return msg ; } public void validateCaptcha ( String username , String code , String uuid ) { String verifyKey = CacheConstants . CAPTCHA_CODE_KEY + StringUtils . nvl ( uuid , \"<STR_LIT>\" ) ; String captcha = redisCache . getCacheObject ( verifyKey ) ; redisCache . deleteObject ( verifyKey ) ; if ( captcha == null ) { throw new CaptchaExpireException ( ) ; } if ( ! code . equalsIgnoreCase ( captcha ) ) { throw new CaptchaException ( ) ; } } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . Option ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IOptionService extends IService < Option > {", "output": "}"}, {"input": "package org . springblade . cgform . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springblade . cgform . entity . FlowForm ; import org . springblade . cgform . mapper . FlowFormMapper ; import org . springblade . cgform . service . IFlowFormService ; import org . springframework . stereotype . Service ; @ Service public class FlowFormServiceImpl extends ServiceImpl < FlowFormMapper , FlowForm > implements IFlowFormService {", "output": "}"}, {"input": "package org . springblade . config . util ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringUtil ; import org . springblade . core . tool . utils . WebUtil ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; public class MjkjUtil { public static String stringTojson ( String text ) { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( text ) ) { Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; String s = map . get ( header ) ; return s ; } return \"<STR_LIT>\" ;", "output": "} }"}, {"input": "package com . youlai . system . plugin . mybatis . annotation ; import java . lang . annotation . * ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface DataPermission { String deptAlias ( ) default \"<STR_LIT>\" ; String deptIdColumnName ( ) default \"<STR_LIT>\" ; String userAlias ( ) default \"<STR_LIT>\" ;", "output": "String userIdColumnName ( ) default \"<STR_LIT>\" ; }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class UserBook implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer examId ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer quId ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; public Integer getId ( ) { return id ; }", "output": "public void setId ( Integer id ) { this . id = id ; } public Integer getExamId ( ) { return examId ; } public void setExamId ( Integer examId ) { this . examId = examId ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getQuId ( ) { return quId ; } public void setQuId ( Integer quId ) { this . quId = quId ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + quId + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" ; } }"}, {"input": "package com . youlai . system . model . form ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import jakarta . validation . constraints . NotBlank ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class RoleForm { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String code ; @ Schema ( description = \"<STR_LIT>\" ) private Integer sort ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" ) private Integer dataScope ;", "output": "}"}, {"input": "package com . oddfar . campus . common . exception . user ; import com . oddfar . campus . common . exception . base . BaseException ; public class UserException extends BaseException { private static final long serialVersionUID = <NUM_LIT> ; public UserException ( String code , Object [ ] args ) { super ( \"<STR_LIT>\" , code , args , null ) ; }", "output": "}"}, {"input": "package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . Email ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . Date ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class User extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Set < Role > roles ; @ TableField ( exist = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Set < Job > jobs ; @ TableField ( value = \"<STR_LIT>\" ) @ ApiModelProperty ( hidden = true ) private Long deptId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableField ( exist = false ) private Dept dept ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String username ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nickName ; @ Email @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String email ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String phone ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String gender ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String avatarName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String avatarPath ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String password ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean enabled ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Boolean isAdmin = false ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Date pwdResetTime ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } User user = ( User ) o ; return Objects . equals ( id , user . id ) && Objects . equals ( username , user . username ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id , username ) ;", "output": "} }"}, {"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . TableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOne extends FileProvider implements IGenerate { private TableVo tableVo ; private List < ColumnVo > columns ; private List < ColumnVo > originalColumns ; public CodeGenerateOne ( TableVo tableVo ) { this . tableVo = tableVo ; } public CodeGenerateOne ( TableVo tableVo , List < ColumnVo > columns , List < ColumnVo > originalColumns ) { this . tableVo = tableVo ; this . columns = columns ; this . originalColumns = originalColumns ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , tableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( tableVo . getFieldRequiredNum ( ) == null ) { tableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getSearchFieldNum ( ) == null ) { tableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( tableVo . getFieldRowNum ( ) == null ) { tableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , tableVo ) ; try { if ( ( columns == null ) || ( columns . size ( ) == <NUM_LIT> ) ) { columns = DbReadTableUtil . getColumns ( tableVo . getTableName ( ) ) ; }", "output": "localHashMap . put ( \"<STR_LIT>\" , columns ) ; if ( ( originalColumns == null ) || ( originalColumns . size ( ) == <NUM_LIT> ) ) { originalColumns = DbReadTableUtil . getOriginalColumns ( tableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , originalColumns ) ; for ( ColumnVo localColumnVo : originalColumns ) { if ( localColumnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , localColumnVo . getFieldType ( ) ) ; } } } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ; } public List < String > generateCodeFile ( String stylePath ) throws Exception { log . debug ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; String str1 = DbConfig . projectPath ; Map < String , Object > localMap = dtaMapMethod ( ) ; String templatepath = DbConfig . templatepath ; if ( strSubStartEnd ( templatepath , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { templatepath = \"<STR_LIT>\" + strSubStartEnd ( templatepath , \"<STR_LIT>\" ) + \"<STR_LIT>\" ; DbConfig . setTemplatepath ( templatepath ) ; } FileVo locala = new FileVo ( templatepath ) ; locala . setStylePath ( stylePath ) ; generateCodeFile ( locala , str1 , localMap ) ; log . info ( \"<STR_LIT>\" + tableVo . getTableName ( ) + \"<STR_LIT>\" ) ; return msg ; } public List < String > generateCodeFile ( String projectPath , String templatePath , String stylePath ) throws Exception { if ( ( projectPath != null ) && ( ! \"<STR_LIT>\" . equals ( projectPath ) ) ) { DbConfig . setProjectPath ( projectPath ) ; } if ( ( templatePath != null ) && ( ! \"<STR_LIT>\" . equals ( templatePath ) ) ) { DbConfig . setTemplatepath ( templatePath ) ; } generateCodeFile ( stylePath ) ; return msg ; } }"}, {"input": "package top . kangert . kspider . logback ; import ch . qos . logback . classic . spi . ILoggingEvent ; import ch . qos . logback . classic . spi . ThrowableProxy ; import ch . qos . logback . core . UnsynchronizedAppenderBase ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . context . SpiderContextHolder ; import top . kangert . kspider . context . SpiderWebSocketContext ; import top . kangert . kspider . model . SpiderLog ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class SpiderFlowWebSocketAppender extends UnsynchronizedAppenderBase < ILoggingEvent > { @ Override protected void append ( ILoggingEvent event ) { SpiderContext context = SpiderContextHolder . get ( ) ; if ( context instanceof SpiderWebSocketContext ) { SpiderWebSocketContext socketContext = ( SpiderWebSocketContext ) context ; Object [ ] argumentArray = event . getArgumentArray ( ) ; List < Object > arguments = argumentArray == null ? Collections . emptyList ( ) : new ArrayList < > ( Arrays . asList ( argumentArray ) ) ; ThrowableProxy throwableProxy = ( ThrowableProxy ) event . getThrowableProxy ( ) ; if ( throwableProxy != null ) { arguments . add ( throwableProxy . getThrowable ( ) ) ; }", "output": "socketContext . log ( new SpiderLog ( event . getLevel ( ) . levelStr . toLowerCase ( ) , event . getMessage ( ) , arguments ) ) ; } } }"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . youlai . system . common . base . BaseEntity ; import lombok . Getter ; import lombok . Setter ; @ Getter @ Setter public class SysDept extends BaseEntity { @ TableId ( type = IdType . AUTO ) private Long id ; private String name ; private String code ; private Long parentId ; private String treePath ; private Integer sort ; private Integer status ; private Long createBy ; private Long updateBy ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosBeanDefinitionRegistrar . class ) public @ interface EnableNacos { NacosProperties globalProperties ( ) ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustContractParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String closeLogContractOrderCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > oneKeySymbolNameList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String zyzsType ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface ServerService extends IService < Server > { PageResult < Server > queryAll ( ServerQueryCriteria criteria , Page < Object > page ) ; List < Server > queryAll ( ServerQueryCriteria criteria ) ; void create ( Server resources ) ; void update ( Server resources ) ; void delete ( Set < Long > ids ) ; Server findByIp ( String ip ) ;", "output": "Boolean testConnect ( Server resources ) ; void download ( List < Server > queryAll , HttpServletResponse response ) throws IOException ; }"}, {"input": "package com . oddfar . campus . common . core ; import cn . hutool . core . util . ArrayUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . CollectionUtils ; import com . baomidou . mybatisplus . core . toolkit . support . SFunction ; import org . springframework . util . StringUtils ; import java . util . Collection ; import java . util . Map ; public class LambdaQueryWrapperX < T > extends LambdaQueryWrapper < T > { public LambdaQueryWrapperX < T > likeIfPresent ( SFunction < T , ? > column , String val ) { if ( StringUtils . hasText ( val ) ) { return ( LambdaQueryWrapperX < T > ) super . like ( column , val ) ; } return this ; } public LambdaQueryWrapperX < T > inIfPresent ( SFunction < T , ? > column , Collection < ? > values ) { if ( ! CollectionUtils . isEmpty ( values ) ) { return ( LambdaQueryWrapperX < T > ) super . in ( column , values ) ; } return this ; } public LambdaQueryWrapperX < T > inIfPresent ( SFunction < T , ? > column , Object ... values ) { if ( ! ArrayUtil . isEmpty ( values ) ) { return ( LambdaQueryWrapperX < T > ) super . in ( column , values ) ; } return this ; } public LambdaQueryWrapperX < T > eqIfPresent ( SFunction < T , ? > column , Object val ) { if ( val != null ) { return ( LambdaQueryWrapperX < T > ) super . eq ( column , val ) ; } return this ; } public LambdaQueryWrapperX < T > neIfPresent ( SFunction < T , ? > column , Object val ) { if ( val != null ) { return ( LambdaQueryWrapperX < T > ) super . ne ( column , val ) ; } return this ; } public LambdaQueryWrapperX < T > gtIfPresent ( SFunction < T , ? > column , Object val ) { if ( val != null ) { return ( LambdaQueryWrapperX < T > ) super . gt ( column , val ) ; }", "output": "return this ; } public LambdaQueryWrapperX < T > geIfPresent ( SFunction < T , ? > column , Object val ) { if ( val != null ) { return ( LambdaQueryWrapperX < T > ) super . ge ( column , val ) ; } return this ; } public LambdaQueryWrapperX < T > ltIfPresent ( SFunction < T , ? > column , Object val ) { if ( val != null ) { return ( LambdaQueryWrapperX < T > ) super . lt ( column , val ) ; } return this ; } public LambdaQueryWrapperX < T > leIfPresent ( SFunction < T , ? > column , Object val ) { if ( val != null ) { return ( LambdaQueryWrapperX < T > ) super . le ( column , val ) ; } return this ; } public LambdaQueryWrapperX < T > betweenIfPresent ( SFunction < T , ? > column , Object val1 , Object val2 ) { if ( val1 != null && val2 != null ) { return ( LambdaQueryWrapperX < T > ) super . between ( column , val1 , val2 ) ; } if ( val1 != null ) { return ( LambdaQueryWrapperX < T > ) ge ( column , val1 ) ; } if ( val2 != null ) { return ( LambdaQueryWrapperX < T > ) le ( column , val2 ) ; } return this ; } public LambdaQueryWrapperX < T > betweenIfPresent ( SFunction < T , ? > column , Object [ ] values ) { Object val1 = ArrayUtil . get ( values , <NUM_LIT> ) ; Object val2 = ArrayUtil . get ( values , <NUM_LIT> ) ; return betweenIfPresent ( column , val1 , val2 ) ; } public LambdaQueryWrapperX < T > betweenIfPresent ( SFunction < T , ? > column , Map < String , Object > values ) { String val1 = ( String ) values . get ( \"<STR_LIT>\" ) ; String val2 = ( String ) values . get ( \"<STR_LIT>\" ) ; return betweenIfPresent ( column , val1 , val2 ) ; } @ Override public LambdaQueryWrapperX < T > eq ( boolean condition , SFunction < T , ? > column , Object val ) { super . eq ( condition , column , val ) ; return this ; } @ Override public LambdaQueryWrapperX < T > eq ( SFunction < T , ? > column , Object val ) { super . eq ( column , val ) ; return this ; } @ Override public LambdaQueryWrapperX < T > orderByDesc ( SFunction < T , ? > column ) { super . orderByDesc ( true , column ) ; return this ; } @ Override public LambdaQueryWrapperX < T > last ( String lastSql ) { super . last ( lastSql ) ; return this ; } @ Override public LambdaQueryWrapperX < T > in ( SFunction < T , ? > column , Collection < ? > coll ) { super . in ( column , coll ) ; return this ; } }"}, {"input": "package org . springblade . common ; import org . springframework . context . ApplicationEvent ; public class ActionLogEvent extends ApplicationEvent { public ActionLogEvent ( Object source ) { super ( source ) ; }", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . reflect ; public class ClassLoaderUtil { public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { } if ( cl == null ) { cl = ClassLoaderUtil . class . getClassLoader ( ) ; if ( cl == null ) { try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( Throwable ex ) {", "output": "} } } return cl ; } public static boolean isPresent ( String className , ClassLoader classLoader ) { try { classLoader . loadClass ( className ) ; return true ; } catch ( Throwable ex ) { return false ; } } }"}, {"input": "package com . youlai . system . enums ; import com . fasterxml . jackson . annotation . JsonValue ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; @ Schema ( enumAsRef = true ) @ Getter public enum LogModuleEnum { LOGIN ( \"<STR_LIT>\" ) , USER ( \"<STR_LIT>\" ) , DEPT ( \"<STR_LIT>\" ) , ROLE ( \"<STR_LIT>\" ) , MENU ( \"<STR_LIT>\" ) , DICT ( \"<STR_LIT>\" ) , OTHER ( \"<STR_LIT>\" ) ; @ JsonValue private final String moduleName ;", "output": "LogModuleEnum ( String moduleName ) { this . moduleName = moduleName ; } }"}, {"input": "package cn . org . alan . exam . model . vo . userbook ; import cn . org . alan . exam . model . entity . Option ; import lombok . Data ; import java . util . List ; @ Data public class UserExamBookVO { private String content ; private List < Option > answerList ; private String rightAnswers ; private String analyse ; private String reply ;", "output": "}"}, {"input": "package com . yf . base . utils ; import javax . imageio . stream . FileImageInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . util . Base64 ; public class ImageUtils { public static byte [ ] image2byte ( String path ) { byte [ ] data = null ; FileImageInputStream input = null ; try { input = new FileImageInputStream ( new File ( path ) ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ <NUM_LIT> ] ; int numBytesRead = <NUM_LIT> ; while ( ( numBytesRead = input . read ( buf ) ) != - <NUM_LIT> ) { output . write ( buf , <NUM_LIT> , numBytesRead ) ; } data = output . toByteArray ( ) ; output . close ( ) ; input . close ( ) ; } catch ( FileNotFoundException ex1 ) { ex1 . printStackTrace ( ) ; } catch ( IOException ex1 ) { ex1 . printStackTrace ( ) ; } return data ; } public static String imageToBase64Str ( String imgFile ) { try { byte [ ] fileContent = org . apache . commons . io . FileUtils . readFileToByteArray ( new File ( imgFile ) ) ;", "output": "return Base64 . getEncoder ( ) . encodeToString ( fileContent ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; } }"}, {"input": "package org . example . dddworkspace . application . service ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; public interface WorkspaceMsCommandService { WorkspaceResult create ( WorkspaceCreateCommand command ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . service . ServerService ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ Api ( tags = \"<STR_LIT>\" ) @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class ServerController { private final ServerService serverService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportServerDeploy ( HttpServletResponse response , ServerQueryCriteria criteria ) throws IOException { serverService . download ( serverService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Server > > queryServerDeploy ( ServerQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( serverService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createServerDeploy ( @ Validated @ RequestBody Server resources ) { serverService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ;", "output": "} @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateServerDeploy ( @ Validated @ RequestBody Server resources ) { serverService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteServerDeploy ( @ RequestBody Set < Long > ids ) { serverService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > testConnectServerDeploy ( @ Validated @ RequestBody Server resources ) { return new ResponseEntity < > ( serverService . testConnect ( resources ) , HttpStatus . CREATED ) ; } }"}, {"input": "package com . oddfar . campus . common . annotation ; import com . fasterxml . jackson . annotation . JacksonAnnotationsInside ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . oddfar . campus . common . config . SensitiveSerializer ; import com . oddfar . campus . common . enums . SensitiveStrategy ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . FIELD ) @ JacksonAnnotationsInside @ JsonSerialize ( using = SensitiveSerializer . class ) public @ interface Sensitive { SensitiveStrategy strategy ( ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . service . AppService ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class AppController { private final AppService appService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportApp ( HttpServletResponse response , AppQueryCriteria criteria ) throws IOException { appService . download ( appService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < App > > queryApp ( AppQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( appService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createApp ( @ Validated @ RequestBody App resources ) { appService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateApp ( @ Validated @ RequestBody App resources ) { appService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteApp ( @ RequestBody Set < Long > ids ) { appService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; }", "output": "}"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . domain . vo . SessionVO ; import com . xcs . wx . service . SessionService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class SessionController { private final SessionService sessionService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < SessionVO > > list ( ) { return ResponseVO . ok ( sessionService . querySession ( ) ) ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . oddfar . campus . common . domain . BaseEntity ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . NoArgsConstructor ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Size ; import java . util . Set ; @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ Data @ AllArgsConstructor @ NoArgsConstructor public class SysRoleEntity extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long roleId ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String roleName ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String roleKey ; @ NotBlank ( message = \"<STR_LIT>\" ) private String roleSort ; private boolean menuCheckStrictly ; private String status ; @ TableField ( exist = false ) private boolean flag = false ; @ TableField ( exist = false ) private Long [ ] menuIds ; @ TableField ( exist = false ) private Set < String > permissions ; private String remark ; public SysRoleEntity ( Long roleId ) { this . roleId = roleId ; }", "output": "public boolean isAdmin ( ) { return isAdmin ( this . roleId ) ; } public static boolean isAdmin ( Long roleId ) { return roleId != null && <NUM_LIT> == roleId ; } }"}, {"input": "package ginyi . system . domain . model . dto ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . * ; import java . util . Date ; import java . util . List ; @ EqualsAndHashCode ( callSuper = true ) @ Data public class DeptDto extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = UpdateGroup . class , message = \"<STR_LIT>\" ) private Long deptId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > deptIds ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long parentId ; private String ancestors ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = {", "output": "AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leader ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String phone ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Email ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String email ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date beginTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date endTime ; }"}, {"input": "package com . xcs . wx . aop ; import cn . hutool . core . annotation . AnnotationUtil ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . dynamic . datasource . toolkit . DynamicDataSourceContextHolder ; import com . xcs . wx . util . DSNameUtil ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . springframework . stereotype . Component ; @ Slf4j @ Aspect @ Component public class RepositoryAspect { @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint joinPoint ) throws Throwable { String previousDs = DynamicDataSourceContextHolder . peek ( ) ; try { Class < ? > targetClass = joinPoint . getTarget ( ) . getClass ( ) ; DS dsAnnotation = AnnotationUtil . getAnnotation ( targetClass , DS . class ) ; if ( dsAnnotation != null ) { DynamicDataSourceContextHolder . push ( DSNameUtil . getDSName ( dsAnnotation . value ( ) ) ) ; } return joinPoint . proceed ( ) ; } finally {", "output": "if ( previousDs != null ) { DynamicDataSourceContextHolder . push ( previousDs ) ; } else { DynamicDataSourceContextHolder . clear ( ) ; } } } }"}, {"input": "package com . yf . system . modules . config . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class CfgBase extends Model < CfgBase > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String siteName ; @ TableField ( \"<STR_LIT>\" ) private String loginLogo ; @ TableField ( \"<STR_LIT>\" ) private String loginBg ; @ TableField ( \"<STR_LIT>\" ) private String backLogo ; @ TableField ( \"<STR_LIT>\" ) private String copyRight ;", "output": "}"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlColumn { private String title ; private String dataIndex ; private String align ; private String customRender ; private ScopedSlots scopedSlots ; private String hrefSlotName ; private ScopedSlots jsSlots ; private String jsEnhance ; private Integer width ; private boolean sorter = false ; public OnlColumn ( String title , String dataIndex , Integer width ) { this . align = \"<STR_LIT>\" ;", "output": "this . title = title ; this . dataIndex = dataIndex ; this . width = width ; } }"}, {"input": "package com . oddfar . campus . framework . api . file ; public class MimeTypeUtils { public static final String IMAGE_PNG = \"<STR_LIT>\" ; public static final String IMAGE_JPG = \"<STR_LIT>\" ; public static final String IMAGE_JPEG = \"<STR_LIT>\" ; public static final String IMAGE_BMP = \"<STR_LIT>\" ; public static final String IMAGE_GIF = \"<STR_LIT>\" ; public static final String [ ] IMAGE_EXTENSION = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static final String [ ] FLASH_EXTENSION = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static final String [ ] MEDIA_EXTENSION = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static final String [ ] VIDEO_EXTENSION = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static final String [ ] IMAGE_VIDEO_EXTENSION = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ; public static final String [ ] DEFAULT_ALLOWED_EXTENSION = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static String getExtension ( String prefix ) {", "output": "switch ( prefix ) { case IMAGE_PNG : return \"<STR_LIT>\" ; case IMAGE_JPG : return \"<STR_LIT>\" ; case IMAGE_JPEG : return \"<STR_LIT>\" ; case IMAGE_BMP : return \"<STR_LIT>\" ; case IMAGE_GIF : return \"<STR_LIT>\" ; default : return \"<STR_LIT>\" ; } } }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . NoticeGradeMapper ; import cn . org . alan . exam . model . entity . NoticeGrade ; import cn . org . alan . exam . service . INoticeGradeService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class NoticeGradeServiceImpl extends ServiceImpl < NoticeGradeMapper , NoticeGrade > implements INoticeGradeService {", "output": "}"}, {"input": "package top . kangert . kspider . executor . node . event ; import lombok . AllArgsConstructor ; import lombok . Getter ; import lombok . Setter ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . constant . OutputType ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . model . SpiderOutput ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component public class OutputEventPublisher { @ Autowired private ApplicationEventPublisher eventPublisher ; public void publish ( SpiderContext context , SpiderNode node , List < SpiderOutput . OutputItem > outputItems ) { OutputType [ ] outputTypes = OutputType . values ( ) ; for ( OutputType outputType : outputTypes ) { if ( Constants . YES . equals ( node . getJsonProperty ( outputType . getVariableName ( ) ) ) ) {", "output": "eventPublisher . publishEvent ( new OutputEventBean ( context , node , outputItems , outputType . getVariableName ( ) ) ) ; } } } @ Getter @ Setter @ AllArgsConstructor class OutputEventBean { private SpiderContext context ; private SpiderNode node ; private List < SpiderOutput . OutputItem > outputItems ; private String event ; } }"}, {"input": "package org . springblade . web . constant ; public interface RedisConstant { String sysDict = \"<STR_LIT>\" ; String tableNameAndId = \"<STR_LIT>\" ; String tableNameSymbolName = \"<STR_LIT>\" ; String tableDataList = \"<STR_LIT>\" ;", "output": "String symbolName = \"<STR_LIT>\" ; String symbolUbwName = \"<STR_LIT>\" ; String symbolBbwName = \"<STR_LIT>\" ; String symbolBbwjgName = \"<STR_LIT>\" ; }"}, {"input": "package cn . org . alan . exam . model . form . question ; import cn . org . alan . exam . common . group . QuestionGroup ; import cn . org . alan . exam . model . entity . Option ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import jakarta . validation . Valid ; import jakarta . validation . constraints . * ; import lombok . Data ; import java . time . LocalDateTime ; import java . util . List ; import java . util . Objects ; @ Data public class QuestionFrom { private Integer id ; @ NotNull ( message = \"<STR_LIT>\" , groups = QuestionGroup . QuestionAddGroup . class ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" , groups = QuestionGroup . QuestionAddGroup . class ) @ Max ( value = <NUM_LIT> , message = \"<STR_LIT>\" , groups = QuestionGroup . QuestionAddGroup . class ) private Integer quType ; private String image ; private String analysis ; @ NotBlank ( message = \"<STR_LIT>\" , groups = QuestionGroup . QuestionAddGroup . class ) private String content ; private LocalDateTime createTime ; @ NotNull ( message = \"<STR_LIT>\" , groups = QuestionGroup . QuestionAddGroup . class ) private Integer repoId ; private List < Option > options ;", "output": "}"}, {"input": "package com . yf . base . api . api ; import lombok . AllArgsConstructor ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ NoArgsConstructor @ AllArgsConstructor public enum ApiError implements Serializable { ERROR_10010001 ( \"<STR_LIT>\" ) , ERROR_10010002 ( \"<STR_LIT>\" ) , ERROR_10010003 ( \"<STR_LIT>\" ) , ERROR_10010012 ( \"<STR_LIT>\" ) , ERROR_10010013 ( \"<STR_LIT>\" ) , ERROR_10010014 ( \"<STR_LIT>\" ) , ERROR_20010001 ( \"<STR_LIT>\" ) , ERROR_20010002 ( \"<STR_LIT>\" ) , ERROR_90010001 ( \"<STR_LIT>\" ) , ERROR_90010002 ( \"<STR_LIT>\" ) , ERROR_90010003 ( \"<STR_LIT>\" ) , ERROR_90010004 ( \"<STR_LIT>\" ) , ERROR_90010005 ( \"<STR_LIT>\" ) , ERROR_90010006 ( \"<STR_LIT>\" ) , ERROR_90010007 ( \"<STR_LIT>\" ) , ERROR_60000001 ( \"<STR_LIT>\" ) ; public String msg ; public static void main ( String [ ] args ) { for ( ApiError e : ApiError . values ( ) ) { System . out . println ( \"<STR_LIT>\" + e . name ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + e . msg + \"<STR_LIT>\" ) ; } } public Integer getCode ( ) { return Integer . parseInt ( this . name ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . constant ; public class HttpStatus { public static final int SUCCESS = <NUM_LIT> ; public static final int CREATED = <NUM_LIT> ; public static final int ACCEPTED = <NUM_LIT> ; public static final int NO_CONTENT = <NUM_LIT> ; public static final int MOVED_PERM = <NUM_LIT> ; public static final int SEE_OTHER = <NUM_LIT> ; public static final int NOT_MODIFIED = <NUM_LIT> ; public static final int BAD_REQUEST = <NUM_LIT> ; public static final int UNAUTHORIZED = <NUM_LIT> ; public static final int FORBIDDEN = <NUM_LIT> ; public static final int NOT_FOUND = <NUM_LIT> ; public static final int BAD_METHOD = <NUM_LIT> ; public static final int CONFLICT = <NUM_LIT> ; public static final int UNSUPPORTED_TYPE = <NUM_LIT> ; public static final int ERROR = <NUM_LIT> ; public static final int NOT_IMPLEMENTED = <NUM_LIT> ;", "output": "}"}, {"input": "package com . xcs . wx . exception ; public class BizException extends BaseException { public BizException ( Integer code , String msg ) { super ( code , msg ) ; }", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . stat ; import com . baomidou . mybatisplus . annotation . TableField ; import lombok . Data ; import java . time . LocalDate ; @ Data public class DailyVO { private Integer id ; private Integer userId ; private LocalDate loginDate ; private Integer totalSeconds ;", "output": "}"}, {"input": "package org . springblade . config . util ; import freemarker . template . TemplateException ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . hibernate . HibernateException ; import org . hibernate . Session ; import org . hibernate . boot . Metadata ; import org . hibernate . boot . MetadataSources ; import org . hibernate . boot . registry . StandardServiceRegistryBuilder ; import org . hibernate . cfg . Configuration ; import org . hibernate . service . ServiceRegistry ; import org . hibernate . tool . hbm2ddl . SchemaExport ; import org . hibernate . tool . schema . TargetType ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . db . DataBaseConfig ; import org . springblade . config . db . TableModel ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . cgform . entity . CgformField ; import org . springblade . core . tool . utils . Func ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . sql . * ; import java . util . * ; @ Slf4j public class SqlHelper { private static DbTableHandleI dbTableHandle ; public SqlHelper ( ) throws SQLException , DBException { dbTableHandle = TableUtil . getTableHandle ( ) ; } public static void createTable ( TableModel tableModel ) throws IOException , TemplateException , HibernateException , SQLException , DBException { String databaseType = TableUtil . getDatabaseType ( ) ; if ( MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) ) { List < CgformField > fieldList = new ArrayList < > ( ) ; CgformField field ; for ( Iterator < CgformField > iterator = tableModel . getColumns ( ) . iterator ( ) ; iterator . hasNext ( ) ; fieldList . add ( field ) ) { field = iterator . next ( ) ; if ( DbType . INT . equals ( field . getDbType ( ) ) ) { field . setDbType ( DbType . DOUBLE ) ; field . setDbPointLength ( <NUM_LIT> ) ; } } tableModel . setColumns ( fieldList ) ; } String xml = FreemarkerHelper . process ( \"<STR_LIT>\" , getTableData ( tableModel , databaseType ) ) ; log . info ( xml ) ; DataBaseConfig dbConfig = tableModel . getDbConfig ( ) ; Configuration configuration = new Configuration ( ) . configure ( ) ; Properties properties = configuration . getProperties ( ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getDriverClassName ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUrl ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getUsername ( ) ) ; properties . put ( \"<STR_LIT>\" , dbConfig . getPassword ( ) ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , true ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , TableUtil . getJdbcDriver ( databaseType ) ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; properties . put ( \"<STR_LIT>\" , false ) ; properties . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; MetadataSources metadataSources = new MetadataSources ( serviceRegistry ) ; ByteArrayInputStream input = new ByteArrayInputStream ( xml . getBytes ( ) ) ; metadataSources . addInputStream ( input ) ; Metadata metadata = metadataSources . buildMetadata ( ) ; SchemaExport schemaExport = new SchemaExport ( ) ; schemaExport . create ( EnumSet . of ( TargetType . DATABASE ) , metadata ) ; input . close ( ) ; List < Exception > exceptions = schemaExport . getExceptions ( ) ; Iterator < Exception > exceptionIterator = exceptions . iterator ( ) ; Exception exception ; while ( true ) { if ( ! exceptionIterator . hasNext ( ) ) { return ; } exception = exceptionIterator . next ( ) ; if ( \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { SQLSyntaxErrorException e = ( SQLSyntaxErrorException ) exception . getCause ( ) ; if ( \"<STR_LIT>\" . equals ( e . getSQLState ( ) ) ) { continue ; } break ; } else { if ( ! \"<STR_LIT>\" . equals ( exception . getCause ( ) . getClass ( ) . getName ( ) ) ) { break ; } if ( exception . getCause ( ) . toString ( ) . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { exception . printStackTrace ( ) ; throw new DBException ( exception . getCause ( ) . getMessage ( ) ) ; } log . error ( exception . getMessage ( ) ) ; } } throw new DBException ( exception . getMessage ( ) ) ; } public List < String > getUpdateTableSql ( TableModel table ) throws DBException , SQLException { String databaseType = TableUtil . getDatabaseType ( ) ; String tableName = TableUtil . fixTableName ( table . getTableName ( ) , databaseType ) ; String sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; List < String > updateTableSql = new ArrayList < > ( ) ; try { Map var6 = this . getColumnMetaMap ( null , tableName ) ; Map var7 = this . tableModel2MetaMap ( table ) ; Map var8 = this . fieldList2Map ( table . getColumns ( ) ) ; Iterator var9 = var7 . keySet ( ) . iterator ( ) ; label72 : while ( true ) { while ( true ) { String var10 ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; ColumnMeta var11 ; if ( ! var6 . containsKey ( var10 ) ) { var11 = ( ColumnMeta ) var7 . get ( var10 ) ; String var17 = ( String ) var8 . get ( var10 ) ; if ( var8 . containsKey ( var10 ) && var6 . containsKey ( var17 ) ) { ColumnMeta var13 = ( ColumnMeta ) var6 . get ( var17 ) ; String var14 = dbTableHandle . getReNameFieldName ( var11 ) ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) ) { updateTableSql . add ( var14 ) ; } else { updateTableSql . add ( sql + var14 ) ; } String var15 = this . getUpdateOnlCgformFieldSql ( var10 , var11 . getColumnId ( ) ) ; updateTableSql . add ( var15 ) ; if ( ! var13 . equals ( var11 ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var11 , var13 ) ) ; if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( databaseType ) ) { updateTableSql . add ( sql + this . getSpecialHandle ( var11 , var13 ) ) ; } } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! var13 . b ( var11 ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } else { updateTableSql . add ( sql + this . getAddColumnSql ( var11 ) ) ; if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && StringUtils . isNotEmpty ( var11 . getComment ( ) ) ) { updateTableSql . add ( this . getCommentSql ( var11 ) ) ; } } } else { var11 = ( ColumnMeta ) var6 . get ( var10 ) ; ColumnMeta var12 = ( ColumnMeta ) var7 . get ( var10 ) ; if ( ! var11 . a ( var12 , databaseType ) ) { updateTableSql . add ( sql + this . getUpdateColumnSql ( var12 , var11 ) ) ; } if ( ! MjkjConstant . DB_TYPE_SQLSERVER . equals ( databaseType ) && ! MjkjConstant . DB_TYPE_ORACLE . equals ( databaseType ) && ! var11 . b ( var12 ) ) { updateTableSql . add ( this . getCommentSql ( var12 ) ) ; } } } var9 = var6 . keySet ( ) . iterator ( ) ; while ( var9 . hasNext ( ) ) { var10 = ( String ) var9 . next ( ) ; if ( ! var7 . containsKey ( var10 . toLowerCase ( ) ) && ! var8 . containsValue ( var10 . toLowerCase ( ) ) ) { updateTableSql . add ( sql + this . getDropColumnSql ( var10 ) ) ; } } break label72 ; } } } catch ( SQLException var16 ) { throw new RuntimeException ( ) ; } log . info ( \"<STR_LIT>\" + updateTableSql . toString ( ) ) ; return updateTableSql ; } private static Map < String , Object > getTableData ( TableModel tableModel , String dataType ) { HashMap map = new HashMap ( ) ; Iterator iterator = tableModel . getColumns ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = ( CgformField ) iterator . next ( ) ; field . setDbDefaultVal ( c ( field . getDbDefaultVal ( ) ) ) ; } map . put ( \"<STR_LIT>\" , tableModel ) ; map . put ( \"<STR_LIT>\" , dataType ) ; return map ; } private Map < String , ColumnMeta > getColumnMetaMap ( String schema , String tableName ) throws SQLException { HashMap resultMap = new HashMap ( ) ; Connection connection = null ; try { connection = TableUtil . getConnection ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } DatabaseMetaData metaData = connection . getMetaData ( ) ; ResultSet result = metaData . getColumns ( connection . getCatalog ( ) , connection . getSchema ( ) , tableName , null ) ; while ( result . next ( ) ) { String columnName = result . getString ( <NUM_LIT> ) ; int columnType = result . getInt ( <NUM_LIT> ) ; } ; ResultSet set = metaData . getColumns ( connection . getCatalog ( ) , schema , tableName , \"<STR_LIT>\" ) ; while ( set . next ( ) ) { ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( tableName ) ; String columnName = set . getString ( \"<STR_LIT>\" ) . toLowerCase ( ) ; meta . setColumnName ( columnName ) ; String typeName = set . getString ( \"<STR_LIT>\" ) ; int decimalDigits = set . getInt ( \"<STR_LIT>\" ) ; String matchClassType = dbTableHandle . getMatchClassTypeByDataType ( typeName , decimalDigits ) ; meta . setColunmType ( matchClassType ) ; int columnSize = set . getInt ( \"<STR_LIT>\" ) ; meta . setColumnSize ( columnSize ) ; meta . setDecimalDigits ( decimalDigits ) ; String isNullable = set . getInt ( \"<STR_LIT>\" ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ; meta . setIsNullable ( isNullable ) ; String remarks = set . getString ( \"<STR_LIT>\" ) ; meta . setComment ( remarks ) ; String columnDef = set . getString ( \"<STR_LIT>\" ) ; String fieldDefault = c ( columnDef ) == null ? \"<STR_LIT>\" : c ( columnDef ) ; meta . setFieldDefault ( fieldDefault ) ; log . info ( \"<STR_LIT>\" + columnName . toUpperCase ( ) + \"<STR_LIT>\" + typeName + \"<STR_LIT>\" + decimalDigits + \"<STR_LIT>\" + columnSize ) ; resultMap . put ( columnName , meta ) ; } return resultMap ; } private Map < String , ColumnMeta > tableModel2MetaMap ( TableModel model ) { HashMap resultMap = new HashMap ( ) ; List < CgformField > list = model . getColumns ( ) ; Iterator < CgformField > iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; ColumnMeta meta = new ColumnMeta ( ) ; meta . setTableName ( model . getTableName ( ) . toLowerCase ( ) ) ; meta . setColumnId ( Func . toStr ( field . getId ( ) ) ) ; meta . setColumnName ( field . getDbFieldName ( ) . toLowerCase ( ) ) ; meta . setColumnSize ( field . getDbLength ( ) ) ; meta . setColunmType ( field . getDbType ( ) . toLowerCase ( ) ) ; meta . setIsNullable ( field . getDbIsNull ( ) == <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; meta . setComment ( field . getDbFieldTxt ( ) ) ; meta . setDecimalDigits ( field . getDbPointLength ( ) ) ; meta . setFieldDefault ( c ( field . getDbDefaultVal ( ) ) ) ; meta . setPkType ( model . getJformPkType ( ) == null ? \"<STR_LIT>\" : model . getJformPkType ( ) ) ; meta . setOldColumnName ( field . getDbFieldNameOld ( ) != null ? field . getDbFieldNameOld ( ) . toLowerCase ( ) : null ) ; log . info ( \"<STR_LIT>\" + field . getDbFieldName ( ) . toLowerCase ( ) + \"<STR_LIT>\" + field . getDbType ( ) . toLowerCase ( ) + \"<STR_LIT>\" + field . getDbPointLength ( ) + \"<STR_LIT>\" + field . getDbLength ( ) ) ; resultMap . put ( field . getDbFieldName ( ) . toLowerCase ( ) , meta ) ; } return resultMap ; } private Map < String , String > fieldList2Map ( List < CgformField > fieldList ) { HashMap resultMap = new HashMap ( ) ; Iterator < CgformField > iterator = fieldList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; resultMap . put ( field . getDbFieldName ( ) , field . getDbFieldNameOld ( ) ) ; } return resultMap ; } private String getDropColumnSql ( String fieldName ) { return dbTableHandle . getDropColumnSql ( fieldName ) ; } private String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) throws DBException { return dbTableHandle . getUpdateColumnSql ( cgformcolumnMeta , datacolumnMeta ) ; } private String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return dbTableHandle . getSpecialHandle ( cgformcolumnMeta , datacolumnMeta ) ; } private String getReNameFieldName ( ColumnMeta columnMeta ) { return dbTableHandle . getReNameFieldName ( columnMeta ) ; } private String getAddColumnSql ( ColumnMeta columnMeta ) { return dbTableHandle . getAddColumnSql ( columnMeta ) ; } private String getCommentSql ( ColumnMeta columnMeta ) { return dbTableHandle . getCommentSql ( columnMeta ) ; } private String getUpdateOnlCgformFieldSql ( String oldDbFieldName , String id ) { return \"<STR_LIT>\" + oldDbFieldName + \"<STR_LIT>\" + id + \"<STR_LIT>\" ; } private int updateOldDbFieldName ( String oldDbFieldName , String id , Session session ) { return session . createSQLQuery ( \"<STR_LIT>\" + oldDbFieldName + \"<STR_LIT>\" + id + \"<STR_LIT>\" ) . executeUpdate ( ) ; } private static String c ( String str ) { if ( StringUtils . isNotEmpty ( str ) ) { try { Double . valueOf ( str ) ; } catch ( Exception var2 ) { if ( ! str . startsWith ( \"<STR_LIT>\" ) || ! str . endsWith ( \"<STR_LIT>\" ) ) { str = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; } } } return str ; } public String getDropIndexsSql ( String indexName , String tableName ) { return dbTableHandle . dropIndexs ( indexName , tableName ) ; } public String getCountIndexSql ( String indexName , String tableName ) { return dbTableHandle . countIndex ( indexName , tableName ) ; } public static List < String > getIndexes ( String table ) throws SQLException { Connection conn = null ; ResultSet indexInfo = null ; ArrayList < String > indexes = new ArrayList < > ( ) ; try { conn = TableUtil . getConnection ( ) ; DatabaseMetaData metaData = conn . getMetaData ( ) ; indexInfo = metaData . getIndexInfo ( null , null , table , false , false ) ; indexInfo . getMetaData ( ) ; while ( indexInfo . next ( ) ) { String indexName = indexInfo . getString ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isEmpty ( indexName ) ) { indexName = indexInfo . getString ( \"<STR_LIT>\" ) ; } if ( ConvertUtils . isNotEmpty ( indexName ) ) { indexes . add ( indexName ) ; } } } catch ( SQLException e ) { log . error ( e . getMessage ( ) , e ) ; } finally {", "output": "if ( conn != null ) { conn . close ( ) ; } } return indexes ; } }"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . youlai . system . common . base . BaseEntity ; import lombok . Data ; @ Data public class SysDict extends BaseEntity { @ TableId ( type = IdType . AUTO ) private Long id ; private String name ; private String code ; private Integer status ; private String remark ;", "output": "}"}, {"input": "package top . kangert . kspider . service ; import org . springframework . data . domain . Page ; import org . springframework . data . domain . Pageable ; import top . kangert . kspider . domain . dto . DataSourceDTO ; import java . util . List ; public interface DataSourceService { void removeById ( Long id ) ; List < DataSourceDTO > findAll ( ) ; DataSourceDTO getById ( Long id ) ; void test ( DataSourceDTO dataSource ) ; DataSourceDTO save ( DataSourceDTO dataSource ) ; Page < DataSourceDTO > findAll ( Pageable pageable ) ;", "output": "}"}, {"input": "package com . yf . system . modules . role . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysRole extends Model < SysRole > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String roleName ; @ TableField ( \"<STR_LIT>\" ) private Integer dataScope ; @ TableField ( \"<STR_LIT>\" ) private Integer roleLevel ; private String remark ; @ TableField ( \"<STR_LIT>\" ) private Date createTime ; @ TableField ( \"<STR_LIT>\" ) private Date updateTime ; @ TableField ( \"<STR_LIT>\" ) private String createBy ; @ TableField ( \"<STR_LIT>\" ) private String updateBy ;", "output": "}"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysMenu ; import ginyi . system . domain . model . dto . MenuDto ; import ginyi . system . domain . model . vo . BaseVo ; import java . util . Set ; public interface ISysMenuService { public Set < String > selectMenuPermsByRoleId ( Long roleId ) ; public Set < String > selectMenuPermsByUserId ( Long userId ) ; public BaseVo < SysMenu > selectMenuList ( ) ; public BaseVo < SysMenu > list ( MenuDto menuDto ) ; public void addMenu ( MenuDto menuDto ) ; public SysMenu getMenuById ( Long menuId ) ; public void updateMenu ( MenuDto menuDto ) ; public void removeMenuById ( Long menuId ) ; public void removeMenuByIds ( Set < Long > ids ) ; public void updateStatus ( MenuDto menuDto ) ;", "output": "}"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . oddfar . campus . common . domain . BaseEntity ; import com . oddfar . campus . common . validator . Xss ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . NoArgsConstructor ; import javax . validation . constraints . Email ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Size ; import java . util . Date ; import java . util . List ; @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ Data @ NoArgsConstructor public class SysUserEntity extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long userId ; @ Xss ( message = \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String userName ; @ Xss ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String nickName ; @ Email ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String email ; @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String phonenumber ; private String sex ; private String avatar ; private String password ; private String status ; private String loginIp ; private Date loginDate ; private String remark ; @ TableField ( exist = false ) private List < SysRoleEntity > roles ; @ TableField ( exist = false ) private Long [ ] roleIds ; @ TableField ( exist = false ) private Long [ ] postIds ; @ TableField ( exist = false ) private Long roleId ; public SysUserEntity ( Long userId ) { this . userId = userId ; }", "output": "public boolean isAdmin ( ) { return isAdmin ( this . userId ) ; } public static boolean isAdmin ( Long userId ) { return userId != null && <NUM_LIT> == userId ; } }"}, {"input": "package cn . org . alan . exam . util . excel ; import java . util . LinkedHashMap ; public class ExcelClassField { private String fieldName ; private String name ; private LinkedHashMap < String , String > kvMap ; private Object example ; private int sort ; private int hasAnnotation ; public String getFieldName ( ) { return fieldName ; } public void setFieldName ( String fieldName ) { this . fieldName = fieldName ; } public String getName ( ) { return name ; } public void setName ( String name ) { this . name = name ; } public LinkedHashMap < String , String > getKvMap ( ) { return kvMap ; }", "output": "public void setKvMap ( LinkedHashMap < String , String > kvMap ) { this . kvMap = kvMap ; } public Object getExample ( ) { return example ; } public void setExample ( Object example ) { this . example = example ; } public int getSort ( ) { return sort ; } public void setSort ( int sort ) { this . sort = sort ; } public int getHasAnnotation ( ) { return hasAnnotation ; } public void setHasAnnotation ( int hasAnnotation ) { this . hasAnnotation = hasAnnotation ; } }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . util . ExtractUtils ; import org . jsoup . nodes . Element ; import org . jsoup . select . Elements ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component public class ElementFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return Element . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String xpath ( Element element , String xpath ) { return ExtractUtils . getValueByXPath ( element , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > xpaths ( Element element , String xpath ) { return ExtractUtils . getValuesByXPath ( element , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( Element element , String regx ) { return ExtractUtils . getFirstMatcher ( element . html ( ) , regx , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( Element element , String regx , int groupIndex ) { return ExtractUtils . getFirstMatcher ( element . html ( ) , regx , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regx ( Element element , String regx , List < Integer > groups ) { return ExtractUtils . getFirstMatcher ( element . html ( ) , regx , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( Element element , String regx ) { return ExtractUtils . getMatchers ( element . html ( ) , regx , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( Element element , String regx , int groupIndex ) { return ExtractUtils . getMatchers ( element . html ( ) , regx , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < List < String > > regxs ( Element element , String regx , List < Integer > groups ) { return ExtractUtils . getMatchers ( element . html ( ) , regx , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element selector ( Element element , String cssQuery ) { return element . selectFirst ( cssQuery ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements selectors ( Element element , String cssQuery ) { return element . select ( cssQuery ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements subling ( Element element ) { return element . siblingElements ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element parent ( Element element ) {", "output": "return element . parent ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements parents ( Element element ) { return element . parents ( ) ; } }"}, {"input": "package org . springblade . cgform . model . generate . pojo . onetomany ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public class SubTableVo { private String entityPackage ; private String tableName ; private String entityName ; private String primaryKeyPolicy ; private String sequenceCode ; private String ftlDescription ; private String [ ] originalForeignKeys ; private String [ ] foreignKeys ; private String foreignRelationType ; private List < ColumnVo > colums ; private List < ColumnVo > originalColumns ; private Map < ? , ? > extendParams ; public Map < ? , ? > getExtendParams ( ) { return this . extendParams ; } public void setExtendParams ( Map < ? , ? > extendParams ) { this . extendParams = extendParams ; } public String getEntityPackage ( ) { return this . entityPackage ; } public String getTableName ( ) { return this . tableName ; } public String getEntityName ( ) { return this . entityName ; } public String getFtlDescription ( ) { return this . ftlDescription ; } public List < ColumnVo > getColums ( ) { return this . colums ; } public void setColums ( List < ColumnVo > colums ) { this . colums = colums ; } public void setEntityPackage ( String entityPackage ) { this . entityPackage = entityPackage ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public void setEntityName ( String entityName ) { this . entityName = entityName ; } public void setFtlDescription ( String ftlDescription ) { this . ftlDescription = ftlDescription ; } public String [ ] getForeignKeys ( ) { return this . foreignKeys ; } public void setForeignKeys ( String [ ] foreignKeys ) { this . foreignKeys = foreignKeys ; } public String getPrimaryKeyPolicy ( ) { return this . primaryKeyPolicy ; } public String getSequenceCode ( ) { return this . sequenceCode ; } public void setPrimaryKeyPolicy ( String primaryKeyPolicy ) { this . primaryKeyPolicy = primaryKeyPolicy ; } public void setSequenceCode ( String sequenceCode ) { this . sequenceCode = sequenceCode ; } public List < ColumnVo > getOriginalColumns ( ) { return this . originalColumns ; } public void setOriginalColumns ( List < ColumnVo > originalColumns ) { this . originalColumns = originalColumns ; } public String [ ] getOriginalForeignKeys ( ) { return this . originalForeignKeys ; }", "output": "@ Deprecated public void setOriginalForeignKeys ( String [ ] originalForeignKeys ) { this . originalForeignKeys = originalForeignKeys ; } public String getForeignRelationType ( ) { return this . foreignRelationType ; } public void setForeignRelationType ( String foreignRelationType ) { this . foreignRelationType = foreignRelationType ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + this . entityPackage + \"<STR_LIT>\" + this . tableName + \"<STR_LIT>\" + this . entityName + \"<STR_LIT>\" + this . primaryKeyPolicy + \"<STR_LIT>\" + this . sequenceCode + \"<STR_LIT>\" + this . ftlDescription + \"<STR_LIT>\" + Arrays . toString ( this . originalForeignKeys ) + \"<STR_LIT>\" + Arrays . toString ( this . foreignKeys ) + \"<STR_LIT>\" + this . colums + \"<STR_LIT>\" + this . originalColumns + \"<STR_LIT>\" ; } }"}, {"input": "package org . example . ddduser . infrastructure . config ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MicroserviceProperties { private MicroserviceConfig workspace ; @ Data public static class MicroserviceConfig { private String url ; private String accessKey ; private String secretKey ;", "output": "} }"}, {"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import org . apache . commons . collections4 . map . LinkedMap ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import org . springframework . core . io . ClassPathResource ; import org . springframework . core . io . Resource ; import java . io . BufferedReader ; import java . io . File ; import java . io . InputStreamReader ; import java . nio . file . Files ; import java . util . List ; import java . util . Map ; public class EmailTemplateUtils { public static String TYPE_PUBLIC = \"<STR_LIT>\" ; public static final String DEFAULT_LANG = \"<STR_LIT>\" ; private static IMjkjBaseSqlService sqlService ; private static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static String getTemplate ( String lang , String type , String title , List < String > list , String dym ) { String html = \"<STR_LIT>\" ; if ( Func . equals ( type , TYPE_PUBLIC ) ) { String fileName = \"<STR_LIT>\" ; html = getHtml ( fileName ) ; html = html . replaceAll ( \"<STR_LIT>\" , title ) ; String content = \"<STR_LIT>\" ; if ( Func . isNotEmpty ( dym ) ) { content = getDymDiv ( dym ) ; } for ( String div : list ) { if ( div . startsWith ( \"<STR_LIT>\" ) ) { content += div ; } else {", "output": "content += getDiv ( div ) ; } } html = html . replaceAll ( \"<STR_LIT>\" , content ) ; } html = html . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) . replace ( \"<STR_LIT>\" , getLanguage ( lang , \"<STR_LIT>\" ) ) ; return html ; } public static String fomatYzmYxq ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatYzm ( String yzm ) { String div = \"<STR_LIT>\" + \"<STR_LIT>\" + yzm + \"<STR_LIT>\" ; return div ; } public static String fomatFontWeight ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDymDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getDiv ( String str ) { String div = \"<STR_LIT>\" + str + \"<STR_LIT>\" ; return div ; } private static String getHtml ( String fileName ) { try { Resource resource = new ClassPathResource ( \"<STR_LIT>\" + fileName ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( resource . getInputStream ( ) , \"<STR_LIT>\" ) ) ; StringBuffer sb = new StringBuffer ( ) ; String str = \"<STR_LIT>\" ; while ( ( str = br . readLine ( ) ) != null ) { sb . append ( str ) ; } return sb . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public static String getLanguage ( String code ) { try { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; String language = DEFAULT_LANG ; if ( Func . isNotEmpty ( header ) ) { language = header ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , code ) ; Map < String , Object > dataMap = getSqlService ( ) . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMap ) ) { return \"<STR_LIT>\" ; } String text = MjkjUtils . getMap2Str ( dataMap , \"<STR_LIT>\" ) ; Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; if ( Func . isEmpty ( map ) ) { return \"<STR_LIT>\" ; } return map . get ( language ) ; } catch ( Exception e ) { } return \"<STR_LIT>\" ; } public static String getLanguage ( String lang , String code ) { try { String header = WebUtil . getHeader ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( header ) ) { lang = header ; } } catch ( Exception e ) { } try { if ( Func . isEmpty ( lang ) ) { lang = DEFAULT_LANG ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , code ) ; Map < String , Object > dataMap = getSqlService ( ) . getDataOneByFieldParams ( \"<STR_LIT>\" , wrapper ) ; if ( Func . isEmpty ( dataMap ) ) { return \"<STR_LIT>\" ; } String text = MjkjUtils . getMap2Str ( dataMap , \"<STR_LIT>\" ) ; Map < String , String > map = JsonUtil . parse ( text , Map . class ) ; if ( Func . isEmpty ( map ) ) { return \"<STR_LIT>\" ; } return map . get ( lang ) ; } catch ( Exception e ) { } return \"<STR_LIT>\" ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . config . xml ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . GenericBeanDefinition ; import org . springframework . beans . factory . xml . XmlReaderContext ; import org . springframework . context . annotation . PropertySource ; import org . w3c . dom . Element ; public class NacosPropertySourceXmlBeanDefinition extends GenericBeanDefinition { private Element element ; private XmlReaderContext xmlReaderContext ; public NacosPropertySourceXmlBeanDefinition ( ) { setBeanClass ( getClass ( ) ) ; } public Element getElement ( ) { return element ; } void setElement ( Element element ) { this . element = element ; } public XmlReaderContext getXmlReaderContext ( ) {", "output": "return xmlReaderContext ; } void setXmlReaderContext ( XmlReaderContext xmlReaderContext ) { this . xmlReaderContext = xmlReaderContext ; } }"}, {"input": "package com . oddfar . campus . common . exception . user ; public class UserPasswordNotMatchException extends UserException { private static final long serialVersionUID = <NUM_LIT> ; public UserPasswordNotMatchException ( ) { super ( \"<STR_LIT>\" , null ) ; }", "output": "}"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . model . entity . SysRoleMenu ; import java . util . List ; import java . util . Set ; public interface SysRoleMenuService extends IService < SysRoleMenu > { List < Long > listMenuIdsByRoleId ( Long roleId ) ; void refreshRolePermsCache ( ) ; void refreshRolePermsCache ( String roleCode ) ; void refreshRolePermsCache ( String oldRoleCode , String newRoleCode ) ; Set < String > getRolePermsByRoleCodes ( Set < String > roles ) ;", "output": "}"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . xcs . wx . domain . Contact ; import com . xcs . wx . domain . dto . ContactDTO ; import com . xcs . wx . domain . vo . AllContactVO ; import com . xcs . wx . domain . vo . ContactVO ; import com . xcs . wx . domain . vo . ExportContactVO ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Set ; public interface ContactMapper extends BaseMapper < Contact > { Page < ContactVO > queryContact ( Page < ContactVO > page , @ Param ( \"<STR_LIT>\" ) ContactDTO contactDTO ) ; List < AllContactVO > queryAllContact ( ) ; Set < String > getContactWithMp ( ) ; int countContact ( ) ;", "output": "List < ExportContactVO > exportContact ( ) ; }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . dto . ChatRoomDTO ; import com . xcs . wx . domain . vo . ChatRoomDetailVO ; import com . xcs . wx . domain . vo . ChatRoomVO ; import com . xcs . wx . domain . vo . PageVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . service . ChatRoomService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class ChatRoomController { private final ChatRoomService chatRoomService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < ChatRoomVO > > list ( ChatRoomDTO chatRoomDTO ) {", "output": "PageVO < ChatRoomVO > pageVO = chatRoomService . queryChatRoom ( chatRoomDTO ) ; return ResponseVO . ok ( pageVO . getRecords ( ) , pageVO . getCurrent ( ) , pageVO . getTotal ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < ChatRoomDetailVO > detail ( @ RequestParam String chatRoomName ) { return ResponseVO . ok ( chatRoomService . queryChatRoomDetail ( chatRoomName ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < String > export ( ) { return ResponseVO . ok ( chatRoomService . exportChatRoom ( ) ) ; } }"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . model . entity . SysUserRole ; import java . util . List ; public interface SysUserRoleService extends IService < SysUserRole > { boolean saveUserRoles ( Long userId , List < Long > roleIds ) ;", "output": "boolean hasAssignedUsers ( Long roleId ) ; }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class FloatConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Float . class == fieldType || float . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Float . class == fieldType ? null : <NUM_LIT> ; } try { return Float . parseFloat ( text ) ; } catch ( NumberFormatException e ) { return Float . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Float value = ( Float ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ;", "output": "String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ; cell . setCellType ( CellType . NUMERIC ) ; cell . setCellValue ( cellContent ) ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformButton extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonIcon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exp ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String optType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String optPosition ;", "output": "}"}, {"input": "package me . zhengjie . modules . security . config . bean ; import com . wf . captcha . * ; import com . wf . captcha . base . Captcha ; import lombok . Data ; import me . zhengjie . exception . BadConfigurationException ; import me . zhengjie . utils . StringUtils ; import java . awt . * ; import java . util . Objects ; @ Data public class LoginProperties { private boolean singleLogin = false ; private LoginCode loginCode ; public static final String cacheKey = \"<STR_LIT>\" ; public boolean isSingleLogin ( ) { return singleLogin ; }", "output": "public Captcha getCaptcha ( ) { if ( Objects . isNull ( loginCode ) ) { loginCode = new LoginCode ( ) ; if ( Objects . isNull ( loginCode . getCodeType ( ) ) ) { loginCode . setCodeType ( LoginCodeEnum . ARITHMETIC ) ; } } return switchCaptcha ( loginCode ) ; } private Captcha switchCaptcha ( LoginCode loginCode ) { Captcha captcha ; switch ( loginCode . getCodeType ( ) ) { case ARITHMETIC : captcha = new FixedArithmeticCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case CHINESE : captcha = new ChineseCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case CHINESE_GIF : captcha = new ChineseGifCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case GIF : captcha = new GifCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; case SPEC : captcha = new SpecCaptcha ( loginCode . getWidth ( ) , loginCode . getHeight ( ) ) ; captcha . setLen ( loginCode . getLength ( ) ) ; break ; default : throw new BadConfigurationException ( \"<STR_LIT>\" ) ; } if ( StringUtils . isNotBlank ( loginCode . getFontName ( ) ) ) { captcha . setFont ( new Font ( loginCode . getFontName ( ) , Font . PLAIN , loginCode . getFontSize ( ) ) ) ; } return captcha ; } static class FixedArithmeticCaptcha extends ArithmeticCaptcha { public FixedArithmeticCaptcha ( int width , int height ) { super ( width , height ) ; } @ Override protected char [ ] alphas ( ) { int n1 = num ( <NUM_LIT> , <NUM_LIT> ) , n2 = num ( <NUM_LIT> , <NUM_LIT> ) ; int opt = num ( <NUM_LIT> ) ; int res = new int [ ] { n1 + n2 , n1 - n2 , n1 * n2 } [ opt ] ; char optChar = \"<STR_LIT>\" . charAt ( opt ) ; this . setArithmeticString ( String . format ( \"<STR_LIT>\" , n1 , optChar , n2 ) ) ; this . chars = String . valueOf ( res ) ; return chars . toCharArray ( ) ; } } }"}, {"input": "package org . springblade . gateway . filter ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . stereotype . Component ; import org . springframework . util . StringUtils ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . Arrays ; import java . util . stream . Collectors ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . GATEWAY_REQUEST_URL_ATTR ; import static org . springframework . cloud . gateway . support . ServerWebExchangeUtils . addOriginalRequestUrl ; @ Component public class RequestFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) . mutate ( ) . headers ( httpHeaders -> httpHeaders . remove ( \"<STR_LIT>\" ) ) . build ( ) ; addOriginalRequestUrl ( exchange , request . getURI ( ) ) ; String rawPath = request . getURI ( ) . getRawPath ( ) ;", "output": "String newPath = \"<STR_LIT>\" + Arrays . stream ( StringUtils . tokenizeToStringArray ( rawPath , \"<STR_LIT>\" ) ) . skip ( <NUM_LIT> ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; ServerHttpRequest newRequest = request . mutate ( ) . path ( newPath ) . build ( ) ; exchange . getAttributes ( ) . put ( GATEWAY_REQUEST_URL_ATTR , newRequest . getURI ( ) ) ; return chain . filter ( exchange . mutate ( ) . request ( newRequest . mutate ( ) . build ( ) ) . build ( ) ) ; } @ Override public int getOrder ( ) { return - <NUM_LIT> ; } }"}, {"input": "package me . zhengjie . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . domain . LocalStorage ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . service . LocalStorageService ; import me . zhengjie . domain . vo . LocalStorageQueryCriteria ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import io . swagger . annotations . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class LocalStorageController { private final LocalStorageService localStorageService ; @ GetMapping @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < LocalStorage > > queryFile ( LocalStorageQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( localStorageService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportFile ( HttpServletResponse response , LocalStorageQueryCriteria criteria ) throws IOException { localStorageService . download ( localStorageService . queryAll ( criteria ) , response ) ; }", "output": "@ PostMapping @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createFile ( @ RequestParam String name , @ RequestParam ( \"<STR_LIT>\" ) MultipartFile file ) { localStorageService . create ( name , file ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ResponseEntity < LocalStorage > uploadPicture ( @ RequestParam MultipartFile file ) { String suffix = FileUtil . getExtensionName ( file . getOriginalFilename ( ) ) ; if ( ! FileUtil . IMAGE . equals ( FileUtil . getFileType ( suffix ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } LocalStorage localStorage = localStorageService . create ( null , file ) ; return new ResponseEntity < > ( localStorage , HttpStatus . OK ) ; } @ PutMapping @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateFile ( @ Validated @ RequestBody LocalStorage resources ) { localStorageService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ DeleteMapping @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteFile ( @ RequestBody Long [ ] ids ) { localStorageService . deleteAll ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package me . zhengjie . utils ; import javax . crypto . Cipher ; import javax . crypto . SecretKey ; import javax . crypto . SecretKeyFactory ; import javax . crypto . spec . DESKeySpec ; import javax . crypto . spec . IvParameterSpec ; import java . nio . charset . StandardCharsets ; public class EncryptUtils { private static final String STR_PARAM = \"<STR_LIT>\" ; private static Cipher cipher ; private static final IvParameterSpec IV = new IvParameterSpec ( STR_PARAM . getBytes ( StandardCharsets . UTF_8 ) ) ; private static DESKeySpec getDesKeySpec ( String source ) throws Exception { if ( source == null || source . length ( ) == <NUM_LIT> ) { return null ; } cipher = Cipher . getInstance ( \"<STR_LIT>\" ) ; String strKey = \"<STR_LIT>\" ; return new DESKeySpec ( strKey . getBytes ( StandardCharsets . UTF_8 ) ) ;", "output": "} public static String desEncrypt ( String source ) throws Exception { DESKeySpec desKeySpec = getDesKeySpec ( source ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( \"<STR_LIT>\" ) ; SecretKey secretKey = keyFactory . generateSecret ( desKeySpec ) ; cipher . init ( Cipher . ENCRYPT_MODE , secretKey , IV ) ; return byte2hex ( cipher . doFinal ( source . getBytes ( StandardCharsets . UTF_8 ) ) ) . toUpperCase ( ) ; } public static String desDecrypt ( String source ) throws Exception { byte [ ] src = hex2byte ( source . getBytes ( StandardCharsets . UTF_8 ) ) ; DESKeySpec desKeySpec = getDesKeySpec ( source ) ; SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( \"<STR_LIT>\" ) ; SecretKey secretKey = keyFactory . generateSecret ( desKeySpec ) ; cipher . init ( Cipher . DECRYPT_MODE , secretKey , IV ) ; byte [ ] retByte = cipher . doFinal ( src ) ; return new String ( retByte ) ; } private static String byte2hex ( byte [ ] inStr ) { String stmp ; StringBuilder out = new StringBuilder ( inStr . length * <NUM_LIT> ) ; for ( byte b : inStr ) { stmp = Integer . toHexString ( b & <NUM_LIT> ) ; if ( stmp . length ( ) == <NUM_LIT> ) { out . append ( \"<STR_LIT>\" ) . append ( stmp ) ; } else { out . append ( stmp ) ; } } return out . toString ( ) ; } private static byte [ ] hex2byte ( byte [ ] b ) { int size = <NUM_LIT> ; if ( ( b . length % size ) != <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } byte [ ] b2 = new byte [ b . length / <NUM_LIT> ] ; for ( int n = <NUM_LIT> ; n < b . length ; n += size ) { String item = new String ( b , n , <NUM_LIT> ) ; b2 [ n / <NUM_LIT> ] = ( byte ) Integer . parseInt ( item , <NUM_LIT> ) ; } return b2 ; } }"}, {"input": "package top . kangert . kspider . util ; import cn . hutool . json . JSON ; import cn . hutool . json . JSONUtil ; import org . jsoup . nodes . Element ; import org . jsoup . select . Elements ; import us . codecraft . xsoup . Xsoup ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class ExtractUtils { private static Map < String , Pattern > patterns = new HashMap < > ( ) ; public static Pattern compile ( String regx ) { Pattern pattern = patterns . get ( regx ) ; if ( pattern == null ) { pattern = Pattern . compile ( regx , Pattern . DOTALL ) ; patterns . put ( regx , pattern ) ; } return pattern ; } public static List < String > getMatchers ( String content , String regx , boolean isGroup ) { return getMatchers ( content , regx , isGroup ? <NUM_LIT> : <NUM_LIT> ) ; } public static List < String > getMatchers ( String content , String regx , int groupIndex ) { Matcher matcher = compile ( regx ) . matcher ( content ) ; List < String > results = new ArrayList < > ( ) ; while ( matcher . find ( ) ) { results . add ( matcher . group ( groupIndex ) ) ; } return results ; } public static List < List < String > > getMatchers ( String content , String regx , List < Integer > groups ) { Matcher matcher = compile ( regx ) . matcher ( content ) ; List < List < String > > results = new ArrayList < > ( ) ; while ( matcher . find ( ) ) { List < String > matches = new ArrayList < > ( ) ; for ( Integer groupIndex : groups ) { matches . add ( matcher . group ( groupIndex ) ) ; } results . add ( matches ) ; } return results ; } public static String getFirstMatcher ( String content , String regx , boolean isGroup ) { return getFirstMatcher ( content , regx , isGroup ? <NUM_LIT> : <NUM_LIT> ) ; } public static String getFirstMatcher ( String content , String regx , int groupIndex ) { Matcher matcher = compile ( regx ) . matcher ( content ) ; if ( matcher . find ( ) ) { return matcher . group ( groupIndex ) ; } return null ; } public static List < String > getFirstMatcher ( String content , String regx , List < Integer > groups ) { Matcher matcher = compile ( regx ) . matcher ( content ) ; List < String > matches = new ArrayList < > ( ) ; if ( matcher . find ( ) ) { for ( Integer groupIndex : groups ) { matches . add ( matcher . group ( groupIndex ) ) ; } } return matches ; } public static String getHostFromURL ( String url ) { return getFirstMatcher ( url , \"<STR_LIT>\" , false ) ; } public static String getFirstHTMLBySelector ( Element element , String selector ) { element = getFirstElement ( element , selector ) ; return element == null ? null : element . html ( ) ; } public static String getFirstOuterHTMLBySelector ( Element element , String selector ) { element = getFirstElement ( element , selector ) ; return element == null ? null : element . outerHtml ( ) ; } public static String getFirstTextBySelector ( Element element , String selector ) { element = getFirstElement ( element , selector ) ; return element == null ? null : element . text ( ) ; } public static String getFirstAttrBySelector ( Element element , String selector , String attr ) { element = getFirstElement ( element , selector ) ; return element == null ? null : element . attr ( attr ) ; } public static Element getFirstElement ( Element element , String selector ) { return element . selectFirst ( selector ) ; } public static List < Element > getElements ( Element element , String selector ) { return element . select ( selector ) ; } public static List < String > getHTMLBySelector ( Element element , String selector ) { Elements elements = element . select ( selector ) ; List < String > result = new ArrayList < > ( ) ; for ( Element elem : elements ) { result . add ( elem . html ( ) ) ; } return result ; } public static List < String > getOuterHTMLBySelector ( Element element , String selector ) { Elements elements = element . select ( selector ) ; List < String > result = new ArrayList < > ( ) ; for ( Element elem : elements ) { result . add ( elem . outerHtml ( ) ) ; } return result ;", "output": "} public static List < String > getTextBySelector ( Element element , String selector ) { Elements elements = element . select ( selector ) ; List < String > result = new ArrayList < > ( ) ; for ( Element elem : elements ) { result . add ( elem . text ( ) ) ; } return result ; } public static List < String > getAttrBySelector ( Element element , String selector , String attr ) { Elements elements = element . select ( selector ) ; List < String > result = new ArrayList < > ( ) ; for ( Element elem : elements ) { result . add ( elem . attr ( attr ) ) ; } return result ; } public static Object getValueByJsonPath ( Object root , String jsonPath ) { return JSONUtil . getByPath ( ( JSON ) root , jsonPath ) ; } public static List < String > getValuesByXPath ( Element element , String xpath ) { return Xsoup . select ( element , xpath ) . list ( ) ; } public static List < String > getValuesByXPath ( Elements elements , String xpath ) { return Xsoup . select ( elements . html ( ) , xpath ) . list ( ) ; } public static String getValueByXPath ( Element element , String xpath ) { return Xsoup . select ( element , xpath ) . get ( ) ; } public static String getValueByXPath ( Elements elements , String xpath ) { return Xsoup . select ( elements . html ( ) , xpath ) . get ( ) ; } public static String getElementByXPath ( Element element , String xpath ) { return Xsoup . select ( element , xpath ) . get ( ) ; } public static boolean isNumber ( String str ) { return compile ( \"<STR_LIT>\" ) . matcher ( str ) . matches ( ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BaseIdsReqDTO extends BaseDTO { @ JsonIgnore private String userId ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > ids ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableLogic ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data public class MjkjBase implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . io . BaseEncoding ; public class EncodeUtil { public static String encodeHex ( byte [ ] input ) { return BaseEncoding . base16 ( ) . encode ( input ) ; } public static byte [ ] decodeHex ( CharSequence input ) { return BaseEncoding . base16 ( ) . decode ( input ) ; } public static String encodeBase64 ( byte [ ] input ) { return BaseEncoding . base64 ( ) . encode ( input ) ;", "output": "} public static byte [ ] decodeBase64 ( CharSequence input ) { return BaseEncoding . base64 ( ) . decode ( input ) ; } public static String encodeBase64UrlSafe ( byte [ ] input ) { return BaseEncoding . base64Url ( ) . encode ( input ) ; } public static byte [ ] decodeBase64UrlSafe ( CharSequence input ) { return BaseEncoding . base64Url ( ) . decode ( input ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; public class NacosBootConfigException extends RuntimeException { public NacosBootConfigException ( Throwable cause ) {", "output": "super ( cause ) ; } public NacosBootConfigException ( String message , Throwable cause ) { super ( message , cause ) ; } }"}, {"input": "package ginyi . framework . security . service ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . mysql . MyPage ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import ginyi . system . domain . SysMenu ; import ginyi . system . domain . SysRole ; import ginyi . system . domain . model . dto . RoleDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . RoleVo ; import ginyi . system . mapper . SysMenuMapper ; import ginyi . system . mapper . SysRoleMapper ; import ginyi . system . service . ISysRoleService ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . annotation . Resource ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @ Service public class SysRoleServiceImpl implements ISysRoleService { @ Resource private SysRoleMapper roleMapper ; @ Resource private SysMenuMapper menuMapper ; @ Resource private RedisCache redisCache ; @ Override public Set < String > selectRolePermissionByUserId ( Long userId ) { List < SysRole > perms = roleMapper . selectRolePermissionByUserId ( userId ) ; Set < String > permsSet = new HashSet < > ( ) ; for ( SysRole perm : perms ) { if ( StringUtils . isNotNull ( perm ) ) { permsSet . addAll ( Arrays . asList ( perm . getRoleKey ( ) . trim ( ) . split ( \"<STR_LIT>\" ) ) ) ; } } return permsSet ; } @ Override public BaseVo < RoleVo > list ( RoleDto roleDto , Long page , Long pageSize ) { IPage < RoleVo > list = roleMapper . list ( roleDto , new MyPage ( page , pageSize ) . getPage ( ) ) ; BaseVo < RoleVo > baseVo = new BaseVo < > ( ) ; baseVo . setList ( list . getRecords ( ) ) ; baseVo . setCount ( ( int ) list . getTotal ( ) ) ; return baseVo ; } @ Override public RoleVo getRoleByRoleId ( Long roleId ) { if ( redisCache . hasKey ( CacheConstants . ROLE_NOT_EXIST_KEY + roleId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleId + CommonMessageConstants . ROLE_NOT_EXIST ) ; } RoleVo role = redisCache . getCacheObject ( CacheConstants . ROLE_DETAILS_BY_ROLEID_KEY + roleId , RoleVo . class ) ; if ( StringUtils . isNotNull ( role ) ) { return role ; } role = roleMapper . selectRoleByRoleId ( roleId ) ; if ( StringUtils . isNull ( role ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NOT_EXIST_KEY + roleId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleId + CommonMessageConstants . ROLE_NOT_EXIST ) ; } redisCache . setCacheObject ( CacheConstants . ROLE_DETAILS_BY_ROLEID_KEY + roleId , role ) ; return role ; } @ Override @ Transactional public void addRole ( RoleDto roleDto ) { if ( redisCache . hasKey ( CacheConstants . ROLE_NAME_USED_KEY + roleDto . getRoleName ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_NAME_USED ) ; } if ( redisCache . hasKey ( CacheConstants . ROLE_CODE_USED_KEY + roleDto . getRoleName ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_PERMISSION_CODE_USED ) ; } LambdaQueryWrapper < SysRole > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleName , roleDto . getRoleName ( ) ) ; SysRole role = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( role ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NAME_USED_KEY + roleDto . getRoleName ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_NAME_USED ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleKey , roleDto . getRoleKey ( ) ) ; role = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( role ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NAME_USED_KEY + roleDto . getRoleKey ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_PERMISSION_CODE_USED ) ; } roleMapper . insertRole ( roleDto ) ; roleMapper . insertRoleMenu ( roleDto ) ; redisCache . removeCacheObject ( CacheConstants . ROLE_KEY_PREFIX ) ; } @ Override @ Transactional public void updateRole ( RoleDto roleDto ) { if ( redisCache . hasKey ( CacheConstants . ROLE_NOT_EXIST_KEY + roleDto . getRoleId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleDto . getRoleId ( ) + CommonMessageConstants . ROLE_NOT_EXIST ) ; } if ( redisCache . hasKey ( CacheConstants . ROLE_CODE_USED_KEY + roleDto . getRoleKey ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_PERMISSION_CODE_USED ) ; } if ( redisCache . hasKey ( CacheConstants . ROLE_NAME_USED_KEY + roleDto . getRoleName ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_NAME_USED ) ; } LambdaQueryWrapper < SysRole > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleId , roleDto . getRoleId ( ) ) ; SysRole role = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( role ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NOT_EXIST_KEY + roleDto . getRoleId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleDto . getRoleId ( ) + CommonMessageConstants . ROLE_NOT_EXIST ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleName , roleDto . getRoleName ( ) ) ; role = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( role ) && ! roleDto . getRoleId ( ) . equals ( role . getRoleId ( ) ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NAME_USED_KEY + roleDto . getRoleName ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_NAME_USED ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleKey , roleDto . getRoleKey ( ) ) ; role = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( role ) && ! roleDto . getRoleId ( ) . equals ( role . getRoleId ( ) ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_CODE_USED_KEY + roleDto . getRoleKey ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . ROLE_PERMISSION_CODE_USED ) ; } if ( roleDto . getPermissions ( ) . size ( ) > <NUM_LIT> ) { List < SysMenu > menuList = redisCache . getCacheList ( CacheConstants . MENU_LIST_KEY , SysMenu . class ) ; if ( StringUtils . isNull ( menuList ) || menuList . size ( ) == <NUM_LIT> ) { LambdaQueryWrapper < SysMenu > menuQueryWrapper = new LambdaQueryWrapper < > ( ) ; menuList = menuMapper . selectList ( menuQueryWrapper ) ; redisCache . setCacheList ( CacheConstants . MENU_LIST_KEY , menuList ) ; } for ( Long menuId : roleDto . getPermissions ( ) ) { boolean exist = menuList . stream ( ) . anyMatch ( menu -> menuId . equals ( menu . getMenuId ( ) ) ) ; if ( ! exist ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , menuId + CommonMessageConstants . ROLE_MENU_NOT_EXIST ) ; } } } roleMapper . updateRole ( roleDto ) ; if ( roleDto . getPermissions ( ) . size ( ) > <NUM_LIT> ) { roleMapper . updateRoleMenu ( roleDto ) ; } redisCache . removeCacheObject ( CacheConstants . ROLE_KEY_PREFIX ) ; } @ Override public void removeByRoleId ( Long roleId ) { if ( redisCache . hasKey ( CacheConstants . ROLE_NOT_EXIST_KEY + roleId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleId + CommonMessageConstants . ROLE_NOT_EXIST ) ; }", "output": "LambdaQueryWrapper < SysRole > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleId , roleId ) ; SysRole role = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( role ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NOT_EXIST_KEY + roleId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleId + CommonMessageConstants . ROLE_NOT_EXIST ) ; } roleMapper . deleteById ( roleId ) ; redisCache . removeCacheObject ( CacheConstants . ROLE_KEY_PREFIX ) ; } @ Override public void removeByRoleIds ( Set < Long > ids ) { if ( ids . size ( ) > <NUM_LIT> ) { List < SysRole > roleList ; roleList = redisCache . getCacheList ( CacheConstants . ROLE_LIST_KEY , SysRole . class ) ; if ( StringUtils . isNull ( roleList ) || roleList . size ( ) == <NUM_LIT> ) { LambdaQueryWrapper < SysRole > queryWrapper = new LambdaQueryWrapper < > ( ) ; roleList = roleMapper . selectList ( queryWrapper ) ; redisCache . setCacheList ( CacheConstants . ROLE_LIST_KEY , roleList ) ; } for ( Long roleId : ids ) { if ( redisCache . hasKey ( CacheConstants . ROLE_NOT_EXIST_KEY + roleId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleId + CommonMessageConstants . ROLE_NOT_EXIST ) ; } boolean exist = roleList . stream ( ) . anyMatch ( role -> roleId . equals ( role . getRoleId ( ) ) ) ; if ( ! exist ) { redisCache . setCacheObject ( CacheConstants . ROLE_NOT_EXIST_KEY + roleId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleId + CommonMessageConstants . ROLE_NOT_EXIST ) ; } } roleMapper . deleteBatchIds ( ids ) ; redisCache . removeCacheObject ( CacheConstants . ROLE_KEY_PREFIX ) ; } else { throw new CommonException ( StateCode . ERROR_REQUEST_PARAMS , CommonMessageConstants . SYS_REQUEST_ILLEGAL ) ; } } @ Override public void updateStatus ( RoleDto roleDto ) { if ( StringUtils . isNull ( roleDto . getRoleId ( ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . ROLE_ID_NOT_FOUND ) ; } if ( ! ( \"<STR_LIT>\" . equals ( roleDto . getStatus ( ) ) || \"<STR_LIT>\" . equals ( roleDto . getStatus ( ) ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . ROLE_STATUS_ILLEGAL ) ; } if ( redisCache . hasKey ( CacheConstants . ROLE_NOT_EXIST_KEY + roleDto . getRoleId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleDto . getRoleId ( ) + CommonMessageConstants . ROLE_NOT_EXIST ) ; } LambdaQueryWrapper < SysRole > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysRole :: getRoleId , roleDto . getRoleId ( ) ) ; SysRole menu = roleMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( menu ) ) { redisCache . setCacheObject ( CacheConstants . ROLE_NOT_EXIST_KEY + roleDto . getRoleId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , roleDto . getRoleId ( ) + CommonMessageConstants . ROLE_NOT_EXIST ) ; } roleMapper . updateRoleStatus ( roleDto ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class SheetConfig { private Class < ? > rowType ; private int sheetIndex ; private String sheetName ; private int dataRowStartIndex ; private boolean writeHeader ; public boolean isWriteHeader ( ) { return writeHeader ; } public void setWriteHeader ( boolean writeHeader ) { this . writeHeader = writeHeader ; } private List < HeaderCellConfig > headerRowConfig = new ArrayList < HeaderCellConfig > ( ) ; private List < DataCellConfig > dataRowConfig = new ArrayList < DataCellConfig > ( ) ; public Class < ? > getRowType ( ) { return rowType ; } public void setRowType ( Class < ? > rowType ) { this . rowType = rowType ; } public int getSheetIndex ( ) { return sheetIndex ; } public void setSheetIndex ( int sheetIndex ) { this . sheetIndex = sheetIndex ; } public String getSheetName ( ) { return sheetName ; } public void setSheetName ( String sheetName ) { this . sheetName = sheetName ; } public int getDataRowStartIndex ( ) { return dataRowStartIndex ; } public void setDataRowStartIndex ( int dataRowStartIndex ) { this . dataRowStartIndex = dataRowStartIndex ; } public List < HeaderCellConfig > getHeaderRowConfig ( ) { return headerRowConfig ; } public void addHeaderCellConfig ( HeaderCellConfig headerCellConfig ) { if ( headerCellConfig != null ) { headerRowConfig . add ( headerCellConfig ) ; } } public List < DataCellConfig > getDataRowConfig ( ) { return dataRowConfig ; }", "output": "public void addDataCellConfig ( DataCellConfig dataCellConfig ) { if ( dataCellConfig != null ) { dataRowConfig . add ( dataCellConfig ) ; } } }"}, {"input": "package me . zhengjie . utils ; import com . baomidou . mybatisplus . core . metadata . IPage ; import java . util . * ; public class PageUtil extends cn . hutool . core . util . PageUtil { public static < T > List < T > paging ( int page , int size , List < T > list ) { int fromIndex = page * size ; int toIndex = page * size + size ; if ( fromIndex > list . size ( ) ) { return Collections . emptyList ( ) ; } else if ( toIndex >= list . size ( ) ) { return list . subList ( fromIndex , list . size ( ) ) ; } else { return list . subList ( fromIndex , toIndex ) ;", "output": "} } public static < T > PageResult < T > toPage ( IPage < T > page ) { return new PageResult < > ( page . getRecords ( ) , page . getTotal ( ) ) ; } public static < T > PageResult < T > toPage ( List < T > list ) { return new PageResult < > ( list , list . size ( ) ) ; } public static < T > PageResult < T > noData ( ) { return new PageResult < > ( null , <NUM_LIT> ) ; } public static < T > PageResult < T > toPage ( List < T > list , long totalElements ) { return new PageResult < > ( list , totalElements ) ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Positive ; import java . math . BigDecimal ; @ Data public class WithdrawalParam { @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( message = \"<STR_LIT>\" ) private String coinSymbol ; @ NotBlank ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private String address ; @ NotBlank ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private String chainType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String remark ; @ Positive ( message = \"<STR_LIT>\" ) @ ApiModelProperty ( \"<STR_LIT>\" ) private BigDecimal amount ;", "output": "}"}, {"input": "package com . youlai . system . enums ; import com . youlai . system . common . base . IBaseEnum ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; @ Getter @ Schema ( enumAsRef = true ) public enum GenderEnum implements IBaseEnum < Integer > { MALE ( <NUM_LIT> , \"<STR_LIT>\" ) , FEMALE ( <NUM_LIT> , \"<STR_LIT>\" ) ; private final Integer value ; private final String label ;", "output": "GenderEnum ( Integer value , String label ) { this . value = value ; this . label = label ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . Date ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) @ AllArgsConstructor @ NoArgsConstructor public class BaseQueryReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date statDateL ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date statDateR ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String q ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . ExamGradeMapper ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . mapper . * ; import cn . org . alan . exam . model . entity . * ; import cn . org . alan . exam . model . vo . stat . AllStatsVO ; import cn . org . alan . exam . model . vo . stat . DailyVO ; import cn . org . alan . exam . model . vo . stat . GradeExamVO ; import cn . org . alan . exam . model . vo . stat . GradeStudentVO ; import cn . org . alan . exam . service . IStatService ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import java . time . LocalDateTime ; import java . util . ArrayList ; import java . util . List ; @ Service public class StatServiceImpl extends ServiceImpl < ExamGradeMapper , ExamGrade > implements IStatService { @ Resource private StatMapper statMapper ; @ Resource private GradeMapper gradeMapper ; @ Resource private ExamMapper examMapper ; @ Resource private QuestionMapper questionMapper ; @ Resource private UserDailyLoginDurationMapper userDailyLoginDurationMapper ; @ Override public Result < List < GradeStudentVO > > getStudentGradeCount ( ) { List < GradeStudentVO > gradeStudentVOs ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { gradeStudentVOs = statMapper . StudentGradeCount ( <NUM_LIT> , SecurityUtil . getUserId ( ) ) ; } else { gradeStudentVOs = statMapper . StudentGradeCount ( <NUM_LIT> , SecurityUtil . getUserId ( ) ) ; } return Result . success ( \"<STR_LIT>\" , gradeStudentVOs ) ; } @ Override public Result < List < GradeExamVO > > getExamGradeCount ( ) { List < GradeExamVO > gradeExamVOs ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { gradeExamVOs = statMapper . ExamGradeCount ( <NUM_LIT> , SecurityUtil . getUserId ( ) ) ; } else { gradeExamVOs = statMapper . ExamGradeCount ( <NUM_LIT> , SecurityUtil . getUserId ( ) ) ;", "output": "} return Result . success ( \"<STR_LIT>\" , gradeExamVOs ) ; } @ Override public Result < AllStatsVO > getAllCount ( ) { AllStatsVO allStatsVO = new AllStatsVO ( ) ; String role = SecurityUtil . getRole ( ) ; if ( \"<STR_LIT>\" . equals ( role ) ) { allStatsVO . setClassCount ( gradeMapper . selectCount ( null ) . intValue ( ) ) ; allStatsVO . setExamCount ( examMapper . selectCount ( null ) . intValue ( ) ) ; allStatsVO . setQuestionCount ( questionMapper . selectCount ( null ) . intValue ( ) ) ; } else if ( \"<STR_LIT>\" . equals ( role ) ) { allStatsVO . setClassCount ( gradeMapper . selectCount ( new LambdaQueryWrapper < Grade > ( ) . eq ( Grade :: getUserId , SecurityUtil . getUserId ( ) ) ) . intValue ( ) ) ; allStatsVO . setExamCount ( examMapper . selectCount ( new LambdaQueryWrapper < Exam > ( ) . eq ( Exam :: getUserId , SecurityUtil . getUserId ( ) ) ) . intValue ( ) ) ; allStatsVO . setQuestionCount ( questionMapper . selectCount ( new LambdaQueryWrapper < Question > ( ) . eq ( Question :: getUserId , SecurityUtil . getUserId ( ) ) ) . intValue ( ) ) ; } return Result . success ( \"<STR_LIT>\" , allStatsVO ) ; } @ Override public Result < List < DailyVO > > getDaily ( ) { List < DailyVO > daily = userDailyLoginDurationMapper . getDaily ( SecurityUtil . getUserId ( ) ) ; return Result . success ( \"<STR_LIT>\" , daily ) ; } }"}, {"input": "package org . springblade . cgform . model . generate . util ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; @ Slf4j public class FileUtil { public static List < String > fileStrList = new ArrayList < String > ( ) ; public static List < String > fileStrListFtl = new ArrayList < String > ( ) ; public static List < File > fileArrSort ( File file ) throws IOException { ArrayList < File > list = new ArrayList < File > ( ) ; readAllFiles ( file , ( List < File > ) list ) ; Collections . sort ( list , ( Comparator < ? super File > ) new Comparator < File > ( ) { public int compare ( File file , File file2 ) { return file . getAbsolutePath ( ) . compareTo ( file2 . getAbsolutePath ( ) ) ; }", "output": "} ) ; return ( List < File > ) list ; } public static void readAllFiles ( File file , List < File > list ) throws IOException { log . debug ( \"<STR_LIT>\" + file . getPath ( ) + \"<STR_LIT>\" + file . isHidden ( ) + \"<STR_LIT>\" + file . isDirectory ( ) ) ; if ( ! file . isHidden ( ) && file . isDirectory ( ) && ! isFileStrList ( file ) ) { final File [ ] listFiles = file . listFiles ( ) ; for ( int i = <NUM_LIT> ; i < listFiles . length ; ++ i ) { readAllFiles ( listFiles [ i ] , list ) ; } } else if ( ! isFileStrList2 ( file ) && ! isFileStrList ( file ) ) { list . add ( file ) ; } } public static String fileArrSort ( File file , File file2 ) { if ( file . equals ( file2 ) ) { return \"<STR_LIT>\" ; } if ( file . getParentFile ( ) == null ) { return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) ) ; } return file2 . getAbsolutePath ( ) . substring ( file . getAbsolutePath ( ) . length ( ) + <NUM_LIT> ) ; } public static boolean isDirectory ( File file ) { return ! file . isDirectory ( ) && isBlank ( file . getName ( ) ) ; } public static boolean isBlank ( String s ) { return ! StringUtils . isBlank ( subStrDot ( s ) ) ; } public static String subStrDot ( String s ) { if ( s == null ) { return null ; } final int index = s . indexOf ( \"<STR_LIT>\" ) ; if ( index == - <NUM_LIT> ) { return \"<STR_LIT>\" ; } return s . substring ( index + <NUM_LIT> ) ; } public static File readFile ( String s ) { if ( s == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } File file = new File ( s ) ; createFiles ( file ) ; return file ; } public static void createFiles ( File file ) { if ( file . getParentFile ( ) != null ) { file . getParentFile ( ) . mkdirs ( ) ; } } private static boolean isFileStrList ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrList . size ( ) ; ++ i ) { if ( file . getName ( ) . equals ( fileStrList . get ( i ) ) ) { return true ; } } return false ; } private static boolean isFileStrList2 ( File file ) { for ( int i = <NUM_LIT> ; i < fileStrListFtl . size ( ) ; ++ i ) { if ( file . getName ( ) . endsWith ( fileStrListFtl . get ( i ) ) ) { return true ; } } return false ; } static { fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrList . add ( \"<STR_LIT>\" ) ; fileStrListFtl . add ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . oddfar . campus . common . config ; import com . fasterxml . jackson . core . JsonGenerator ; import com . fasterxml . jackson . databind . BeanProperty ; import com . fasterxml . jackson . databind . JsonMappingException ; import com . fasterxml . jackson . databind . JsonSerializer ; import com . fasterxml . jackson . databind . SerializerProvider ; import com . fasterxml . jackson . databind . ser . ContextualSerializer ; import com . oddfar . campus . common . annotation . Sensitive ; import com . oddfar . campus . common . enums . SensitiveStrategy ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeansException ; import java . io . IOException ; import java . util . Objects ; @ Slf4j public class SensitiveSerializer extends JsonSerializer < String > implements ContextualSerializer { private SensitiveStrategy strategy ; @ Override public void serialize ( String value , JsonGenerator gen , SerializerProvider serializers ) throws IOException {", "output": "try { gen . writeString ( strategy . desensitizer ( ) . apply ( value ) ) ; } catch ( BeansException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; gen . writeString ( value ) ; } } @ Override public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { Sensitive annotation = property . getAnnotation ( Sensitive . class ) ; if ( Objects . nonNull ( annotation ) && Objects . equals ( String . class , property . getType ( ) . getRawClass ( ) ) ) { this . strategy = annotation . strategy ( ) ; return this ; } return prov . findValueSerializer ( property . getType ( ) , property ) ; } }"}, {"input": "package com . yf . ability . excel . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( { ElementType . METHOD , ElementType . FIELD , ElementType . TYPE }", "output": ") @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelField { String title ( ) ; String filter ( ) default \"<STR_LIT>\" ; int sort ( ) default <NUM_LIT> ; String pattern ( ) default \"<STR_LIT>\" ; String dictCode ( ) default \"<STR_LIT>\" ; String dicText ( ) default \"<STR_LIT>\" ; String dictTable ( ) default \"<STR_LIT>\" ; }"}, {"input": "package org . springblade . config . util ; import freemarker . template . Configuration ; import freemarker . template . Template ; import lombok . extern . slf4j . Slf4j ; import java . io . StringWriter ; import java . util . Map ; @ Slf4j public class FreemarkerHelper { private static Configuration configuration = new Configuration ( Configuration . VERSION_2_3_31 ) ; ; public static String process ( String templatePath , String encode , Map < String , Object > data ) { try { StringWriter write = new StringWriter ( ) ; Template template = null ; template = configuration . getTemplate ( templatePath , encode ) ; template . process ( data , write ) ; return write . toString ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ;", "output": "return e . toString ( ) ; } } public static String process ( String templatePath , Map < String , Object > data ) { return process ( templatePath , \"<STR_LIT>\" , data ) ; } static { configuration . setNumberFormat ( \"<STR_LIT>\" ) ; configuration . setClassForTemplateLoading ( FreemarkerHelper . class , \"<STR_LIT>\" ) ; } }"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . mysql . MyPage ; import ginyi . system . domain . SysLogLogin ; import ginyi . system . domain . SysLogOperation ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . service . ISysLogService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . data . domain . Sort ; import org . springframework . data . mongodb . core . MongoTemplate ; import org . springframework . data . mongodb . core . query . Query ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . List ; @ Slf4j @ Service public class SysLogServiceImpl implements ISysLogService { @ Resource private MongoTemplate mongoTemplate ; @ Override public BaseVo < SysLogLogin > getLoginLogList ( Long page , Long pageSize ) { MyPage IPage = new MyPage ( page , pageSize ) ; BaseVo < SysLogLogin > baseVo = new BaseVo < > ( ) ; Query query = new Query ( ) ; long count = mongoTemplate . count ( query , SysLogLogin . class ) ; query . skip ( ( int ) ( IPage . getPageSize ( ) * ( IPage . getPageNum ( ) - <NUM_LIT> ) ) ) ; query . limit ( IPage . getPageSize ( ) . intValue ( ) ) ; query . with ( Sort . by ( Sort . Order . desc ( \"<STR_LIT>\" ) ) ) ; List < SysLogLogin > list = mongoTemplate . find ( query , SysLogLogin . class ) ; baseVo . setList ( list ) ; baseVo . setCount ( ( int ) count ) ; return baseVo ; }", "output": "@ Override public BaseVo < SysLogOperation > getOperationLogList ( Long page , Long pageSize ) { MyPage IPage = new MyPage ( page , pageSize ) ; BaseVo < SysLogOperation > baseVo = new BaseVo < > ( ) ; Query query = new Query ( ) ; long count = mongoTemplate . count ( query , SysLogOperation . class ) ; int skip = ( int ) ( IPage . getPageSize ( ) * ( IPage . getPageNum ( ) - <NUM_LIT> ) ) ; query . skip ( skip ) . limit ( IPage . getPageSize ( ) . intValue ( ) ) ; query . with ( Sort . by ( Sort . Order . desc ( \"<STR_LIT>\" ) ) ) ; List < SysLogOperation > list = mongoTemplate . find ( query , SysLogOperation . class ) ; baseVo . setList ( list ) ; baseVo . setCount ( ( int ) count ) ; return baseVo ; } }"}, {"input": "package com . yf . base . utils ; import org . apache . commons . io . FileUtils ; import org . springframework . core . io . ClassPathResource ; import javax . servlet . http . HttpServletResponse ; import java . io . * ; public class ResourceUtil { public static byte [ ] toByteArray ( InputStream input ) throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> * <NUM_LIT> ] ; int n = <NUM_LIT> ; while ( - <NUM_LIT> != ( n = input . read ( buffer ) ) ) { output . write ( buffer , <NUM_LIT> , n ) ; } return output . toByteArray ( ) ; } public static void write ( HttpServletResponse response , String path ) throws Exception { InputStream fis = new ClassPathResource ( path ) . getInputStream ( ) ; byte [ ] data = toByteArray ( fis ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; response . setContentType ( \"<STR_LIT>\" ) ; OutputStream os = new BufferedOutputStream ( response . getOutputStream ( ) ) ; os . write ( data ) ; os . flush ( ) ; os . close ( ) ; } public static String tempDir ( boolean create ) { String path = System . getProperty ( \"<STR_LIT>\" ) ; if ( create ) { File file = new File ( path ) ; if ( ! file . exists ( ) ) { file . mkdirs ( ) ; } } return path ; } public static String fullPath ( String path ) throws IOException { String filePath = tempDir ( true ) + path ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { return filePath ; } InputStream is = new ClassPathResource ( path ) . getInputStream ( ) ; FileUtils . copyInputStreamToFile ( is , file ) ; return filePath ; }", "output": "public static void main ( String [ ] args ) throws IOException { System . out . println ( fullPath ( \"<STR_LIT>\" ) ) ; } }"}, {"input": "package org . springblade . config . util ; import java . io . File ; import java . io . FileInputStream ; import java . text . DecimalFormat ; public class FileSizeUtil { private static final String TAG = FileSizeUtil . class . getSimpleName ( ) ; public static final int SIZETYPE_B = <NUM_LIT> ; public static final int SIZETYPE_KB = <NUM_LIT> ; public static final int SIZETYPE_MB = <NUM_LIT> ; public static final int SIZETYPE_GB = <NUM_LIT> ; public static double getFileOrFilesSize ( String filePath , int sizeType ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return FormetFileSize ( blockSize , sizeType ) ; } public static String getAutoFileOrFilesSize ( String filePath ) { File file = new File ( filePath ) ; long blockSize = <NUM_LIT> ; try { if ( file . isDirectory ( ) ) { blockSize = getFileSizes ( file ) ; } else { blockSize = getFileSize ( file ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return formatFileSize ( blockSize ) ; } private static long getFileSize ( File file ) throws Exception { long size = <NUM_LIT> ; if ( file . exists ( ) ) { FileInputStream fis = null ; fis = new FileInputStream ( file ) ; size = fis . available ( ) ; } else { file . createNewFile ( ) ; } return size ; } private static long getFileSizes ( File f ) throws Exception { long size = <NUM_LIT> ; File flist [ ] = f . listFiles ( ) ; assert flist != null ; for ( File file : flist ) { if ( file . isDirectory ( ) ) { size = size + getFileSizes ( file ) ; } else { size = size + getFileSize ( file ) ; } } return size ; } public static String formatFileSize ( long fileS ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; String fileSizeString = \"<STR_LIT>\" ; String wrongSize = \"<STR_LIT>\" ;", "output": "if ( fileS == <NUM_LIT> ) { return wrongSize ; } if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else if ( fileS < <NUM_LIT> ) { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } else { fileSizeString = df . format ( ( double ) fileS / <NUM_LIT> ) + \"<STR_LIT>\" ; } return fileSizeString ; } private static double FormetFileSize ( long fileS , int sizeType ) { DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; double fileSizeLong = <NUM_LIT> ; switch ( sizeType ) { case SIZETYPE_B : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS ) ) ; break ; case SIZETYPE_KB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ; break ; case SIZETYPE_MB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ; break ; case SIZETYPE_GB : fileSizeLong = Double . valueOf ( df . format ( ( double ) fileS / <NUM_LIT> ) ) ; break ; default : break ; } return fileSizeLong ; } }"}, {"input": "package com . youlai . system . filter ; import cn . hutool . captcha . generator . CodeGenerator ; import cn . hutool . core . util . StrUtil ; import com . youlai . system . common . constant . SecurityConstants ; import com . youlai . system . common . result . ResultCode ; import com . youlai . system . common . util . ResponseUtils ; import jakarta . servlet . FilterChain ; import jakarta . servlet . ServletException ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . servlet . http . HttpServletResponse ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . security . web . util . matcher . AntPathRequestMatcher ; import org . springframework . web . filter . OncePerRequestFilter ; import java . io . IOException ; public class CaptchaValidationFilter extends OncePerRequestFilter { private static final AntPathRequestMatcher LOGIN_PATH_REQUEST_MATCHER = new AntPathRequestMatcher ( SecurityConstants . LOGIN_PATH , \"<STR_LIT>\" ) ; public static final String CAPTCHA_CODE_PARAM_NAME = \"<STR_LIT>\" ; public static final String CAPTCHA_KEY_PARAM_NAME = \"<STR_LIT>\" ; private final RedisTemplate < String , Object > redisTemplate ; private final CodeGenerator codeGenerator ; public CaptchaValidationFilter ( RedisTemplate < String , Object > redisTemplate , CodeGenerator codeGenerator ) { this . redisTemplate = redisTemplate ; this . codeGenerator = codeGenerator ; } @ Override public void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain chain ) throws ServletException , IOException { if ( LOGIN_PATH_REQUEST_MATCHER . matches ( request ) ) { String captchaCode = request . getParameter ( CAPTCHA_CODE_PARAM_NAME ) ; if ( StrUtil . isBlank ( captchaCode ) ) { chain . doFilter ( request , response ) ; return ; } String verifyCodeKey = request . getParameter ( CAPTCHA_KEY_PARAM_NAME ) ; String cacheVerifyCode = ( String ) redisTemplate . opsForValue ( ) . get ( SecurityConstants . CAPTCHA_CODE_PREFIX + verifyCodeKey ) ; if ( cacheVerifyCode == null ) { ResponseUtils . writeErrMsg ( response , ResultCode . VERIFY_CODE_TIMEOUT ) ; } else { if ( codeGenerator . verify ( cacheVerifyCode , captchaCode ) ) { chain . doFilter ( request , response ) ; } else { ResponseUtils . writeErrMsg ( response , ResultCode . VERIFY_CODE_ERROR ) ; } } } else { chain . doFilter ( request , response ) ;", "output": "} } }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysServer ; import ginyi . system . domain . model . dto . CacheDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . CacheKeyVo ; import ginyi . system . domain . model . vo . CacheVo ; public interface ISysMonitorService { public SysServer getServerInfo ( ) throws InterruptedException ; public BaseVo < CacheKeyVo > getCacheList ( ) ; public CacheVo getCacheDetails ( CacheDto cacheDto ) ; public void removeCache ( String key ) ;", "output": "}"}, {"input": "package top . kangert . kspider . expression ; import top . kangert . kspider . expression . parsing . Span ; import top . kangert . kspider . expression . parsing . TokenStream ; public class ExpressionError { public static void error ( String message , TokenStream stream ) { if ( stream . hasMore ( ) ) { error ( message , stream . consume ( ) . getSpan ( ) ) ; } else { String source = stream . getSource ( ) ; if ( source == null ) { error ( message , new Span ( \"<STR_LIT>\" , <NUM_LIT> , <NUM_LIT> ) ) ; } else { error ( message , new Span ( source , source . length ( ) - <NUM_LIT> , source . length ( ) ) ) ; } } } public static void error ( String message , Span location , Throwable cause ) { Span . Line line = location . getLine ( ) ; message = \"<STR_LIT>\" + line . getLineNumber ( ) + \"<STR_LIT>\" + message + \"<STR_LIT>\" ; message += line . getText ( ) ; message += \"<STR_LIT>\" ; int errorStart = location . getStart ( ) - line . getStart ( ) ; int errorEnd = errorStart + location . getText ( ) . length ( ) - <NUM_LIT> ; for ( int i = <NUM_LIT> , n = line . getText ( ) . length ( ) ; i < n ; i ++ ) { boolean useTab = line . getText ( ) . charAt ( i ) == '<STR_LIT>' ; message += i >= errorStart && i <= errorEnd ? \"<STR_LIT>\" : useTab ? \"<STR_LIT>\" : \"<STR_LIT>\" ; } if ( cause == null ) { throw new TemplateException ( message , location ) ; } else { throw new TemplateException ( message , location , cause ) ; } } public static void error ( String message , Span location ) { error ( message , location , null ) ; } public static class TemplateException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private final Span location ; private final String errorMessage ; private TemplateException ( String message , Span location ) { super ( message ) ; this . errorMessage = message ; this . location = location ; } public TemplateException ( String message , Span location , Throwable cause ) { super ( message , cause ) ; this . errorMessage = message ; this . location = location ; } public Span getLocation ( ) { return location ; } @ Override public String getMessage ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( getCause ( ) == null || getCause ( ) == this ) { return super . getMessage ( ) ; } builder . append ( errorMessage . substring ( <NUM_LIT> , errorMessage . indexOf ( '<STR_LIT>' ) ) ) ; builder . append ( \"<STR_LIT>\" ) ; Throwable cause = getCause ( ) ; while ( cause != null && cause != this ) { if ( cause instanceof TemplateException ) {", "output": "TemplateException ex = ( TemplateException ) cause ; if ( ex . getCause ( ) == null || ex . getCause ( ) == ex ) { builder . append ( ex . errorMessage ) ; } else { builder . append ( ex . errorMessage . substring ( <NUM_LIT> , ex . errorMessage . indexOf ( '<STR_LIT>' ) ) ) ; } builder . append ( \"<STR_LIT>\" ) ; } cause = cause . getCause ( ) ; } return builder . toString ( ) ; } } public static class StringLiteralException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; } }"}, {"input": "package org . springblade . gateway . props ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . cloud . context . config . annotation . RefreshScope ; import java . util . ArrayList ; import java . util . List ; @ Data @ RefreshScope @ ConfigurationProperties ( \"<STR_LIT>\" ) public class AuthProperties { private final List < String > skipUrl = new ArrayList < > ( ) ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceSql extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSql ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgbSqlName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceName ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; public class Pair < L , R > { @ Nullable private final L left ; @ Nullable private final R right ; public Pair ( @ Nullable L left , @ Nullable R right ) { this . left = left ; this . right = right ; } @ Nullable public L getLeft ( ) { return left ; } @ Nullable public R getRight ( ) { return right ; } @ Override public int hashCode ( ) { final int prime = <NUM_LIT> ; int result = <NUM_LIT> ; result = prime * result + ( ( left == null ) ? <NUM_LIT> : left . hashCode ( ) ) ; return prime * result + ( ( right == null ) ? <NUM_LIT> : right . hashCode ( ) ) ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Pair other = ( Pair ) obj ; if ( left == null ) { if ( other . left != null ) { return false ; } } else if ( ! left . equals ( other . left ) ) { return false ; } if ( right == null ) { if ( other . right != null ) { return false ; } } else if ( ! right . equals ( other . right ) ) { return false ; } return true ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + left + \"<STR_LIT>\" + right + '<STR_LIT>' ; } public static < L , R > Pair < L , R > of ( @ Nullable L left , @ Nullable R right ) { return new Pair < L , R > ( left , right ) ; }", "output": "}"}, {"input": "package ginyi . framework . security . service ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . mysql . MyPage ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . SysNotice ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . NoticeDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . NoticeVo ; import ginyi . system . mapper . SysNoticeMapper ; import ginyi . system . mapper . SysUserMapper ; import ginyi . system . service . ISysNoticeService ; import ginyi . system . service . ITokenService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Service public class ISysNoticeServiceImpl implements ISysNoticeService { @ Resource private SysNoticeMapper noticeMapper ; @ Resource private SysUserMapper userMapper ; @ Resource private ITokenService tokenService ; @ Resource private HttpServletRequest request ; @ Resource private RedisCache redisCache ; @ Override public BaseVo < SysNotice > list ( NoticeDto noticeDto , Long page , Long pageSize ) { IPage < SysNotice > list = noticeMapper . list ( noticeDto , new MyPage ( page , pageSize ) . getPage ( ) ) ; for ( SysNotice notice : list . getRecords ( ) ) { if ( StringUtils . isNull ( notice . getUserReadIds ( ) ) ) { notice . setUserReadIds ( new ArrayList < > ( ) ) ; } } BaseVo < SysNotice > baseVo = new BaseVo < > ( ) ; baseVo . setList ( list . getRecords ( ) ) ; baseVo . setCount ( ( int ) list . getTotal ( ) ) ; return baseVo ; } @ Override public BaseVo < NoticeVo > getUserNoticeList ( Long page , Long pageSize ) { LoginUser loginUser = tokenService . getLoginUser ( request ) ; Long userId = loginUser . getUserId ( ) ; IPage < SysNotice > list = noticeMapper . getUserNoticeList ( userId , new MyPage ( page , pageSize ) . getPage ( ) ) ; ArrayList < NoticeVo > noticeList = new ArrayList < > ( ) ; for ( SysNotice notice : list . getRecords ( ) ) { List < Long > userReadIds = notice . getUserReadIds ( ) ; NoticeVo vo = new NoticeVo ( ) ; BeanUtils . copyProperties ( notice , vo ) ; if ( StringUtils . isNotNull ( userReadIds ) ) { vo . setHaveRead ( userReadIds . contains ( userId ) ) ; } noticeList . add ( vo ) ; } BaseVo < NoticeVo > baseVo = new BaseVo < > ( ) ; baseVo . setList ( noticeList ) ; baseVo . setCount ( ( int ) list . getTotal ( ) ) ; return baseVo ; } @ Override public void add ( NoticeDto noticeDto ) { List < SysUser > userList = userMapper . selectList ( null ) ; if ( noticeDto . getUserIds ( ) . size ( ) > <NUM_LIT> ) { for ( Long userId : noticeDto . getUserIds ( ) ) { boolean isExist = false ; for ( SysUser user : userList ) { if ( userId . equals ( user . getUserId ( ) ) ) { isExist = true ; break ; } } if ( ! isExist ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , userId + CommonMessageConstants . USER_NOT_EXIST ) ; } } } else { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . USER_IDS_ILLEGAL ) ; } noticeMapper . addNotice ( noticeDto ) ; } @ Override public void updateNotice ( NoticeDto noticeDto ) { if ( redisCache . hasKey ( CacheConstants . NOTICE_NOT_EXIST_KEY + noticeDto . getNoticeId ( ) ) ) {", "output": "throw new CommonException ( StateCode . ERROR_NOT_EXIST , noticeDto . getNoticeId ( ) + CommonMessageConstants . NOTICE_NOT_EXIST ) ; } SysNotice notice = noticeMapper . selectOne ( noticeDto . getNoticeId ( ) ) ; if ( StringUtils . isNull ( notice ) ) { redisCache . setCacheObject ( CacheConstants . NOTICE_NOT_EXIST_KEY + noticeDto . getNoticeId ( ) , noticeDto . getNoticeId ( ) ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , noticeDto . getNoticeId ( ) + CommonMessageConstants . NOTICE_NOT_EXIST ) ; } if ( StringUtils . isNotNull ( notice . getUserReadIds ( ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS_SERVICE , CommonMessageConstants . NOTICE_NOT_ALLOW ) ; } noticeMapper . updateNotice ( noticeDto ) ; } @ Override public void haveRead ( Long noticeId ) { if ( redisCache . hasKey ( CacheConstants . NOTICE_NOT_EXIST_KEY + noticeId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , noticeId + CommonMessageConstants . NOTICE_NOT_EXIST ) ; } LambdaQueryWrapper < SysNotice > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysNotice :: getNoticeId , noticeId ) ; SysNotice notice = noticeMapper . selectOne ( noticeId ) ; if ( StringUtils . isNull ( notice ) ) { redisCache . setCacheObject ( CacheConstants . NOTICE_NOT_EXIST_KEY + noticeId , noticeId ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , noticeId + CommonMessageConstants . NOTICE_NOT_EXIST ) ; } LoginUser loginUser = tokenService . getLoginUser ( request ) ; Long userId = loginUser . getUserId ( ) ; List < Long > userReadIds = notice . getUserReadIds ( ) ; if ( StringUtils . isNull ( userReadIds ) ) { userReadIds = new ArrayList < > ( ) ; } if ( ! notice . getUserIds ( ) . contains ( userId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . NOTICE_CURRENT_USER_NOT_EXIST ) ; } if ( userReadIds . contains ( userId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . NOTICE_HAVE_READ ) ; } userReadIds . add ( userId ) ; notice . setUserReadIds ( userReadIds ) ; noticeMapper . haveRead ( notice ) ; } @ Override public void remove ( Long noticeId ) { if ( redisCache . hasKey ( CacheConstants . NOTICE_NOT_EXIST_KEY + noticeId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , noticeId + CommonMessageConstants . NOTICE_NOT_EXIST ) ; } SysNotice notice = noticeMapper . selectOne ( noticeId ) ; if ( StringUtils . isNull ( notice ) ) { redisCache . setCacheObject ( CacheConstants . NOTICE_NOT_EXIST_KEY + noticeId , noticeId ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , noticeId + CommonMessageConstants . NOTICE_NOT_EXIST ) ; } LambdaQueryWrapper < SysNotice > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysNotice :: getNoticeId , noticeId ) ; noticeMapper . delete ( queryWrapper ) ; } }"}, {"input": "package top . kangert . kspider . exception ; public class BaseException extends RuntimeException { private int code ; private String messageId ; private String message ; public BaseException ( String message ) { this . message = message ; } public BaseException ( String message , Throwable e ) { this . message = message ; } public BaseException ( int code , String message ) { this . message = message ; this . code = code ; } public BaseException ( ExceptionCodes e ) { this . code = e . getCode ( ) ; this . messageId = e . getMessageId ( ) ;", "output": "this . message = e . getMessage ( ) ; } public BaseException ( ExceptionCodes e , String message ) { this . code = e . getCode ( ) ; this . messageId = e . getMessageId ( ) ; this . message = e . getMessage ( ) + \"<STR_LIT>\" + message ; } public BaseException ( int code , String message , Throwable e ) { this . message = message ; this . code = code ; } public int getCode ( ) { return code ; } public void setCode ( int code ) { this . code = code ; } public String getMessageId ( ) { return messageId ; } public void setMessageId ( String messageId ) { this . messageId = messageId ; } public String getMessage ( ) { return message ; } public void setMessage ( String message ) { this . message = message ; } }"}, {"input": "package ginyi . system . domain . model . vo ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class PostVo extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long postId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String postCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String postName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String status ;", "output": "}"}, {"input": "package top . kangert . kspider . expression ; import java . util . * ; import top . kangert . kspider . expression . interpreter . AstInterpreter ; public class ExpressionTemplateContext { private final List < Map < String , Object > > scopes = new ArrayList < Map < String , Object > > ( ) ; private final List < Map < String , Object > > freeScopes = new ArrayList < Map < String , Object > > ( ) ; private final static ThreadLocal < ExpressionTemplateContext > CONTEXT_THREAD_LOCAL = new ThreadLocal < > ( ) ; public static ExpressionTemplateContext get ( ) { return CONTEXT_THREAD_LOCAL . get ( ) ; } public static void remove ( ) { CONTEXT_THREAD_LOCAL . remove ( ) ; } public static void set ( ExpressionTemplateContext context ) { CONTEXT_THREAD_LOCAL . set ( context ) ; } public ExpressionTemplateContext ( ) { push ( ) ; } public ExpressionTemplateContext ( Map < String , Object > variables ) { this ( ) ; if ( variables != null ) { variables . forEach ( this :: set ) ; } } public ExpressionTemplateContext set ( String name , Object value ) { for ( int i = scopes . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { Map < String , Object > ctx = scopes . get ( i ) ; if ( ctx . isEmpty ( ) ) { continue ; } if ( ctx . containsKey ( name ) ) { ctx . put ( name , value ) ; return this ; } } scopes . get ( scopes . size ( ) - <NUM_LIT> ) . put ( name , value ) ; return this ; } public ExpressionTemplateContext setOnCurrentScope ( String name , Object value ) { scopes . get ( scopes . size ( ) - <NUM_LIT> ) . put ( name , value ) ; return this ; } public Object get ( String name ) { for ( int i = scopes . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { Map < String , Object > ctx = scopes . get ( i ) ; if ( ctx . isEmpty ( ) ) { continue ; } Object value = ctx . get ( name ) ;", "output": "if ( value != null ) { return value ; } } return null ; } public Set < String > getVariables ( ) { Set < String > variables = new HashSet < String > ( ) ; for ( int i = <NUM_LIT> , n = scopes . size ( ) ; i < n ; i ++ ) { variables . addAll ( scopes . get ( i ) . keySet ( ) ) ; } return variables ; } public void push ( ) { Map < String , Object > newScope = freeScopes . size ( ) > <NUM_LIT> ? freeScopes . remove ( freeScopes . size ( ) - <NUM_LIT> ) : new HashMap < String , Object > ( ) ; scopes . add ( newScope ) ; } public void pop ( ) { Map < String , Object > oldScope = scopes . remove ( scopes . size ( ) - <NUM_LIT> ) ; oldScope . clear ( ) ; freeScopes . add ( oldScope ) ; } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class SendEmailParam implements Serializable { private String email ; private String title ; private List < String > content ;", "output": "}"}, {"input": "package org . springblade . config . autopoi . poi . exception . excel ; import org . springblade . config . autopoi . poi . exception . excel . enums . ExcelExportEnum ; public class ExcelExportException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private ExcelExportEnum type ; public ExcelExportException ( ) { super ( ) ;", "output": "} public ExcelExportException ( ExcelExportEnum type ) { super ( type . getMsg ( ) ) ; this . type = type ; } public ExcelExportException ( ExcelExportEnum type , Throwable cause ) { super ( type . getMsg ( ) , cause ) ; } public ExcelExportException ( String message ) { super ( message ) ; } public ExcelExportException ( String message , ExcelExportEnum type ) { super ( message ) ; this . type = type ; } public ExcelExportEnum getType ( ) { return type ; } public void setType ( ExcelExportEnum type ) { this . type = type ; } }"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysRoleMenuReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > menuIds ;", "output": "}"}, {"input": "package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . SysLog ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . aspectj . lang . ProceedingJoinPoint ; import org . springframework . scheduling . annotation . Async ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public interface SysLogService extends IService < SysLog > { PageResult < SysLog > queryAll ( SysLogQueryCriteria criteria , Page < SysLog > page ) ; List < SysLog > queryAll ( SysLogQueryCriteria criteria ) ; PageResult < SysLog > queryAllByUser ( SysLogQueryCriteria criteria , Page < SysLog > page ) ; @ Async void save ( String username , String browser , String ip , ProceedingJoinPoint joinPoint , SysLog sysLog ) ; Object findByErrDetail ( Long id ) ;", "output": "void download ( List < SysLog > sysLogs , HttpServletResponse response ) throws IOException ; void delAllByError ( ) ; void delAllByInfo ( ) ; }"}, {"input": "package ginyi . framework . security . interceptor ; import com . alibaba . fastjson2 . JSON ; import ginyi . common . annotation . RepeatSubmit ; import ginyi . common . result . CommonResult ; import ginyi . common . result . StateCode ; import ginyi . common . utils . ServletUtils ; import org . springframework . stereotype . Component ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . HandlerInterceptor ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . lang . reflect . Method ; @ Component public abstract class RepeatSubmitInterceptor implements HandlerInterceptor { @ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { if ( handler instanceof HandlerMethod ) { HandlerMethod handlerMethod = ( HandlerMethod ) handler ; Method method = handlerMethod . getMethod ( ) ; RepeatSubmit annotation = method . getAnnotation ( RepeatSubmit . class ) ; if ( annotation != null ) { if ( this . isRepeatSubmit ( request , annotation ) ) {", "output": "CommonResult commonResult = CommonResult . error ( StateCode . ERROR_PARAMS_SERVICE , annotation . message ( ) ) ; ServletUtils . renderString ( response , JSON . toJSONString ( commonResult ) ) ; return false ; } } return true ; } else { return true ; } } public abstract boolean isRepeatSubmit ( HttpServletRequest request , RepeatSubmit annotation ) ; }"}, {"input": "package me . zhengjie . modules . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Set ; @ Mapper public interface RoleMapper extends BaseMapper < Role > { List < Role > queryAll ( ) ; Role findById ( @ Param ( \"<STR_LIT>\" ) Long roleId ) ; Role findByName ( @ Param ( \"<STR_LIT>\" ) String name ) ; List < Role > findByUserId ( @ Param ( \"<STR_LIT>\" ) Long userId ) ;", "output": "Long countAll ( @ Param ( \"<STR_LIT>\" ) RoleQueryCriteria criteria ) ; List < Role > findAll ( @ Param ( \"<STR_LIT>\" ) RoleQueryCriteria criteria ) ; int countByDepts ( @ Param ( \"<STR_LIT>\" ) Set < Long > deptIds ) ; @ Select ( \"<STR_LIT>\" + \"<STR_LIT>\" ) List < Role > findByMenuId ( @ Param ( \"<STR_LIT>\" ) Long menuId ) ; }"}, {"input": "package com . oddfar . campus . framework . api . file ; import org . springframework . web . multipart . MultipartFile ; public interface FileOperatorApi {", "output": "void storageFile ( String bucketName , MultipartFile file , String [ ] allowedExtension ) ; }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoaderFactory ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import io . github . chensheng . dddboot . nacos . spring . factory . CacheableEventPublishingNacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContextInitializer ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; import java . util . function . Function ; public class NacosConfigApplicationContextInitializer implements ApplicationContextInitializer < ConfigurableApplicationContext > { private final Logger logger = LoggerFactory . getLogger ( NacosConfigApplicationContextInitializer . class ) ; private final NacosConfigEnvironmentProcessor processor ; private final CacheableEventPublishingNacosServiceFactory singleton = CacheableEventPublishingNacosServiceFactory . getSingleton ( ) ; private final Function < Properties , ConfigService > builder = properties -> { try { return singleton . createConfigService ( properties ) ; } catch ( NacosException e ) { throw new NacosBootConfigException ( \"<STR_LIT>\" + properties , e ) ; } } ; private ConfigurableEnvironment environment ; private NacosConfigProperties nacosConfigProperties ; public NacosConfigApplicationContextInitializer ( NacosConfigEnvironmentProcessor configEnvironmentProcessor ) { this . processor = configEnvironmentProcessor ; } @ Override public void initialize ( ConfigurableApplicationContext context ) { singleton . setApplicationContext ( context ) ; environment = context . getEnvironment ( ) ; nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( environment ) ; final NacosConfigLoader configLoader = NacosConfigLoaderFactory . getSingleton ( nacosConfigProperties , environment , builder ) ; if ( ! enable ( ) ) { logger . info ( \"<STR_LIT>\" ) ; } else { if ( processor . enable ( ) ) { processor . publishDeferService ( context ) ; configLoader . addListenerIfAutoRefreshed ( processor . getDeferPropertySources ( ) ) ; } else { configLoader . loadConfig ( ) ; configLoader . addListenerIfAutoRefreshed ( ) ; } } final ConfigurableListableBeanFactory factory = context . getBeanFactory ( ) ; if ( ! factory . containsSingleton ( NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ) { factory . registerSingleton ( NacosBeanUtils . GLOBAL_NACOS_PROPERTIES_BEAN_NAME , configLoader . getGlobalProperties ( ) ) ; } } private boolean enable ( ) { return processor . enable ( ) || nacosConfigProperties . getBootstrap ( ) . isEnable ( ) ;", "output": "} }"}, {"input": "package com . oddfar . campus . framework . security . context ; import org . springframework . security . core . Authentication ; public class AuthenticationContextHolder { private static final ThreadLocal < Authentication > contextHolder = new ThreadLocal < > ( ) ; public static Authentication getContext ( ) { return contextHolder . get ( ) ; } public static void setContext ( Authentication context ) { contextHolder . set ( context ) ;", "output": "} public static void clearContext ( ) { contextHolder . remove ( ) ; } }"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class FieldModel { private String fieldName ; private String tableName ; private String codeField ; private String textField ; private String pidField ; private String pidValue ; private String hsaChildField ;", "output": "}"}, {"input": "package me . zhengjie . aspect ; import com . google . common . collect . ImmutableList ; import me . zhengjie . annotation . Limit ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . utils . RequestHolder ; import me . zhengjie . utils . StringUtils ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . aspectj . lang . reflect . MethodSignature ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . core . script . DefaultRedisScript ; import org . springframework . data . redis . core . script . RedisScript ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . lang . reflect . Method ; @ Aspect @ Component public class LimitAspect { private final RedisTemplate < Object , Object > redisTemplate ; private static final Logger logger = LoggerFactory . getLogger ( LimitAspect . class ) ; public LimitAspect ( RedisTemplate < Object , Object > redisTemplate ) { this . redisTemplate = redisTemplate ; } @ Pointcut ( \"<STR_LIT>\" ) public void pointcut ( ) { } @ Around ( \"<STR_LIT>\" ) public Object around ( ProceedingJoinPoint joinPoint ) throws Throwable { HttpServletRequest request = RequestHolder . getHttpServletRequest ( ) ; MethodSignature signature = ( MethodSignature ) joinPoint . getSignature ( ) ; Method signatureMethod = signature . getMethod ( ) ; Limit limit = signatureMethod . getAnnotation ( Limit . class ) ; LimitType limitType = limit . limitType ( ) ; String key = limit . key ( ) ; if ( StringUtils . isEmpty ( key ) ) { if ( limitType == LimitType . IP ) { key = StringUtils . getIp ( request ) ; }", "output": "else { key = signatureMethod . getName ( ) ; } } ImmutableList < Object > keys = ImmutableList . of ( StringUtils . join ( limit . prefix ( ) , \"<STR_LIT>\" , key , \"<STR_LIT>\" , request . getRequestURI ( ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ) ; String luaScript = buildLuaScript ( ) ; RedisScript < Number > redisScript = new DefaultRedisScript < > ( luaScript , Number . class ) ; Number count = redisTemplate . execute ( redisScript , keys , limit . count ( ) , limit . period ( ) ) ; if ( null != count && count . intValue ( ) <= limit . count ( ) ) { logger . info ( \"<STR_LIT>\" , count , keys , limit . name ( ) ) ; return joinPoint . proceed ( ) ; } else { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } private String buildLuaScript ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; } }"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . vo . ContactLabelVO ; import java . util . List ; public interface ContactLabelService {", "output": "List < ContactLabelVO > queryContactLabel ( ) ; }"}, {"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . DesformData ; import org . springblade . cgform . mapper . DesformDataMapper ; import org . springblade . cgform . service . IDesformDataService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class DesformDataServiceImpl extends BaseServiceImpl < DesformDataMapper , DesformData > implements IDesformDataService {", "output": "}"}, {"input": "package me . zhengjie . modules . system . service . impl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . service . DataService ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . modules . system . service . RoleService ; import me . zhengjie . utils . enums . DataScopeEnum ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class DataServiceImpl implements DataService { private final RoleService roleService ; private final DeptService deptService ; @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public List < Long > getDeptIds ( User user ) { Set < Long > deptIds = new HashSet < > ( ) ; List < Role > roleList = roleService . findByUsersId ( user . getId ( ) ) ; for ( Role role : roleList ) { DataScopeEnum dataScopeEnum = DataScopeEnum . find ( role . getDataScope ( ) ) ; switch ( Objects . requireNonNull ( dataScopeEnum ) ) { case THIS_LEVEL : deptIds . add ( user . getDept ( ) . getId ( ) ) ; break ; case CUSTOMIZE : deptIds . addAll ( getCustomize ( deptIds , role ) ) ; break ; default : return new ArrayList < > ( ) ; } } return new ArrayList < > ( deptIds ) ; } public Set < Long > getCustomize ( Set < Long > deptIds , Role role ) { Set < Dept > depts = deptService . findByRoleId ( role . getId ( ) ) ; for ( Dept dept : depts ) { deptIds . add ( dept . getId ( ) ) ; List < Dept > deptChildren = deptService . findByPid ( dept . getId ( ) ) ; if ( deptChildren != null && deptChildren . size ( ) != <NUM_LIT> ) { deptIds . addAll ( deptService . getDeptChildren ( deptChildren ) ) ; } }", "output": "return deptIds ; } }"}, {"input": "package top . kangert . kspider ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . boot . autoconfigure . security . servlet . UserDetailsServiceAutoConfiguration ; import org . springframework . data . jpa . repository . config . EnableJpaAuditing ; import org . springframework . scheduling . annotation . EnableScheduling ; @ SpringBootApplication ( exclude = UserDetailsServiceAutoConfiguration . class , scanBasePackages = \"<STR_LIT>\" ) @ EnableScheduling @ EnableJpaAuditing public class KspiderApplication { public static void main ( String [ ] args ) { SpringApplication . run ( KspiderApplication . class , args ) ;", "output": "} }"}, {"input": "package org . springblade . config . constant ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class MjjyConfig { private static String excludeTable ; private static String databaseSchema ; private static String generateExcludeTable ; private static boolean debug = false ; private static String wx_open_appId ; private static String wx_open_appSecret ; private static String wx_open_redirectUri ; public static String getExcludeTable ( ) {", "output": "return excludeTable ; } public void setExcludeTable ( String excludeTable ) { MjjyConfig . excludeTable = excludeTable ; } public static String getWx_open_appId ( ) { return wx_open_appId ; } public void setWx_open_appId ( String wx_open_appId ) { MjjyConfig . wx_open_appId = wx_open_appId ; } public static String getWx_open_appSecret ( ) { return wx_open_appSecret ; } public void setWx_open_appSecret ( String wx_open_appSecret ) { MjjyConfig . wx_open_appSecret = wx_open_appSecret ; } public static String getWx_open_redirectUri ( ) { return wx_open_redirectUri ; } public void setWx_open_redirectUri ( String wx_open_redirectUri ) { MjjyConfig . wx_open_redirectUri = wx_open_redirectUri ; } public static String getDatabaseSchema ( ) { return databaseSchema ; } public void setDatabaseSchema ( String databaseSchema ) { MjjyConfig . databaseSchema = databaseSchema ; } public static String getGenerateExcludeTable ( ) { return generateExcludeTable ; } public void setGenerateExcludeTable ( String generateExcludeTable ) { MjjyConfig . generateExcludeTable = generateExcludeTable ; } public static boolean isDebug ( ) { return debug ; } public void setDebug ( boolean debug ) { MjjyConfig . debug = debug ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class Role implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private String roleName ; private String code ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public String getRoleName ( ) { return roleName ; } public void setRoleName ( String roleName ) { this . roleName = roleName ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + roleName + \"<STR_LIT>\" + code + \"<STR_LIT>\" ; }", "output": "}"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . ExamQuestion ; import com . baomidou . mybatisplus . extension . service . IService ; public interface IExamQuestionService extends IService < ExamQuestion > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . ExcelXmlConstants ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . util . Arrays ; public class XlsxSheetHandler extends DefaultHandler { private static final Logger logger = LoggerFactory . getLogger ( XlsxSheetHandler . class ) ; private SheetConfig sheetConfig ; private SharedStringsTable sharedStringsTable ; private RowReadingListener rowReadingListener ; private boolean use1904DateWindowing ; private int totalRowCount ; private int currentRowIndex ; private int currentCellIndex ; private CellValueType currentCellValueType ; private String currentCellContent ; private String [ ] currentRowContent ; public XlsxSheetHandler ( SheetConfig sheetConfig , SharedStringsTable sharedStringsTable , RowReadingListener rowReadingListener , boolean use1904DateWindowing ) { if ( sheetConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( sharedStringsTable == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . sheetConfig = sheetConfig ; this . sharedStringsTable = sharedStringsTable ; this . rowReadingListener = rowReadingListener ; this . use1904DateWindowing = use1904DateWindowing ; } @ Override public void startElement ( String uri , String localName , String qName , Attributes attributes ) throws SAXException { doStartDimension ( qName , attributes ) ; doStartRow ( qName ) ; doStartCell ( qName , attributes ) ; doStartCellValue ( qName , attributes ) ; } @ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { doEndCellValue ( qName ) ; doEndRow ( qName ) ; } @ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { currentCellContent += new String ( ch , start , length ) ; } private void doStartDimension ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . DIMENSION_TAG . equals ( qName ) ) { return ; } String ref = attributes . getValue ( ExcelXmlConstants . DIMENSION_ATTR_REF ) ; String totalRowsStr = ref . substring ( ref . indexOf ( \"<STR_LIT>\" ) + <NUM_LIT> ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { totalRowCount = Integer . parseInt ( totalRowsStr ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doStartRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } currentRowContent = new String [ <NUM_LIT> ] ; } private void doStartCell ( String qName , Attributes attributes ) { if ( ! ExcelXmlConstants . CELL_TAG . equals ( qName ) ) { return ; } String processingPositionInfo = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_POSITION ) ; int processingRowIndex = doResolveRowIndex ( processingPositionInfo ) ; if ( processingRowIndex > currentRowIndex ) { currentRowIndex = processingRowIndex ; } currentCellIndex = doResolveCellIndex ( processingPositionInfo ) ; String cellType = attributes . getValue ( ExcelXmlConstants . CELL_ATTR_TYPE ) ; if ( ExcelXmlConstants . CELL_ATTR_TYPE_STRING . equals ( cellType ) ) { currentCellValueType = CellValueType . STRING ; } else { currentCellValueType = CellValueType . AUTO ; } } private void doStartCellValue ( String qName , Attributes attributes ) { if ( ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) || ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentCellContent = \"<STR_LIT>\" ; } } private void doEndRow ( String qName ) { if ( ! ExcelXmlConstants . ROW_TAG . equals ( qName ) ) { return ; } if ( currentRowIndex < sheetConfig . getDataRowStartIndex ( ) ) { return ; } try { Object currentRowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , currentRowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , currentRowData , currentRowIndex ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void doEndCellValue ( String qName ) { if ( ! ExcelXmlConstants . CELL_VALUE_TAG . equals ( qName ) && ! ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { return ; } if ( currentCellIndex >= currentRowContent . length ) { currentRowContent = Arrays . copyOf ( currentRowContent , ( int ) ( currentCellIndex * <NUM_LIT> ) ) ; } if ( ExcelXmlConstants . CELL_VALUE_TAG_1 . equals ( qName ) ) { currentRowContent [ currentCellIndex ] = currentCellContent ; return ; } if ( CellValueType . STRING == currentCellValueType ) { try { int valueIndex = Integer . parseInt ( currentCellContent ) ; currentCellContent = sharedStringsTable . getItemAt ( valueIndex ) . toString ( ) ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } currentRowContent [ currentCellIndex ] = currentCellContent ; } private int doResolveRowIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) { return <NUM_LIT> ; } String rowIndexStr = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; try { return Integer . parseInt ( rowIndexStr ) - <NUM_LIT> ; } catch ( NumberFormatException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } return <NUM_LIT> ; } private int doResolveCellIndex ( String positionInfo ) { if ( TextUtil . isEmpty ( positionInfo ) ) {", "output": "return <NUM_LIT> ; } char [ ] indexChars = positionInfo . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toCharArray ( ) ; if ( indexChars == null || indexChars . length == <NUM_LIT> ) { return <NUM_LIT> ; } int cellIndex = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < indexChars . length ; i ++ ) { cellIndex += ( indexChars [ i ] - '<STR_LIT>' ) * Math . pow ( <NUM_LIT> , ( indexChars . length - i - <NUM_LIT> ) ) ; } return cellIndex - <NUM_LIT> ; } }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . UserBook ; import cn . org . alan . exam . model . vo . userbook . ReUserExamBookVO ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface UserBookConverter { List < ReUserExamBookVO > listEntityToVo ( List < UserBook > list ) ;", "output": "}"}, {"input": "package com . youlai . system . middleware ; import com . youlai . system . model . entity . SysUser ; import lombok . extern . slf4j . Slf4j ; import org . junit . jupiter . api . Test ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . boot . test . context . SpringBootTest ; import org . springframework . data . redis . core . RedisTemplate ; @ SpringBootTest @ Slf4j public class RedisTests { @ Autowired private RedisTemplate redisTemplate ; @ Test public void testRedisSerializer ( ) { SysUser user = new SysUser ( ) ; user . setId ( <NUM_LIT> ) ; user . setNickname ( \"<STR_LIT>\" ) ;", "output": "redisTemplate . opsForValue ( ) . set ( \"<STR_LIT>\" , user ) ; SysUser userCache = ( SysUser ) redisTemplate . opsForValue ( ) . get ( \"<STR_LIT>\" ) ; log . info ( \"<STR_LIT>\" , userCache ) ; } }"}, {"input": "package org . springblade . config . market ; public interface MarketConstant { String MARKET_JYS_LIST [ ] = { \"<STR_LIT>\" } ; String MARKET_TYPE_LIST [ ] = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; String MARKET_JYS_HUOBI = \"<STR_LIT>\" ; String MARKET_JYS_BINANCE = \"<STR_LIT>\" ; String MARKET_JYS_COINHOUSE = \"<STR_LIT>\" ; String MARKET_XH_TYPE = \"<STR_LIT>\" ;", "output": "String MARKET_BBW_TYPE = \"<STR_LIT>\" ; String MARKET_UBW_TYPE = \"<STR_LIT>\" ; String PERIOD [ ] = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import java . util . Collections ; import java . util . List ; @ Component public class ListFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return List . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static int length ( List < ? > list ) { return list . size ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String join ( List < ? > list ) { return StrUtil . join ( \"<STR_LIT>\" , list . toArray ( ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String join ( List < ? > list , String separator ) { if ( list . size ( ) == <NUM_LIT> ) { return list . get ( <NUM_LIT> ) . toString ( ) ; } else { return StrUtil . join ( separator , list . toArray ( ) ) ; }", "output": "} @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > sort ( List < String > list ) { Collections . sort ( list ) ; return list ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < ? > shuffle ( List < ? > list ) { Collections . shuffle ( list ) ; return list ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class ExamQuAnswer implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer userId ; private Integer examId ; private Integer questionId ; private Integer questionType ; private String answerId ; private String answerContent ; private Integer checkout ; private Integer isSign ; private Integer isRight ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getExamId ( ) { return examId ; } public void setExamId ( Integer examId ) { this . examId = examId ;", "output": "} public Integer getQuestionId ( ) { return questionId ; } public void setQuestionId ( Integer questionId ) { this . questionId = questionId ; } public Integer getQuestionType ( ) { return questionType ; } public void setQuestionType ( Integer questionType ) { this . questionType = questionType ; } public String getAnswerId ( ) { return answerId ; } public void setAnswerId ( String answerId ) { this . answerId = answerId ; } public String getAnswerContent ( ) { return answerContent ; } public void setAnswerContent ( String answerContent ) { this . answerContent = answerContent ; } public Integer getCheckout ( ) { return checkout ; } public void setCheckout ( Integer checkout ) { this . checkout = checkout ; } public Integer getIsSign ( ) { return isSign ; } public void setIsSign ( Integer isSign ) { this . isSign = isSign ; } public Integer getIsRight ( ) { return isRight ; } public void setIsRight ( Integer isRight ) { this . isRight = isRight ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + questionId + \"<STR_LIT>\" + questionType + \"<STR_LIT>\" + answerId + \"<STR_LIT>\" + answerContent + \"<STR_LIT>\" + checkout + \"<STR_LIT>\" + isSign + \"<STR_LIT>\" + isRight + \"<STR_LIT>\" ; } }"}, {"input": "package com . youlai . system . plugin . syslog . annotation ; import com . youlai . system . enums . LogModuleEnum ; import java . lang . annotation . * ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) @ Documented public @ interface LogAnnotation {", "output": "String value ( ) default \"<STR_LIT>\" ; LogModuleEnum module ( ) ; }"}, {"input": "package org . springblade . config . autopoi . poi . cache ; import org . apache . poi . openxml4j . exceptions . InvalidFormatException ; import org . apache . poi . ss . usermodel . Workbook ; import org . apache . poi . ss . usermodel . WorkbookFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springblade . config . autopoi . poi . cache . manager . POICacheManager ; import org . springframework . core . io . ClassPathResource ; import java . io . InputStream ; import java . util . Arrays ; import java . util . List ; public final class ExcelCache { private static final Logger LOGGER = LoggerFactory . getLogger ( ExcelCache . class ) ; public static Workbook getWorkbook ( String url , Integer [ ] sheetNums , boolean needAll ) { InputStream is = null ; List < Integer > sheetList = Arrays . asList ( sheetNums ) ; try { is = POICacheManager . getFile ( url ) ; Workbook wb = WorkbookFactory . create ( is ) ; if ( ! needAll ) {", "output": "for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { is . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } public static Workbook getWorkbookByTemplate ( String url , Integer [ ] sheetNums , boolean needAll ) { List < Integer > sheetList = Arrays . asList ( sheetNums ) ; InputStream fis = null ; try { ClassPathResource resource = new ClassPathResource ( url ) ; fis = resource . getInputStream ( ) ; Workbook wb = WorkbookFactory . create ( fis ) ; if ( ! needAll ) { for ( int i = wb . getNumberOfSheets ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; i -- ) { if ( ! sheetList . contains ( i ) ) { wb . removeSheetAt ( i ) ; } } } return wb ; } catch ( InvalidFormatException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } finally { try { fis . close ( ) ; } catch ( Exception e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } } return null ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . apache . poi . xssf . usermodel . XSSFWorkbook ; import java . io . IOException ; import java . io . InputStream ; public class WorkbookUtil { public static Workbook createWorkBook ( InputStream templateInputStream , ExcelType excelType ) throws IOException { Workbook workbook ; if ( ExcelType . XLS . equals ( excelType ) ) { workbook = ( templateInputStream == null ) ? new HSSFWorkbook ( ) : new HSSFWorkbook ( new POIFSFileSystem ( templateInputStream ) ) ; } else { workbook = ( templateInputStream == null ) ? new SXSSFWorkbook ( <NUM_LIT> ) : new SXSSFWorkbook ( new XSSFWorkbook ( templateInputStream ) , <NUM_LIT> ) ; } return workbook ; } public static Sheet createOrGetSheet ( Workbook workbook , SheetConfig sheetConfig ) { Sheet sheet = null ; try { try { sheet = workbook . getSheetAt ( sheetConfig . getSheetIndex ( ) ) ; } catch ( Exception e ) { sheet = createSheet ( workbook , sheetConfig ) ; } } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } return sheet ; } public static Sheet createSheet ( Workbook workbook , SheetConfig sheetConfig ) { return workbook . createSheet ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ? sheetConfig . getSheetName ( ) : \"<STR_LIT>\" + ( sheetConfig . getSheetIndex ( ) + <NUM_LIT> ) ) ; } public static Row createOrGetRow ( Sheet sheet , int rowIndex ) { Row row = sheet . getRow ( rowIndex ) ; if ( row != null ) { return row ; } return sheet . createRow ( rowIndex ) ; } public static Cell createOrGetCell ( Row row , int cellIndex ) { Cell cell = row . getCell ( cellIndex ) ; if ( cell != null ) { return cell ; } return row . createCell ( cellIndex ) ; } public static CellStyle createCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( workbook == null || config == null ) { return null ; } CellStyle newCellStyle = workbook . createCellStyle ( ) ; if ( config . getFont ( ) != null ) { Font font = workbook . createFont ( ) ; if ( config . getFont ( ) . getFontName ( ) != null ) { font . setFontName ( config . getFont ( ) . getFontName ( ) ) ; } if ( config . getFont ( ) . getFontHeightInPoints ( ) > <NUM_LIT> ) { font . setFontHeightInPoints ( config . getFont ( ) . getFontHeightInPoints ( ) ) ; }", "output": "font . setBold ( config . getFont ( ) . isBold ( ) ) ; newCellStyle . setFont ( font ) ; } if ( config . getWrapText ( ) != null ) { newCellStyle . setWrapText ( config . getWrapText ( ) ) ; } if ( config . getVerticalAlignment ( ) != null ) { newCellStyle . setVerticalAlignment ( config . getVerticalAlignment ( ) ) ; } if ( config . getAlignment ( ) != null ) { newCellStyle . setAlignment ( config . getAlignment ( ) ) ; } if ( config . getLocked ( ) != null ) { newCellStyle . setLocked ( config . getLocked ( ) ) ; } if ( config . getFillPattern ( ) != null ) { newCellStyle . setFillPattern ( config . getFillPattern ( ) ) ; } if ( config . getFillForegroundColor ( ) != null ) { newCellStyle . setFillForegroundColor ( config . getFillForegroundColor ( ) ) ; } if ( config . getBorderBottom ( ) != null ) { newCellStyle . setBorderBottom ( config . getBorderBottom ( ) ) ; } if ( config . getBorderLeft ( ) != null ) { newCellStyle . setBorderLeft ( config . getBorderLeft ( ) ) ; } return newCellStyle ; } }"}, {"input": "package com . yf . base . utils ; import lombok . extern . log4j . Log4j2 ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . springframework . util . Assert ; import java . lang . reflect . Field ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Log4j2 public class Reflections { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; public static Field [ ] getAllFields ( Object object ) { Class < ? > clazz = object . getClass ( ) ; List < Field > fieldList = new ArrayList < > ( ) ; while ( clazz != null ) { fieldList . addAll ( new ArrayList < > ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ) ; clazz = clazz . getSuperclass ( ) ; } Field [ ] fields = new Field [ fieldList . size ( ) ] ; fieldList . toArray ( fields ) ; return fields ; } public static Object invokeGetter ( Object obj , String propertyName ) { Object object = obj ; for ( String name : StringUtils . split ( propertyName , \"<STR_LIT>\" ) ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( name ) ; object = invokeMethod ( object , getterMethodName , new Class [ ] { } , new Object [ ] { } ) ; } return object ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Object object = obj ; String [ ] names = StringUtils . split ( propertyName , \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < names . length ; i ++ ) { if ( i < names . length - <NUM_LIT> ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( names [ i ] ) ; object = invokeMethod ( object , getterMethodName , new Class [ ] { } , new Object [ ] { } ) ; } else { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( names [ i ] ) ; invokeMethodByName ( object , setterMethodName , new Object [ ] { value } ) ; } } } public static Object getFieldValue ( final Object obj , final String fieldName ) { Field field = getAccessibleField ( obj , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + \"<STR_LIT>\" ) ; } Object result = null ; try { result = field . get ( obj ) ; } catch ( IllegalAccessException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } return result ; } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getAccessibleField ( obj , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + \"<STR_LIT>\" ) ; } try { field . set ( obj , value ) ; } catch ( IllegalAccessException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } } public static Object invokeMethod ( final Object obj , final String methodName , final Class < ? > [ ] parameterTypes , final Object [ ] args ) { Method method = getAccessibleMethod ( obj , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj + \"<STR_LIT>\" ) ; } try { return method . invoke ( obj , args ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static Object invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj + \"<STR_LIT>\" ) ; } try { return method . invoke ( obj , args ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static Field getAccessibleField ( final Object obj , final String fieldName ) { Validate . notNull ( obj , \"<STR_LIT>\" ) ; Validate . notBlank ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = obj . getClass ( ) ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { continue ; } } return null ; } public static Method getAccessibleMethod ( final Object obj , final String methodName , final Class < ? > ... parameterTypes ) { Validate . notNull ( obj , \"<STR_LIT>\" ) ; Validate . notBlank ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = obj . getClass ( ) ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { try { Method method = searchType . getDeclaredMethod ( methodName , parameterTypes ) ; makeAccessible ( method ) ; return method ; } catch ( NoSuchMethodException e ) { continue ; } } return null ; } public static Method getAccessibleMethodByName ( final Object obj , final String methodName ) {", "output": "Validate . notNull ( obj , \"<STR_LIT>\" ) ; Validate . notBlank ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = obj . getClass ( ) ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static void makeAccessible ( Method method ) { if ( ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) && ! method . isAccessible ( ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) && ! field . isAccessible ( ) ) { field . setAccessible ( true ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > Class < T > getClassGenricType ( final Class clazz ) { return getClassGenricType ( clazz , <NUM_LIT> ) ; } public static Class getClassGenricType ( final Class clazz , final int index ) { Type genType = clazz . getGenericSuperclass ( ) ; if ( ! ( genType instanceof ParameterizedType ) ) { log . warn ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } Type [ ] params = ( ( ParameterizedType ) genType ) . getActualTypeArguments ( ) ; if ( index >= params . length || index < <NUM_LIT> ) { log . warn ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + clazz . getSimpleName ( ) + \"<STR_LIT>\" + params . length ) ; return Object . class ; } if ( ! ( params [ index ] instanceof Class ) ) { log . warn ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } return ( Class ) params [ index ] ; } public static Class < ? > getUserClass ( Object instance ) { Assert . notNull ( instance , \"<STR_LIT>\" ) ; Class clazz = instance . getClass ( ) ; if ( clazz != null && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass != null && ! Object . class . equals ( superClass ) ) { return superClass ; } } return clazz ; } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) { if ( e instanceof IllegalAccessException || e instanceof IllegalArgumentException || e instanceof NoSuchMethodException ) { return new IllegalArgumentException ( e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } else if ( e instanceof RuntimeException ) { return ( RuntimeException ) e ; } return new RuntimeException ( \"<STR_LIT>\" , e ) ; } }"}, {"input": "package org . springblade . gateway . filter ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalResponseLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } return chain . filter ( exchange ) . then ( Mono . fromRunnable ( ( ) -> { MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; String requestUrl = UriComponentsBuilder . fromPath ( path ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; StringBuilder responseLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > responseArgs = new ArrayList < > ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; ServerHttpResponse response = exchange . getResponse ( ) ; responseLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; responseArgs . add ( response . getStatusCode ( ) . value ( ) ) ; responseArgs . add ( requestMethod ) ;", "output": "responseArgs . add ( requestUrl ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { responseLog . append ( \"<STR_LIT>\" ) ; responseArgs . add ( headerName ) ; responseArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ; } ) ; responseLog . append ( \"<STR_LIT>\" ) ; log . info ( responseLog . toString ( ) , responseArgs . toArray ( ) ) ; } ) ) ; } @ Override public int getOrder ( ) { return Ordered . HIGHEST_PRECEDENCE ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . Session ; import com . xcs . wx . domain . vo . SessionVO ; import org . mapstruct . Mapper ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface SessionMapping {", "output": "SessionVO convert ( Session session ) ; }"}, {"input": "package org . springblade . gateway . provider ; import org . springframework . cloud . gateway . support . ServerWebExchangeUtils ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . util . MultiValueMap ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . util . UriComponentsBuilder ; import java . net . URI ; import java . util . LinkedHashSet ; public class RequestProvider { public static String getOriginalRequestUrl ( ServerWebExchange exchange ) { ServerHttpRequest request = exchange . getRequest ( ) ; LinkedHashSet < URI > uris = exchange . getRequiredAttribute ( ServerWebExchangeUtils . GATEWAY_ORIGINAL_REQUEST_URL_ATTR ) ; URI requestUri = uris . stream ( ) . findFirst ( ) . orElse ( request . getURI ( ) ) ;", "output": "MultiValueMap < String , String > queryParams = request . getQueryParams ( ) ; return UriComponentsBuilder . fromPath ( requestUri . getRawPath ( ) ) . queryParams ( queryParams ) . build ( ) . toUriString ( ) ; } }"}, {"input": "package me . zhengjie . modules . system . domain ; import com . alibaba . fastjson . annotation . JSONField ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . List ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Menu extends BaseEntity implements Serializable { @ NotNull ( groups = { Update . class } ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ JSONField ( serialize = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Set < Role > roles ; @ TableField ( exist = false ) private List < Menu > children ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String title ; @ TableField ( value = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String componentName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer menuSort = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String component ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String path ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String permission ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String icon ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean cache ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean hidden ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long pid ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Integer subCount = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean iFrame ; @ Override public boolean equals ( Object o ) { if ( this == o ) {", "output": "return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Menu menu = ( Menu ) o ; return Objects . equals ( id , menu . id ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id ) ; } public Boolean getHasChildren ( ) { return subCount > <NUM_LIT> ; } public Boolean getLeaf ( ) { return subCount <= <NUM_LIT> ; } public String getLabel ( ) { return title ; } }"}, {"input": "package org . springblade . gateway . provider ; import org . springblade . core . launch . constant . TokenConstant ; import java . util . ArrayList ; import java . util . List ; public class AuthProvider { public static final String AUTH_KEY = TokenConstant . HEADER ; public static final String API_PATH_REG = \"<STR_LIT>\" ; public static final String API_KEY = \"<STR_LIT>\" ; public static final String API_SECRET_KEY = \"<STR_LIT>\" ; public static final String BODY_REQUEST_BODY_PARAMETERS = \"<STR_LIT>\" ; private static final List < String > DEFAULT_SKIP_URL = new ArrayList < > ( ) ; static { DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; DEFAULT_SKIP_URL . add ( \"<STR_LIT>\" ) ; } public static List < String > getDefaultSkipUrl ( ) { return DEFAULT_SKIP_URL ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . config ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import org . springframework . core . convert . ConversionService ; import org . springframework . format . support . DefaultFormattingConversionService ; import java . util . Map ; public class DefaultNacosConfigConverter < T > implements NacosConfigConverter < T > { private final Class < T > targetType ; private final ConversionService conversionService ; private final String type ; public DefaultNacosConfigConverter ( Class < T > targetType ) { this ( targetType , new DefaultFormattingConversionService ( ) , \"<STR_LIT>\" ) ; } public DefaultNacosConfigConverter ( Class < T > targetType , ConversionService conversionService , String type ) { this . targetType = targetType ; this . conversionService = conversionService ; this . type = type ; } @ Override public T convert ( String source ) { if ( Map . class . isAssignableFrom ( targetType ) ) { return ( T ) ConfigParseUtils . toProperties ( source , type ) ;", "output": "} if ( conversionService . canConvert ( source . getClass ( ) , targetType ) ) { return conversionService . convert ( source , targetType ) ; } return null ; } @ Override public boolean canConvert ( Class < T > targetType ) { return conversionService . canConvert ( String . class , targetType ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . exercise ; import lombok . Data ; @ Data public class ExerciseRepoVO { private Integer id ; private String repoTitle ; private Integer totalCount ; private Integer exerciseCount ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . SystemUtils ; import java . io . File ; public class Platforms { public static final String FILE_PATH_SEPARATOR = File . separator ; public static final char FILE_PATH_SEPARATOR_CHAR = File . separatorChar ; public static final char WINDOWS_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final char LINUX_FILE_PATH_SEPARATOR_CHAR = '<STR_LIT>' ; public static final String CLASS_PATH_SEPARATOR = File . pathSeparator ; public static final char CLASS_PATH_SEPARATOR_CHAR = File . pathSeparatorChar ; public static final String LINE_SEPARATOR = System . lineSeparator ( ) ; public static final String TMP_DIR = SystemUtils . JAVA_IO_TMPDIR ; public static final String WORKING_DIR = SystemUtils . USER_DIR ; public static final String USER_HOME = SystemUtils . USER_HOME ; public static final String JAVA_HOME = SystemUtils . JAVA_HOME ; public static final String JAVA_SPECIFICATION_VERSION = SystemUtils . JAVA_SPECIFICATION_VERSION ; public static final String JAVA_VERSION = SystemUtils . JAVA_VERSION ; public static final boolean IS_JAVA7 = SystemUtils . IS_JAVA_1_7 ; public static final boolean IS_JAVA8 = SystemUtils . IS_JAVA_1_8 ; public static final boolean IS_ATLEASET_JAVA7 = IS_JAVA7 || IS_JAVA8 ; public static final boolean IS_ATLEASET_JAVA8 = IS_JAVA8 ; public static final String OS_NAME = SystemUtils . OS_NAME ; public static final String OS_VERSION = SystemUtils . OS_VERSION ; public static final String OS_ARCH = SystemUtils . OS_ARCH ; public static final boolean IS_LINUX = SystemUtils . IS_OS_LINUX ; public static final boolean IS_UNIX = SystemUtils . IS_OS_UNIX ; public static final boolean IS_WINDOWS = SystemUtils . IS_OS_WINDOWS ;", "output": "}"}, {"input": "package ginyi . system . domain . model . vo ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . List ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class RoleVo extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long roleId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String roleName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String roleKey ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > permissions ;", "output": "}"}, {"input": "package org . example . domain . example . entity ; import io . github . chensheng . dddboot . microservice . core . DDDEntity ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; import org . example . domain . example . valueobject . ExampleStatus ; @ Getter @ Builder public class ExampleEntity implements DDDEntity { private Long id ; private String username ; private String password ; private ExampleStatus status ; public static ExampleEntity create ( String username , String password ) { if ( TextUtil . isBlank ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isCNWord ( username ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( password ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( password . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } ExampleEntity user = builder ( ) . username ( username ) . password ( password ) . status ( ExampleStatus . ENABLE ) . build ( ) ; user . checkPasswordFormat ( ) ; return user ; }", "output": "public void updatePassword ( String oldPassword , String newPassword ) { if ( TextUtil . isBlank ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( TextUtil . isBlank ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( newPassword . length ( ) < <NUM_LIT> ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( ! this . password . equals ( oldPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } if ( oldPassword . equals ( newPassword ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . password = newPassword ; this . checkPasswordFormat ( ) ; } public void enable ( ) { if ( this . status == ExampleStatus . ENABLE ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . status = ExampleStatus . ENABLE ; } public void disable ( ) { if ( this . status == ExampleStatus . DISABLE ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . status = ExampleStatus . DISABLE ; } private void checkPasswordFormat ( ) { String passwordFormat = \"<STR_LIT>\" ; if ( TextUtil . isBlank ( password ) || ! password . matches ( passwordFormat ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class IntObjectHashMap < V > implements IntObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private int [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Integer > keySet = new KeySet ( ) ; private final Set < Entry < Integer , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public IntObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public IntObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new int [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( int key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( int key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) { V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Integer , ? extends V > sourceMap ) { if ( sourceMap instanceof IntObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectHashMap < V > source = ( IntObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Integer , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( int key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( int key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( int key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof IntObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) IntObjectMap other = ( IntObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { int key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Integer key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Integer > keySet ( ) { return keySet ; } @ Override public Set < Entry < Integer , V > > entrySet ( ) { return entrySet ; } private int objectToKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } private int indexOf ( int key ) {", "output": "int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( int key ) { return hashCode ( key ) & mask ; } private static int hashCode ( int key ) { return key ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { int key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { int [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new int [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { int oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( int key ) { return Integer . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Integer , V > > { @ Override public Iterator < Entry < Integer , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Integer > { @ Override public int size ( ) { return IntObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return IntObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return IntObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { IntObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Integer > iterator ( ) { return new Iterator < Integer > ( ) { private final Iterator < Entry < Integer , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Integer next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ; entryIndex = prevIndex ; return this ; } @ Override public void remove ( ) { if ( prevIndex == - <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( removeAt ( prevIndex ) ) { nextIndex = prevIndex ; } prevIndex = - <NUM_LIT> ; } @ Override public int key ( ) { return keys [ entryIndex ] ; } @ Override public V value ( ) { return toExternal ( values [ entryIndex ] ) ; } @ Override public void setValue ( V value ) { values [ entryIndex ] = toInternal ( value ) ; } } private final class MapIterator implements Iterator < Entry < Integer , V > > { private final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Entry < Integer , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } iter . next ( ) ; return new MapEntry ( iter . entryIndex ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } final class MapEntry implements Entry < Integer , V > { private final int entryIndex ; MapEntry ( int entryIndex ) { this . entryIndex = entryIndex ; } @ Override public Integer getKey ( ) { verifyExists ( ) ; return keys [ entryIndex ] ; } @ Override public V getValue ( ) { verifyExists ( ) ; return toExternal ( values [ entryIndex ] ) ; } @ Override public V setValue ( V value ) { verifyExists ( ) ; V prevValue = toExternal ( values [ entryIndex ] ) ; values [ entryIndex ] = toInternal ( value ) ; return prevValue ; } private void verifyExists ( ) { if ( values [ entryIndex ] == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } public static int safeFindNextPositivePowerOfTwo ( final int value ) { return value <= <NUM_LIT> ? <NUM_LIT> : value >= <NUM_LIT> ? <NUM_LIT> : findNextPositivePowerOfTwo ( value ) ; } public static int findNextPositivePowerOfTwo ( final int value ) { assert value > Integer . MIN_VALUE && value < <NUM_LIT> ; return <NUM_LIT> << ( <NUM_LIT> - Integer . numberOfLeadingZeros ( value - <NUM_LIT> ) ) ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . DesformData ; public interface DesformDataMapper extends BaseMapper < DesformData > {", "output": "}"}, {"input": "package ginyi . common . utils ; public class LogUtils { public static String getBlock ( Object msg ) { if ( msg == null ) { msg = \"<STR_LIT>\" ; } return \"<STR_LIT>\" + msg . toString ( ) + \"<STR_LIT>\" ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . utils . sql ; import cn . hutool . core . exceptions . UtilException ; import com . oddfar . campus . common . utils . StringUtils ; public class SqlUtil { public static String SQL_REGEX = \"<STR_LIT>\" ; public static String SQL_PATTERN = \"<STR_LIT>\" ; public static String escapeOrderBySql ( String value ) { if ( StringUtils . isNotEmpty ( value ) && ! isValidOrderBySql ( value ) ) { throw new UtilException ( \"<STR_LIT>\" ) ; } return value ; }", "output": "public static boolean isValidOrderBySql ( String value ) { return value . matches ( SQL_PATTERN ) ; } public static void filterKeyword ( String value ) { if ( StringUtils . isEmpty ( value ) ) { return ; } String [ ] sqlKeywords = StringUtils . split ( SQL_REGEX , \"<STR_LIT>\" ) ; for ( String sqlKeyword : sqlKeywords ) { if ( StringUtils . indexOfIgnoreCase ( value , sqlKeyword ) > - <NUM_LIT> ) { throw new UtilException ( \"<STR_LIT>\" ) ; } } } }"}, {"input": "package com . oddfar . campus . framework . service ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysConfigEntity ; public interface SysConfigService { PageResult < SysConfigEntity > page ( SysConfigEntity sysConfigEntity ) ; SysConfigEntity selectConfigById ( Long configId ) ; String selectConfigByKey ( String configKey ) ; < T > T selectConfigByKey ( String configKey , Class < T > clazz ) ; < T > T selectConfigByKey ( String configKey , Class < T > clazz , T defaultValue ) ; boolean selectCaptchaEnabled ( ) ; int insertConfig ( SysConfigEntity config ) ; int updateConfig ( SysConfigEntity config ) ; void deleteConfigByIds ( Long [ ] configIds ) ;", "output": "void loadingConfigCache ( ) ; boolean checkConfigKeyUnique ( SysConfigEntity config ) ; void clearConfigCache ( ) ; void resetConfigCache ( ) ; }"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class Account { private String account ; private String address ; private String walletFile ; private BigDecimal balance = BigDecimal . ZERO ; private BigDecimal gas = BigDecimal . ZERO ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . controller ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdReqDTO ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . plugin . dto . PluginDataDTO ; import com . yf . system . modules . plugin . service . PluginDataService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class PluginDataController extends BaseController {", "output": "@ Autowired private PluginDataService baseService ; @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest save ( @ RequestBody PluginDataDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest delete ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < PluginDataDTO > detail ( @ RequestBody BaseIdReqDTO reqDTO ) { PluginDataDTO dto = baseService . detail ( reqDTO . getId ( ) ) ; return super . success ( dto ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < IPage < PluginDataDTO > > paging ( @ RequestBody PagingReqDTO < PluginDataDTO > reqDTO ) { IPage < PluginDataDTO > page = baseService . paging ( reqDTO ) ; return super . success ( page ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < List < PluginDataDTO > > list ( @ RequestBody PluginDataDTO reqDTO ) { List < PluginDataDTO > dtoList = baseService . list ( reqDTO ) ; return super . success ( dtoList ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import lombok . Data ; @ Data public class ExamQuAnswerExtVO { private static final long serialVersionUID = <NUM_LIT> ; private Integer id ; private Integer gradeId ; private String image ; private String content ; private Integer sort ;", "output": "}"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import org . apache . ibatis . type . ByteArrayTypeHandler ; @ Data @ TableName ( value = \"<STR_LIT>\" , autoResultMap = true ) public class HardLinkVideoAttribute { @ TableId ( \"<STR_LIT>\" ) private Long md5Hash ; @ TableField ( \"<STR_LIT>\" ) private String dirId1 ; @ TableField ( \"<STR_LIT>\" ) private String dirId2 ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] md5 ; @ TableField ( \"<STR_LIT>\" ) private String modifyTime ; @ TableField ( \"<STR_LIT>\" ) private String fileName ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . openqa . selenium . * ; import org . openqa . selenium . interactions . Actions ; import org . openqa . selenium . support . ui . Select ; import top . kangert . kspider . io . SeleniumResponse ; import java . util . List ; import java . util . stream . Collectors ; public class WebElementWrapper implements WebElement { private WebElement element ; private SeleniumResponse response ; public WebElementWrapper ( SeleniumResponse response , WebElement element ) { this . response = response ; this . element = element ; } @ Override public void click ( ) { element . click ( ) ; } @ Override public void submit ( ) { element . submit ( ) ; } @ Override public void sendKeys ( CharSequence ... keysToSend ) { element . sendKeys ( keysToSend ) ; } @ Override public void clear ( ) { element . click ( ) ; } @ Override public String getTagName ( ) { return element . getTagName ( ) ; } @ Override public String getAttribute ( String name ) { return element . getAttribute ( name ) ; } @ Override public boolean isSelected ( ) { return element . isSelected ( ) ; } @ Override public boolean isEnabled ( ) { return element . isEnabled ( ) ; } @ Override public String getText ( ) { return element . getText ( ) ; } @ Override public List < WebElement > findElements ( By by ) { List < WebElement > elements = element . findElements ( by ) ; if ( elements != null ) { return elements . stream ( ) . map ( element -> new WebElementWrapper ( this . response , element ) ) . collect ( Collectors . toList ( ) ) ; } return null ; } @ Override public WebElement findElement ( By by ) { return new WebElementWrapper ( this . response , element . findElement ( by ) ) ; } @ Override public boolean isDisplayed ( ) { return element . isDisplayed ( ) ; } @ Override public Point getLocation ( ) { return element . getLocation ( ) ; } @ Override public Dimension getSize ( ) { return element . getSize ( ) ; } @ Override public Rectangle getRect ( ) { return element . getRect ( ) ; }", "output": "@ Override public String getCssValue ( String propertyName ) { return element . getCssValue ( propertyName ) ; } @ Override public < X > X getScreenshotAs ( OutputType < X > target ) throws WebDriverException { return element . getScreenshotAs ( target ) ; } public Actions action ( ) { return this . response . action ( ) ; } public void clearAction ( ) { this . response . clearAction ( ) ; } public WebElement element ( ) { return this . element ; } public Select select ( ) { return new Select ( this . element ) ; } public SeleniumResponse getResponse ( ) { return response ; } public String html ( ) { return element . getAttribute ( \"<STR_LIT>\" ) ; } public String text ( ) { return element . getAttribute ( \"<STR_LIT>\" ) ; } public String css ( String style ) { return element . getCssValue ( style ) ; } public String attr ( String value ) { return element . getAttribute ( value ) ; } }"}, {"input": "package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . Set ; public interface UserService extends IService < User > { User findById ( long id ) ; void create ( User resources ) ; void update ( User resources ) throws Exception ;", "output": "void delete ( Set < Long > ids ) ; User findByName ( String userName ) ; User getLoginData ( String userName ) ; void updatePass ( String username , String encryptPassword ) ; Map < String , String > updateAvatar ( MultipartFile file ) ; void updateEmail ( String username , String email ) ; PageResult < User > queryAll ( UserQueryCriteria criteria , Page < Object > page ) ; List < User > queryAll ( UserQueryCriteria criteria ) ; void download ( List < User > queryAll , HttpServletResponse response ) throws IOException ; void updateCenter ( User resources ) ; void resetPwd ( Set < Long > ids , String pwd ) ; }"}, {"input": "package com . youlai . system . common . base ; import cn . hutool . core . util . ObjectUtil ; import java . util . EnumSet ; import java . util . Objects ; public interface IBaseEnum < T > { T getValue ( ) ; String getLabel ( ) ; static < E extends Enum < E > & IBaseEnum > E getEnumByValue ( Object value , Class < E > clazz ) { Objects . requireNonNull ( value ) ; EnumSet < E > allEnums = EnumSet . allOf ( clazz ) ; E matchEnum = allEnums . stream ( ) . filter ( e -> ObjectUtil . equal ( e . getValue ( ) , value ) ) . findFirst ( ) . orElse ( null ) ;", "output": "return matchEnum ; } static < E extends Enum < E > & IBaseEnum > String getLabelByValue ( Object value , Class < E > clazz ) { Objects . requireNonNull ( value ) ; EnumSet < E > allEnums = EnumSet . allOf ( clazz ) ; E matchEnum = allEnums . stream ( ) . filter ( e -> ObjectUtil . equal ( e . getValue ( ) , value ) ) . findFirst ( ) . orElse ( null ) ; String label = null ; if ( matchEnum != null ) { label = matchEnum . getLabel ( ) ; } return label ; } static < E extends Enum < E > & IBaseEnum > Object getValueByLabel ( String label , Class < E > clazz ) { Objects . requireNonNull ( label ) ; EnumSet < E > allEnums = EnumSet . allOf ( clazz ) ; String finalLabel = label ; E matchEnum = allEnums . stream ( ) . filter ( e -> ObjectUtil . equal ( e . getLabel ( ) , finalLabel ) ) . findFirst ( ) . orElse ( null ) ; Object value = null ; if ( matchEnum != null ) { value = matchEnum . getValue ( ) ; } return value ; } }"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . common . model . Option ; import com . youlai . system . model . entity . SysRole ; import com . youlai . system . model . form . RoleForm ; import com . youlai . system . model . query . RolePageQuery ; import com . youlai . system . model . vo . RolePageVO ; import java . util . List ; import java . util . Set ; public interface SysRoleService extends IService < SysRole > { Page < RolePageVO > getRolePage ( RolePageQuery queryParams ) ;", "output": "List < Option > listRoleOptions ( ) ; boolean saveRole ( RoleForm roleForm ) ; RoleForm getRoleForm ( Long roleId ) ; boolean updateRoleStatus ( Long roleId , Integer status ) ; boolean deleteRoles ( String ids ) ; List < Long > getRoleMenuIds ( Long roleId ) ; boolean assignMenusToRole ( Long roleId , List < Long > menuIds ) ; Integer getMaximumDataScope ( Set < String > roles ) ; }"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import lombok . Data ; @ Data public class ExamDetailRespVO { private Integer id ; private Integer examId ; private Integer questionId ; private Integer score ; private Integer sort ; private Integer type ;", "output": "}"}, {"input": "package com . xcs . wx . util ; import cn . hutool . core . date . DateTime ; import cn . hutool . core . date . DateUtil ; public class DateFormatUtil { public static String formatTimestamp ( long timestampInSeconds ) { DateTime dateTime = new DateTime ( timestampInSeconds * <NUM_LIT> ) ; DateTime now = DateUtil . date ( ) ; if ( DateUtil . isSameDay ( dateTime , now ) ) { return DateUtil . format ( dateTime , \"<STR_LIT>\" ) ; } if ( DateUtil . isSameDay ( dateTime , DateUtil . yesterday ( ) ) ) { return \"<STR_LIT>\" ; } if ( dateTime . isAfterOrEquals ( DateUtil . beginOfWeek ( now ) ) && DateUtil . isSameWeek ( dateTime , now , true ) ) { return DateUtil . dayOfWeekEnum ( dateTime ) . toChinese ( \"<STR_LIT>\" ) ;", "output": "} if ( dateTime . year ( ) != now . year ( ) ) { return DateUtil . format ( dateTime , \"<STR_LIT>\" ) ; } return DateUtil . format ( dateTime , \"<STR_LIT>\" ) ; } }"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . domain . AlipayConfig ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface AliPayConfigMapper extends BaseMapper < AlipayConfig > {", "output": "}"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class Notice implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private String title ; private String image ; private String content ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) { this . isDeleted = isDeleted ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public String getImage ( ) { return image ; } public void setImage ( String image ) { this . image = image ; } public String getContent ( ) { return content ; } public void setContent ( String content ) { this . content = content ; } public Integer getUserId ( ) {", "output": "return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + title + '<STR_LIT>' + \"<STR_LIT>\" + image + '<STR_LIT>' + \"<STR_LIT>\" + content + '<STR_LIT>' + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package com . oddfar . campus . framework . security . handle ; import cn . hutool . extra . spring . SpringUtil ; import com . alibaba . fastjson2 . JSON ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . constant . HttpStatus ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . event . LogininforEvent ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . utils . MessageUtils ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . web . service . TokenService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Configuration ; import org . springframework . security . core . Authentication ; import org . springframework . security . web . authentication . logout . LogoutSuccessHandler ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Configuration public class LogoutSuccessHandlerImpl implements LogoutSuccessHandler { @ Autowired private TokenService tokenService ; @ Override public void onLogoutSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) throws IOException , ServletException { LoginUser loginUser = tokenService . getLoginUser ( request ) ;", "output": "if ( StringUtils . isNotNull ( loginUser ) ) { tokenService . delLoginUser ( loginUser . getToken ( ) ) ; recordLogoutInfo ( loginUser . getUsername ( ) , loginUser . getUserId ( ) , Constants . LOGOUT , MessageUtils . message ( \"<STR_LIT>\" ) , request ) ; } ServletUtils . renderString ( response , JSON . toJSONString ( R . error ( HttpStatus . SUCCESS , MessageUtils . message ( \"<STR_LIT>\" ) ) ) ) ; } private void recordLogoutInfo ( String username , Long userId , String status , String message , HttpServletRequest request ) { LogininforEvent logininforEvent = new LogininforEvent ( ) ; logininforEvent . setUsername ( username ) ; logininforEvent . setUserId ( userId ) ; logininforEvent . setStatus ( status ) ; logininforEvent . setMessage ( message ) ; logininforEvent . setRequest ( request ) ; SpringUtil . getApplicationContext ( ) . publishEvent ( logininforEvent ) ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class TransParam implements Serializable { private String from ; private String to ; private String coinSymbol ; private BigDecimal amount ; private String exchangeCoinId ;", "output": "}"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . util . List ; @ Data public class DeptHModel { private List < TradePlateItem > buyItems ; private List < TradePlateItem > sellItems ; private String symbolName ; private String topic ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . node ; import lombok . extern . slf4j . Slf4j ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . support . ExpressionEngine ; import top . kangert . kspider . websocket . WebSocketEvent ; import org . springframework . stereotype . Component ; import cn . hutool . core . exceptions . ExceptionUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONObject ; import cn . hutool . json . JSONUtil ; import javax . annotation . Resource ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Component @ Slf4j public class FunctionExecutor implements NodeExecutor { @ Resource private ExpressionEngine expressionEngine ; @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { List < Map < String , String > > functions = node . getJsonArrayProperty ( Constants . FUNCTION ) ; for ( Map < String , String > item : functions ) { Object functionStr = item . get ( Constants . FUNCTION ) ; JSONObject functionJson = JSONUtil . parseObj ( functionStr ) ; String function = functionJson . getStr ( \"<STR_LIT>\" ) ; if ( StrUtil . isNotBlank ( function ) ) { try { log . debug ( \"<STR_LIT>\" , function ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , functionJson . getStr ( \"<STR_LIT>\" ) , function ) ; expressionEngine . execute ( function , variables ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , function , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; }", "output": "} } } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { Shape shape = new Shape ( ) ; shape . setName ( supportType ( ) ) ; shape . setLabel ( \"<STR_LIT>\" ) ; shape . setDesc ( \"<STR_LIT>\" ) ; shape . setIcon ( \"<STR_LIT>\" ) ; return shape ; } @ Override public List < ConfigItem > configItems ( ) { List < ConfigItem > configItemList = new ArrayList < ConfigItem > ( ) ; ConfigItem functions = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . CUSTOM_MULT_VALUE , ConfigItem . DataType . LIST_MAP , Constants . FUNCTION , null , new ArrayList < > ( ) , null , null ) ; configItemList . add ( functions ) ; return configItemList ; } }"}, {"input": "package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . * ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . sql . Timestamp ; @ Data @ TableName ( \"<STR_LIT>\" ) public class QiniuContent implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ TableField ( \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String key ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucket ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String size ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String url ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String suffix ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type = \"<STR_LIT>\" ; @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Timestamp updateTime ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . mapper ; import cn . hutool . core . util . ObjectUtil ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysConfigEntity ; public interface SysConfigMapper extends BaseMapperX < SysConfigEntity > { default PageResult < SysConfigEntity > selectPage ( SysConfigEntity config ) { return selectPage ( new LambdaQueryWrapperX < SysConfigEntity > ( ) . likeIfPresent ( SysConfigEntity :: getConfigName , config . getConfigName ( ) ) . likeIfPresent ( SysConfigEntity :: getConfigKey , config . getConfigKey ( ) ) . eqIfPresent ( SysConfigEntity :: getGroupCode , config . getGroupCode ( ) ) . betweenIfPresent ( SysConfigEntity :: getCreateTime , config . getParams ( ) ) ) ; } default SysConfigEntity selectConfig ( SysConfigEntity config ) { return selectOne ( new LambdaQueryWrapperX < SysConfigEntity > ( ) . eq ( ObjectUtil . isNotEmpty ( config . getConfigId ( ) ) , SysConfigEntity :: getConfigId , config . getConfigId ( ) ) . eq ( ObjectUtil . isNotEmpty ( config . getConfigName ( ) ) , SysConfigEntity :: getConfigName , config . getConfigName ( ) ) . eq ( ObjectUtil . isNotEmpty ( config . getConfigKey ( ) ) , SysConfigEntity :: getConfigKey , config . getConfigKey ( ) ) ) ; } default SysConfigEntity checkConfigKeyUnique ( SysConfigEntity config ) { return selectOne ( new LambdaQueryWrapperX < SysConfigEntity > ( ) . eq ( SysConfigEntity :: getConfigKey , config . getConfigKey ( ) ) ) ; }", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader . xlsx ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . openxml4j . opc . OPCPackage ; import org . apache . poi . xssf . eventusermodel . XSSFReader ; import org . apache . poi . xssf . model . SharedStringsTable ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbook ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . CTWorkbookPr ; import org . openxmlformats . schemas . spreadsheetml . x2006 . main . WorkbookDocument ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . InputSource ; import org . xml . sax . XMLReader ; import javax . xml . parsers . SAXParser ; import javax . xml . parsers . SAXParserFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxReader extends BaseExcelReader { private static final Logger logger = LoggerFactory . getLogger ( XlsxReader . class ) ; @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { return ; } OPCPackage opcPackage = OPCPackage . open ( inputStream ) ; XSSFReader xssfReader = new XSSFReader ( opcPackage ) ; SharedStringsTable sharedStringsTable = xssfReader . getSharedStringsTable ( ) ; boolean use1904DateWindowing = use1904DateWindowing ( xssfReader ) ; List < InputStream > sheetDataList = new ArrayList < InputStream > ( ) ; Map < String , InputStream > sheetDataMap = new HashMap < String , InputStream > ( ) ; XSSFReader . SheetIterator sheetDataIt = ( XSSFReader . SheetIterator ) xssfReader . getSheetsData ( ) ; while ( sheetDataIt . hasNext ( ) ) { InputStream sheetData = sheetDataIt . next ( ) ; String sheetName = sheetDataIt . getSheetName ( ) ; sheetDataList . add ( sheetData ) ; sheetDataMap . put ( sheetName , sheetData ) ; } XMLReader xmlReader = initXMLReader ( ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { InputStream sheetData = null ; if ( TextUtil . isNotEmpty ( sheetConfig . getSheetName ( ) ) ) { sheetData = sheetDataMap . get ( sheetConfig . getSheetName ( ) ) ; } else if ( sheetConfig . getSheetIndex ( ) < sheetDataList . size ( ) ) { sheetData = sheetDataList . get ( sheetConfig . getSheetIndex ( ) ) ; } if ( sheetData == null ) { logger . error ( \"<STR_LIT>\" , sheetConfig . getSheetIndex ( ) , sheetConfig . getSheetName ( ) ) ; continue ; } try { XlsxSheetHandler sheetHandler = new XlsxSheetHandler ( sheetConfig , sharedStringsTable , rowReadingListener , use1904DateWindowing ) ; xmlReader . setContentHandler ( sheetHandler ) ; InputSource sheetSource = new InputSource ( sheetData ) ; xmlReader . parse ( sheetSource ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } finally { if ( sheetData != null ) { try { sheetData . close ( ) ;", "output": "} catch ( IOException e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } } private XMLReader initXMLReader ( ) throws Exception { SAXParserFactory saxFactory = SAXParserFactory . newInstance ( ) ; saxFactory . setFeature ( \"<STR_LIT>\" , true ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; saxFactory . setFeature ( \"<STR_LIT>\" , false ) ; SAXParser saxParser = saxFactory . newSAXParser ( ) ; XMLReader xmlReader = saxParser . getXMLReader ( ) ; return xmlReader ; } private boolean use1904DateWindowing ( XSSFReader xssfReader ) throws Exception { InputStream workbookXml = xssfReader . getWorkbookData ( ) ; WorkbookDocument ctWorkbook = WorkbookDocument . Factory . parse ( workbookXml ) ; CTWorkbook wb = ctWorkbook . getWorkbook ( ) ; CTWorkbookPr prefix = wb . getWorkbookPr ( ) ; if ( prefix != null ) { return prefix . getDate1904 ( ) ; } return false ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformField ; import org . apache . ibatis . annotations . Param ; import java . util . Map ; public interface CgformFieldMapper extends BaseMapper < CgformField > { Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String tbname , @ Param ( \"<STR_LIT>\" ) Long dataId ) ; Integer getBlobCou ( Long headId ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import com . fasterxml . jackson . annotation . JsonFormat ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class Certificate implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private String certificateName ; private String image ; private String certificationNuit ; @ TableField ( fill = FieldFill . INSERT ) @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) { this . isDeleted = isDeleted ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public String getCertificateName ( ) { return certificateName ; } public void setCertificateName ( String certificateName ) { this . certificateName = certificateName ; } public String getImage ( ) { return image ; } public void setImage ( String image ) { this . image = image ; } public String getCertificationNuit ( ) { return certificationNuit ; } public void setCertificationNuit ( String certificationNuit ) { this . certificationNuit = certificationNuit ; } public LocalDateTime getCreateTime ( ) {", "output": "return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + certificateName + '<STR_LIT>' + \"<STR_LIT>\" + image + '<STR_LIT>' + \"<STR_LIT>\" + certificationNuit + '<STR_LIT>' + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import org . springframework . mock . web . MockHttpServletRequest ; import java . text . SimpleDateFormat ; import java . util . Date ; import static me . zhengjie . utils . StringUtils . getIp ; import static me . zhengjie . utils . StringUtils . getWeekDay ; import static me . zhengjie . utils . StringUtils . toCamelCase ; import static me . zhengjie . utils . StringUtils . toCapitalizeCamelCase ; import static me . zhengjie . utils . StringUtils . toUnderScoreCase ; import static org . junit . jupiter . api . Assertions . assertEquals ; import static org . junit . jupiter . api . Assertions . assertNull ; public class StringUtilsTest { @ Test public void testToCamelCase ( ) { assertNull ( toCamelCase ( null ) ) ; } @ Test public void testToCapitalizeCamelCase ( ) { assertNull ( StringUtils . toCapitalizeCamelCase ( null ) ) ; assertEquals ( \"<STR_LIT>\" , toCapitalizeCamelCase ( \"<STR_LIT>\" ) ) ; } @ Test public void testToUnderScoreCase ( ) { assertNull ( StringUtils . toUnderScoreCase ( null ) ) ; assertEquals ( \"<STR_LIT>\" , toUnderScoreCase ( \"<STR_LIT>\" ) ) ; assertEquals ( \"<STR_LIT>\" , toUnderScoreCase ( \"<STR_LIT>\" ) ) ; assertEquals ( \"<STR_LIT>\" , toUnderScoreCase ( \"<STR_LIT>\" ) ) ; } @ Test public void testGetWeekDay ( ) { SimpleDateFormat simpleDateformat = new SimpleDateFormat ( \"<STR_LIT>\" ) ;", "output": "assertEquals ( simpleDateformat . format ( new Date ( ) ) , getWeekDay ( ) ) ; } @ Test public void testGetIP ( ) { assertEquals ( \"<STR_LIT>\" , getIp ( new MockHttpServletRequest ( ) ) ) ; } }"}, {"input": "package com . youlai . system . common . constant ; public interface SecurityConstants { String CAPTCHA_CODE_PREFIX = \"<STR_LIT>\" ; String ROLE_PERMS_PREFIX = \"<STR_LIT>\" ; String BLACKLIST_TOKEN_PREFIX = \"<STR_LIT>\" ; String LOGIN_PATH = \"<STR_LIT>\" ; String JWT_TOKEN_PREFIX = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; import java . nio . charset . Charset ; import java . util . HashMap ; import java . util . Map ; @ Component public class UrlFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String parameter ( String url , String key ) { return parameterMap ( url ) . get ( key ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Map < String , String > parameterMap ( String url ) { Map < String , String > map = new HashMap < String , String > ( ) ; int index = url . indexOf ( \"<STR_LIT>\" ) ; if ( index != - <NUM_LIT> ) { String param = url . substring ( index + <NUM_LIT> ) ; if ( StrUtil . isNotBlank ( param ) ) { String [ ] params = param . split ( \"<STR_LIT>\" ) ; for ( String item : params ) { String [ ] kv = item . split ( \"<STR_LIT>\" ) ; if ( kv . length > <NUM_LIT> ) { if ( StrUtil . isNotBlank ( kv [ <NUM_LIT> ] ) ) { String value = \"<STR_LIT>\" ; if ( kv . length > <NUM_LIT> && StrUtil . isNotBlank ( kv [ <NUM_LIT> ] ) ) { int kv1Index = kv [ <NUM_LIT> ] . indexOf ( \"<STR_LIT>\" ) ; if ( kv1Index != - <NUM_LIT> ) { value = kv [ <NUM_LIT> ] . substring ( <NUM_LIT> , kv1Index ) ; } else { value = kv [ <NUM_LIT> ] ; } } map . put ( kv [ <NUM_LIT> ] , value ) ; } } } } } return map ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String encode ( String url ) { return encode ( url , Charset . defaultCharset ( ) . name ( ) ) ;", "output": "} @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String encode ( String url , String charset ) { try { return url != null ? URLEncoder . encode ( url , charset ) : null ; } catch ( UnsupportedEncodingException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String decode ( String url ) { return decode ( url , Charset . defaultCharset ( ) . name ( ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String decode ( String url , String charset ) { try { return url != null ? URLDecoder . decode ( url , charset ) : null ; } catch ( UnsupportedEncodingException e ) { return null ; } } }"}, {"input": "package com . yf . base . utils ; import com . yf . base . utils . jackson . JsonHelper ; import java . math . BigDecimal ; import java . util . ArrayList ; import java . util . List ; public class CalcUtils { public static List < BigDecimal > avgSplit ( BigDecimal input , int size ) { int x10 = DecimalUtils . multiply ( input , <NUM_LIT> ) . intValue ( ) ; int per = DecimalUtils . divide ( new BigDecimal ( x10 ) , size ) . intValue ( ) ; int left = x10 ; List < BigDecimal > list = new ArrayList < > ( ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { int num = per ;", "output": "if ( i == size - <NUM_LIT> ) { num = left ; } BigDecimal item = DecimalUtils . divide ( new BigDecimal ( num ) , <NUM_LIT> ) . setScale ( <NUM_LIT> , BigDecimal . ROUND_HALF_UP ) ; list . add ( item ) ; left -= per ; } return list ; } public static void main ( String [ ] args ) { List < BigDecimal > list = avgSplit ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> ) ; System . out . println ( JsonHelper . toJson ( list ) ) ; } }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . Session ; import com . xcs . wx . domain . SqliteMaster ; import com . xcs . wx . domain . vo . SessionVO ; import java . util . List ; public interface SqliteMasterMapper extends BaseMapper < SqliteMaster > {", "output": "}"}, {"input": "package com . youlai . system . model . vo ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; import lombok . Setter ; import java . math . BigDecimal ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public class VisitStatsVO { @ Schema ( description = \"<STR_LIT>\" ) private String type ; @ Schema ( description = \"<STR_LIT>\" ) private String title ; @ Schema ( description = \"<STR_LIT>\" ) private Integer todayCount ; @ Schema ( description = \"<STR_LIT>\" ) private Integer totalCount ; @ Schema ( description = \"<STR_LIT>\" ) private BigDecimal growthRate ; @ Schema ( description = \"<STR_LIT>\" ) private String granularityLabel ;", "output": "}"}, {"input": "package org . example . ddduser . infrastructure . repository . microservice ; import io . github . chensheng . dddboot . openfeign . annotation . FeignClient ; import io . github . chensheng . dddboot . web . core . Response ; import feign . Headers ; import feign . RequestLine ; import org . example . ddduser . infrastructure . repository . microservice . request . WorkspaceCreateRequest ; import org . example . ddduser . infrastructure . repository . microservice . response . Workspace ; @ FeignClient ( url = \"<STR_LIT>\" , interceptors = { WorkspaceSecurityInterceptor . class } ) public interface WorkspaceMicroservice {", "output": "@ RequestLine ( \"<STR_LIT>\" ) @ Headers ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) Response < Workspace > create ( WorkspaceCreateRequest request ) ; }"}, {"input": "package ginyi . system . mapper ; import ginyi . system . domain . SysLogLogin ; import java . util . List ; public interface SysLogininforMapper { public void insertLogininfor ( SysLogLogin logininfor ) ; public List < SysLogLogin > selectLogininforList ( SysLogLogin logininfor ) ; public int deleteLogininforByIds ( Long [ ] infoIds ) ; public int cleanLogininfor ( ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . io . type ; import java . io . Serializable ; import java . io . Writer ; public class StringBuilderWriter extends Writer implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; private final StringBuilder builder ; public StringBuilderWriter ( ) { this . builder = new StringBuilder ( ) ; } public StringBuilderWriter ( final int capacity ) { this . builder = new StringBuilder ( capacity ) ; } public StringBuilderWriter ( final StringBuilder builder ) { this . builder = builder != null ? builder : new StringBuilder ( ) ; } @ Override public Writer append ( final char value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value ) { builder . append ( value ) ; return this ; } @ Override public Writer append ( final CharSequence value , final int start , final int end ) { builder . append ( value , start , end ) ; return this ; } @ Override public void close ( ) { } @ Override public void flush ( ) { } @ Override public void write ( final String value ) { if ( value != null ) { builder . append ( value ) ; } } @ Override public void write ( final char [ ] value , final int offset , final int length ) { if ( value != null ) { builder . append ( value , offset , length ) ;", "output": "} } public StringBuilder getBuilder ( ) { return builder ; } @ Override public String toString ( ) { return builder . toString ( ) ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . UserBook ; import cn . org . alan . exam . model . form . userbook . ReUserBookForm ; import cn . org . alan . exam . model . vo . userbook . * ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import java . util . List ; public interface IUserBookService extends IService < UserBook > {", "output": "Result < IPage < UserPageBookVO > > getPage ( Integer pageNum , Integer pageSize , String examName ) ; Result < List < ReUserExamBookVO > > getReUserExamBook ( Integer examId ) ; Result < BookOneQuVO > getBookOne ( Integer quId ) ; Result < AddBookAnswerVO > addBookAnswer ( ReUserBookForm reUserBookForm ) ; }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysDictDataEntity ; import com . oddfar . campus . common . utils . DictUtils ; import com . oddfar . campus . framework . mapper . SysDictDataMapper ; import com . oddfar . campus . framework . service . SysDictDataService ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . List ; @ Service public class SysDictDataServiceImpl implements SysDictDataService { @ Resource private SysDictDataMapper dictDataMapper ; @ Override public PageResult < SysDictDataEntity > page ( SysDictDataEntity dictDataEntity ) { return dictDataMapper . selectPage ( dictDataEntity ) ; } @ Override public int insertDictData ( SysDictDataEntity dictData ) { int row = dictDataMapper . insert ( dictData ) ; if ( row > <NUM_LIT> ) { List < SysDictDataEntity > dictDatas = dictDataMapper . selectDictDataByType ( dictData . getDictType ( ) ) ; DictUtils . setDictCache ( dictData . getDictType ( ) , dictDatas ) ;", "output": "} return row ; } @ Override public SysDictDataEntity selectDictDataById ( Long dictCode ) { return dictDataMapper . selectById ( dictCode ) ; } @ Override public int updateDictData ( SysDictDataEntity data ) { int row = dictDataMapper . updateById ( data ) ; if ( row > <NUM_LIT> ) { List < SysDictDataEntity > dictDatas = dictDataMapper . selectDictDataByType ( data . getDictType ( ) ) ; DictUtils . setDictCache ( data . getDictType ( ) , dictDatas ) ; } return row ; } @ Override public void deleteDictDataByIds ( Long [ ] dictCodes ) { for ( Long dictCode : dictCodes ) { SysDictDataEntity data = dictDataMapper . selectById ( dictCode ) ; dictDataMapper . deleteById ( dictCode ) ; List < SysDictDataEntity > dictDatas = dictDataMapper . selectDictDataByType ( data . getDictType ( ) ) ; DictUtils . setDictCache ( data . getDictType ( ) , dictDatas ) ; } } }"}, {"input": "package com . yf . ability . shiro . jwt ; import com . auth0 . jwt . JWT ; import com . auth0 . jwt . JWTVerifier ; import com . auth0 . jwt . algorithms . Algorithm ; import com . auth0 . jwt . interfaces . DecodedJWT ; import com . yf . base . utils . file . MD5Util ; import java . util . Calendar ; import java . util . Date ; public class JwtUtils { private static final int EXPIRE_TIME = <NUM_LIT> ; private static final String SECRET = \"<STR_LIT>\" ; public static boolean verify ( String token , String username ) { try { Algorithm algorithm = Algorithm . HMAC256 ( encryptSecret ( username ) ) ; JWTVerifier verifier = JWT . require ( algorithm ) . withClaim ( \"<STR_LIT>\" , username ) . build ( ) ; verifier . verify ( token ) ; return true ; } catch ( Exception exception ) { return false ; } } public static String getUsername ( String token ) throws Exception { DecodedJWT jwt = JWT . decode ( token ) ;", "output": "return jwt . getClaim ( \"<STR_LIT>\" ) . asString ( ) ; } public static String sign ( String username ) { Calendar cl = Calendar . getInstance ( ) ; cl . setTimeInMillis ( System . currentTimeMillis ( ) ) ; cl . add ( Calendar . HOUR , EXPIRE_TIME ) ; Algorithm algorithm = Algorithm . HMAC256 ( encryptSecret ( username ) ) ; return JWT . create ( ) . withClaim ( \"<STR_LIT>\" , username ) . withExpiresAt ( cl . getTime ( ) ) . sign ( algorithm ) ; } private static String encryptSecret ( String userName ) { return MD5Util . MD5 ( userName + \"<STR_LIT>\" + SECRET ) ; } public static boolean expired ( String token ) { DecodedJWT jwt = JWT . decode ( token ) ; return new Date ( ) . after ( jwt . getExpiresAt ( ) ) ; } }"}, {"input": "package ginyi . server . web . controller ; import ginyi . common . result . CommonResult ; import ginyi . system . domain . model . dto . LoginDto ; import ginyi . system . domain . model . vo . LoginVo ; import ginyi . system . service . ISysLoginService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) @ Slf4j public class Test { @ Autowired private ISysLoginService loginService ; @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public CommonResult < LoginVo > login ( @ RequestBody @ Validated LoginDto loginDto ) { LoginVo loginVo = loginService . login ( loginDto ) ;", "output": "return CommonResult . success ( loginVo ) ; } }"}, {"input": "package ginyi . server . web ; import ginyi . framework . core . config . AppConfig ; import lombok . extern . slf4j . Slf4j ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . autoconfigure . SpringBootApplication ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . data . redis . core . RedisTemplate ; import javax . sql . DataSource ; import java . net . UnknownHostException ; @ Slf4j @ SpringBootApplication ( scanBasePackages = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ MapperScan ( { \"<STR_LIT>\" , \"<STR_LIT>\" }", "output": ") public class WebApplication { public static void main ( String [ ] args ) throws UnknownHostException { ConfigurableApplicationContext context = SpringApplication . run ( WebApplication . class , args ) ; AppConfig . printAppInfo ( context ) ; } }"}, {"input": "package ginyi . system . domain . model . vo ; import lombok . Data ; @ Data public class SessionUserVo { private String token ; private Long loginTime ; private String ipaddr ; private String loginLocation ; private String browser ; private String os ; private String username ;", "output": "}"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import java . util . List ; import java . util . Map ; @ Data public class AccumulatorRecursiveActionParam { private ICgformEnhanceSqlService sqlService ; private CgformHead head ; private List < CgformField > cgformFieldList ; private List < Map < String , Object > > importList ; private String batchCode ; private SqlMapper sqlMapper ; private Map < String , Object > otherMap ; private CgformEnhanceJavaBatchInter java ;", "output": "}"}, {"input": "package ginyi . framework . security . config ; import ginyi . framework . core . config . GinyiConfig ; import ginyi . common . utils . Constants ; import ginyi . framework . security . interceptor . PreviewEnvInterceptor ; import ginyi . framework . security . interceptor . RepeatSubmitInterceptor ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . CacheControl ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . InterceptorRegistry ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; import javax . annotation . Resource ; import java . util . concurrent . TimeUnit ; @ Configuration public class ResourcesConfig implements WebMvcConfigurer { @ Resource private RepeatSubmitInterceptor repeatSubmitInterceptor ; @ Resource private PreviewEnvInterceptor previewEnvInterceptor ; @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { registry . addResourceHandler ( Constants . RESOURCE_PREFIX + \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" + GinyiConfig . profile + \"<STR_LIT>\" ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) . setCacheControl ( CacheControl . maxAge ( <NUM_LIT> , TimeUnit . HOURS ) . cachePublic ( ) ) ; ; } @ Override public void addInterceptors ( InterceptorRegistry registry ) { registry . addInterceptor ( repeatSubmitInterceptor ) . addPathPatterns ( \"<STR_LIT>\" ) ; registry . addInterceptor ( previewEnvInterceptor ) . addPathPatterns ( \"<STR_LIT>\" ) ; }", "output": "@ Bean public CorsFilter corsFilter ( ) { CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; config . setMaxAge ( <NUM_LIT> ) ; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } }"}, {"input": "package org . example . infrastructure . repository . example ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . example . infrastructure . common . constants . ExampleBizCode ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import javax . servlet . http . HttpServletRequest ; @ Component public class ExampleSecurityRepositoryImpl implements ExampleSecurityRepository { @ Override public Long getLoginUser ( ) throws BizException { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } try { return Long . parseLong ( userId ) ; }", "output": "catch ( NumberFormatException e ) { throw new BizException ( ExampleBizCode . AUTH_ERROR . name ( ) , \"<STR_LIT>\" ) ; } } @ Override public Long getLoginUserQuietly ( ) { HttpServletRequest request = getRequest ( ) ; if ( request == null ) { return null ; } String userId = request . getHeader ( \"<STR_LIT>\" ) ; if ( TextUtil . isBlank ( userId ) ) { return null ; } try { return Long . parseLong ( userId ) ; } catch ( NumberFormatException e ) { return null ; } } private HttpServletRequest getRequest ( ) { ServletRequestAttributes servletRequestAttributes = ( ServletRequestAttributes ) RequestContextHolder . getRequestAttributes ( ) ; if ( servletRequestAttributes == null ) { return null ; } return servletRequestAttributes . getRequest ( ) ; } }"}, {"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . apache . commons . lang . StringUtils ; public class ColumnMeta { private String tableName ; private String columnId ; private String columnName ; private int columnSize ; private String colunmType ; private String comment ; private String fieldDefault ; private int decimalDigits ; private String isNullable ; private String pkType ; private String oldColumnName ; public ColumnMeta ( ) { } public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } else if ( ! ( obj instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var2 = ( ColumnMeta ) obj ; if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var2 . getColunmType ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . columnSize == var2 . getColumnSize ( ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var2 . getColumnName ( ) ) && this . isNullable . equals ( var2 . isNullable ) && this . a ( this . comment , var2 . getComment ( ) ) && this . a ( this . fieldDefault , var2 . getFieldDefault ( ) ) ; } } } public boolean a ( Object var1 , String var2 ) { if ( var1 == this ) { return true ; } else if ( ! ( var1 instanceof ColumnMeta ) ) { return false ; } else { ColumnMeta var3 = ( ColumnMeta ) var1 ; if ( MjkjConstant . DB_TYPE_SQLSERVER . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_POSTGRESQL . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( MjkjConstant . DB_TYPE_ORACLE . equals ( var2 ) ) { if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) ; } } else if ( ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) && ! this . colunmType . contains ( \"<STR_LIT>\" ) ) { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . columnSize == var3 . getColumnSize ( ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } else { return this . colunmType . equals ( var3 . getColunmType ( ) ) && this . columnName . equals ( var3 . getColumnName ( ) ) && this . isNullable . equals ( var3 . isNullable ) && this . a ( this . comment , var3 . getComment ( ) ) && this . a ( this . fieldDefault , var3 . getFieldDefault ( ) ) ; } } } public boolean a ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } public boolean b ( ColumnMeta var1 ) { return var1 == this ? true : this . a ( this . comment , var1 . getComment ( ) ) ; } private boolean a ( String var1 , String var2 ) { boolean var3 = StringUtils . isNotEmpty ( var1 ) ; boolean var4 = StringUtils . isNotEmpty ( var2 ) ; if ( var3 != var4 ) { return false ; } else { return var3 ? var1 . equals ( var2 ) : true ; } } public String getColumnName ( ) { return this . columnName ; } public int getColumnSize ( ) { return this . columnSize ; } public String getColunmType ( ) { return this . colunmType ; } public String getComment ( ) { return this . comment ; } public int getDecimalDigits ( ) { return this . decimalDigits ; } public String getIsNullable ( ) { return this . isNullable ; } public String getOldColumnName ( ) { return this . oldColumnName ; } public int hashCode ( ) { return this . columnSize + this . colunmType . hashCode ( ) * this . columnName . hashCode ( ) ; } public void setColumnName ( String columnName ) { this . columnName = columnName ; } public void setColumnSize ( int columnSize ) { this . columnSize = columnSize ; } public void setColunmType ( String colunmType ) { this . colunmType = colunmType ; } public void setComment ( String comment ) { this . comment = comment ; } public void setDecimalDigits ( int decimalDigits ) { this . decimalDigits = decimalDigits ; } public void setIsNullable ( String isNullable ) { this . isNullable = isNullable ; } public void setOldColumnName ( String oldColumnName ) { this . oldColumnName = oldColumnName ; } public String toString ( ) { return this . columnName + \"<STR_LIT>\" + this . colunmType + \"<STR_LIT>\" + this . isNullable + \"<STR_LIT>\" + this . columnSize ; } public String getColumnId ( ) { return this . columnId ; } public void setColumnId ( String columnId ) { this . columnId = columnId ; } public String getTableName ( ) {", "output": "return this . tableName ; } public void setTableName ( String tableName ) { this . tableName = tableName ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getPkType ( ) { return this . pkType ; } public void setPkType ( String pkType ) { this . pkType = pkType ; } }"}, {"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . core . Ordered ; public interface ResponseBodyDecorator extends Ordered { Object decorate ( Object body ) ;", "output": "}"}, {"input": "package org . springblade . cgform . model . generate . impl ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . DbReadTableUtil ; import org . springblade . cgform . model . generate . IGenerate ; import org . springblade . cgform . model . generate . file . FileVo ; import org . springblade . cgform . model . generate . impl . provider . FileProvider ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . pojo . onetomany . MainTableVo ; import org . springblade . cgform . model . generate . pojo . onetomany . SubTableVo ; import org . springblade . cgform . model . generate . util . NonceUtils ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class CodeGenerateOneToMany extends FileProvider implements IGenerate { private MainTableVo mainTableVo ; private List < ColumnVo > mainColums ; private List < ColumnVo > originalMainColumns ; private List < SubTableVo > subTables ; public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < SubTableVo > subTables ) { this . subTables = subTables ; this . mainTableVo = mainTableVo ; } public CodeGenerateOneToMany ( MainTableVo mainTableVo , List < ColumnVo > mainColums , List < ColumnVo > originalMainColumns , List < SubTableVo > subTables ) { this . mainTableVo = mainTableVo ; this . mainColums = mainColums ; this . originalMainColumns = originalMainColumns ; this . subTables = subTables ; } public Map < String , Object > dtaMapMethod ( ) throws Exception { Map < String , Object > localHashMap = new HashMap < > ( ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . bussiPackage ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityPackage ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getEntityName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getTableName ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , mainTableVo . getFtlDescription ( ) ) ; localHashMap . put ( \"<STR_LIT>\" , DbConfig . dbTableId ) ; if ( mainTableVo . getFieldRequiredNum ( ) == null ) { mainTableVo . setFieldRequiredNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageFieldRequiredNum ) ? Integer . parseInt ( DbConfig . pageFieldRequiredNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getSearchFieldNum ( ) == null ) { mainTableVo . setSearchFieldNum ( Integer . valueOf ( StringUtils . isNotEmpty ( DbConfig . pageSearchFiledNum ) ? Integer . parseInt ( DbConfig . pageSearchFiledNum ) : - <NUM_LIT> ) ) ; } if ( mainTableVo . getFieldRowNum ( ) == null ) { mainTableVo . setFieldRowNum ( Integer . valueOf ( Integer . parseInt ( DbConfig . pageFieldRowNum ) ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainTableVo ) ; try { if ( ( mainColums == null ) || ( mainColums . size ( ) == <NUM_LIT> ) ) { mainColums = DbReadTableUtil . getColumns ( mainTableVo . getTableName ( ) ) ; } if ( ( originalMainColumns == null ) || ( originalMainColumns . size ( ) == <NUM_LIT> ) ) { originalMainColumns = DbReadTableUtil . getOriginalColumns ( mainTableVo . getTableName ( ) ) ; } localHashMap . put ( \"<STR_LIT>\" , mainColums ) ; localHashMap . put ( \"<STR_LIT>\" , originalMainColumns ) ; for ( ColumnVo columnVo : this . originalMainColumns ) { if ( columnVo . getFieldName ( ) . toLowerCase ( ) . equals ( DbConfig . dbTableId . toLowerCase ( ) ) ) { localHashMap . put ( \"<STR_LIT>\" , columnVo . getFieldType ( ) ) ; } } for ( SubTableVo subTableVo : this . subTables ) { if ( subTableVo . getColums ( ) == null || subTableVo . getColums ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setColums ( DbReadTableUtil . getColumns ( subTableVo . getTableName ( ) ) ) ; } if ( subTableVo . getOriginalColumns ( ) == null || subTableVo . getOriginalColumns ( ) . size ( ) == <NUM_LIT> ) { subTableVo . setOriginalColumns ( DbReadTableUtil . getOriginalColumns ( subTableVo . getTableName ( ) ) ) ; } String [ ] foreignKeys = subTableVo . getForeignKeys ( ) ; ArrayList < String > list = new ArrayList < String > ( ) ; String [ ] array = foreignKeys ; for ( int length = array . length , i = <NUM_LIT> ; i < length ; ++ i ) { list . add ( DbReadTableUtil . humpConver ( array [ i ] , true ) ) ; } subTableVo . setForeignKeys ( list . toArray ( new String [ <NUM_LIT> ] ) ) ; subTableVo . setOriginalForeignKeys ( foreignKeys ) ; } localHashMap . put ( \"<STR_LIT>\" , subTables ) ; } catch ( Exception localException ) { throw localException ; } long l = NonceUtils . c ( ) + NonceUtils . g ( ) ; localHashMap . put ( \"<STR_LIT>\" , String . valueOf ( l ) ) ; log . info ( \"<STR_LIT>\" + localHashMap . toString ( ) ) ; return localHashMap ;", "output": "} public List < String > generateCodeFile ( String stylePath ) throws Exception { String str1 = DbConfig . projectPath ; Map < String , Object > localMap = dtaMapMethod ( ) ; String templatepath = DbConfig . templatepath ; if ( strSubStartEnd ( templatepath , \"<STR_LIT>\" ) . equals ( \"<STR_LIT>\" ) ) { templatepath = \"<STR_LIT>\" + strSubStartEnd ( templatepath , \"<STR_LIT>\" ) + \"<STR_LIT>\" ; DbConfig . setTemplatepath ( templatepath ) ; } FileVo locala = new FileVo ( templatepath ) ; locala . setStylePath ( stylePath ) ; generateCodeFile ( locala , str1 , localMap ) ; log . info ( \"<STR_LIT>\" + mainTableVo . getTableName ( ) ) ; return msg ; } public List < String > generateCodeFile ( String projectPath , String templatePath , String stylePath ) throws Exception { if ( ( projectPath != null ) && ( ! \"<STR_LIT>\" . equals ( projectPath ) ) ) { DbConfig . setProjectPath ( projectPath ) ; } if ( ( templatePath != null ) && ( ! \"<STR_LIT>\" . equals ( templatePath ) ) ) { DbConfig . setTemplatepath ( templatePath ) ; } generateCodeFile ( stylePath ) ; return msg ; } }"}, {"input": "package com . yf . system . modules . user . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . ability . shiro . dto . SysUserLoginDTO ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . user . dto . request . * ; import com . yf . system . modules . user . dto . response . UserListRespDTO ; import com . yf . system . modules . user . entity . SysUser ; import java . util . List ; public interface SysUserService extends IService < SysUser > { SysUserSaveReqDTO detail ( String id ) ;", "output": "IPage < UserListRespDTO > paging ( PagingReqDTO < SysUserQueryReqDTO > reqDTO ) ; void delete ( List < String > ids ) ; SysUserLoginDTO login ( SysUserLoginReqDTO reqDTO ) ; SysUserLoginDTO token ( String token ) ; void logout ( String token ) ; void update ( SysUserUpdateReqDTO reqDTO ) ; void save ( SysUserSaveReqDTO reqDTO ) ; SysUserLoginDTO reg ( UserRegReqDTO reqDTO ) ; }"}, {"input": "package me . zhengjie . modules . system . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . DictDetail ; import me . zhengjie . modules . system . service . DictDetailService ; import me . zhengjie . modules . system . domain . vo . DictDetailQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class DictDetailController { private final DictDetailService dictDetailService ; private static final String ENTITY_NAME = \"<STR_LIT>\" ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping public ResponseEntity < PageResult < DictDetail > > queryDictDetail ( DictDetailQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( dictDetailService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > getDictDetailMaps ( @ RequestParam String dictName ) { String [ ] names = dictName . split ( \"<STR_LIT>\" ) ; Map < String , List < DictDetail > > dictMap = new HashMap < > ( <NUM_LIT> ) ; for ( String name : names ) { dictMap . put ( name , dictDetailService . getDictByName ( name ) ) ; } return new ResponseEntity < > ( dictMap , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createDictDetail ( @ Validated @ RequestBody DictDetail resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( \"<STR_LIT>\" + ENTITY_NAME + \"<STR_LIT>\" ) ; } dictDetailService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateDictDetail ( @ Validated ( DictDetail . Update . class ) @ RequestBody DictDetail resources ) { dictDetailService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteDictDetail ( @ PathVariable Long id ) { dictDetailService . delete ( id ) ;", "output": "return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package com . youlai . system . model . form ; import io . swagger . v3 . oas . annotations . media . Schema ; import jakarta . validation . constraints . NotNull ; import lombok . Getter ; import lombok . Setter ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public class DeptForm { @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String code ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ NotNull ( message = \"<STR_LIT>\" ) private Long parentId ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer sort ;", "output": "}"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . exception . CommonException ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import ginyi . common . utils . enums . UserStatus ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . SysUser ; import ginyi . system . service . ISysPasswordService ; import ginyi . system . service . ISysPermissionService ; import ginyi . system . service . ISysUserService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . core . userdetails . UserDetails ; import org . springframework . security . core . userdetails . UserDetailsService ; import org . springframework . security . core . userdetails . UsernameNotFoundException ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; @ Service public class UserDetailsServiceImpl implements UserDetailsService { private static final Logger log = LoggerFactory . getLogger ( UserDetailsServiceImpl . class ) ; @ Resource private ISysUserService userService ; @ Resource private ISysPasswordService passwordService ; @ Resource private ISysPermissionService permissionService ; @ Override public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException {", "output": "SysUser user = userService . selectUserByUserName ( username ) ; if ( StringUtils . isNull ( user ) ) { throw new CommonException ( StateCode . ERROR_UNAUTHENTICATION , CommonMessageConstants . USER_NOT_EXIST ) ; } else if ( UserStatus . DELETED . getCode ( ) . equals ( user . getDeleted ( ) ) ) { throw new CommonException ( StateCode . ERROR_UNAUTHENTICATION , CommonMessageConstants . USER_IS_DELETED ) ; } else if ( UserStatus . DISABLE . getCode ( ) . equals ( user . getStatus ( ) ) ) { throw new CommonException ( StateCode . ERROR_UNAUTHENTICATION , CommonMessageConstants . USER_IS_FORBIDDEN ) ; } passwordService . validate ( user ) ; return createLoginUser ( user ) ; } public UserDetails createLoginUser ( SysUser user ) { return new LoginUser ( user . getUserId ( ) , user . getDeptId ( ) , user , permissionService . getMenuPermission ( user ) ) ; } }"}, {"input": "package org . springblade . web . utils . resource ; import org . springblade . core . oss . OssTemplate ; import org . springblade . core . oss . enums . OssEnum ; import org . springblade . core . oss . props . OssProperties ; import org . springblade . core . oss . rule . BladeOssRule ; import org . springblade . core . oss . rule . OssRule ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . StringPool ; import org . springblade . entity . Oss ; import org . springframework . stereotype . Component ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class OssBuilder { public static final String OSS_CODE = \"<STR_LIT>\" ; public static final String OSS_PARAM_KEY = \"<STR_LIT>\" ; private final OssProperties ossProperties ; public OssBuilder ( OssProperties ossProperties ) { this . ossProperties = ossProperties ; } private final Map < String , OssTemplate > templatePool = new ConcurrentHashMap < > ( ) ; private final Map < String , Oss > ossPool = new ConcurrentHashMap < > ( ) ; public OssTemplate template ( ) { return template ( StringPool . EMPTY ) ; } public OssTemplate template ( String code ) { String tenantId = AuthUtil . getTenantId ( ) ; Oss oss = getOss ( tenantId , code ) ; Oss ossCached = ossPool . get ( tenantId ) ; OssTemplate template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { synchronized ( OssBuilder . class ) { template = templatePool . get ( tenantId ) ; if ( Func . hasEmpty ( template , ossCached ) || ! oss . getEndpoint ( ) . equals ( ossCached . getEndpoint ( ) ) || ! oss . getAccessKey ( ) . equals ( ossCached . getAccessKey ( ) ) ) { OssRule ossRule ; if ( oss . getEndpoint ( ) . equals ( ossProperties . getEndpoint ( ) ) && oss . getAccessKey ( ) . equals ( ossProperties . getAccessKey ( ) ) && ossProperties . getTenantMode ( ) ) { ossRule = new BladeOssRule ( Boolean . TRUE ) ; } else { ossRule = new BladeOssRule ( Boolean . FALSE ) ; } template = AliOssBuilder . template ( oss , ossRule ) ; templatePool . put ( tenantId , template ) ; ossPool . put ( tenantId , oss ) ; } } } return template ; } public Oss getOss ( String tenantId , String code ) { Oss defaultOss = new Oss ( ) ; defaultOss . setId ( <NUM_LIT> ) ; defaultOss . setCategory ( OssEnum . of ( ossProperties . getName ( ) ) . getCategory ( ) ) ;", "output": "defaultOss . setEndpoint ( ossProperties . getEndpoint ( ) ) ; defaultOss . setBucketName ( ossProperties . getBucketName ( ) ) ; defaultOss . setAccessKey ( ossProperties . getAccessKey ( ) ) ; defaultOss . setSecretKey ( ossProperties . getSecretKey ( ) ) ; return defaultOss ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . Notice ; import cn . org . alan . exam . model . form . NoticeForm ; import cn . org . alan . exam . model . vo . NoticeVO ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; public interface INoticeService extends IService < Notice > { Result < String > addNotice ( NoticeForm noticeForm ) ; Result < String > deleteNotice ( String ids ) ; Result < String > updateNotice ( String id , NoticeForm noticeForm ) ; Result < IPage < NoticeVO > > getNotice ( Integer pageNum , Integer pageSize , String title ) ; Result < IPage < NoticeVO > > getNewNotice ( Integer pageNum , Integer pageSize ) ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . api . file ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . exception . file . FileNameLengthLimitExceededException ; import com . oddfar . campus . common . exception . file . FileSizeLimitExceededException ; import com . oddfar . campus . common . exception . file . InvalidExtensionException ; import com . oddfar . campus . common . utils . DateUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . uuid . Seq ; import com . oddfar . campus . framework . api . sysconfig . ConfigExpander ; import org . apache . commons . io . FilenameUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . web . multipart . MultipartFile ; import java . io . File ; import java . io . IOException ; import java . nio . file . Paths ; import java . util . Objects ; public class FileUploadUtils { private static final Logger log = LoggerFactory . getLogger ( FileUploadUtils . class ) ; public static final long DEFAULT_MAX_SIZE = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; public static final int DEFAULT_FILE_NAME_LENGTH = <NUM_LIT> ; private static String defaultBaseDir = ConfigExpander . getFileProfile ( ) ; public static void setDefaultBaseDir ( String defaultBaseDir ) { FileUploadUtils . defaultBaseDir = defaultBaseDir ; } public static String getDefaultBaseDir ( ) { return defaultBaseDir ; } public static final String upload ( MultipartFile file ) throws IOException { try { return upload ( getDefaultBaseDir ( ) , file , MimeTypeUtils . DEFAULT_ALLOWED_EXTENSION ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) , e ) ; } } public static final String upload ( String baseDir , MultipartFile file ) throws IOException { try { return upload ( baseDir , file , MimeTypeUtils . DEFAULT_ALLOWED_EXTENSION ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) , e ) ; } } public static final String upload ( String baseDir , MultipartFile file , String [ ] allowedExtension ) throws FileSizeLimitExceededException , IOException , FileNameLengthLimitExceededException , InvalidExtensionException { int fileNamelength = Objects . requireNonNull ( file . getOriginalFilename ( ) ) . length ( ) ; if ( fileNamelength > FileUploadUtils . DEFAULT_FILE_NAME_LENGTH ) { throw new FileNameLengthLimitExceededException ( FileUploadUtils . DEFAULT_FILE_NAME_LENGTH ) ; } assertAllowed ( file , allowedExtension ) ; String fileName = extractFilename ( file ) ; String absPath = getAbsoluteFile ( baseDir , fileName ) . getAbsolutePath ( ) ; file . transferTo ( Paths . get ( absPath ) ) ; return getPathFileName ( baseDir , fileName ) ; } public static final String extractFilename ( MultipartFile file ) { return StringUtils . format ( \"<STR_LIT>\" , DateUtils . datePath ( ) , FilenameUtils . getBaseName ( file . getOriginalFilename ( ) ) , Seq . getId ( Seq . uploadSeqType ) , getExtension ( file ) ) ; } public static final File getAbsoluteFile ( String uploadDir , String fileName ) throws IOException { File desc = new File ( uploadDir + File . separator + fileName ) ; if ( ! desc . exists ( ) ) { if ( ! desc . getParentFile ( ) . exists ( ) ) { desc . getParentFile ( ) . mkdirs ( ) ; } } return desc ; } public static final String getPathFileName ( String uploadDir , String fileName ) throws IOException { int dirLastIndex = ConfigExpander . getFileProfile ( ) . length ( ) + <NUM_LIT> ; String currentDir = StringUtils . substring ( uploadDir , dirLastIndex ) ; return Constants . RESOURCE_PREFIX + \"<STR_LIT>\" + currentDir + \"<STR_LIT>\" + fileName ; } public static final void assertAllowed ( MultipartFile file , String [ ] allowedExtension ) throws FileSizeLimitExceededException , InvalidExtensionException { long size = file . getSize ( ) ; if ( size > DEFAULT_MAX_SIZE ) { throw new FileSizeLimitExceededException ( DEFAULT_MAX_SIZE / <NUM_LIT> / <NUM_LIT> ) ; } String fileName = file . getOriginalFilename ( ) ; String extension = getExtension ( file ) ; if ( allowedExtension != null && ! isAllowedExtension ( extension , allowedExtension ) ) { if ( allowedExtension == MimeTypeUtils . IMAGE_EXTENSION ) { throw new InvalidExtensionException . InvalidImageExtensionException ( allowedExtension , extension , fileName ) ; } else if ( allowedExtension == MimeTypeUtils . FLASH_EXTENSION ) { throw new InvalidExtensionException . InvalidFlashExtensionException ( allowedExtension , extension , fileName ) ; } else if ( allowedExtension == MimeTypeUtils . MEDIA_EXTENSION ) { throw new InvalidExtensionException . InvalidMediaExtensionException ( allowedExtension , extension , fileName ) ; } else if ( allowedExtension == MimeTypeUtils . VIDEO_EXTENSION ) { throw new InvalidExtensionException . InvalidVideoExtensionException ( allowedExtension , extension , fileName ) ; } else { throw new InvalidExtensionException ( allowedExtension , extension , fileName ) ; } } } public static final boolean isAllowedExtension ( String extension , String [ ] allowedExtension ) { for ( String str : allowedExtension ) { if ( str . equalsIgnoreCase ( extension ) ) { return true ; } } return false ; } public static final String getExtension ( MultipartFile file ) {", "output": "String extension = FilenameUtils . getExtension ( file . getOriginalFilename ( ) ) ; if ( StringUtils . isEmpty ( extension ) ) { extension = MimeTypeUtils . getExtension ( Objects . requireNonNull ( file . getContentType ( ) ) ) ; } return extension ; } }"}, {"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . DesformData ; import org . springblade . core . mp . base . BaseService ; public interface IDesformDataService extends BaseService < DesformData > {", "output": "}"}, {"input": "package com . xcs . wx . repository ; import com . xcs . wx . domain . Msg ; import com . xcs . wx . domain . vo . CountRecentMsgsVO ; import com . xcs . wx . domain . vo . MsgTypeDistributionVO ; import com . xcs . wx . domain . vo . TopContactsVO ; import java . util . List ; public interface MsgRepository { List < Msg > queryMsgByTalker ( String talker , Long nextSequence ) ; List < Msg > exportMsg ( String talker ) ;", "output": "List < MsgTypeDistributionVO > msgTypeDistribution ( ) ; List < CountRecentMsgsVO > countRecentMsgs ( ) ; List < TopContactsVO > topContacts ( ) ; int countSent ( ) ; int countReceived ( ) ; }"}, {"input": "package org . example . application . example . dto . command ; import lombok . Data ; import javax . validation . constraints . NotEmpty ; @ Data public class ExampleUpdatePasswordCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String oldPassword ; @ NotEmpty ( message = \"<STR_LIT>\" ) private String newPassword ;", "output": "}"}, {"input": "package top . kangert . kspider . controller ; import top . kangert . kspider . controller . BaseController ; import top . kangert . kspider . domain . Variable ; import top . kangert . kspider . service . VariableService ; import top . kangert . kspider . util . BaseResponse ; import top . kangert . kspider . util . PageInfo ; import java . util . Map ; import javax . annotation . Resource ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class VariableController extends BaseController { @ Resource private VariableService variableService ; @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse addVar ( @ RequestBody Map < String , Object > params ) { variableService . addItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse deleteVar ( @ RequestBody Map < String , Object > params ) { variableService . deleteItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse editVar ( @ RequestBody Map < String , Object > params ) { variableService . editItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse queryVar ( @ RequestBody Map < String , Object > params ) { PageInfo < Variable > pageInfo = variableService . queryItems ( params ) ; return successResponse ( pageInfo ) ; }", "output": "}"}, {"input": "package com . xcs . wx . util ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Paths ; @ Slf4j public class ImgDecoderUtil { private static final int [ ] PIC_HEAD = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; public static String decodeDat ( String filePath , String outPath ) { try { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { return null ; } int [ ] codeResult = getCode ( filePath ) ; int fileType = codeResult [ <NUM_LIT> ] ; int decodeCode = codeResult [ <NUM_LIT> ] ; if ( decodeCode == - <NUM_LIT> ) { return null ; } String extension ; switch ( fileType ) { case <NUM_LIT> : extension = \"<STR_LIT>\" ; break ; case <NUM_LIT> : extension = \"<STR_LIT>\" ; break ; case <NUM_LIT> : extension = \"<STR_LIT>\" ; break ; default : extension = \"<STR_LIT>\" ; break ; } String fileName = file . getName ( ) ; String picName = fileName . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + extension ; String fileOutPath = Paths . get ( outPath , picName ) . toString ( ) ; if ( new File ( fileOutPath ) . exists ( ) ) { return fileOutPath ; } byte [ ] data = Files . readAllBytes ( Paths . get ( filePath ) ) ; try ( FileOutputStream fileOut = new FileOutputStream ( fileOutPath ) ) { for ( byte b : data ) { fileOut . write ( b ^ decodeCode ) ;", "output": "} } return fileOutPath ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , e ) ; } return null ; } private static int [ ] getCode ( String filePath ) { File file = new File ( filePath ) ; if ( file . isDirectory ( ) ) { return new int [ ] { - <NUM_LIT> , - <NUM_LIT> } ; } try ( FileInputStream datFile = new FileInputStream ( filePath ) ) { byte [ ] datRead = new byte [ <NUM_LIT> ] ; if ( datFile . read ( datRead , <NUM_LIT> , <NUM_LIT> ) != <NUM_LIT> ) { return new int [ ] { - <NUM_LIT> , - <NUM_LIT> } ; } for ( int i = <NUM_LIT> ; i < PIC_HEAD . length ; i += <NUM_LIT> ) { int code = ( datRead [ <NUM_LIT> ] & <NUM_LIT> ) ^ PIC_HEAD [ i ] ; int idfCode = ( datRead [ <NUM_LIT> ] & <NUM_LIT> ) ^ code ; if ( idfCode == PIC_HEAD [ i + <NUM_LIT> ] ) { return new int [ ] { i , code } ; } } } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , e ) ; } return new int [ ] { - <NUM_LIT> , - <NUM_LIT> } ; } public static void main ( String [ ] args ) { decodeDat ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package com . yf . base . utils . passwd ; import com . yf . base . utils . file . MD5Util ; import org . apache . commons . lang3 . RandomStringUtils ; public class PassHandler { public static boolean checkPass ( String inputPass , String salt , String pass ) { String pwdMd5 = MD5Util . MD5 ( inputPass ) ; return MD5Util . MD5 ( pwdMd5 + salt ) . equals ( pass ) ; } public static PassInfo buildPassword ( String inputPass ) { String salt = RandomStringUtils . randomAlphabetic ( <NUM_LIT> ) ; String encryptPassword = MD5Util . MD5 ( MD5Util . MD5 ( inputPass ) + salt ) ; return new PassInfo ( salt , encryptPassword ) ; } public static void main ( String [ ] args ) { PassInfo pa = buildPassword ( \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" + pa . getPassword ( ) + \"<STR_LIT>\" + pa . getSalt ( ) + \"<STR_LIT>\" ) ; PassInfo ps = buildPassword ( \"<STR_LIT>\" ) ; System . out . println ( \"<STR_LIT>\" + ps . getPassword ( ) + \"<STR_LIT>\" + ps . getSalt ( ) + \"<STR_LIT>\" ) ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . tools . io ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . text . Charsets ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . commons . lang3 . Validate ; import java . io . * ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . List ; public class FileUtil { private static FileVisitor < Path > deleteFileVisitor = new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Files . delete ( file ) ; return FileVisitResult . CONTINUE ; } @ Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { Files . delete ( dir ) ; return FileVisitResult . CONTINUE ; } } ; public static byte [ ] toByteArray ( final File file ) throws IOException { return Files . readAllBytes ( file . toPath ( ) ) ; } public static String toString ( final File file ) throws IOException { return com . google . common . io . Files . toString ( file , Charsets . UTF_8 ) ; } public static List < String > toLines ( final File file ) throws IOException { return Files . readAllLines ( file . toPath ( ) , Charsets . UTF_8 ) ; } public static void write ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 ) ) { writer . append ( data ) ; } } public static void append ( final CharSequence data , final File file ) throws IOException { Validate . notNull ( file ) ; Validate . notNull ( data ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( file . toPath ( ) , Charsets . UTF_8 , StandardOpenOption . APPEND ) ) { writer . append ( data ) ; } } public static InputStream asInputStream ( String fileName ) throws IOException { return asInputStream ( getPath ( fileName ) ) ; } public static InputStream asInputStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asInputStream ( file . toPath ( ) ) ; } public static InputStream asInputStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newInputStream ( path ) ; } public static OutputStream asOututStream ( String fileName ) throws IOException { return asOututStream ( getPath ( fileName ) ) ; } public static OutputStream asOututStream ( File file ) throws IOException { Validate . notNull ( file , \"<STR_LIT>\" ) ; return asOututStream ( file . toPath ( ) ) ; } public static OutputStream asOututStream ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newOutputStream ( path ) ; } public static BufferedReader asBufferedReader ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return asBufferedReader ( getPath ( fileName ) ) ; } public static BufferedReader asBufferedReader ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedReader ( path , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( String fileName ) throws IOException { Validate . notBlank ( fileName , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( getPath ( fileName ) , Charsets . UTF_8 ) ; } public static BufferedWriter asBufferedWriter ( Path path ) throws IOException { Validate . notNull ( path , \"<STR_LIT>\" ) ; return Files . newBufferedWriter ( path , Charsets . UTF_8 ) ; } public static void copy ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copy ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copy ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; if ( Files . isDirectory ( from ) ) { copyDir ( from , to ) ; } else { copyFile ( from , to ) ; } } public static void copyFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; copyFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( Files . exists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! FileUtil . isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . copy ( from , to ) ; } public static void copyDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; copyDir ( from . toPath ( ) , to . toPath ( ) ) ; } public static void copyDir ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; makesureDirExists ( to ) ; try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( from ) ) { for ( Path path : dirStream ) { copy ( path , to . resolve ( path . getFileName ( ) ) ) ; } } } public static void moveFile ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . notNull ( from ) ; Validate . notNull ( to ) ; moveFile ( from . toPath ( ) , to . toPath ( ) ) ; } public static void moveFile ( @ NotNull Path from , @ NotNull Path to ) throws IOException { Validate . isTrue ( isFileExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isDirExists ( to ) , \"<STR_LIT>\" , to ) ; Files . move ( from , to ) ; } public static void moveDir ( @ NotNull File from , @ NotNull File to ) throws IOException { Validate . isTrue ( isDirExists ( from ) , \"<STR_LIT>\" , from ) ; Validate . notNull ( to ) ; Validate . isTrue ( ! isFileExists ( to ) , \"<STR_LIT>\" , to ) ; final boolean rename = from . renameTo ( to ) ; if ( ! rename ) { if ( to . getCanonicalPath ( ) . startsWith ( from . getCanonicalPath ( ) + File . separator ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to ) ; } copyDir ( from , to ) ; deleteDir ( from ) ; if ( from . exists ( ) ) { throw new IOException ( \"<STR_LIT>\" + from + \"<STR_LIT>\" + to + '<STR_LIT>' ) ; } } } public static void touch ( String filePath ) throws IOException { touch ( new File ( filePath ) ) ; } public static void touch ( File file ) throws IOException { com . google . common . io . Files . touch ( file ) ; } public static void deleteFile ( @ Nullable File file ) throws IOException { Validate . isTrue ( isFileExists ( file ) , \"<STR_LIT>\" , file ) ; deleteFile ( file . toPath ( ) ) ; } public static void deleteFile ( @ Nullable Path path ) throws IOException { Validate . isTrue ( isFileExists ( path ) , \"<STR_LIT>\" , path ) ; Files . delete ( path ) ; } public static void deleteDir ( Path dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; Files . walkFileTree ( dir , deleteFileVisitor ) ; } public static void deleteDir ( File dir ) throws IOException { Validate . isTrue ( isDirExists ( dir ) , \"<STR_LIT>\" , dir ) ; deleteDir ( dir . toPath ( ) ) ; } public static boolean isDirExists ( String dirPath ) { if ( dirPath == null ) { return false ; } return isDirExists ( getPath ( dirPath ) ) ; } public static boolean isDirExists ( Path dirPath ) { return dirPath != null && Files . exists ( dirPath ) && Files . isDirectory ( dirPath ) ; } public static boolean isDirExists ( File dir ) { if ( dir == null ) { return false ; } return isDirExists ( dir . toPath ( ) ) ; } public static void makesureDirExists ( String dirPath ) throws IOException { makesureDirExists ( getPath ( dirPath ) ) ; } public static void makesureDirExists ( File file ) throws IOException {", "output": "Validate . notNull ( file ) ; makesureDirExists ( file . toPath ( ) ) ; } public static void makesureDirExists ( Path dirPath ) throws IOException { Validate . notNull ( dirPath ) ; Files . createDirectories ( dirPath ) ; } public static void makesureParentDirExists ( File file ) throws IOException { Validate . notNull ( file ) ; makesureDirExists ( file . getParentFile ( ) ) ; } public static boolean isFileExists ( String fileName ) { if ( fileName == null ) { return false ; } return isFileExists ( getPath ( fileName ) ) ; } public static boolean isFileExists ( File file ) { if ( file == null ) { return false ; } return isFileExists ( file . toPath ( ) ) ; } public static boolean isFileExists ( Path path ) { if ( path == null ) { return false ; } return Files . exists ( path ) && Files . isRegularFile ( path ) ; } public static Path createTempDir ( ) throws IOException { return Files . createTempDirectory ( System . currentTimeMillis ( ) + \"<STR_LIT>\" ) ; } public static Path createTempFile ( ) throws IOException { return Files . createTempFile ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static Path createTempFile ( String prefix , String suffix ) throws IOException { return Files . createTempFile ( prefix , suffix ) ; } private static Path getPath ( String filePath ) { return Paths . get ( filePath ) ; } public static String getFileName ( @ NotNull String fullName ) { Validate . notEmpty ( fullName ) ; int last = fullName . lastIndexOf ( Platforms . FILE_PATH_SEPARATOR_CHAR ) ; return fullName . substring ( last + <NUM_LIT> ) ; } public static String getFileExtension ( File file ) { return com . google . common . io . Files . getFileExtension ( file . getName ( ) ) ; } public static String getFileExtension ( String fullName ) { if ( fullName == null ) { return TextUtil . EMPTY_STRING ; } return com . google . common . io . Files . getFileExtension ( fullName ) ; } }"}, {"input": "package top . kangert . kspider . annotation ; import java . lang . annotation . * ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( ElementType . METHOD ) public @ interface Example {", "output": "String value ( ) ; }"}, {"input": "package com . xcs . wx . msg . impl ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import org . springframework . stereotype . Service ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; @ Service public class SystemMsgStrategy implements MsgStrategy { private static final String REGEX = \"<STR_LIT>\" ; @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ; } @ Override public void process ( MsgVO msgVO ) { msgVO . setStrContent ( msgVO . getStrContent ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ;", "output": "Pattern pattern = Pattern . compile ( REGEX ) ; Matcher matcher = pattern . matcher ( msgVO . getStrContent ( ) ) ; if ( matcher . find ( ) ) { String extractedText = matcher . group ( <NUM_LIT> ) . trim ( ) ; extractedText = extractedText . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . trim ( ) ; msgVO . setStrContent ( extractedText ) ; } } }"}, {"input": "package com . oddfar . campus . common . utils . ip ; import com . alibaba . fastjson2 . JSON ; import com . alibaba . fastjson2 . JSONObject ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . http . HttpUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class AddressUtils { private static final Logger log = LoggerFactory . getLogger ( AddressUtils . class ) ; public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { if ( IpUtils . internalIp ( ip ) ) { return \"<STR_LIT>\" ; } { try { String rspStr = HttpUtils . sendGet ( IP_URL , \"<STR_LIT>\" + ip + \"<STR_LIT>\" , Constants . GBK ) ; if ( StringUtils . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ;", "output": "return UNKNOWN ; } JSONObject obj = JSON . parseObject ( rspStr ) ; String region = obj . getString ( \"<STR_LIT>\" ) ; String city = obj . getString ( \"<STR_LIT>\" ) ; return String . format ( \"<STR_LIT>\" , region , city ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , ip ) ; } } return UNKNOWN ; } }"}, {"input": "package com . oddfar . campus . framework . config ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import com . fasterxml . jackson . datatype . jsr310 . JavaTimeModule ; import com . fasterxml . jackson . datatype . jsr310 . deser . LocalDateTimeDeserializer ; import com . fasterxml . jackson . datatype . jsr310 . ser . LocalDateTimeSerializer ; import com . oddfar . campus . framework . handler . BigNumberSerializer ; import lombok . extern . slf4j . Slf4j ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . jackson . Jackson2ObjectMapperBuilderCustomizer ; import org . springframework . boot . autoconfigure . jackson . JacksonAutoConfiguration ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . time . LocalDateTime ; import java . time . format . DateTimeFormatter ; import java . util . TimeZone ; @ Slf4j @ Configuration @ AutoConfigureBefore ( JacksonAutoConfiguration . class ) public class JacksonConfig { @ Bean public Jackson2ObjectMapperBuilderCustomizer customizer ( ) { return builder -> { JavaTimeModule javaTimeModule = new JavaTimeModule ( ) ; javaTimeModule . addSerializer ( Long . class , BigNumberSerializer . INSTANCE ) ; javaTimeModule . addSerializer ( Long . TYPE , BigNumberSerializer . INSTANCE ) ; javaTimeModule . addSerializer ( BigInteger . class , BigNumberSerializer . INSTANCE ) ; javaTimeModule . addSerializer ( BigDecimal . class , ToStringSerializer . instance ) ;", "output": "DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"<STR_LIT>\" ) ; javaTimeModule . addSerializer ( LocalDateTime . class , new LocalDateTimeSerializer ( formatter ) ) ; javaTimeModule . addDeserializer ( LocalDateTime . class , new LocalDateTimeDeserializer ( formatter ) ) ; builder . modules ( javaTimeModule ) ; builder . timeZone ( TimeZone . getDefault ( ) ) ; log . info ( \"<STR_LIT>\" ) ; } ; } }"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; @ Data public class DictDetailQueryCriteria { private String label ; private String dictName ;", "output": "}"}, {"input": "package me . zhengjie . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class LocalStorageQueryCriteria { private String blurry ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package com . yf . config . jackson ; import com . fasterxml . jackson . databind . ObjectMapper ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . converter . json . Jackson2ObjectMapperBuilder ; @ Configuration public class JacksonConfig { @ Bean public ObjectMapper jacksonObjectMapper ( Jackson2ObjectMapperBuilder builder ) { ObjectMapper objectMapper = builder . createXmlMapper ( false ) . build ( ) ; objectMapper . setSerializerFactory ( objectMapper . getSerializerFactory ( ) . withSerializerModifier ( new JacksonSerializerModifier ( ) ) ) ; return objectMapper ;", "output": "} }"}, {"input": "package com . oddfar . campus . framework . security . context ; import cn . hutool . core . convert . Convert ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; public class PermissionContextHolder { private static final String PERMISSION_CONTEXT_ATTRIBUTES = \"<STR_LIT>\" ; public static void setContext ( String permission ) { RequestContextHolder . currentRequestAttributes ( ) . setAttribute ( PERMISSION_CONTEXT_ATTRIBUTES , permission , RequestAttributes . SCOPE_REQUEST ) ; } public static String getContext ( ) {", "output": "return Convert . toStr ( RequestContextHolder . currentRequestAttributes ( ) . getAttribute ( PERMISSION_CONTEXT_ATTRIBUTES , RequestAttributes . SCOPE_REQUEST ) ) ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractQuickCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ; String orderCode ;", "output": "BigDecimal price ; BigDecimal amount ; String logContractId ; }"}, {"input": "package com . yf . ability . captcha . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CheckCaptchaReqDTO implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String captchaKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String captchaValue ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import org . springframework . context . ApplicationEvent ; import org . springframework . core . io . Resource ; import org . w3c . dom . Element ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . Map ; public class NacosConfigMetadataEvent extends ApplicationEvent { private String dataId ; private String groupId ; private String beanName ; private Object bean ; private Class < ? > beanType ; private AnnotatedElement annotatedElement ; private Resource xmlResource ; private Map < Object , Object > nacosProperties ; private Map < String , Object > nacosPropertiesAttributes ; public NacosConfigMetadataEvent ( Object source ) { super ( source ) ; } public String getDataId ( ) { return dataId ; }", "output": "public void setDataId ( String dataId ) { this . dataId = dataId ; } public String getGroupId ( ) { return groupId ; } public void setGroupId ( String groupId ) { this . groupId = groupId ; } public String getBeanName ( ) { return beanName ; } public void setBeanName ( String beanName ) { this . beanName = beanName ; } public Object getBean ( ) { return bean ; } public void setBean ( Object bean ) { this . bean = bean ; } public Class < ? > getBeanType ( ) { return beanType ; } public void setBeanType ( Class < ? > beanType ) { this . beanType = beanType ; } public AnnotatedElement getAnnotatedElement ( ) { return annotatedElement ; } public void setAnnotatedElement ( AnnotatedElement annotatedElement ) { this . annotatedElement = annotatedElement ; } public Resource getXmlResource ( ) { return xmlResource ; } public void setXmlResource ( Resource xmlResource ) { this . xmlResource = xmlResource ; } public Map < Object , Object > getNacosProperties ( ) { return nacosProperties ; } public void setNacosProperties ( Map < Object , Object > nacosProperties ) { this . nacosProperties = nacosProperties ; } public Map < String , Object > getNacosPropertiesAttributes ( ) { return nacosPropertiesAttributes ; } public void setNacosPropertiesAttributes ( Map < String , Object > nacosPropertiesAttributes ) { this . nacosPropertiesAttributes = nacosPropertiesAttributes ; } }"}, {"input": "package com . yf . ability . captcha . controller ; import com . yf . ability . captcha . service . CaptchaService ; import com . yf . base . api . api . controller . BaseController ; import com . wf . captcha . SpecCaptcha ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiImplicitParam ; import io . swagger . annotations . ApiImplicitParams ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; import org . springframework . web . bind . annotation . RequestParam ; import org . springframework . web . bind . annotation . RestController ; import javax . servlet . ServletOutputStream ; import javax . servlet . http . HttpServletResponse ; import java . util . UUID ; @ Api ( tags = {", "output": "\"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class CaptchaController extends BaseController { @ Autowired private CaptchaService captchaService ; @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ ApiImplicitParams ( { @ ApiImplicitParam ( name = \"<STR_LIT>\" , value = \"<STR_LIT>\" , dataType = \"<STR_LIT>\" , paramType = \"<STR_LIT>\" , example = \"<STR_LIT>\" , required = true ) } ) public void captcha ( HttpServletResponse response , @ RequestParam ( \"<STR_LIT>\" ) String key ) throws Exception { response . setContentType ( \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; response . setHeader ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; response . setDateHeader ( \"<STR_LIT>\" , <NUM_LIT> ) ; SpecCaptcha captcha = new SpecCaptcha ( <NUM_LIT> , <NUM_LIT> ) ; captcha . setLen ( <NUM_LIT> ) ; ServletOutputStream os = null ; try { os = response . getOutputStream ( ) ; captcha . out ( os ) ; } finally { os . close ( ) ; } captchaService . saveCaptcha ( key , captcha . text ( ) . toLowerCase ( ) ) ; } public static void main ( String [ ] args ) { System . out . println ( UUID . randomUUID ( ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import io . github . chensheng . dddboot . excel . annotation . ExcelSheet ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . concurrent . ConcurrentHashMap ; public class WorkbookConfigResolver { private static final ConcurrentHashMap < Class < ? > , SheetConfig > SHEET_CONFIG_CACHE = new ConcurrentHashMap < Class < ? > , SheetConfig > ( ) ; public static WorkbookConfig resolveWorkbook ( Class < ? > ... rowTypes ) { WorkbookConfig workbookConfig = new WorkbookConfig ( ) ; if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { return workbookConfig ; } for ( int i = <NUM_LIT> ; i < rowTypes . length ; i ++ ) { Class < ? > rowType = rowTypes [ i ] ; SheetConfig sheetConfig = resolveSheet ( rowType ) ; if ( sheetConfig . getSheetIndex ( ) < <NUM_LIT> ) { sheetConfig . setSheetIndex ( i ) ; } workbookConfig . add ( sheetConfig ) ; } return workbookConfig ; } public static SheetConfig resolveSheet ( Class < ? > rowType ) { if ( rowType == null ) { return null ; } if ( SHEET_CONFIG_CACHE . contains ( rowType ) ) { return SHEET_CONFIG_CACHE . get ( rowType ) ; } SheetConfig sheetConfig = new SheetConfig ( ) ; sheetConfig . setRowType ( rowType ) ; ExcelSheet excelSheet = rowType . getDeclaredAnnotation ( ExcelSheet . class ) ; if ( excelSheet != null ) { sheetConfig . setSheetIndex ( excelSheet . index ( ) ) ; sheetConfig . setSheetName ( excelSheet . name ( ) ) ; sheetConfig . setDataRowStartIndex ( excelSheet . dataRowStartIndex ( ) ) ; sheetConfig . setWriteHeader ( excelSheet . writeHeader ( ) ) ; } Field [ ] fields = rowType . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; } ExcelCell excelCell = field . getDeclaredAnnotation ( ExcelCell . class ) ; if ( excelCell == null ) { continue ; } String headerName = excelCell . name ( ) ; if ( TextUtil . isEmpty ( headerName ) ) { headerName = field . getName ( ) ; } HeaderCellConfig headerCellConfig = new HeaderCellConfig ( ) ; headerCellConfig . setIndex ( excelCell . index ( ) ) ; headerCellConfig . setName ( headerName ) ;", "output": "sheetConfig . addHeaderCellConfig ( headerCellConfig ) ; DataCellConfig dataCellConfig = new DataCellConfig ( ) ; dataCellConfig . setIndex ( excelCell . index ( ) ) ; dataCellConfig . setField ( field ) ; dataCellConfig . setFormat ( excelCell . format ( ) ) ; dataCellConfig . setType ( excelCell . type ( ) ) ; sheetConfig . addDataCellConfig ( dataCellConfig ) ; } SHEET_CONFIG_CACHE . putIfAbsent ( rowType , sheetConfig ) ; return sheetConfig ; } }"}, {"input": "package com . yf . system . modules . user . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysUserBind extends Model < SysUserBind > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String userId ; @ TableField ( \"<STR_LIT>\" ) private String loginType ; @ TableField ( \"<STR_LIT>\" ) private String openId ; @ TableField ( \"<STR_LIT>\" ) private Date createTime ; @ TableField ( \"<STR_LIT>\" ) private Date updateTime ;", "output": "}"}, {"input": "package top . kangert . kspider . expression . interpreter ; public abstract class AbstractReflection { private static AbstractReflection instance = new JavaReflection ( ) ; public synchronized static void setInstance ( AbstractReflection abstractReflection ) { instance = abstractReflection ; } public synchronized static AbstractReflection getInstance ( ) {", "output": "return instance ; } public abstract Object getField ( Object obj , String name ) ; public abstract Object getMethod ( Object obj , String name , Object ... arguments ) ; public abstract Object getExtensionMethod ( Object obj , String name , Object ... arguments ) ; public abstract void registerExtensionClass ( Class < ? > target , Class < ? > clazz ) ; public abstract Object getFieldValue ( Object obj , Object field ) ; public abstract Object callMethod ( Object obj , Object method , Object ... arguments ) ; }"}, {"input": "package com . yf . base . utils ; import java . io . File ; import java . io . FileInputStream ; import java . math . BigInteger ; import java . nio . charset . StandardCharsets ; import java . security . MessageDigest ; public class Md5Util { public static String md5 ( String str ) { try { MessageDigest md = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; byte [ ] array = md . digest ( str . getBytes ( StandardCharsets . UTF_8 ) ) ; StringBuilder sb = new StringBuilder ( ) ; for ( byte item : array ) { sb . append ( Integer . toHexString ( ( item & <NUM_LIT> ) | <NUM_LIT> ) , <NUM_LIT> , <NUM_LIT> ) ; } return sb . toString ( ) ; } catch ( Exception e ) { return null ;", "output": "} } public static String getFileMd5 ( File file ) { if ( ! file . isFile ( ) ) { return null ; } MessageDigest digest = null ; FileInputStream in = null ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len ; try { digest = MessageDigest . getInstance ( \"<STR_LIT>\" ) ; in = new FileInputStream ( file ) ; while ( ( len = in . read ( buffer , <NUM_LIT> , <NUM_LIT> ) ) != - <NUM_LIT> ) { digest . update ( buffer , <NUM_LIT> , len ) ; } in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } BigInteger bigInt = new BigInteger ( <NUM_LIT> , digest . digest ( ) ) ; return bigInt . toString ( <NUM_LIT> ) ; } }"}, {"input": "package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DictService extends IService < Dict > { PageResult < Dict > queryAll ( DictQueryCriteria criteria , Page < Object > page ) ;", "output": "List < Dict > queryAll ( DictQueryCriteria criteria ) ; void create ( Dict resources ) ; void update ( Dict resources ) ; void delete ( Set < Long > ids ) ; void download ( List < Dict > queryAll , HttpServletResponse response ) throws IOException ; }"}, {"input": "package com . youlai . system . common . constant ; public interface SystemConstants {", "output": "Long ROOT_NODE_ID = <NUM_LIT> ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ; String ROOT_ROLE_CODE = \"<STR_LIT>\" ; }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class CertificateUser implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer examId ; private String code ; private Integer certificateId ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getExamId ( ) { return examId ; } public void setExamId ( Integer examId ) { this . examId = examId ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ;", "output": "} public Integer getCertificateId ( ) { return certificateId ; } public void setCertificateId ( Integer certificateId ) { this . certificateId = certificateId ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + code + \"<STR_LIT>\" + certificateId + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . util . Map ; @ Data public class CreditParam { private String cmd ; private Map < String , Object > body ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigPublishedEvent extends NacosConfigEvent { private final String content ; private final boolean published ; public NacosConfigPublishedEvent ( ConfigService configService , String dataId , String groupId , String content , boolean published ) { super ( configService , dataId , groupId ) ; this . content = content ; this . published = published ; }", "output": "public String getContent ( ) { return content ; } public boolean isPublished ( ) { return published ; } }"}, {"input": "package io . github . chensheng . dddboot . web . core ; import org . springframework . core . convert . converter . Converter ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . regex . Pattern ; public class SmartStringToDateConverter implements Converter < String , Date > { private static final String REG_DATETIME_FORMAT = \"<STR_LIT>\" ; private static final String REG_DATE_FORMAT = \"<STR_LIT>\" ; private ThreadLocal < SimpleDateFormat > threadLocalDatetimeFormat = new ThreadLocal < SimpleDateFormat > ( ) { protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; private ThreadLocal < SimpleDateFormat > threadLocalDateFormat = new ThreadLocal < SimpleDateFormat > ( ) {", "output": "protected SimpleDateFormat initialValue ( ) { return new SimpleDateFormat ( \"<STR_LIT>\" ) ; } } ; @ Override public Date convert ( String source ) { if ( source == null ) { return null ; } try { if ( Pattern . compile ( REG_DATE_FORMAT ) . matcher ( source ) . matches ( ) ) { return threadLocalDateFormat . get ( ) . parse ( source ) ; } else { return threadLocalDatetimeFormat . get ( ) . parse ( source ) ; } } catch ( ParseException e ) { return null ; } } }"}, {"input": "package io . github . chensheng . dddboot . excel . annotation ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface ExcelCell { int index ( ) ; String name ( ) default \"<STR_LIT>\" ; String format ( ) default \"<STR_LIT>\" ;", "output": "CellValueType type ( ) default CellValueType . AUTO ; }"}, {"input": "package cn . org . alan . exam . model . vo . repo ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class RepoVO { private Integer id ; private Integer userId ; private String title ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private String realName ;", "output": "}"}, {"input": "package com . youlai . system . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . common . util . DateUtils ; import com . youlai . system . model . bo . VisitCount ; import com . youlai . system . model . entity . SysLog ; import com . youlai . system . model . query . LogPageQuery ; import com . youlai . system . model . vo . LogPageVO ; import com . youlai . system . model . vo . VisitStatsVO ; import com . youlai . system . model . vo . VisitTrendVO ; import com . youlai . system . service . SysLogService ; import com . youlai . system . mapper . SysLogMapper ; import org . springframework . stereotype . Service ; import java . math . BigDecimal ; import java . time . LocalDate ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Service public class SysLogServiceImpl extends ServiceImpl < SysLogMapper , SysLog > implements SysLogService { @ Override public Page < LogPageVO > listPagedLogs ( LogPageQuery queryParams ) { DateUtils . toDatabaseFormat ( queryParams , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return this . baseMapper . listPagedLogs ( new Page ( queryParams . getPageNum ( ) , queryParams . getPageSize ( ) ) , queryParams ) ; } @ Override public VisitTrendVO getVisitTrend ( LocalDate startDate , LocalDate endDate ) { VisitTrendVO visitTrend = new VisitTrendVO ( ) ; List < String > dates = new ArrayList < > ( ) ; while ( ! startDate . isAfter ( endDate ) ) { dates . add ( startDate . toString ( ) ) ; startDate = startDate . plusDays ( <NUM_LIT> ) ; } visitTrend . setDates ( dates ) ; List < VisitCount > pvCounts = this . baseMapper . getPvCounts ( dates . get ( <NUM_LIT> ) + \"<STR_LIT>\" , dates . get ( dates . size ( ) - <NUM_LIT> ) + \"<STR_LIT>\" ) ; List < VisitCount > ipCounts = this . baseMapper . getIpCounts ( dates . get ( <NUM_LIT> ) + \"<STR_LIT>\" , dates . get ( dates . size ( ) - <NUM_LIT> ) + \"<STR_LIT>\" ) ; Map < String , Integer > pvMap = pvCounts . stream ( ) . collect ( Collectors . toMap ( VisitCount :: getDate , VisitCount :: getCount ) ) ; Map < String , Integer > ipMap = ipCounts . stream ( ) . collect ( Collectors . toMap ( VisitCount :: getDate , VisitCount :: getCount ) ) ; List < Integer > pvList = new ArrayList < > ( ) ; List < Integer > ipList = new ArrayList < > ( ) ; for ( String date : dates ) { pvList . add ( pvMap . getOrDefault ( date , <NUM_LIT> ) ) ; ipList . add ( ipMap . getOrDefault ( date , <NUM_LIT> ) ) ; } visitTrend . setPvList ( pvList ) ; visitTrend . setIpList ( ipList ) ; return visitTrend ; } @ Override public List < VisitStatsVO > getVisitStats ( ) { List < VisitStatsVO > list = new ArrayList < > ( ) ; VisitStatsVO pvStats = this . baseMapper . getPvStats ( ) ; pvStats . setTitle ( \"<STR_LIT>\" ) ; pvStats . setType ( \"<STR_LIT>\" ) ; pvStats . setGranularityLabel ( \"<STR_LIT>\" ) ; list . add ( pvStats ) ; VisitStatsVO uvStats = new VisitStatsVO ( ) ; uvStats . setTitle ( \"<STR_LIT>\" ) ; uvStats . setType ( \"<STR_LIT>\" ) ; uvStats . setTodayCount ( <NUM_LIT> ) ;", "output": "uvStats . setTotalCount ( <NUM_LIT> ) ; uvStats . setGrowthRate ( BigDecimal . ZERO ) ; uvStats . setGranularityLabel ( \"<STR_LIT>\" ) ; list . add ( uvStats ) ; VisitStatsVO ipStats = this . baseMapper . getIpStats ( ) ; ipStats . setTitle ( \"<STR_LIT>\" ) ; ipStats . setType ( \"<STR_LIT>\" ) ; ipStats . setGranularityLabel ( \"<STR_LIT>\" ) ; list . add ( ipStats ) ; return list ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . writer . xlsx ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . writer . BaseExcelWriter ; import io . github . chensheng . dddboot . excel . writer . RowWritingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . excel . core . * ; import org . apache . poi . ss . usermodel . * ; import org . apache . poi . xssf . streaming . SXSSFWorkbook ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class XlsxWriter extends BaseExcelWriter { private static final Logger logger = LoggerFactory . getLogger ( XlsxWriter . class ) ; private Map < CellStyleConfig , CellStyle > cellStyleMap = new HashMap < CellStyleConfig , CellStyle > ( ) ; @ Override protected void doWrite ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , WorkbookConfig workbookConfig ) throws Exception { Workbook workbook = null ; try { workbook = WorkbookUtil . createWorkBook ( templateIs , ExcelType . XLSX ) ; for ( SheetConfig sheetConfig : workbookConfig . getSheets ( ) ) { Sheet sheet = WorkbookUtil . createOrGetSheet ( workbook , sheetConfig ) ; createSheetHeader ( workbook , sheet , sheetConfig ) ; writeSheetData ( workbook , sheet , sheetConfig , rowWritingListener ) ; } workbook . write ( outputStream ) ; } finally { cellStyleMap . clear ( ) ; destroy ( workbook ) ; } } private void destroy ( Workbook workbook ) { if ( workbook == null ) { return ; } if ( workbook instanceof SXSSFWorkbook ) { SXSSFWorkbook sxssfWorkbook = ( SXSSFWorkbook ) workbook ; sxssfWorkbook . dispose ( ) ; return ; } try { workbook . close ( ) ; } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } private void createSheetHeader ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig ) { if ( ! sheetConfig . isWriteHeader ( ) ) { return ; } List < HeaderCellConfig > headerRowConfig = sheetConfig . getHeaderRowConfig ( ) ; if ( CollectionUtil . isEmpty ( headerRowConfig ) ) { return ; } int headerRowIndex = sheetConfig . getDataRowStartIndex ( ) - <NUM_LIT> ; if ( headerRowIndex < <NUM_LIT> ) { return ; } Row row = WorkbookUtil . createOrGetRow ( sheet , headerRowIndex ) ; for ( HeaderCellConfig cellConfig : headerRowConfig ) { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ; cell . setCellValue ( cellConfig . getName ( ) ) ; if ( cellConfig . getStyle ( ) != null ) { CellStyle cellStyle = createOrGetCellStyle ( workbook , cellConfig . getStyle ( ) ) ; cell . setCellStyle ( cellStyle ) ; } } } private void writeSheetData ( Workbook workbook , Sheet sheet , SheetConfig sheetConfig , RowWritingListener rowWritingListener ) { List < ? > sheetData = rowWritingListener . getSheetData ( sheetConfig ) ; if ( CollectionUtil . isEmpty ( sheetData ) ) { return ; } int dataRowStartIndex = sheetConfig . getDataRowStartIndex ( ) ; for ( int i = <NUM_LIT> ; i < sheetData . size ( ) ; i ++ ) { Object rowData = sheetData . get ( i ) ; Row row = WorkbookUtil . createOrGetRow ( sheet , dataRowStartIndex + i ) ; for ( DataCellConfig cellConfig : sheetConfig . getDataRowConfig ( ) ) { try { Cell cell = WorkbookUtil . createOrGetCell ( row , cellConfig . getIndex ( ) ) ; CellContentConverterFactory . setCellContent ( workbook , cell , rowData , cellConfig . getField ( ) , cellConfig . getType ( ) , cellConfig . getFormat ( ) ) ; if ( cellConfig . getStyle ( ) != null ) { CellStyle cellStyle = createOrGetCellStyle ( workbook , cellConfig . getStyle ( ) ) ; cell . setCellStyle ( cellStyle ) ; } } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } } } private CellStyle createOrGetCellStyle ( Workbook workbook , CellStyleConfig config ) { if ( cellStyleMap . containsKey ( config ) ) { return cellStyleMap . get ( config ) ; }", "output": "CellStyle cellStyle = WorkbookUtil . createCellStyle ( workbook , config ) ; cellStyleMap . put ( config , cellStyle ) ; return cellStyle ; } }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import cn . hutool . http . useragent . UserAgent ; import cn . hutool . http . useragent . UserAgentUtil ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysLoginLogEntity ; import com . oddfar . campus . common . domain . event . LogininforEvent ; import com . oddfar . campus . common . utils . LogUtils ; import com . oddfar . campus . common . utils . SpringUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . ip . AddressUtils ; import com . oddfar . campus . common . utils . ip . IpUtils ; import com . oddfar . campus . framework . mapper . SysLoginLogMapper ; import com . oddfar . campus . framework . service . SysLoginLogService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . event . EventListener ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . Arrays ; import java . util . Date ; import java . util . List ; @ Service @ Slf4j public class SysLoginLogServiceImpl implements SysLoginLogService { @ Resource private SysLoginLogMapper loginLogMapper ; @ Async @ EventListener public void recordLogininfor ( LogininforEvent logininforEvent ) { HttpServletRequest request = logininforEvent . getRequest ( ) ; final UserAgent userAgent = UserAgentUtil . parse ( request . getHeader ( \"<STR_LIT>\" ) ) ; final String ip = IpUtils . getIpAddr ( request ) ; String address = AddressUtils . getRealAddressByIP ( ip ) ; StringBuilder s = new StringBuilder ( ) ; s . append ( LogUtils . getBlock ( ip ) ) ; s . append ( address ) ; s . append ( LogUtils . getBlock ( logininforEvent . getUsername ( ) ) ) ; s . append ( LogUtils . getBlock ( logininforEvent . getUserId ( ) ) ) ; s . append ( LogUtils . getBlock ( logininforEvent . getStatus ( ) ) ) ;", "output": "s . append ( LogUtils . getBlock ( logininforEvent . getMessage ( ) ) ) ; log . info ( s . toString ( ) , logininforEvent . getArgs ( ) ) ; String os = userAgent . getOs ( ) . getName ( ) ; String browser = userAgent . getBrowser ( ) . getName ( ) ; SysLoginLogEntity logininfor = new SysLoginLogEntity ( ) ; logininfor . setLoginTime ( new Date ( ) ) ; logininfor . setUserName ( logininforEvent . getUsername ( ) ) ; logininfor . setUserId ( logininforEvent . getUserId ( ) ) ; logininfor . setIpaddr ( ip ) ; logininfor . setLoginLocation ( address ) ; logininfor . setBrowser ( browser ) ; logininfor . setOs ( os ) ; logininfor . setMsg ( logininforEvent . getMessage ( ) ) ; if ( StringUtils . equalsAny ( logininforEvent . getStatus ( ) , Constants . LOGIN_SUCCESS , Constants . LOGOUT , Constants . REGISTER ) ) { logininfor . setStatus ( Constants . SUCCESS ) ; } else if ( Constants . LOGIN_FAIL . equals ( logininforEvent . getStatus ( ) ) ) { logininfor . setStatus ( Constants . FAIL ) ; } SpringUtils . getBean ( SysLoginLogService . class ) . insertLogininfor ( logininfor ) ; } @ Override public PageResult < SysLoginLogEntity > selectLogininforPage ( SysLoginLogEntity logininfor ) { return loginLogMapper . selectLogininforPage ( logininfor ) ; } @ Override public void insertLogininfor ( SysLoginLogEntity logininfor ) { loginLogMapper . insert ( logininfor ) ; } @ Override public List < SysLoginLogEntity > selectLogininforList ( SysLoginLogEntity logininfor ) { return loginLogMapper . selectLogininforList ( logininfor ) ; } @ Override public int deleteLogininforByIds ( Long [ ] infoIds ) { return loginLogMapper . deleteBatchIds ( Arrays . asList ( infoIds ) ) ; } @ Override public void cleanLogininfor ( ) { loginLogMapper . cleanLogininfor ( ) ; } }"}, {"input": "package top . kangert . kspider . executor . function ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; import top . kangert . kspider . util . FileUtils ; import org . springframework . stereotype . Component ; import org . springframework . util . CollectionUtils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . RandomUtil ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . charset . Charset ; import java . util . List ; import java . util . concurrent . TimeUnit ; @ Component @ Comment ( \"<STR_LIT>\" ) public class FileFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } private static File getFile ( String path , boolean createDirectory ) { File f = new File ( path ) ; if ( createDirectory && ! f . getParentFile ( ) . exists ( ) ) { f . getParentFile ( ) . mkdirs ( ) ; } return f ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , String content , boolean append ) throws IOException { write ( path , content , Charset . defaultCharset ( ) . name ( ) , append ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , String content , String charset , boolean append ) throws IOException { write ( path , StringFunctionExecutor . bytes ( content , charset ) , append ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , byte [ ] bytes , boolean append ) throws IOException { write ( path , new ByteArrayInputStream ( bytes ) , append ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , InputStream stream , boolean append ) throws IOException { try ( FileOutputStream fos = new FileOutputStream ( getFile ( path , true ) , append ) ) { IoUtil . copy ( stream , fos ) ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , InputStream stream ) throws IOException { write ( path , stream , false ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , String content ) throws IOException { write ( path , content , false ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , String content , String charset ) throws IOException { write ( path , content , charset , false ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void write ( String path , byte [ ] bytes ) throws IOException { write ( path , bytes , false ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , List < String > urls ) throws IOException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { FileUtils . downloadFile ( path , url , \"<STR_LIT>\" , true , false ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , List < String > urls , boolean saveOriginPath ) throws IOException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { FileUtils . downloadFile ( path , url , \"<STR_LIT>\" , true , saveOriginPath ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , List < String > urls , List < Integer > randomRange ) throws IOException , InterruptedException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { Long sleepMillis = RandomUtil . randomLong ( randomRange . get ( <NUM_LIT> ) , randomRange . get ( <NUM_LIT> ) ) ; TimeUnit . MILLISECONDS . sleep ( sleepMillis ) ; FileUtils . downloadFile ( path , url , \"<STR_LIT>\" , false , false ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , List < String > urls , List < Integer > randomRange , boolean saveOriginPath ) throws IOException , InterruptedException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { Long sleepMillis = RandomUtil . randomLong ( randomRange . get ( <NUM_LIT> ) , randomRange . get ( <NUM_LIT> ) ) ; TimeUnit . MILLISECONDS . sleep ( sleepMillis ) ; FileUtils . downloadFile ( path , url , \"<STR_LIT>\" , false , saveOriginPath ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String proxy , List < String > urls ) throws IOException { if ( ! CollectionUtils . isEmpty ( urls ) ) {", "output": "for ( String url : urls ) { FileUtils . downloadFile ( path , url , proxy , true , false ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String proxy , List < String > urls , boolean saveOriginPath ) throws IOException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { FileUtils . downloadFile ( path , url , proxy , true , saveOriginPath ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String proxy , List < String > urls , List < Integer > randomRange ) throws IOException , InterruptedException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { Long sleepMillis = RandomUtil . randomLong ( randomRange . get ( <NUM_LIT> ) , randomRange . get ( <NUM_LIT> ) ) ; TimeUnit . MILLISECONDS . sleep ( sleepMillis ) ; FileUtils . downloadFile ( path , url , proxy , false , false ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String proxy , List < String > urls , List < Integer > randomRange , boolean saveOriginPath ) throws IOException , InterruptedException { if ( ! CollectionUtils . isEmpty ( urls ) ) { for ( String url : urls ) { Long sleepMillis = RandomUtil . randomLong ( randomRange . get ( <NUM_LIT> ) , randomRange . get ( <NUM_LIT> ) ) ; TimeUnit . MILLISECONDS . sleep ( sleepMillis ) ; FileUtils . downloadFile ( path , url , proxy , false , saveOriginPath ) ; } } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String url ) throws IOException { if ( url != null ) { FileUtils . downloadFile ( path , url , \"<STR_LIT>\" , true , false ) ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String url , boolean saveOriginPath ) throws IOException { if ( url != null ) { FileUtils . downloadFile ( path , url , \"<STR_LIT>\" , true , saveOriginPath ) ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String proxy , String url ) throws IOException { if ( url != null ) { FileUtils . downloadFile ( path , url , proxy , true , false ) ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static void download ( String path , String proxy , String url , boolean saveOriginPath ) throws IOException { if ( url != null ) { FileUtils . downloadFile ( path , url , proxy , true , saveOriginPath ) ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] bytes ( String path ) throws IOException { try ( FileInputStream fis = new FileInputStream ( getFile ( path , false ) ) ) { return IoUtil . readBytes ( fis ) ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String string ( String path , String charset ) throws IOException { return StringFunctionExecutor . newString ( bytes ( path ) , charset ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String string ( String path ) throws IOException { return StringFunctionExecutor . newString ( bytes ( path ) , Charset . defaultCharset ( ) . name ( ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . util . editor ; import java . beans . PropertyEditorSupport ; public class NacosCharSequenceEditor extends PropertyEditorSupport { @ Override public void setValue ( Object value ) { if ( value == null ) { super . setValue ( \"<STR_LIT>\" ) ; } if ( value instanceof CharSequence ) { CharSequence sequence = ( CharSequence ) value ; super . setValue ( sequence . toString ( ) ) ; } else { super . setValue ( value ) ; } }", "output": "@ Override public String getAsText ( ) { Object value = getValue ( ) ; return String . valueOf ( value ) ; } }"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Pattern ; @ Component @ Comment ( \"<STR_LIT>\" ) public class ListFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static int length ( List < ? > list ) { return list != null ? list . size ( ) : <NUM_LIT> ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < List < ? > > split ( List < ? > list , int len ) { List < List < ? > > result = new ArrayList < > ( ) ; if ( list == null || list . size ( ) == <NUM_LIT> || len < <NUM_LIT> ) { return result ; } int size = list . size ( ) ; int count = ( size + len - <NUM_LIT> ) / len ; for ( int i = <NUM_LIT> ; i < count ; i ++ ) { List < ? > subList = list . subList ( i * len , ( ( i + <NUM_LIT> ) * len > size ? size : len * ( i + <NUM_LIT> ) ) ) ; result . add ( subList ) ; }", "output": "return result ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < ? > sublist ( List < ? > list , int fromIndex , int toIndex ) { return list != null ? list . subList ( fromIndex , toIndex ) : new ArrayList < > ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > filterStr ( List < String > list , String pattern ) { if ( list == null || list . isEmpty ( ) ) { return null ; } List < String > result = new ArrayList < > ( list . size ( ) ) ; for ( String item : list ) { if ( Pattern . matches ( pattern , item ) ) { result . add ( item ) ; } } return result ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class AllContactVO { private String userName ; private String nickName ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; @ TableName ( \"<STR_LIT>\" ) public class ExamQuestion { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer examId ; private Integer questionId ; private Integer score ; private Integer sort ; private Integer type ; @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + questionId + \"<STR_LIT>\" + score + \"<STR_LIT>\" + sort + \"<STR_LIT>\" + type + '<STR_LIT>' ; } public void setId ( Integer id ) { this . id = id ; } public void setExamId ( Integer examId ) { this . examId = examId ; } public void setQuestionId ( Integer questionId ) { this . questionId = questionId ; } public void setScore ( Integer score ) { this . score = score ; } public void setSort ( Integer sort ) { this . sort = sort ; } public void setType ( Integer type ) { this . type = type ; } public Integer getId ( ) { return id ; } public Integer getExamId ( ) { return examId ; } public Integer getQuestionId ( ) { return questionId ; } public Integer getScore ( ) { return score ;", "output": "} public Integer getSort ( ) { return sort ; } public Integer getType ( ) { return type ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . CertificateUser ; import com . baomidou . mybatisplus . extension . service . IService ; public interface ICertificateUserService extends IService < CertificateUser > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader ; import java . io . InputStream ; public interface ExcelReader {", "output": "void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception ; }"}, {"input": "package com . youlai . system . controller ; import com . youlai . system . enums . LogModuleEnum ; import com . youlai . system . plugin . norepeat . annotation . PreventRepeatSubmit ; import com . youlai . system . common . model . Option ; import com . youlai . system . common . result . Result ; import com . youlai . system . model . form . DeptForm ; import com . youlai . system . model . query . DeptQuery ; import com . youlai . system . model . vo . DeptVO ; import com . youlai . system . plugin . syslog . annotation . LogAnnotation ; import com . youlai . system . service . SysDeptService ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import io . swagger . v3 . oas . annotations . Operation ; import lombok . RequiredArgsConstructor ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import jakarta . validation . Valid ; import java . util . List ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class SysDeptController { private final SysDeptService deptService ; @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping @ LogAnnotation ( value = \"<STR_LIT>\" , module = LogModuleEnum . DEPT ) public Result < List < DeptVO > > getDeptList ( DeptQuery queryParams ) { List < DeptVO > list = deptService . getDeptList ( queryParams ) ; return Result . success ( list ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < Option > > getDeptOptions ( ) { List < Option > list = deptService . listDeptOptions ( ) ; return Result . success ( list ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) @ PreventRepeatSubmit public Result saveDept ( @ Valid @ RequestBody DeptForm formData ) { Long id = deptService . saveDept ( formData ) ; return Result . success ( id ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < DeptForm > getDeptForm ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable Long deptId ) { DeptForm deptForm = deptService . getDeptForm ( deptId ) ; return Result . success ( deptForm ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result updateDept ( @ PathVariable Long deptId , @ Valid @ RequestBody DeptForm formData ) { deptId = deptService . updateDept ( deptId , formData ) ; return Result . success ( deptId ) ;", "output": "} @ Operation ( summary = \"<STR_LIT>\" ) @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result deleteDepartments ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable ( \"<STR_LIT>\" ) String ids ) { boolean result = deptService . deleteByIds ( ids ) ; return Result . judge ( result ) ; } }"}, {"input": "package org . springblade . config . autopoi . config ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . autopoi . util . ApplicationContextUtil ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Slf4j public class AutoPoiConfig { @ Bean public ApplicationContextUtil applicationContextUtil ( ) {", "output": "log . info ( \"<STR_LIT>\" ) ; return new ApplicationContextUtil ( ) ; } }"}, {"input": "package com . oddfar . campus . framework . expander ; import com . oddfar . campus . framework . service . SysConfigService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import javax . annotation . PostConstruct ; @ Component public class SysConfigExpander { private static SysConfigService configService ; @ Autowired private SysConfigService sysConfigService ; @ PostConstruct public void init ( ) { configService = sysConfigService ; } public static String getUserDefaultAvatar ( ) { return configService . selectConfigByKey ( \"<STR_LIT>\" ) ; } public static String getLoginCaptchaType ( ) { return configService . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } public static String getFileProfile ( ) { String osName = System . getProperty ( \"<STR_LIT>\" ) . toLowerCase ( ) ; if ( osName . contains ( \"<STR_LIT>\" ) ) { return configService . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } if ( osName . contains ( \"<STR_LIT>\" ) ) { return configService . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } if ( osName . contains ( \"<STR_LIT>\" ) ) {", "output": "return configService . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } return null ; } }"}, {"input": "package ginyi . framework . security . properties ; import ginyi . common . annotation . Anonymous ; import org . apache . commons . lang3 . RegExUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . web . method . HandlerMethod ; import org . springframework . web . servlet . mvc . method . RequestMappingInfo ; import org . springframework . web . servlet . mvc . method . annotation . RequestMappingHandlerMapping ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Optional ; import java . util . regex . Pattern ; @ Configuration public class PermitAllUrlProperties implements InitializingBean , ApplicationContextAware { private static final Pattern PATTERN = Pattern . compile ( \"<STR_LIT>\" ) ; private ApplicationContext applicationContext ; private List < String > urls = new ArrayList < > ( ) ; public String ASTERISK = \"<STR_LIT>\" ; @ Override public void afterPropertiesSet ( ) { RequestMappingHandlerMapping mapping = applicationContext . getBean ( RequestMappingHandlerMapping . class ) ; Map < RequestMappingInfo , HandlerMethod > map = mapping . getHandlerMethods ( ) ; map . keySet ( ) . forEach ( info -> { HandlerMethod handlerMethod = map . get ( info ) ; Anonymous method = AnnotationUtils . findAnnotation ( handlerMethod . getMethod ( ) , Anonymous . class ) ; Optional . ofNullable ( method ) . ifPresent ( anonymous -> info . getPatternsCondition ( ) . getPatterns ( ) . forEach ( url -> urls . add ( RegExUtils . replaceAll ( url , PATTERN , ASTERISK ) ) ) ) ; Anonymous controller = AnnotationUtils . findAnnotation ( handlerMethod . getBeanType ( ) , Anonymous . class ) ; Optional . ofNullable ( controller ) . ifPresent ( anonymous -> info . getPatternsCondition ( ) . getPatterns ( ) . forEach ( url -> urls . add ( RegExUtils . replaceAll ( url , PATTERN , ASTERISK ) ) ) ) ;", "output": "} ) ; } @ Override public void setApplicationContext ( ApplicationContext context ) throws BeansException { this . applicationContext = context ; } public List < String > getUrls ( ) { return urls ; } public void setUrls ( List < String > urls ) { this . urls = urls ; } }"}, {"input": "package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . lang . Dict ; import cn . hutool . core . util . RandomUtil ; import cn . hutool . extra . template . Template ; import cn . hutool . extra . template . TemplateConfig ; import cn . hutool . extra . template . TemplateEngine ; import cn . hutool . extra . template . TemplateUtil ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . service . VerifyService ; import me . zhengjie . utils . RedisUtils ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . Collections ; @ Service @ RequiredArgsConstructor public class VerifyServiceImpl implements VerifyService { @ Value ( \"<STR_LIT>\" ) private Long expiration ; private final RedisUtils redisUtils ; @ Override @ Transactional ( rollbackFor = Exception . class ) public EmailVo sendEmail ( String email , String key ) { EmailVo emailVo ; String content ; String redisKey = key + email ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( \"<STR_LIT>\" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; Template template = engine . getTemplate ( \"<STR_LIT>\" ) ; Object oldCode = redisUtils . get ( redisKey ) ; if ( oldCode == null ) { String code = RandomUtil . randomNumbers ( <NUM_LIT> ) ; if ( ! redisUtils . set ( redisKey , code , expiration ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } content = template . render ( Dict . create ( ) . set ( \"<STR_LIT>\" , code ) ) ; emailVo = new EmailVo ( Collections . singletonList ( email ) , \"<STR_LIT>\" , content ) ; } else { content = template . render ( Dict . create ( ) . set ( \"<STR_LIT>\" , oldCode ) ) ; emailVo = new EmailVo ( Collections . singletonList ( email ) , \"<STR_LIT>\" , content ) ; } return emailVo ; } @ Override public void validated ( String key , String code ) { Object value = redisUtils . get ( key ) ; if ( value == null || ! value . toString ( ) . equals ( code ) ) {", "output": "throw new BadRequestException ( \"<STR_LIT>\" ) ; } else { redisUtils . del ( key ) ; } } }"}, {"input": "package ginyi . common . utils . http ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . servlet . ServletRequest ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . nio . charset . StandardCharsets ; public class HttpHelper { private static final Logger LOGGER = LoggerFactory . getLogger ( HttpHelper . class ) ; public static String getBodyString ( ServletRequest request ) { StringBuilder sb = new StringBuilder ( ) ; BufferedReader reader = null ; try ( InputStream inputStream = request . getInputStream ( ) ) { reader = new BufferedReader ( new InputStreamReader ( inputStream , StandardCharsets . UTF_8 ) ) ; String line = \"<STR_LIT>\" ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) ; } } catch ( IOException e ) { LOGGER . warn ( \"<STR_LIT>\" ) ;", "output": "} finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { LOGGER . error ( ExceptionUtils . getMessage ( e ) ) ; } } } return sb . toString ( ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . score ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class UserScoreVO { private Integer id ; private Integer userId ; private String title ; private String realName ; private Integer userTime ; private Integer userScore ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime limitTime ; private Integer count ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class FeedsMediaVO { private String url ; private String thumb ;", "output": "}"}, {"input": "package org . springblade . web . utils . googleauth ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . lang . reflect . UndeclaredThrowableException ; import java . math . BigInteger ; import java . security . GeneralSecurityException ; public class TOTP { private static final int [ ] DIGITS_POWER = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; private static byte [ ] hmac_sha ( String crypto , byte [ ] keyBytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . getInstance ( crypto ) ; SecretKeySpec macKey = new SecretKeySpec ( keyBytes , \"<STR_LIT>\" ) ; hmac . init ( macKey ) ; return hmac . doFinal ( text ) ; } catch ( GeneralSecurityException gse ) { throw new UndeclaredThrowableException ( gse ) ; } } private static byte [ ] hexStr2Bytes ( String hex ) { byte [ ] bArray = new BigInteger ( \"<STR_LIT>\" + hex , <NUM_LIT> ) . toByteArray ( ) ; byte [ ] ret = new byte [ bArray . length - <NUM_LIT> ] ; System . arraycopy ( bArray , <NUM_LIT> , ret , <NUM_LIT> , ret . length ) ; return ret ; } public static String generateTOTP ( String key , String time , String returnDigits , String crypto ) { int codeDigits = Integer . decode ( returnDigits ) ; String result = null ; while ( time . length ( ) < <NUM_LIT> ) time = \"<STR_LIT>\" + time ; byte [ ] msg = hexStr2Bytes ( time ) ; byte [ ] k = hexStr2Bytes ( key ) ; byte [ ] hash = hmac_sha ( crypto , k , msg ) ; int offset = hash [ hash . length - <NUM_LIT> ] & <NUM_LIT> ; int binary = ( ( hash [ offset ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) << <NUM_LIT> ) | ( hash [ offset + <NUM_LIT> ] & <NUM_LIT> ) ; int otp = binary % DIGITS_POWER [ codeDigits ] ; result = Integer . toString ( otp ) ; while ( result . length ( ) < codeDigits ) {", "output": "result = \"<STR_LIT>\" + result ; } return result ; } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class ContactHeadImgUrl { @ TableId ( \"<STR_LIT>\" ) private String usrName ; @ TableField ( \"<STR_LIT>\" ) private String smallHeadImgUrl ; @ TableField ( \"<STR_LIT>\" ) private String bigHeadImgUrl ; @ TableField ( \"<STR_LIT>\" ) private String headImgMd5 ; @ TableField ( \"<STR_LIT>\" ) private Integer reverse0 ; @ TableField ( \"<STR_LIT>\" ) private String reverse1 ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . number ; import com . google . common . math . IntMath ; import com . google . common . math . LongMath ; import java . math . RoundingMode ; public class MathUtil { public static int nextPowerOfTwo ( int value ) { return IntMath . ceilingPowerOfTwo ( value ) ; } public static long nextPowerOfTwo ( long value ) { return LongMath . ceilingPowerOfTwo ( value ) ; } public static int previousPowerOfTwo ( int value ) { return IntMath . floorPowerOfTwo ( value ) ; } public static long previousPowerOfTwo ( long value ) { return LongMath . floorPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( int value ) { return IntMath . isPowerOfTwo ( value ) ; } public static boolean isPowerOfTwo ( long value ) { return LongMath . isPowerOfTwo ( value ) ; } public static int modByPowerOfTwo ( int value , int mod ) { return value & ( mod - <NUM_LIT> ) ; } public static int mod ( int x , int m ) { return IntMath . mod ( x , m ) ; } public static long mod ( long x , long m ) { return LongMath . mod ( x , m ) ; } public static int mod ( long x , int m ) { return LongMath . mod ( x , m ) ; }", "output": "public static int divide ( int p , int q , RoundingMode mode ) { return IntMath . divide ( p , q , mode ) ; } public static long divide ( long p , long q , RoundingMode mode ) { return LongMath . divide ( p , q , mode ) ; } public static int pow ( int b , int k ) { return IntMath . pow ( b , k ) ; } public static long pow ( long b , int k ) { return LongMath . pow ( b , k ) ; } public static int sqrt ( int x , RoundingMode mode ) { return IntMath . sqrt ( x , mode ) ; } public static long sqrt ( long x , RoundingMode mode ) { return LongMath . sqrt ( x , mode ) ; } }"}, {"input": "package me . zhengjie . modules . quartz . utils ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import org . quartz . * ; import org . quartz . impl . triggers . CronTriggerImpl ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import java . util . Date ; import static org . quartz . TriggerBuilder . newTrigger ; @ Slf4j @ Component public class QuartzManage { private static final String JOB_NAME = \"<STR_LIT>\" ; @ Resource private Scheduler scheduler ; public void addJob ( QuartzJob quartzJob ) { try { JobDetail jobDetail = JobBuilder . newJob ( ExecutionJob . class ) . withIdentity ( JOB_NAME + quartzJob . getId ( ) ) . build ( ) ; Trigger cronTrigger = newTrigger ( ) . withIdentity ( JOB_NAME + quartzJob . getId ( ) ) . startNow ( ) . withSchedule ( CronScheduleBuilder . cronSchedule ( quartzJob . getCronExpression ( ) ) ) . build ( ) ; cronTrigger . getJobDataMap ( ) . put ( QuartzJob . JOB_KEY , quartzJob ) ; ( ( CronTriggerImpl ) cronTrigger ) . setStartTime ( new Date ( ) ) ; scheduler . scheduleJob ( jobDetail , cronTrigger ) ; if ( quartzJob . getIsPause ( ) ) { pauseJob ( quartzJob ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } } public void updateJobCron ( QuartzJob quartzJob ) { try {", "output": "TriggerKey triggerKey = TriggerKey . triggerKey ( JOB_NAME + quartzJob . getId ( ) ) ; CronTrigger trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; if ( trigger == null ) { addJob ( quartzJob ) ; trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; } CronScheduleBuilder scheduleBuilder = CronScheduleBuilder . cronSchedule ( quartzJob . getCronExpression ( ) ) ; trigger = trigger . getTriggerBuilder ( ) . withIdentity ( triggerKey ) . withSchedule ( scheduleBuilder ) . build ( ) ; ( ( CronTriggerImpl ) trigger ) . setStartTime ( new Date ( ) ) ; trigger . getJobDataMap ( ) . put ( QuartzJob . JOB_KEY , quartzJob ) ; scheduler . rescheduleJob ( triggerKey , trigger ) ; if ( quartzJob . getIsPause ( ) ) { pauseJob ( quartzJob ) ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } } public void deleteJob ( QuartzJob quartzJob ) { try { JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . pauseJob ( jobKey ) ; scheduler . deleteJob ( jobKey ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } } public void resumeJob ( QuartzJob quartzJob ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( JOB_NAME + quartzJob . getId ( ) ) ; CronTrigger trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; if ( trigger == null ) { addJob ( quartzJob ) ; } JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . resumeJob ( jobKey ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } } public void runJobNow ( QuartzJob quartzJob ) { try { TriggerKey triggerKey = TriggerKey . triggerKey ( JOB_NAME + quartzJob . getId ( ) ) ; CronTrigger trigger = ( CronTrigger ) scheduler . getTrigger ( triggerKey ) ; if ( trigger == null ) { addJob ( quartzJob ) ; } JobDataMap dataMap = new JobDataMap ( ) ; dataMap . put ( QuartzJob . JOB_KEY , quartzJob ) ; JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . triggerJob ( jobKey , dataMap ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } } public void pauseJob ( QuartzJob quartzJob ) { try { JobKey jobKey = JobKey . jobKey ( JOB_NAME + quartzJob . getId ( ) ) ; scheduler . pauseJob ( jobKey ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package top . kangert . kspider . support ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class ErrorResponse { @ JsonIgnore private Integer status ; private String message ; @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime timestamp ; private ErrorResponse ( ) { timestamp = LocalDateTime . now ( ) ; } public ErrorResponse ( Integer status , String message ) { this ( ) ; this . status = status ;", "output": "this . message = message ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Comparator ; import java . util . Iterator ; public final class SortedArrayList < E > extends ArrayList < E > { private static final long serialVersionUID = - <NUM_LIT> ; protected final Comparator < ? super E > comparator ; public SortedArrayList ( Comparator < ? super E > c ) { comparator = c ; } public SortedArrayList ( ) { comparator = null ; } public SortedArrayList ( Collection < ? extends E > c ) { comparator = null ; addAll ( c ) ; } public Comparator getComparator ( ) { return comparator ; } @ Override public boolean add ( E o ) { int idx = <NUM_LIT> ; if ( ! isEmpty ( ) ) { idx = findInsertionPoint ( o ) ; } super . add ( idx , o ) ; return true ; } @ Override public boolean addAll ( Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; } public int findInsertionPoint ( E o ) { return findInsertionPoint ( o , <NUM_LIT> , size ( ) - <NUM_LIT> ) ; } @ Override @ Deprecated public void add ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public E set ( int index , E element ) { throw new UnsupportedOperationException ( ) ; } @ Override @ Deprecated public boolean addAll ( int index , Collection < ? extends E > c ) { throw new UnsupportedOperationException ( ) ; } @ SuppressWarnings ( { \"<STR_LIT>\" } ) protected int compare ( E k1 , E k2 ) { if ( comparator == null ) { return ( ( Comparable ) k1 ) . compareTo ( k2 ) ; } return comparator . compare ( k1 , k2 ) ; } protected int findInsertionPoint ( E o , int originalLow , int originalHigh ) { int low = originalLow ; int high = originalHigh ; while ( low <= high ) { int mid = low + ( ( high - low ) > > > <NUM_LIT> ) ; int delta = compare ( get ( mid ) , o ) ; if ( delta > <NUM_LIT> ) { high = mid - <NUM_LIT> ; } else { low = mid + <NUM_LIT> ; }", "output": "} return low ; } }"}, {"input": "package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class DeployQueryCriteria { private String appName ; private List < Timestamp > createTime ; private Long offset ; private Long size ;", "output": "}"}, {"input": "package com . youlai . system . model . query ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . youlai . system . common . base . BasePageQuery ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; import lombok . Setter ; import java . time . LocalDateTime ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public class RolePageQuery extends BasePageQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime startDate ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime endDate ;", "output": "}"}, {"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . LinkedHashMap ; import java . util . Map ; @ Data public class GatewayPredicate { private String name ; private Map < String , String > args = new LinkedHashMap < > ( ) ;", "output": "}"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . QiniuContent ; import me . zhengjie . domain . vo . QiniuQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface QiniuContentMapper extends BaseMapper < QiniuContent > { QiniuContent findByKey ( @ Param ( \"<STR_LIT>\" ) String name ) ; IPage < QiniuContent > findAll ( @ Param ( \"<STR_LIT>\" ) QiniuQueryCriteria criteria , Page < Object > page ) ;", "output": "List < QiniuContent > findAll ( QiniuQueryCriteria criteria ) ; }"}, {"input": "package com . youlai . system . common . base ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . fasterxml . jackson . annotation . JsonFormat ; import com . fasterxml . jackson . annotation . JsonInclude ; import lombok . Data ; import java . io . Serial ; import java . io . Serializable ; import java . time . LocalDateTime ; @ Data public class BaseEntity implements Serializable { @ Serial private static final long serialVersionUID = <NUM_LIT> ; @ TableField ( fill = FieldFill . INSERT ) @ JsonInclude ( value = JsonInclude . Include . NON_NULL ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; @ TableField ( fill = FieldFill . INSERT_UPDATE ) @ JsonInclude ( value = JsonInclude . Include . NON_NULL ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime updateTime ; @ TableLogic ( value = \"<STR_LIT>\" , delval = \"<STR_LIT>\" ) private Integer isDeleted ;", "output": "}"}, {"input": "package com . youlai . system . common . util ; import com . alibaba . excel . EasyExcel ; import com . youlai . system . plugin . easyexcel . MyAnalysisEventListener ; import java . io . InputStream ; public class ExcelUtils { public static < T > String importExcel ( InputStream is , Class clazz , MyAnalysisEventListener < T > listener ) { EasyExcel . read ( is , clazz , listener ) . sheet ( ) . doRead ( ) ; return listener . getMsg ( ) ;", "output": "} }"}, {"input": "package org . springblade . cgform . model . file ; import com . fasterxml . jackson . annotation . JsonInclude ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class FileResultListModel implements INode < FileResultListModel > { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long id ; @ JsonSerialize ( using = ToStringSerializer . class ) private Long parentId ; @ JsonInclude ( JsonInclude . Include . NON_EMPTY ) private List < FileResultListModel > children ; @ Override public List < FileResultListModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; } this . data = this . children ;", "output": "return this . children ; } private List < FileResultListModel > data ; private Long date ; private Integer downCount ; private Integer isFolder ; private boolean open ; private Integer readCount ; private Long size ; private String type ; private String value ; private String createName ; public void setChildren ( List < FileResultListModel > children ) { this . children = children ; this . data = children ; } }"}, {"input": "package com . xcs . wx . util ; import java . nio . file . FileSystems ; public class DirUtil { private static final String USER_DIR = System . getProperty ( \"<STR_LIT>\" ) ; private static final String SEPARATOR = FileSystems . getDefault ( ) . getSeparator ( ) ; private static final String DATA = \"<STR_LIT>\" ; private static final String EXPORT = \"<STR_LIT>\" ; private static final String DB = \"<STR_LIT>\" ; private static final String IMG = \"<STR_LIT>\" ; private static final String USER_CONFIG = \"<STR_LIT>\" ; private static final String SWITCH_USER_CONFIG = \"<STR_LIT>\" ; private DirUtil ( ) { } public static String getDir ( String ... dirs ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = <NUM_LIT> ; i < dirs . length ; i ++ ) { sb . append ( dirs [ i ] ) ; if ( ( i + <NUM_LIT> ) < dirs . length ) { sb . append ( SEPARATOR ) ; } } return sb . toString ( ) ; } public static String getImgDir ( String wxId ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + DB + SEPARATOR + wxId + SEPARATOR + IMG ; } public static String getImgDirWithName ( String wxId , String fileName ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + DB + SEPARATOR + wxId + SEPARATOR + IMG + SEPARATOR + fileName ; } public static String getSwitchUserDir ( ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + SWITCH_USER_CONFIG ; } public static String getUserDir ( String wxId ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + DB + SEPARATOR + wxId + SEPARATOR + USER_CONFIG ; } public static String getDbDir ( ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + DB ; } public static String getDbDir ( String wxId ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + DB + SEPARATOR + wxId + SEPARATOR ; } public static String getExportDir ( String fileName ) { return USER_DIR + SEPARATOR + DATA + SEPARATOR + EXPORT + SEPARATOR + fileName ; }", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; public class NacosConfigRemovedEvent extends NacosConfigEvent { private final boolean removed ; public NacosConfigRemovedEvent ( ConfigService configService , String dataId , String groupId , boolean removed ) {", "output": "super ( configService , dataId , groupId ) ; this . removed = removed ; } public boolean isRemoved ( ) { return removed ; } }"}, {"input": "package com . youlai . system . config ; import cn . hutool . captcha . generator . CodeGenerator ; import cn . hutool . captcha . generator . MathGenerator ; import cn . hutool . captcha . generator . RandomGenerator ; import com . youlai . system . config . property . CaptchaProperties ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . awt . * ; @ Configuration public class CaptchaConfig { @ Autowired private CaptchaProperties captchaProperties ; @ Bean public CodeGenerator codeGenerator ( ) { String codeType = captchaProperties . getCode ( ) . getType ( ) ; int codeLength = captchaProperties . getCode ( ) . getLength ( ) ; if ( \"<STR_LIT>\" . equalsIgnoreCase ( codeType ) ) { return new MathGenerator ( codeLength ) ; } else if ( \"<STR_LIT>\" . equalsIgnoreCase ( codeType ) ) { return new RandomGenerator ( codeLength ) ; } else {", "output": "throw new IllegalArgumentException ( \"<STR_LIT>\" + codeType ) ; } } @ Bean public Font captchaFont ( ) { String fontName = captchaProperties . getFont ( ) . getName ( ) ; int fontSize = captchaProperties . getFont ( ) . getSize ( ) ; int fontWight = captchaProperties . getFont ( ) . getWeight ( ) ; return new Font ( fontName , fontWight , fontSize ) ; } }"}, {"input": "package org . example . domain . example . repository ; import io . github . chensheng . dddboot . microservice . core . DDDRepository ; import org . example . domain . example . entity . ExampleEntity ; public interface ExampleRepository extends DDDRepository < ExampleEntity > { ExampleEntity getByUsername ( String username ) ;", "output": "}"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class KLine { public KLine ( ) { } public KLine ( String period ) { this . period = period ; }", "output": "private BigDecimal openPrice = BigDecimal . ZERO ; private BigDecimal highestPrice = BigDecimal . ZERO ; private BigDecimal lowestPrice = BigDecimal . ZERO ; private BigDecimal closePrice = BigDecimal . ZERO ; private long time ; private String period ; private int count ; private BigDecimal volume = BigDecimal . ZERO ; private BigDecimal turnover = BigDecimal . ZERO ; private Integer type ; }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ForceModel { private BigDecimal forcePrice ; private String memberId ;", "output": "}"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . vo . SessionVO ; import java . util . List ; public interface SessionService { List < SessionVO > querySession ( ) ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class PluginData extends Model < PluginData > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; private String code ; private String title ; @ TableField ( \"<STR_LIT>\" ) private String schemaId ; @ TableField ( \"<STR_LIT>\" ) private String groupId ; @ TableField ( \"<STR_LIT>\" ) private String configData ; @ TableField ( \"<STR_LIT>\" ) private String serviceClazz ; private String component ; @ TableField ( \"<STR_LIT>\" ) private Boolean inUse ; private String state ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import org . apache . commons . lang3 . StringEscapeUtils ; import java . io . UnsupportedEncodingException ; import java . net . URLDecoder ; import java . net . URLEncoder ; public class EscapeUtil { public static String urlEncode ( String part ) { try { return URLEncoder . encode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException ignored ) { return \"<STR_LIT>\" ; }", "output": "} public static String urlDecode ( String part ) { try { return URLDecoder . decode ( part , Charsets . UTF_8_NAME ) ; } catch ( UnsupportedEncodingException e ) { return \"<STR_LIT>\" ; } } public static String escapeXml ( String xml ) { return StringEscapeUtils . escapeXml11 ( xml ) ; } public static String unescapeXml ( String xml ) { return StringEscapeUtils . unescapeXml ( xml ) ; } public static String escapeHtml ( String html ) { return StringEscapeUtils . escapeHtml4 ( html ) ; } public static String unescapeHtml ( String html ) { return StringEscapeUtils . unescapeHtml4 ( html ) ; } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class RemoveWalletParam { private String tableName ; private String walletId ; private BigDecimal removefrozenBalance = BigDecimal . ZERO ; private BigDecimal addBalance = BigDecimal . ZERO ; private BigDecimal removeBalance = BigDecimal . ZERO ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private String contractSymbolName ; private boolean messageRefreshFlag = true ;", "output": "}"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . ExerciseRecord ; import cn . org . alan . exam . model . form . ExerciseFillAnswerFrom ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . model . vo . exercise . AnswerInfoVO ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . Mappings ; import org . springframework . stereotype . Component ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface ExerciseConverter { @ Mappings ( { @ Mapping ( source = \"<STR_LIT>\" , target = \"<STR_LIT>\" ) , @ Mapping ( source = \"<STR_LIT>\" , target = \"<STR_LIT>\" ) } ) ExerciseRecord fromToEntity ( ExerciseFillAnswerFrom exerciseFillAnswerFrom ) ; AnswerInfoVO quVOToAnswerInfoVO ( QuestionVO questionVO ) ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysOperLogEntity ; import java . util . Arrays ; import java . util . List ; public interface SysOperLogMapper extends BaseMapperX < SysOperLogEntity > { default PageResult < SysOperLogEntity > selectOperLogPage ( SysOperLogEntity operLog ) { return selectPage ( new LambdaQueryWrapperX < SysOperLogEntity > ( ) . likeIfPresent ( SysOperLogEntity :: getAppName , operLog . getAppName ( ) ) . likeIfPresent ( SysOperLogEntity :: getLogName , operLog . getLogName ( ) ) . eqIfPresent ( SysOperLogEntity :: getStatus , operLog . getStatus ( ) ) . eqIfPresent ( SysOperLogEntity :: getOperIp , operLog . getOperIp ( ) ) . eqIfPresent ( SysOperLogEntity :: getOperId , operLog . getOperId ( ) ) . betweenIfPresent ( SysOperLogEntity :: getOperTime , operLog . getParams ( ) ) . orderByDesc ( SysOperLogEntity :: getOperId ) ) ; } default int deleteOperLogByIds ( Long [ ] operIds ) { return deleteBatchIds ( Arrays . asList ( operIds ) ) ;", "output": "} public void cleanOperLog ( ) ; default List < SysOperLogEntity > selectOperLogList ( SysOperLogEntity operLog ) { return selectList ( new LambdaQueryWrapperX < SysOperLogEntity > ( ) . likeIfPresent ( SysOperLogEntity :: getAppName , operLog . getAppName ( ) ) . likeIfPresent ( SysOperLogEntity :: getLogName , operLog . getLogName ( ) ) . eqIfPresent ( SysOperLogEntity :: getOperIp , operLog . getOperIp ( ) ) . betweenIfPresent ( SysOperLogEntity :: getOperTime , operLog . getParams ( ) ) ) ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustXhXjwtParam { String type ; String exchangeCoinId ; String memberId ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ; BigDecimal amount ; boolean sjwt ;", "output": "String walletTableName ; String walletId ; String exchangeType ; }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import java . util . Properties ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; public class NacosConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor , ApplicationContextAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; private ConfigurableApplicationContext applicationContext ; @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { NacosConfigurationProperties nacosConfigurationProperties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; if ( nacosConfigurationProperties != null ) { bind ( bean , beanName , nacosConfigurationProperties ) ; } return bean ; } private void bind ( Object bean , String beanName , NacosConfigurationProperties nacosConfigurationProperties ) { NacosConfigurationPropertiesBinder binder ; try { binder = applicationContext . getBean ( NacosConfigurationPropertiesBinder . BEAN_NAME , NacosConfigurationPropertiesBinder . class ) ; if ( binder == null ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } } catch ( Exception e ) { binder = new NacosConfigurationPropertiesBinder ( applicationContext ) ; } binder . bind ( bean , beanName , nacosConfigurationProperties ) ; } @ Override public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { return bean ; }", "output": "@ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . applicationContext = ( ConfigurableApplicationContext ) applicationContext ; } }"}, {"input": "package com . oddfar . campus . framework . interceptor . impl ; import com . alibaba . fastjson2 . JSON ; import com . oddfar . campus . common . annotation . RepeatSubmit ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . filter . RepeatedlyRequestWrapper ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . http . HttpHelper ; import com . oddfar . campus . framework . interceptor . RepeatSubmitInterceptor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ Component public class SameUrlDataInterceptor extends RepeatSubmitInterceptor { public final String REPEAT_PARAMS = \"<STR_LIT>\" ; public final String REPEAT_TIME = \"<STR_LIT>\" ; @ Value ( \"<STR_LIT>\" ) private String header ; @ Autowired private RedisCache redisCache ; @ SuppressWarnings ( \"<STR_LIT>\" ) @ Override public boolean isRepeatSubmit ( HttpServletRequest request , RepeatSubmit annotation ) { String nowParams = \"<STR_LIT>\" ; if ( request instanceof RepeatedlyRequestWrapper ) { RepeatedlyRequestWrapper repeatedlyRequest = ( RepeatedlyRequestWrapper ) request ; nowParams = HttpHelper . getBodyString ( repeatedlyRequest ) ; } if ( StringUtils . isEmpty ( nowParams ) ) { nowParams = JSON . toJSONString ( request . getParameterMap ( ) ) ;", "output": "} Map < String , Object > nowDataMap = new HashMap < String , Object > ( ) ; nowDataMap . put ( REPEAT_PARAMS , nowParams ) ; nowDataMap . put ( REPEAT_TIME , System . currentTimeMillis ( ) ) ; String url = request . getRequestURI ( ) ; String submitKey = StringUtils . trimToEmpty ( request . getHeader ( header ) ) ; String cacheRepeatKey = CacheConstants . REPEAT_SUBMIT_KEY + url + submitKey ; Object sessionObj = redisCache . getCacheObject ( cacheRepeatKey ) ; if ( sessionObj != null ) { Map < String , Object > sessionMap = ( Map < String , Object > ) sessionObj ; if ( sessionMap . containsKey ( url ) ) { Map < String , Object > preDataMap = ( Map < String , Object > ) sessionMap . get ( url ) ; if ( compareParams ( nowDataMap , preDataMap ) && compareTime ( nowDataMap , preDataMap , annotation . interval ( ) ) ) { return true ; } } } Map < String , Object > cacheMap = new HashMap < String , Object > ( ) ; cacheMap . put ( url , nowDataMap ) ; redisCache . setCacheObject ( cacheRepeatKey , cacheMap , annotation . interval ( ) , TimeUnit . MILLISECONDS ) ; return false ; } private boolean compareParams ( Map < String , Object > nowMap , Map < String , Object > preMap ) { String nowParams = ( String ) nowMap . get ( REPEAT_PARAMS ) ; String preParams = ( String ) preMap . get ( REPEAT_PARAMS ) ; return nowParams . equals ( preParams ) ; } private boolean compareTime ( Map < String , Object > nowMap , Map < String , Object > preMap , int interval ) { long time1 = ( Long ) nowMap . get ( REPEAT_TIME ) ; long time2 = ( Long ) preMap . get ( REPEAT_TIME ) ; if ( ( time1 - time2 ) < interval ) { return true ; } return false ; } }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . util . List ; @ Data public class ForceModelContractAll { private String memberId ; private List < String > contractLogSymbolNameList ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . api . resource . impl ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import com . oddfar . campus . common . domain . model . SysRoleAuthList ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . api . resource . ResourceCollectorApi ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; public class DefaultResourceCollector implements ResourceCollectorApi { private final Map < String , SysResourceEntity > resourceDefinitions = new ConcurrentHashMap < > ( ) ; private final Map < Long , SysRoleAuthList > roleListMap = new ConcurrentHashMap < > ( ) ; @ Override public void collectResources ( List < SysResourceEntity > apiResource ) { if ( apiResource != null && apiResource . size ( ) > <NUM_LIT> ) { for ( SysResourceEntity resourceEntity : apiResource ) { SysResourceEntity alreadyFlag = resourceDefinitions . get ( resourceEntity . getResourceCode ( ) ) ; if ( alreadyFlag != null ) { throw new RuntimeException ( \"<STR_LIT>\" + alreadyFlag + \"<STR_LIT>\" + resourceEntity ) ; } resourceDefinitions . put ( resourceEntity . getResourceCode ( ) , resourceEntity ) ; } } } @ Override public List < SysResourceEntity > getAllResources ( ) { Set < Map . Entry < String , SysResourceEntity > > entries = resourceDefinitions . entrySet ( ) ; ArrayList < SysResourceEntity > resourceDefinitions = new ArrayList < > ( ) ; for ( Map . Entry < String , SysResourceEntity > entry : entries ) { resourceDefinitions . add ( entry . getValue ( ) ) ; } return resourceDefinitions ; }", "output": "@ Override public void setRoleAuthCache ( Map < Long , List < SysRoleAuth > > rolePermsMap , Map < Long , List < SysRoleAuth > > roleResourceMap ) { roleListMap . clear ( ) ; for ( Long roleId : rolePermsMap . keySet ( ) ) { List < SysRoleAuth > list = rolePermsMap . get ( roleId ) ; Set < String > perms = new HashSet < > ( ) ; list . stream ( ) . forEach ( r -> { if ( StringUtils . isNotEmpty ( r . getPerms ( ) ) ) { perms . add ( r . getPerms ( ) ) ; } } ) ; if ( roleListMap . containsKey ( roleId ) ) { SysRoleAuthList sysRoleList = roleListMap . get ( roleId ) ; if ( sysRoleList . getPerms ( ) != null ) { sysRoleList . getPerms ( ) . addAll ( perms ) ; } else { sysRoleList . setPerms ( perms ) ; } } else { SysRoleAuthList sysRoleList = new SysRoleAuthList ( roleId , perms , null ) ; roleListMap . put ( roleId , sysRoleList ) ; } } for ( Long roleId : roleResourceMap . keySet ( ) ) { List < SysRoleAuth > list = roleResourceMap . get ( roleId ) ; Set < String > resourceSet = new HashSet < > ( ) ; list . stream ( ) . forEach ( r -> { if ( StringUtils . isNotEmpty ( r . getResourceCode ( ) ) ) { resourceSet . add ( r . getResourceCode ( ) ) ; } } ) ; if ( roleListMap . containsKey ( roleId ) ) { SysRoleAuthList sysRoleList = roleListMap . get ( roleId ) ; if ( sysRoleList . getResourceCode ( ) != null ) { sysRoleList . getResourceCode ( ) . addAll ( resourceSet ) ; } else { sysRoleList . setResourceCode ( resourceSet ) ; } } else { SysRoleAuthList sysRoleList = new SysRoleAuthList ( roleId , null , resourceSet ) ; roleListMap . put ( roleId , sysRoleList ) ; } } } @ Override public Map < Long , SysRoleAuthList > getRoleListMap ( ) { return roleListMap ; } }"}, {"input": "package me . zhengjie . modules . quartz . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface QuartzLogMapper extends BaseMapper < QuartzLog > {", "output": "IPage < QuartzLog > findAll ( @ Param ( \"<STR_LIT>\" ) QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzLog > findAll ( @ Param ( \"<STR_LIT>\" ) QuartzJobQueryCriteria criteria ) ; }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysLogOperation ; import java . util . List ; public interface ISysOperLogService { public void insertOperlog ( SysLogOperation operLog ) ; public List < SysLogOperation > selectOperLogList ( SysLogOperation operLog ) ; public int deleteOperLogByIds ( Long [ ] operIds ) ; public SysLogOperation selectOperLogById ( Long operId ) ; public void cleanOperLog ( ) ;", "output": "}"}, {"input": "package com . yf . system . modules . dict . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDicValueDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dicCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String value ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String title ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;", "output": "}"}, {"input": "package ginyi . common . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD }", "output": ") public @ interface CreateBy { String value ( ) default \"<STR_LIT>\" ; }"}, {"input": "package io . github . chensheng . dddboot . tools . mapper ; import com . fasterxml . jackson . annotation . JsonInclude . Include ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . fasterxml . jackson . databind . DeserializationFeature ; import com . fasterxml . jackson . databind . JavaType ; import com . fasterxml . jackson . databind . ObjectMapper ; import com . fasterxml . jackson . databind . SerializationFeature ; import com . fasterxml . jackson . databind . util . JSONPObject ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . Reader ; import java . lang . reflect . Type ; import java . util . Collection ; import java . util . Map ; public class JsonMapper { private static Logger logger = LoggerFactory . getLogger ( JsonMapper . class ) ; public static final JsonMapper INSTANCE = new JsonMapper ( ) ; private ObjectMapper mapper ; public JsonMapper ( ) { this ( null ) ; } public JsonMapper ( Include include ) { mapper = new ObjectMapper ( ) ; if ( include != null ) { mapper . setSerializationInclusion ( include ) ; } mapper . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ; } public static JsonMapper nonNullMapper ( ) { return new JsonMapper ( Include . NON_NULL ) ; } public static JsonMapper nonEmptyMapper ( ) { return new JsonMapper ( Include . NON_EMPTY ) ; } public static JsonMapper defaultMapper ( ) { return new JsonMapper ( ) ; } public String toJson ( Object object ) { try { return mapper . writeValueAsString ( object ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + object , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , Class < T > clazz ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return mapper . readValue ( jsonString , clazz ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString , e ) ; return null ; } } public < T > T fromJson ( @ Nullable String jsonString , JavaType javaType ) { if ( StringUtils . isEmpty ( jsonString ) ) { return null ; } try { return ( T ) mapper . readValue ( jsonString , javaType ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString , e ) ; return null ; } } public < T > T fromJson ( Reader reader , Type type ) { if ( reader == null || type == null ) {", "output": "return null ; } try { return ( T ) mapper . readValue ( reader , mapper . constructType ( type ) ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" , e ) ; return null ; } } public JavaType buildCollectionType ( Class < ? extends Collection > collectionClass , Class < ? > elementClass ) { return mapper . getTypeFactory ( ) . constructCollectionType ( collectionClass , elementClass ) ; } public JavaType buildMapType ( Class < ? extends Map > mapClass , Class < ? > keyClass , Class < ? > valueClass ) { return mapper . getTypeFactory ( ) . constructMapType ( mapClass , keyClass , valueClass ) ; } public void update ( String jsonString , Object object ) { try { mapper . readerForUpdating ( object ) . readValue ( jsonString ) ; } catch ( JsonProcessingException e ) { logger . warn ( \"<STR_LIT>\" + jsonString + \"<STR_LIT>\" + object + \"<STR_LIT>\" , e ) ; } catch ( IOException e ) { logger . warn ( \"<STR_LIT>\" + jsonString + \"<STR_LIT>\" + object + \"<STR_LIT>\" , e ) ; } } public String toJsonP ( String functionName , Object object ) { return toJson ( new JSONPObject ( functionName , object ) ) ; } public void enableEnumUseToString ( ) { mapper . enable ( SerializationFeature . WRITE_ENUMS_USING_TO_STRING ) ; mapper . enable ( DeserializationFeature . READ_ENUMS_USING_TO_STRING ) ; } public ObjectMapper getMapper ( ) { return mapper ; } }"}, {"input": "package top . kangert . kspider . service . impl ; import org . springframework . data . domain . Page ; import org . springframework . data . domain . Pageable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import cn . hutool . core . util . StrUtil ; import top . kangert . kspider . dao . DataSourceRepository ; import top . kangert . kspider . domain . DataSource ; import top . kangert . kspider . domain . dto . DataSourceDTO ; import top . kangert . kspider . domain . mapper . DataSourceMapper ; import top . kangert . kspider . service . DataSourceService ; import javax . annotation . Resource ; import java . sql . Connection ; import java . sql . DriverManager ; import java . util . List ; import java . util . Optional ; @ Service public class DataSourceServiceImpl implements DataSourceService { @ Resource private DataSourceRepository dataSourceRepository ; @ Resource private DataSourceMapper mapper ; @ Override public DataSourceDTO getById ( Long id ) { Optional < DataSource > optional = dataSourceRepository . findById ( id ) ; if ( optional . isPresent ( ) ) { return mapper . toDto ( optional . get ( ) ) ; } return null ; } @ Override public Page < DataSourceDTO > findAll ( Pageable pageable ) { return dataSourceRepository . findAll ( pageable ) . map ( e -> mapper . toDto ( e ) ) ; } @ Override public List < DataSourceDTO > findAll ( ) { return mapper . toDto ( dataSourceRepository . findAll ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public DataSourceDTO save ( DataSourceDTO dataSource ) { return mapper . toDto ( dataSourceRepository . save ( mapper . toEntity ( dataSource ) ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void removeById ( Long id ) { dataSourceRepository . deleteById ( id ) ; } @ Override public void test ( DataSourceDTO dataSource ) { Connection connection = null ; try { Class . forName ( dataSource . getDriverClassName ( ) ) ; String url = dataSource . getJdbcUrl ( ) ; String username = dataSource . getUsername ( ) ; String password = dataSource . getPassword ( ) ; if ( StrUtil . isNotBlank ( username ) ) { connection = DriverManager . getConnection ( url , username , password ) ; } else { connection = DriverManager . getConnection ( url ) ; } } catch ( ClassNotFoundException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataSource . getDriverClassName ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" + e . getMessage ( ) ) ; } finally { if ( connection != null ) { try { connection . close ( ) ; } catch ( Exception ignored ) { } } } }", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . number ; import org . apache . commons . lang3 . StringUtils ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . ParseException ; public class MoneyUtil { private static final ThreadLocal < DecimalFormat > DEFAULT_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static final ThreadLocal < DecimalFormat > PRETTY_FORMAT = createThreadLocalNumberformat ( \"<STR_LIT>\" ) ; private static ThreadLocal < DecimalFormat > createThreadLocalNumberformat ( final String pattern ) { return new ThreadLocal < DecimalFormat > ( ) { @ Override protected DecimalFormat initialValue ( ) { DecimalFormat df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; return df ; } } ; } public static BigDecimal fen2yuan ( BigDecimal num ) { return num . divide ( new BigDecimal ( <NUM_LIT> ) , <NUM_LIT> , RoundingMode . HALF_UP ) ; } public static BigDecimal fen2yuan ( long num ) { return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal fen2yuan ( String num ) { if ( StringUtils . isEmpty ( num ) ) { return new BigDecimal ( <NUM_LIT> ) ; } return fen2yuan ( new BigDecimal ( num ) ) ; } public static BigDecimal yuan2fen ( String y ) { return new BigDecimal ( Math . round ( new BigDecimal ( y ) . multiply ( new BigDecimal ( <NUM_LIT> ) ) . doubleValue ( ) ) ) ; } public static BigDecimal yuan2fen ( double y ) { return yuan2fen ( String . valueOf ( y ) ) ; } public static BigDecimal yuan2fen ( BigDecimal y ) { if ( y != null ) { return yuan2fen ( y . toString ( ) ) ; } else { return new BigDecimal ( <NUM_LIT> ) ; } } public static String format ( BigDecimal number ) { return format ( number . doubleValue ( ) ) ; } public static String format ( double number ) { return DEFAULT_FORMAT . get ( ) . format ( number ) ; } public static String prettyFormat ( BigDecimal number ) { return prettyFormat ( number . doubleValue ( ) ) ; } public static String prettyFormat ( double number ) { return PRETTY_FORMAT . get ( ) . format ( number ) ; } public static String format ( BigDecimal number , String pattern ) { return format ( number . doubleValue ( ) , pattern ) ; } public static String format ( double number , String pattern ) { DecimalFormat df = null ; if ( StringUtils . isEmpty ( pattern ) ) { df = PRETTY_FORMAT . get ( ) ; }", "output": "else { df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; } return df . format ( number ) ; } public static BigDecimal parseString ( String numberStr ) throws ParseException { return new BigDecimal ( DEFAULT_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ; } public static BigDecimal parsePrettyString ( String numberStr ) throws ParseException { return new BigDecimal ( PRETTY_FORMAT . get ( ) . parse ( numberStr ) . doubleValue ( ) ) ; } public static BigDecimal parseString ( String numberStr , String pattern ) throws ParseException { DecimalFormat df = null ; if ( StringUtils . isEmpty ( pattern ) ) { df = PRETTY_FORMAT . get ( ) ; } else { df = ( DecimalFormat ) DecimalFormat . getInstance ( ) ; df . applyPattern ( pattern ) ; } return new BigDecimal ( df . parse ( numberStr ) . doubleValue ( ) ) ; } }"}, {"input": "package cn . org . alan . exam . model . form . examquanswer ; import jakarta . validation . constraints . NotBlank ; import lombok . Data ; @ Data public class ExamQuAnswerAddForm { private Integer examId ; private Integer quId ; @ NotBlank private String answer ;", "output": "}"}, {"input": "package com . youlai . system . model . dto ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Builder ; import lombok . Data ; @ Schema ( description = \"<STR_LIT>\" ) @ Data @ Builder public class LoginResult { @ Schema ( description = \"<STR_LIT>\" ) private String accessToken ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String tokenType ; @ Schema ( description = \"<STR_LIT>\" ) private String refreshToken ; @ Schema ( description = \"<STR_LIT>\" ) private Long expires ;", "output": "}"}, {"input": "package org . example . dddworkspace . api . microservice ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class WorkspaceMsController { @ Autowired private WorkspaceMsCommandService workspaceMsCommandService ; @ PostMapping public WorkspaceResult create ( @ Valid @ RequestBody WorkspaceCreateCommand command ) {", "output": "return workspaceMsCommandService . create ( command ) ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springframework . web . bind . annotation . PathVariable ; import java . io . Serializable ; @ Data public class AccountBindingParam implements Serializable { @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String accountType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String verificationCode ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String checkType ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneRegion ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String loginAulh ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String deviceId ;", "output": "}"}, {"input": "package com . yf . system . modules . user . dto . request ; import com . yf . system . modules . user . dto . SysUserDTO ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserSaveReqDTO extends SysUserDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > roles ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . annotation . ExcelCell ; import java . util . Date ; public class ExcelDto { @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private String fieldString ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" ) private Integer fieldInteger ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Double fieldDouble ; @ ExcelCell ( index = <NUM_LIT> , name = \"<STR_LIT>\" , format = \"<STR_LIT>\" ) private Date fieldDate ; public String getFieldString ( ) { return fieldString ; } public void setFieldString ( String fieldString ) { this . fieldString = fieldString ; } public Integer getFieldInteger ( ) { return fieldInteger ; } public void setFieldInteger ( Integer fieldInteger ) { this . fieldInteger = fieldInteger ; } public Double getFieldDouble ( ) { return fieldDouble ; } public void setFieldDouble ( Double fieldDouble ) { this . fieldDouble = fieldDouble ; } public Date getFieldDate ( ) { return fieldDate ; } public void setFieldDate ( Date fieldDate ) { this . fieldDate = fieldDate ; }", "output": "}"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Option ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface OptionMapper extends BaseMapper < Option > { Integer insertBatch ( List < Option > options ) ; Integer deleteBatchByQuIds ( List < Integer > quIdList ) ; List < Option > selectAllByQuestionId ( Integer id ) ; List < Option > selectByQuestionId ( Integer id ) ; Integer selectRightCountByIds ( List < Integer > optionIds ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . mapper . ExamQuAnswerMapper ; import cn . org . alan . exam . model . entity . ExamQuAnswer ; import cn . org . alan . exam . model . vo . score . QuestionAnalyseVO ; import cn . org . alan . exam . service . IExamQuAnswerService ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . stereotype . Service ; import java . text . DecimalFormat ; import java . util . List ; @ Service public class ExamQuAnswerServiceImpl extends ServiceImpl < ExamQuAnswerMapper , ExamQuAnswer > implements IExamQuAnswerService { @ Resource private ExamQuAnswerMapper examQuAnswerMapper ; @ Override public Result < QuestionAnalyseVO > questionAnalyse ( Integer examId , Integer questionId ) { QuestionAnalyseVO questionAnalyseVO = examQuAnswerMapper . questionAnalyse ( examId , questionId ) ; DecimalFormat format = new DecimalFormat ( \"<STR_LIT>\" ) ; String strAccuracy = format . format ( questionAnalyseVO . getRightCount ( ) / questionAnalyseVO . getTotalCount ( ) ) ; questionAnalyseVO . setAccuracy ( Double . parseDouble ( strAccuracy ) ) ;", "output": "return Result . success ( null , questionAnalyseVO ) ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Question ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . model . vo . exercise . QuestionSheetVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import java . util . List ; public interface QuestionMapper extends BaseMapper < Question > { IPage < QuestionVO > pagingQuestion ( IPage < QuestionVO > page , String content , Integer repoId , Integer type , Integer userId ) ; QuestionVO selectSingle ( Integer id ) ; Integer deleteByUserIds ( List < Integer > userIds ) ; List < Integer > selectIdsByUserIds ( List < Integer > userIds ) ; List < QuestionSheetVO > selectQuestionSheet ( Integer repoId , Integer quType , Integer userId ) ;", "output": "QuestionVO selectDetail ( Integer id ) ; void deleteBatchIdsQu ( List < Integer > list ) ; int countByCondition ( Integer userId , String title , Integer type , Integer repoId ) ; List < Integer > selectQuestionIdsPage ( Integer userId , String title , Integer type , Integer repoId , int offset , Integer pageSize ) ; List < QuestionVO > batchSelectByIds ( List < Integer > missIds ) ; }"}, {"input": "package com . youlai . system . plugin . norepeat . aspect ; import cn . hutool . core . util . StrUtil ; import cn . hutool . jwt . JWTUtil ; import cn . hutool . jwt . RegisteredPayload ; import com . youlai . system . common . constant . SecurityConstants ; import com . youlai . system . exception . BusinessException ; import com . youlai . system . common . result . ResultCode ; import com . youlai . system . plugin . norepeat . annotation . PreventRepeatSubmit ; import jakarta . servlet . http . HttpServletRequest ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . aspectj . lang . ProceedingJoinPoint ; import org . aspectj . lang . annotation . Around ; import org . aspectj . lang . annotation . Aspect ; import org . aspectj . lang . annotation . Pointcut ; import org . redisson . api . RLock ; import org . redisson . api . RedissonClient ; import org . springframework . http . HttpHeaders ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestContextHolder ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . concurrent . TimeUnit ; @ Aspect @ Component @ Slf4j @ RequiredArgsConstructor public class DuplicateSubmitAspect { private final RedissonClient redissonClient ; private static final String RESUBMIT_LOCK_PREFIX = \"<STR_LIT>\" ; @ Pointcut ( \"<STR_LIT>\" ) public void preventDuplicateSubmitPointCut ( PreventRepeatSubmit preventRepeatSubmit ) { log . info ( \"<STR_LIT>\" ) ; } @ Around ( \"<STR_LIT>\" ) public Object doAround ( ProceedingJoinPoint pjp , PreventRepeatSubmit preventRepeatSubmit ) throws Throwable { String resubmitLockKey = generateResubmitLockKey ( ) ; if ( resubmitLockKey != null ) { int expire = preventRepeatSubmit . expire ( ) ; RLock lock = redissonClient . getLock ( resubmitLockKey ) ; boolean lockResult = lock . tryLock ( <NUM_LIT> , expire , TimeUnit . SECONDS ) ; if ( ! lockResult ) { throw new BusinessException ( ResultCode . REPEAT_SUBMIT_ERROR ) ; } } return pjp . proceed ( ) ; } private String generateResubmitLockKey ( ) { String resubmitLockKey = null ; HttpServletRequest request = ( ( ServletRequestAttributes ) RequestContextHolder . getRequestAttributes ( ) ) . getRequest ( ) ;", "output": "String token = request . getHeader ( HttpHeaders . AUTHORIZATION ) ; if ( StrUtil . isNotBlank ( token ) && token . startsWith ( SecurityConstants . JWT_TOKEN_PREFIX ) ) { token = token . substring ( SecurityConstants . JWT_TOKEN_PREFIX . length ( ) ) ; String jti = ( String ) JWTUtil . parseToken ( token ) . getPayload ( RegisteredPayload . JWT_ID ) ; resubmitLockKey = RESUBMIT_LOCK_PREFIX + jti + \"<STR_LIT>\" + request . getMethod ( ) + \"<STR_LIT>\" + request . getRequestURI ( ) ; } return resubmitLockKey ; } }"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class HrefSlots { private String slotName ; private String href ; public HrefSlots ( String slotName , String href ) { this . slotName = slotName ; this . href = href ;", "output": "} }"}, {"input": "package com . yf . base . api . api . dto ; import lombok . Data ; import java . io . Serializable ; @ Data public class BaseDTO implements Serializable {", "output": "}"}, {"input": "package com . oddfar . campus . framework . config ; import com . google . code . kaptcha . text . impl . DefaultTextCreator ; import org . springframework . context . annotation . Configuration ; import java . util . Random ; public class KaptchaTextCreator extends DefaultTextCreator { private static final String [ ] CNUMBERS = \"<STR_LIT>\" . split ( \"<STR_LIT>\" ) ; @ Override public String getText ( ) { Integer result = <NUM_LIT> ; Random random = new Random ( ) ; int x = random . nextInt ( <NUM_LIT> ) ; int y = random . nextInt ( <NUM_LIT> ) ; StringBuilder suChinese = new StringBuilder ( ) ; int randomoperands = random . nextInt ( <NUM_LIT> ) ; if ( randomoperands == <NUM_LIT> ) { result = x * y ; suChinese . append ( CNUMBERS [ x ] ) ; suChinese . append ( \"<STR_LIT>\" ) ; suChinese . append ( CNUMBERS [ y ] ) ; } else if ( randomoperands == <NUM_LIT> ) { if ( ( x != <NUM_LIT> ) && y % x == <NUM_LIT> ) { result = y / x ; suChinese . append ( CNUMBERS [ y ] ) ; suChinese . append ( \"<STR_LIT>\" ) ; suChinese . append ( CNUMBERS [ x ] ) ; } else { result = x + y ; suChinese . append ( CNUMBERS [ x ] ) ; suChinese . append ( \"<STR_LIT>\" ) ; suChinese . append ( CNUMBERS [ y ] ) ; } } else { if ( x >= y ) { result = x - y ; suChinese . append ( CNUMBERS [ x ] ) ;", "output": "suChinese . append ( \"<STR_LIT>\" ) ; suChinese . append ( CNUMBERS [ y ] ) ; } else { result = y - x ; suChinese . append ( CNUMBERS [ y ] ) ; suChinese . append ( \"<STR_LIT>\" ) ; suChinese . append ( CNUMBERS [ x ] ) ; } } suChinese . append ( \"<STR_LIT>\" + result ) ; return suChinese . toString ( ) ; } }"}, {"input": "package org . example . ddduser . test ; import io . github . chensheng . dddboot . test . ArchitectureTest ; import org . junit . Test ; public class DDDArchitectureTest { @ Test public void testDDDArchitecture ( ) {", "output": "ArchitectureTest . validateDDD ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . yf . system . modules . user . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserRoleDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userId ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String roleId ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . annotation . * ; import java . util . Date ; public abstract class DataObject implements IDataObject { @ TableId ( type = IdType . AUTO ) private Long id ; @ Version private Long version ; @ TableField ( fill = FieldFill . INSERT ) private Long createUser ; @ TableField ( fill = FieldFill . INSERT ) private Date createTime ; @ TableField ( fill = FieldFill . UPDATE ) private Long updateUser ; @ TableField ( fill = FieldFill . UPDATE ) private Date updateTime ; public Long getId ( ) { return id ; } public void setId ( Long id ) { this . id = id ; } public Long getVersion ( ) { return version ; } public void setVersion ( Long version ) { this . version = version ; } public Long getCreateUser ( ) { return createUser ; } public void setCreateUser ( Long createUser ) { this . createUser = createUser ; } public Date getCreateTime ( ) { return createTime ; } public void setCreateTime ( Date createTime ) { this . createTime = createTime ; } public Long getUpdateUser ( ) { return updateUser ; } public void setUpdateUser ( Long updateUser ) { this . updateUser = updateUser ; } public Date getUpdateTime ( ) { return updateTime ;", "output": "} public void setUpdateTime ( Date updateTime ) { this . updateTime = updateTime ; } @ Override public void beforeUpdate ( IDataObject original ) { if ( original == null || ! ( original instanceof DataObject ) ) { return ; } DataObject old = ( DataObject ) original ; this . createTime = old . getCreateTime ( ) ; this . createUser = old . getCreateUser ( ) ; this . version = old . getVersion ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; import java . lang . management . ManagementFactory ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; public class RuntimeUtil { private static AtomicInteger shutdownHookThreadIndex = new AtomicInteger ( <NUM_LIT> ) ; public static int getPid ( ) { String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; String [ ] split = jvmName . split ( \"<STR_LIT>\" ) ; if ( split . length != <NUM_LIT> ) { return - <NUM_LIT> ;", "output": "} try { return Integer . parseInt ( split [ <NUM_LIT> ] ) ; } catch ( Exception e ) { return - <NUM_LIT> ; } } public static long getUpTime ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getUptime ( ) ; } public static String getVmArguments ( ) { List < String > vmArguments = ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; return StringUtils . join ( vmArguments , \"<STR_LIT>\" ) ; } public static int getCores ( ) { return Runtime . getRuntime ( ) . availableProcessors ( ) ; } public static void addShutdownHook ( Runnable runnable ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( runnable , \"<STR_LIT>\" + shutdownHookThreadIndex . incrementAndGet ( ) ) ) ; } public static String getCallerClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else { return StringUtils . EMPTY ; } } public static String getCallerMethod ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) + '<STR_LIT>' + element . getMethodName ( ) + \"<STR_LIT>\" ; } else { return StringUtils . EMPTY ; } } public static String getCurrentClass ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) ; } else { return StringUtils . EMPTY ; } } public static String getCurrentMethod ( ) { StackTraceElement [ ] stacktrace = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stacktrace . length >= <NUM_LIT> ) { StackTraceElement element = stacktrace [ <NUM_LIT> ] ; return element . getClassName ( ) + '<STR_LIT>' + element . getMethodName ( ) + \"<STR_LIT>\" ; } else { return StringUtils . EMPTY ; } } }"}, {"input": "package io . github . chensheng . dddboot . excel . core ; public class ExcelXmlConstants { public static final String DIMENSION_TAG = \"<STR_LIT>\" ; public static final String DIMENSION_ATTR_REF = \"<STR_LIT>\" ; public static final String CELL_TAG = \"<STR_LIT>\" ; public static final String CELL_ATTR_POSITION = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE = \"<STR_LIT>\" ; public static final String CELL_ATTR_TYPE_STRING = \"<STR_LIT>\" ; public static final String CELL_VALUE_TAG = \"<STR_LIT>\" ; public static final String CELL_VALUE_TAG_1 = \"<STR_LIT>\" ; public static final String ROW_TAG = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package cn . org . alan . exam . common . handler ; import cn . org . alan . exam . common . exception . AppException ; import cn . org . alan . exam . common . result . Result ; import jakarta . validation . ConstraintViolationException ; import lombok . extern . slf4j . Slf4j ; import org . springframework . dao . DuplicateKeyException ; import org . springframework . http . converter . HttpMessageNotReadableException ; import org . springframework . security . access . AccessDeniedException ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . MissingServletRequestParameterException ; import org . springframework . web . bind . annotation . ExceptionHandler ; import org . springframework . web . bind . annotation . RestControllerAdvice ; import org . springframework . web . multipart . MaxUploadSizeExceededException ; import org . springframework . web . multipart . MultipartException ; import org . springframework . web . multipart . support . MissingServletRequestPartException ; import java . lang . reflect . InvocationTargetException ; import java . sql . SQLIntegrityConstraintViolationException ; @ RestControllerAdvice @ Slf4j public class GlobalExceptionHandler { @ ExceptionHandler ( AppException . class ) public Result < String > handleAppException ( AppException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( e . getLocalizedMessage ( ) ) ; } @ ExceptionHandler ( MethodArgumentNotValidException . class ) public Result < String > handleMethodArgumentNotValidException ( MethodArgumentNotValidException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; String message = e . getBindingResult ( ) . getAllErrors ( ) . get ( <NUM_LIT> ) . getDefaultMessage ( ) ; return Result . failed ( message ) ; } @ ExceptionHandler ( SQLIntegrityConstraintViolationException . class ) public Result < String > handleSQLIntegrityConstraintViolationException ( SQLIntegrityConstraintViolationException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ;", "output": "return Result . failed ( \"<STR_LIT>\" ) ; } @ ExceptionHandler ( HttpMessageNotReadableException . class ) public Result < String > handleHttpMessageNotReadableException ( HttpMessageNotReadableException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( \"<STR_LIT>\" ) ; } @ ExceptionHandler ( MissingServletRequestParameterException . class ) public Result < String > handleMissingServletRequestParameterException ( MissingServletRequestParameterException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( e . getParameterName ( ) + \"<STR_LIT>\" ) ; } @ ExceptionHandler ( DuplicateKeyException . class ) public Result < String > handleDuplicateKeyException ( DuplicateKeyException e ) { String name = e . getMessage ( ) . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( \"<STR_LIT>\" + name + \"<STR_LIT>\" ) ; } @ ExceptionHandler ( AccessDeniedException . class ) public Result < String > handleAccessDeniedException ( AccessDeniedException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( \"<STR_LIT>\" ) ; } @ ExceptionHandler ( MaxUploadSizeExceededException . class ) public Result < String > handlerMaxUploadSizeExceededException ( MaxUploadSizeExceededException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( \"<STR_LIT>\" ) ; } @ ExceptionHandler ( MissingServletRequestPartException . class ) public Result < String > handlerMissingServletRequestPartException ( MissingServletRequestPartException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( \"<STR_LIT>\" ) ; } @ ExceptionHandler ( ConstraintViolationException . class ) public Result < String > handleConstraintViolationException ( ConstraintViolationException e ) { log . error ( e . getMessage ( ) , e . getClass ( ) ) ; return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( Exception . class ) public Result < String > handleException ( Exception e ) { log . error ( e . getMessage ( ) , e . getClass ( ) , e . getCause ( ) ) ; return Result . failed ( \"<STR_LIT>\" ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . writer ; import java . io . InputStream ; import java . io . OutputStream ; public interface ExcelWriter {", "output": "void write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , Class < ? > ... rowTypes ) throws Exception ; }"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import cn . org . alan . exam . model . entity . ExamQuAnswer ; import cn . org . alan . exam . model . entity . Option ; import lombok . Data ; import java . util . List ; @ Data public class ExamQuCollectVO { private String image ; private String title ; private List < Option > option ; private String myOption ; private Integer quType ;", "output": "}"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . lang . Assert ; import cn . hutool . core . util . StrUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . common . constant . SystemConstants ; import com . youlai . system . common . util . DateUtils ; import com . youlai . system . converter . UserConverter ; import com . youlai . system . security . util . SecurityUtils ; import com . youlai . system . mapper . SysUserMapper ; import com . youlai . system . model . dto . UserAuthInfo ; import com . youlai . system . model . bo . UserBO ; import com . youlai . system . model . entity . SysUser ; import com . youlai . system . model . form . UserForm ; import com . youlai . system . model . query . UserPageQuery ; import com . youlai . system . model . dto . UserExportDTO ; import com . youlai . system . model . vo . UserInfoVO ; import com . youlai . system . model . vo . UserPageVO ; import com . youlai . system . security . service . PermissionService ; import com . youlai . system . service . * ; import lombok . RequiredArgsConstructor ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . Arrays ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor public class SysUserServiceImpl extends ServiceImpl < SysUserMapper , SysUser > implements SysUserService { private final PasswordEncoder passwordEncoder ; private final SysUserRoleService userRoleService ; private final UserConverter userConverter ; private final SysRoleMenuService roleMenuService ; private final SysRoleService roleService ; private final PermissionService permissionService ; @ Override public IPage < UserPageVO > listPagedUsers ( UserPageQuery queryParams ) { int pageNum = queryParams . getPageNum ( ) ; int pageSize = queryParams . getPageSize ( ) ; Page < UserBO > page = new Page < > ( pageNum , pageSize ) ; DateUtils . toDatabaseFormat ( queryParams , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Page < UserBO > userPage = this . baseMapper . listPagedUsers ( page , queryParams ) ; return userConverter . toPageVo ( userPage ) ; } @ Override public UserForm getUserFormData ( Long userId ) { return this . baseMapper . getUserFormData ( userId ) ; } @ Override public boolean saveUser ( UserForm userForm ) { String username = userForm . getUsername ( ) ; long count = this . count ( new LambdaQueryWrapper < SysUser > ( ) . eq ( SysUser :: getUsername , username ) ) ; Assert . isTrue ( count == <NUM_LIT> , \"<STR_LIT>\" ) ; SysUser entity = userConverter . toEntity ( userForm ) ; String defaultEncryptPwd = passwordEncoder . encode ( SystemConstants . DEFAULT_PASSWORD ) ; entity . setPassword ( defaultEncryptPwd ) ; boolean result = this . save ( entity ) ; if ( result ) { userRoleService . saveUserRoles ( entity . getId ( ) , userForm . getRoleIds ( ) ) ; } return result ; }", "output": "@ Override @ Transactional public boolean updateUser ( Long userId , UserForm userForm ) { String username = userForm . getUsername ( ) ; long count = this . count ( new LambdaQueryWrapper < SysUser > ( ) . eq ( SysUser :: getUsername , username ) . ne ( SysUser :: getId , userId ) ) ; Assert . isTrue ( count == <NUM_LIT> , \"<STR_LIT>\" ) ; SysUser entity = userConverter . toEntity ( userForm ) ; boolean result = this . updateById ( entity ) ; if ( result ) { userRoleService . saveUserRoles ( entity . getId ( ) , userForm . getRoleIds ( ) ) ; } return result ; } @ Override public boolean deleteUsers ( String idsStr ) { Assert . isTrue ( StrUtil . isNotBlank ( idsStr ) , \"<STR_LIT>\" ) ; List < Long > ids = Arrays . stream ( idsStr . split ( \"<STR_LIT>\" ) ) . map ( Long :: parseLong ) . collect ( Collectors . toList ( ) ) ; return this . removeByIds ( ids ) ; } @ Override public boolean updatePassword ( Long userId , String password ) { return this . update ( new LambdaUpdateWrapper < SysUser > ( ) . eq ( SysUser :: getId , userId ) . set ( SysUser :: getPassword , passwordEncoder . encode ( password ) ) ) ; } @ Override public UserAuthInfo getUserAuthInfo ( String username ) { UserAuthInfo userAuthInfo = this . baseMapper . getUserAuthInfo ( username ) ; if ( userAuthInfo != null ) { Set < String > roles = userAuthInfo . getRoles ( ) ; if ( CollectionUtil . isNotEmpty ( roles ) ) { Set < String > perms = roleMenuService . getRolePermsByRoleCodes ( roles ) ; userAuthInfo . setPerms ( perms ) ; } Integer dataScope = roleService . getMaximumDataScope ( roles ) ; userAuthInfo . setDataScope ( dataScope ) ; } return userAuthInfo ; } @ Override public List < UserExportDTO > listExportUsers ( UserPageQuery queryParams ) { return this . baseMapper . listExportUsers ( queryParams ) ; } @ Override public UserInfoVO getCurrentUserInfo ( ) { String username = SecurityUtils . getUsername ( ) ; SysUser user = this . getOne ( new LambdaQueryWrapper < SysUser > ( ) . eq ( SysUser :: getUsername , username ) . select ( SysUser :: getId , SysUser :: getUsername , SysUser :: getNickname , SysUser :: getAvatar ) ) ; UserInfoVO userInfoVO = userConverter . toUserInfoVo ( user ) ; Set < String > roles = SecurityUtils . getRoles ( ) ; userInfoVO . setRoles ( roles ) ; if ( CollectionUtil . isNotEmpty ( roles ) ) { Set < String > perms = permissionService . getRolePermsFormCache ( roles ) ; userInfoVO . setPerms ( perms ) ; } return userInfoVO ; } }"}, {"input": "package org . springblade . web . mapper ; import org . springframework . data . repository . query . Param ; import java . util . List ; import java . util . Map ; public interface WebMapper { List < Map < String , Object > > getPayment ( @ Param ( \"<STR_LIT>\" ) String id ) ; Map < String , Object > getMemberSum ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer level ) ; Map < String , Object > getMemberProfit ( @ Param ( \"<STR_LIT>\" ) String id , @ Param ( \"<STR_LIT>\" ) Integer type ) ; Map < String , Object > getMemberCsyj ( @ Param ( \"<STR_LIT>\" ) String id ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . model . entity . NoticeGrade ; import com . baomidou . mybatisplus . extension . service . IService ; public interface INoticeGradeService extends IService < NoticeGrade > {", "output": "}"}, {"input": "package com . youlai . system . model . dto ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class FileInfo { @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private String url ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . record ; import cn . org . alan . exam . model . entity . Option ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; import java . util . List ; @ Data public class ExamRecordVO { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private String title ; private Integer examDuration ; private Integer passedScore ; private Integer grossScore ; private Integer maxCount ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer certificateId ; private Integer radioCount ; private Integer radioScore ; private Integer multiCount ; private Integer multiScore ; private Integer judgeCount ; private Integer judgeScore ; private Integer saqCount ; private Integer saqScore ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime startTime ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime endTime ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private Integer userTime ; private Integer userScore ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime limitTime ;", "output": "}"}, {"input": "package com . yf . system . modules . user . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . system . modules . user . entity . SysUserRole ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysUserRoleMapper extends BaseMapper < SysUserRole > { List < SysRole > listByUser ( @ Param ( \"<STR_LIT>\" ) String userId ) ; List < String > findUserPermission ( @ Param ( \"<STR_LIT>\" ) String userId ) ;", "output": "SysUserRole findMaxRole ( @ Param ( \"<STR_LIT>\" ) String userId ) ; int countWithLevel ( @ Param ( \"<STR_LIT>\" ) List < String > userIds , @ Param ( \"<STR_LIT>\" ) Integer roleLevel ) ; int findMaxLevel ( @ Param ( \"<STR_LIT>\" ) String userId ) ; }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Builder ; import lombok . Data ; @ Data @ Builder public class DecryptVO { private String fileName ; private String fileSize ; private int currentProgress ; private int total ;", "output": "}"}, {"input": "package top . kangert . kspider . io ; import org . openqa . selenium . Cookie ; import org . openqa . selenium . WebDriver ; import org . openqa . selenium . WebElement ; import org . openqa . selenium . interactions . Actions ; import top . kangert . kspider . io . SpiderResponse ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class SeleniumResponse implements SpiderResponse { private WebDriver driver ; private Actions actions ; public SeleniumResponse ( WebDriver driver ) { this . driver = driver ; } @ Override public int getStatusCode ( ) { return <NUM_LIT> ; } @ Override public String getTitle ( ) { return driver . getTitle ( ) ; } @ Override public byte [ ] getBytes ( ) { return null ; } @ Override public String getHtml ( ) { return driver . getPageSource ( ) ; } @ Override public Map < String , String > getCookies ( ) { Set < Cookie > cookies = driver . manage ( ) . getCookies ( ) ; Map < String , String > cookieMap = new HashMap < > ( ) ; if ( cookies != null ) { for ( Cookie cookie : cookies ) { cookieMap . put ( cookie . getName ( ) , cookie . getValue ( ) ) ; } } return cookieMap ; } @ Override public Map < String , String > getHeaders ( ) { return null ; } @ Override public String getContentType ( ) { return null ; }", "output": "@ Override public String getUrl ( ) { return driver . getCurrentUrl ( ) ; } public WebDriver getDriver ( ) { return driver ; } public SeleniumResponse switchTo ( int index ) { driver . switchTo ( ) . frame ( index ) ; return this ; } public SeleniumResponse switchTo ( String name ) { driver . switchTo ( ) . frame ( name ) ; return this ; } public SeleniumResponse switchTo ( WebElement element ) { driver . switchTo ( ) . frame ( element ) ; return this ; } public SeleniumResponse switchToDefault ( ) { driver . switchTo ( ) . defaultContent ( ) ; return this ; } public void quit ( ) { try { driver . quit ( ) ; } catch ( Exception ignored ) { } } public Actions action ( ) { if ( actions == null ) { this . actions = new Actions ( this . driver ) ; } return this . actions ; } public void clearAction ( ) { this . actions = null ; } }"}, {"input": "package com . yf . config . jackson ; import com . fasterxml . jackson . databind . BeanDescription ; import com . fasterxml . jackson . databind . SerializationConfig ; import com . fasterxml . jackson . databind . ser . BeanPropertyWriter ; import com . fasterxml . jackson . databind . ser . BeanSerializerModifier ; import com . yf . base . api . annon . Dict ; import com . yf . system . aspect . dict . DataDictFilter ; import java . util . List ; public class JacksonSerializerModifier extends BeanSerializerModifier { @ Override public List < BeanPropertyWriter > changeProperties ( SerializationConfig config , BeanDescription beanDesc , List < BeanPropertyWriter > beanProperties ) {", "output": "for ( BeanPropertyWriter beanProperty : beanProperties ) { Dict dict = beanProperty . getAnnotation ( Dict . class ) ; if ( dict != null ) { DataDictFilter dictFieldSerializer = new DataDictFilter ( beanProperty . getName ( ) , dict . dicCode ( ) , dict . dictTable ( ) , dict . dicText ( ) ) ; beanProperty . assignSerializer ( dictFieldSerializer ) ; } } return beanProperties ; } }"}, {"input": "package com . yf . base . api . annon ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Documented @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . TYPE , ElementType . METHOD } ) public @ interface LogInject { String logType ( ) default \"<STR_LIT>\" ; String title ( ) default \"<STR_LIT>\" ;", "output": "}"}, {"input": "package me . zhengjie . modules . quartz . service . impl ; import cn . hutool . core . util . IdUtil ; import cn . hutool . core . util . StrUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . mapper . QuartzJobMapper ; import me . zhengjie . modules . quartz . mapper . QuartzLogMapper ; import me . zhengjie . modules . quartz . service . QuartzJobService ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import me . zhengjie . modules . quartz . utils . QuartzManage ; import me . zhengjie . utils . * ; import org . quartz . CronExpression ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ RequiredArgsConstructor @ Service ( value = \"<STR_LIT>\" ) public class QuartzJobServiceImpl extends ServiceImpl < QuartzJobMapper , QuartzJob > implements QuartzJobService { private final QuartzJobMapper quartzJobMapper ; private final QuartzLogMapper quartzLogMapper ; private final QuartzManage quartzManage ; private final RedisUtils redisUtils ; @ Override public PageResult < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( quartzJobMapper . findAll ( criteria , page ) ) ; } @ Override public PageResult < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( quartzLogMapper . findAll ( criteria , page ) ) ; } @ Override public List < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria ) { return quartzJobMapper . findAll ( criteria ) ; } @ Override public List < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria ) { return quartzLogMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( QuartzJob resources ) { if ( ! CronExpression . isValidExpression ( resources . getCronExpression ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } save ( resources ) ; quartzManage . addJob ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( QuartzJob resources ) { if ( ! CronExpression . isValidExpression ( resources . getCronExpression ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } if ( StringUtils . isNotBlank ( resources . getSubTask ( ) ) ) { List < String > tasks = Arrays . asList ( resources . getSubTask ( ) . split ( \"<STR_LIT>\" ) ) ; if ( tasks . contains ( resources . getId ( ) . toString ( ) ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } saveOrUpdate ( resources ) ; quartzManage . updateJobCron ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateIsPause ( QuartzJob quartzJob ) { if ( quartzJob . getIsPause ( ) ) { quartzManage . resumeJob ( quartzJob ) ; quartzJob . setIsPause ( false ) ; } else { quartzManage . pauseJob ( quartzJob ) ; quartzJob . setIsPause ( true ) ; } saveOrUpdate ( quartzJob ) ; } @ Override public void execution ( QuartzJob quartzJob ) { quartzManage . runJobNow ( quartzJob ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { for ( Long id : ids ) { QuartzJob quartzJob = getById ( id ) ; quartzManage . deleteJob ( quartzJob ) ; removeById ( quartzJob ) ; } } @ Async @ Override @ Transactional ( rollbackFor = Exception . class ) public void executionSubJob ( String [ ] tasks ) throws InterruptedException { for ( String id : tasks ) { if ( StrUtil . isBlank ( id ) ) { continue ; } QuartzJob quartzJob = getById ( Long . parseLong ( id ) ) ; String uuid = IdUtil . simpleUUID ( ) ; quartzJob . setUuid ( uuid ) ; execution ( quartzJob ) ; Boolean result = ( Boolean ) redisUtils . get ( uuid ) ; while ( result == null ) { Thread . sleep ( <NUM_LIT> ) ; result = ( Boolean ) redisUtils . get ( uuid ) ; } if ( ! result ) { redisUtils . del ( uuid ) ; break ; } } } @ Override public void download ( List < QuartzJob > quartzJobs , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( QuartzJob quartzJob : quartzJobs ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , quartzJob . getJobName ( ) ) ; map . put ( \"<STR_LIT>\" , quartzJob . getBeanName ( ) ) ;", "output": "map . put ( \"<STR_LIT>\" , quartzJob . getMethodName ( ) ) ; map . put ( \"<STR_LIT>\" , quartzJob . getParams ( ) ) ; map . put ( \"<STR_LIT>\" , quartzJob . getCronExpression ( ) ) ; map . put ( \"<STR_LIT>\" , quartzJob . getIsPause ( ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , quartzJob . getDescription ( ) ) ; map . put ( \"<STR_LIT>\" , quartzJob . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } @ Override public void downloadLog ( List < QuartzLog > queryAllLog , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( QuartzLog quartzLog : queryAllLog ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , quartzLog . getJobName ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getBeanName ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getMethodName ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getParams ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getCronExpression ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getExceptionDetail ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getTime ( ) ) ; map . put ( \"<STR_LIT>\" , quartzLog . getIsSuccess ( ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , quartzLog . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } }"}, {"input": "package com . oddfar . campus . common . domain . model ; import com . alibaba . fastjson2 . annotation . JSONField ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import lombok . AllArgsConstructor ; import lombok . Data ; import org . springframework . security . core . GrantedAuthority ; import org . springframework . security . core . userdetails . UserDetails ; import java . util . Collection ; import java . util . Set ; @ Data @ AllArgsConstructor public class LoginUser implements UserDetails { private static final long serialVersionUID = <NUM_LIT> ; private Long userId ; private String token ; private Long expireTime ; private String ipaddr ; private Set < String > permissions ; private Set < String > resources ; private SysUserEntity user ; public LoginUser ( Long userId , SysUserEntity user , Set < String > permissions , Set < String > resources ) { this . userId = userId ; this . user = user ; this . permissions = permissions ; this . resources = resources ; } @ JSONField ( serialize = false ) @ Override public String getPassword ( ) { return user . getPassword ( ) ; } @ Override public String getUsername ( ) { return user . getUserName ( ) ; }", "output": "@ JSONField ( serialize = false ) @ Override public boolean isAccountNonExpired ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isAccountNonLocked ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isCredentialsNonExpired ( ) { return true ; } @ JSONField ( serialize = false ) @ Override public boolean isEnabled ( ) { return true ; } @ Override public Collection < ? extends GrantedAuthority > getAuthorities ( ) { return null ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class NoticeGrade implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer noticeId ; private Integer gradeId ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getNoticeId ( ) { return noticeId ; } public void setNoticeId ( Integer noticeId ) { this . noticeId = noticeId ; } public Integer getGradeId ( ) {", "output": "return gradeId ; } public void setGradeId ( Integer gradeId ) { this . gradeId = gradeId ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + noticeId + \"<STR_LIT>\" + gradeId + \"<STR_LIT>\" ; } }"}, {"input": "package com . yf . ability . captcha . service . impl ; import com . yf . ability . captcha . service . CaptchaService ; import com . yf . ability . redis . service . RedisService ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class CaptchaServiceImpl implements CaptchaService { @ Autowired private RedisService redisService ; private static final String CAPTCHA_PREFIX = \"<STR_LIT>\" ; @ Override public void saveCaptcha ( String key , String value ) { redisService . set ( appendKey ( key ) , value , <NUM_LIT> ) ; } @ Override public boolean checkCaptcha ( String key , String input ) { String fullKey = appendKey ( key ) ; String value = redisService . getString ( fullKey ) ; boolean result = StringUtils . isNotBlank ( value ) && value . equalsIgnoreCase ( input ) ; if ( result ) { redisService . del ( fullKey ) ;", "output": "} return result ; } private String appendKey ( String key ) { return new StringBuffer ( CAPTCHA_PREFIX ) . append ( key ) . toString ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import io . github . chensheng . dddboot . openfeign . core . FeignClient ; import feign . Request ; import feign . Response ; import feign . Util ; import org . apache . http . * ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . client . methods . HttpUriRequest ; import org . apache . http . client . methods . RequestBuilder ; import org . apache . http . client . utils . URIBuilder ; import org . apache . http . client . utils . URLEncodedUtils ; import org . apache . http . entity . ByteArrayEntity ; import org . apache . http . entity . ContentType ; import org . apache . http . entity . StringEntity ; import org . apache . http . util . EntityUtils ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . charset . Charset ; import java . util . * ; import static feign . Util . UTF_8 ; public class ApacheHcFeignClient implements FeignClient { private static final String ACCEPT_HEADER_NAME = \"<STR_LIT>\" ; private PoolingHttpClient poolingHttpClient ; public ApacheHcFeignClient ( OpenFeignProperties properties ) { this . poolingHttpClient = new PoolingHttpClient ( properties ) ; } @ Override public Response execute ( Request request , Request . Options options ) throws IOException { HttpUriRequest httpUriRequest = null ; try { httpUriRequest = toHttpUriRequest ( request , options ) ; } catch ( URISyntaxException e ) { throw new IOException ( \"<STR_LIT>\" + request . url ( ) + \"<STR_LIT>\" , e ) ; } HttpResponse httpResponse = poolingHttpClient . get ( ) . execute ( httpUriRequest ) ; return toFeignResponse ( httpResponse , request ) ; } private HttpUriRequest toHttpUriRequest ( Request request , Request . Options options ) throws URISyntaxException { RequestBuilder requestBuilder = RequestBuilder . create ( request . httpMethod ( ) . name ( ) ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setConnectTimeout ( options . connectTimeoutMillis ( ) ) . setSocketTimeout ( options . readTimeoutMillis ( ) ) . build ( ) ; requestBuilder . setConfig ( requestConfig ) ; URI uri = new URIBuilder ( request . url ( ) ) . build ( ) ; requestBuilder . setUri ( uri . getScheme ( ) + \"<STR_LIT>\" + uri . getAuthority ( ) + uri . getRawPath ( ) ) ; List < NameValuePair > queryParams = URLEncodedUtils . parse ( uri , requestBuilder . getCharset ( ) ) ; for ( NameValuePair queryParam : queryParams ) { requestBuilder . addParameter ( queryParam ) ; } boolean hasAcceptHeader = false ; for ( Map . Entry < String , Collection < String > > headerEntry : request . headers ( ) . entrySet ( ) ) { String headerName = headerEntry . getKey ( ) ; if ( headerName . equalsIgnoreCase ( ACCEPT_HEADER_NAME ) ) { hasAcceptHeader = true ; } if ( headerName . equalsIgnoreCase ( Util . CONTENT_LENGTH ) ) { continue ; } for ( String headerValue : headerEntry . getValue ( ) ) { requestBuilder . addHeader ( headerName , headerValue ) ; } } if ( ! hasAcceptHeader ) { requestBuilder . addHeader ( ACCEPT_HEADER_NAME , \"<STR_LIT>\" ) ; } if ( request . requestBody ( ) . asBytes ( ) != null ) { HttpEntity entity = null ; if ( request . charset ( ) != null ) { ContentType contentType = getContentType ( request ) ; String content = new String ( request . requestBody ( ) . asBytes ( ) , request . charset ( ) ) ; entity = new StringEntity ( content , contentType ) ;", "output": "} else { entity = new ByteArrayEntity ( request . requestBody ( ) . asBytes ( ) ) ; } requestBuilder . setEntity ( entity ) ; } else { requestBuilder . setEntity ( new ByteArrayEntity ( new byte [ <NUM_LIT> ] ) ) ; } return requestBuilder . build ( ) ; } private ContentType getContentType ( Request request ) { ContentType contentType = null ; for ( Map . Entry < String , Collection < String > > entry : request . headers ( ) . entrySet ( ) ) { if ( ! entry . getKey ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { continue ; } Collection < String > values = entry . getValue ( ) ; if ( values == null || values . isEmpty ( ) ) { continue ; } contentType = ContentType . parse ( values . iterator ( ) . next ( ) ) ; if ( contentType . getCharset ( ) == null ) { contentType = contentType . withCharset ( request . charset ( ) ) ; } break ; } return contentType ; } private Response toFeignResponse ( HttpResponse httpResponse , Request request ) throws IOException { StatusLine statusLine = httpResponse . getStatusLine ( ) ; int statusCode = statusLine . getStatusCode ( ) ; String reason = statusLine . getReasonPhrase ( ) ; Map < String , Collection < String > > headers = new HashMap < String , Collection < String > > ( ) ; for ( Header header : httpResponse . getAllHeaders ( ) ) { String name = header . getName ( ) ; String value = header . getValue ( ) ; Collection < String > headerValues = headers . get ( name ) ; if ( headerValues == null ) { headerValues = new ArrayList < String > ( ) ; headers . put ( name , headerValues ) ; } headerValues . add ( value ) ; } return Response . builder ( ) . status ( statusCode ) . reason ( reason ) . headers ( headers ) . request ( request ) . body ( toFeignBody ( httpResponse ) ) . build ( ) ; } private Response . Body toFeignBody ( HttpResponse httpResponse ) { final HttpEntity entity = httpResponse . getEntity ( ) ; if ( entity == null ) { return null ; } return new Response . Body ( ) { @ Override public Integer length ( ) { return entity . getContentLength ( ) >= <NUM_LIT> && entity . getContentLength ( ) <= Integer . MAX_VALUE ? ( int ) entity . getContentLength ( ) : null ; } @ Override public boolean isRepeatable ( ) { return entity . isRepeatable ( ) ; } @ Override public InputStream asInputStream ( ) throws IOException { return entity . getContent ( ) ; } @ Override public Reader asReader ( ) throws IOException { return new InputStreamReader ( asInputStream ( ) , UTF_8 ) ; } @ Override public Reader asReader ( Charset charset ) throws IOException { Util . checkNotNull ( charset , \"<STR_LIT>\" ) ; return new InputStreamReader ( asInputStream ( ) , charset ) ; } @ Override public void close ( ) throws IOException { EntityUtils . consume ( entity ) ; } } ; } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class AddFrozenWalletParam { private String tableName ; private String walletId ; private BigDecimal addfrozenBalance ; private boolean messageRefreshFlag = true ;", "output": "}"}, {"input": "package ginyi . common . exception . handler ; import com . alibaba . fastjson2 . JSON ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . exception . UnPermissionException ; import ginyi . common . exception . UserPasswordNotMatchException ; import ginyi . common . exception . UserPasswordRetryLimitExceedException ; import ginyi . common . result . CommonResult ; import ginyi . common . result . StateCode ; import lombok . extern . slf4j . Slf4j ; import org . springframework . http . HttpStatus ; import org . springframework . http . converter . HttpMessageNotReadableException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ExceptionHandler ; import org . springframework . web . bind . annotation . ResponseStatus ; import org . springframework . web . bind . annotation . RestControllerAdvice ; import org . springframework . web . multipart . MaxUploadSizeExceededException ; import org . springframework . web . multipart . MultipartException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; @ RestControllerAdvice @ Slf4j public class GlobalExceptionHandler { @ ExceptionHandler ( CommonException . class ) @ ResponseStatus ( HttpStatus . OK ) public CommonResult BusinessExceptionHandler ( CommonException e ) { if ( e . getState ( ) == StateCode . ERROR_SYSTEM ) { return CommonResult . error ( e . getState ( ) , CommonMessageConstants . SYS_ERROR ) ; } return CommonResult . error ( e . getState ( ) , e . getData ( ) ) ; } @ ExceptionHandler ( MethodArgumentNotValidException . class ) @ ResponseStatus ( HttpStatus . OK ) public CommonResult MethodArgumentNotValidExceptionHandler ( MethodArgumentNotValidException e ) { List < String > errorList = new ArrayList < > ( ) ; if ( ! e . getBindingResult ( ) . getAllErrors ( ) . isEmpty ( ) ) { for ( ObjectError error : e . getBindingResult ( ) . getAllErrors ( ) ) { errorList . add ( error . getDefaultMessage ( ) ) ; } } HashMap < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , errorList ) ; log . info ( JSON . toJSONString ( CommonResult . error ( StateCode . ERROR_PARAMS , map ) ) ) ; return CommonResult . error ( StateCode . ERROR_PARAMS , map ) ; } @ ResponseStatus ( HttpStatus . OK ) @ ExceptionHandler ( HttpMessageNotReadableException . class ) public CommonResult HttpMessageNotReadableExceptionHandler ( HttpMessageNotReadableException e ) { return CommonResult . error ( StateCode . ERROR_REQUEST_PARAMS , CommonMessageConstants . SYS_REQUEST_ILLEGAL ) ; } @ ResponseStatus ( HttpStatus . OK ) @ ExceptionHandler ( UserPasswordNotMatchException . class ) public CommonResult UserPasswordNotMatchExceptionHandler ( UserPasswordNotMatchException e ) { return CommonResult . error ( StateCode . ERROR_UNAUTHENTICATION , CommonMessageConstants . USER_PASSWORD_NOT_MATCH ) ; } @ ResponseStatus ( HttpStatus . OK ) @ ExceptionHandler ( UserPasswordRetryLimitExceedException . class ) public CommonResult UserPasswordRetryLimitExceedExceptionHandler ( UserPasswordRetryLimitExceedException e ) { return CommonResult . error ( e . getState ( ) , e . getData ( ) ) ; } @ ExceptionHandler ( MultipartException . class ) @ ResponseStatus ( HttpStatus . OK ) public CommonResult MultipartExceptionHandler ( MultipartException e ) { if ( e instanceof MaxUploadSizeExceededException ) { return CommonResult . error ( StateCode . ERROR_MULTIPART , CommonMessageConstants . UPLOAD_SIZE_EXCEED ) ; } return CommonResult . error ( StateCode . ERROR_MULTIPART , CommonMessageConstants . UPLOAD_FILE_ERROR ) ; } @ ExceptionHandler ( { UnPermissionException . class } ) @ ResponseStatus ( HttpStatus . OK ) public CommonResult UnPermissionExceptionHandler ( UnPermissionException e ) { return CommonResult . error ( StateCode . ERROR_NOT_PERMISSION , CommonMessageConstants . SYS_ERROR ) ; } @ ExceptionHandler ( Exception . class ) @ ResponseStatus ( HttpStatus . OK ) public CommonResult ExceptionHandler ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; return CommonResult . error ( StateCode . ERROR_SYSTEM , CommonMessageConstants . SYS_ERROR ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . vo . GradeVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . springframework . stereotype . Repository ; import java . util . List ; @ Repository public interface GradeMapper extends BaseMapper < Grade > { List < Integer > selectIdsByUserIds ( List < Integer > userIds ) ; Integer deleteByUserId ( List < Integer > userIds ) ; Page < GradeVO > selectGradePage ( Page < GradeVO > page , Integer userId , String gradeName , Integer role ) ;", "output": "List < Integer > selectGradeIdsPage ( Integer userId , Integer role , String gradeName , int offset , Integer pageSize ) ; List < GradeVO > batchSelectByIds ( List < Integer > missIds ) ; int countByCondition ( Integer userId , String gradeName , Integer role ) ; }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . dto . FeedsDTO ; import com . xcs . wx . domain . vo . FeedsVO ; import com . xcs . wx . domain . vo . PageVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . service . FeedsService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class FeedsController { private final FeedsService feedsService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < FeedsVO > > list ( FeedsDTO feedsDTO ) {", "output": "PageVO < FeedsVO > pageVO = feedsService . queryFeeds ( feedsDTO ) ; return ResponseVO . ok ( pageVO . getRecords ( ) , pageVO . getCurrent ( ) , pageVO . getTotal ( ) ) ; } }"}, {"input": "package ginyi . common . swagger ; import com . github . xiaoymin . knife4j . spring . annotations . EnableKnife4j ; import io . swagger . annotations . ApiOperation ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . builders . RequestHandlerSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . Contact ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import static springfox . documentation . builders . RequestHandlerSelectors . basePackage ; public class Swagger2Config { @ Value ( \"<STR_LIT>\" ) private String title ; @ Value ( \"<STR_LIT>\" ) private String groupName ; @ Value ( \"<STR_LIT>\" ) private String description ; @ Value ( \"<STR_LIT>\" ) private String url ; @ Value ( \"<STR_LIT>\" ) private String contactName ; @ Value ( \"<STR_LIT>\" ) private String contactEmail ; @ Value ( \"<STR_LIT>\" ) private String version ; @ Bean public Docket createAdminApiDoc ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . groupName ( groupName ) . apiInfo ( apiInfo ( ) ) . select ( ) . apis ( RequestHandlerSelectors . withMethodAnnotation ( ApiOperation . class ) ) . paths ( PathSelectors . any ( ) ) . build ( ) ; }", "output": "private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . title ( title ) . description ( description ) . termsOfServiceUrl ( url ) . contact ( new Contact ( contactName , null , contactEmail ) ) . version ( version ) . build ( ) ; } }"}, {"input": "package org . example . ddduser . application . dto . command ; import lombok . Data ; import javax . validation . constraints . NotEmpty ; import javax . validation . constraints . Pattern ; @ Data public class UserRegisterCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String username ; @ NotEmpty ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String password ;", "output": "}"}, {"input": "package top . kangert . kspider . support ; import java . util . Map ; public interface ExpressionEngine {", "output": "Object execute ( String expression , Map < String , Object > variables ) ; default Object getExpressionObjectMap ( ) { return null ; } }"}, {"input": "package me . zhengjie . config . thread ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; import org . springframework . scheduling . concurrent . ThreadPoolTaskExecutor ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadPoolExecutor ; @ Configuration public class CustomExecutorConfig { @ Bean @ Primary public Executor elAsync ( ) { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor ( ) ; executor . setCorePoolSize ( AsyncTaskProperties . corePoolSize ) ; executor . setMaxPoolSize ( AsyncTaskProperties . maxPoolSize ) ; executor . setQueueCapacity ( AsyncTaskProperties . queueCapacity ) ; executor . setThreadNamePrefix ( \"<STR_LIT>\" ) ; executor . setKeepAliveSeconds ( AsyncTaskProperties . keepAliveSeconds ) ; executor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; executor . initialize ( ) ; return executor ; } @ Bean public Executor otherAsync ( ) { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor ( ) ; executor . setCorePoolSize ( <NUM_LIT> ) ; executor . setQueueCapacity ( <NUM_LIT> ) ; executor . setKeepAliveSeconds ( AsyncTaskProperties . keepAliveSeconds ) ;", "output": "executor . setThreadNamePrefix ( \"<STR_LIT>\" ) ; executor . setRejectedExecutionHandler ( new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; executor . initialize ( ) ; return executor ; } }"}, {"input": "package com . oddfar . campus . common . exception . user ; public class CaptchaExpireException extends UserException { private static final long serialVersionUID = <NUM_LIT> ; public CaptchaExpireException ( ) { super ( \"<STR_LIT>\" , null ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . model . form . count ; public class ClassCountResult { private Integer gradeId ; private String gradeName ; private Integer count ; private int gradeCount ; private int examCount ; private int questionCount ; public Integer getGradeId ( ) { return gradeId ; } public void setGradeId ( Integer gradeId ) { this . gradeId = gradeId ; } public String getGradeName ( ) { return gradeName ;", "output": "} public void setGradeName ( String gradeName ) { this . gradeName = gradeName ; } public Integer getCount ( ) { return count ; } public void setCount ( Integer count ) { this . count = count ; } public int getGradeCount ( ) { return gradeCount ; } public void setGradeCount ( int gradeCount ) { this . gradeCount = gradeCount ; } public int getExamCount ( ) { return examCount ; } public void setExamCount ( int examCount ) { this . examCount = examCount ; } public int getQuestionCount ( ) { return questionCount ; } public void setQuestionCount ( int questionCount ) { this . questionCount = questionCount ; } }"}, {"input": "package com . oddfar . campus . framework . api . sysconfig ; import com . oddfar . campus . framework . service . SysConfigService ; import com . oddfar . campus . framework . service . impl . SysConfigServiceImpl ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration public class ZyConfigAutoConfiguration { @ Bean @ ConditionalOnMissingBean ( SysConfigService . class ) public SysConfigService configService ( ) {", "output": "return new SysConfigServiceImpl ( ) ; } }"}, {"input": "package com . xcs . wx . domain . dto ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ Data @ EqualsAndHashCode ( callSuper = true ) public class FeedsDTO extends PageDTO { private String userName ; private Long startTime ; private Long endTime ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . service ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysLoginLogEntity ; import java . util . List ; public interface SysLoginLogService { public PageResult < SysLoginLogEntity > selectLogininforPage ( SysLoginLogEntity logininfor ) ; public void insertLogininfor ( SysLoginLogEntity logininfor ) ; public List < SysLoginLogEntity > selectLogininforList ( SysLoginLogEntity logininfor ) ; public int deleteLogininforByIds ( Long [ ] infoIds ) ; public void cleanLogininfor ( ) ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function . extension ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . model . WebElements ; import org . openqa . selenium . By ; import org . openqa . selenium . NoSuchElementException ; import org . openqa . selenium . WebElement ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . RandomUtil ; import cn . hutool . core . util . StrUtil ; import java . util . List ; @ Component public class WebElementWrapperFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return WebElementWrapper . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper selector ( WebElementWrapper element , String css ) { try { return ( WebElementWrapper ) element . findElement ( By . cssSelector ( css ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElements selectors ( WebElementWrapper element , String css ) { try { return new WebElements ( element . getResponse ( ) , element . findElements ( By . cssSelector ( css ) ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < WebElement > xpaths ( WebElementWrapper wrapper , String xpath ) { try { return wrapper . findElements ( By . xpath ( xpath ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElement xpath ( WebElementWrapper wrapper , String xpath ) { try { return wrapper . findElement ( By . xpath ( xpath ) ) ; } catch ( NoSuchElementException e ) { return null ; } } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper clickAndHold ( WebElementWrapper element ) { element . action ( ) . clickAndHold ( element . element ( ) ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper release ( WebElementWrapper element ) { element . action ( ) . release ( element . element ( ) ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper move ( WebElementWrapper element , int x , int y ) { element . action ( ) . moveToElement ( element . element ( ) , x , y ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper move ( WebElementWrapper element ) { element . action ( ) . moveToElement ( element . element ( ) ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper doubleClick ( WebElementWrapper element ) { element . action ( ) . doubleClick ( element . element ( ) ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper pauseSendKeys ( WebElementWrapper element , String keys , long pauseTime ) { if ( StrUtil . isBlank ( keys ) ) { return element ; } long defaultMin = <NUM_LIT> ; if ( pauseTime < defaultMin ) { pauseTime = defaultMin ; } CharSequence charSequence = new String ( keys ) ; for ( int i = <NUM_LIT> ; i < charSequence . length ( ) ; i ++ ) { long randomLong = RandomUtil . randomLong ( <NUM_LIT> , pauseTime ) ; try { Thread . sleep ( randomLong ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } finally { element . sendKeys ( charSequence . subSequence ( i , i + <NUM_LIT> ) ) ; pauseTime -= randomLong ; } } return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper pause ( WebElementWrapper element , int pause ) { element . action ( ) . pause ( pause ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElementWrapper perform ( WebElementWrapper element ) { element . action ( ) . perform ( ) ; element . clear ( ) ; return element ;", "output": "} }"}, {"input": "package com . yf . system . modules . dict . dto ; import com . yf . base . api . annon . Dict ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDicDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String code ; @ Dict ( dicCode = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String title ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ;", "output": "}"}, {"input": "package com . oddfar . campus . common . utils . reflect ; import com . oddfar . campus . common . core . text . Convert ; import com . oddfar . campus . common . utils . DateUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . poi . ss . usermodel . DateUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . lang . reflect . * ; import java . util . Date ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectUtils { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String CGLIB_CLASS_SEPARATOR = \"<STR_LIT>\" ; private static Logger logger = LoggerFactory . getLogger ( ReflectUtils . class ) ; @ SuppressWarnings ( \"<STR_LIT>\" ) public static < E > E invokeGetter ( Object obj , String propertyName ) { Object object = obj ; for ( String name : StringUtils . split ( propertyName , \"<STR_LIT>\" ) ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( name ) ; object = invokeMethod ( object , getterMethodName , new Class [ ] { } , new Object [ ] { } ) ; } return ( E ) object ; } public static < E > void invokeSetter ( Object obj , String propertyName , E value ) { Object object = obj ; String [ ] names = StringUtils . split ( propertyName , \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < names . length ; i ++ ) { if ( i < names . length - <NUM_LIT> ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( names [ i ] ) ; object = invokeMethod ( object , getterMethodName , new Class [ ] { } , new Object [ ] { } ) ; } else { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( names [ i ] ) ; invokeMethodByName ( object , setterMethodName , new Object [ ] { value } ) ; } } } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < E > E getFieldValue ( final Object obj , final String fieldName ) { Field field = getAccessibleField ( obj , fieldName ) ; if ( field == null ) { logger . debug ( \"<STR_LIT>\" + obj . getClass ( ) + \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ) ; return null ; } E result = null ; try { result = ( E ) field . get ( obj ) ; } catch ( IllegalAccessException e ) { logger . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } return result ; } public static < E > void setFieldValue ( final Object obj , final String fieldName , final E value ) { Field field = getAccessibleField ( obj , fieldName ) ; if ( field == null ) { logger . debug ( \"<STR_LIT>\" + obj . getClass ( ) + \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ) ;", "output": "return ; } try { field . set ( obj , value ) ; } catch ( IllegalAccessException e ) { logger . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < E > E invokeMethod ( final Object obj , final String methodName , final Class < ? > [ ] parameterTypes , final Object [ ] args ) { if ( obj == null || methodName == null ) { return null ; } Method method = getAccessibleMethod ( obj , methodName , parameterTypes ) ; if ( method == null ) { logger . debug ( \"<STR_LIT>\" + obj . getClass ( ) + \"<STR_LIT>\" + methodName + \"<STR_LIT>\" ) ; return null ; } try { return ( E ) method . invoke ( obj , args ) ; } catch ( Exception e ) { String msg = \"<STR_LIT>\" + method + \"<STR_LIT>\" + obj + \"<STR_LIT>\" + args + \"<STR_LIT>\" ; throw convertReflectionExceptionToUnchecked ( msg , e ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < E > E invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj , methodName , args . length ) ; if ( method == null ) { logger . debug ( \"<STR_LIT>\" + obj . getClass ( ) + \"<STR_LIT>\" + methodName + \"<STR_LIT>\" ) ; return null ; } try { Class < ? > [ ] cs = method . getParameterTypes ( ) ; for ( int i = <NUM_LIT> ; i < cs . length ; i ++ ) { if ( args [ i ] != null && ! args [ i ] . getClass ( ) . equals ( cs [ i ] ) ) { if ( cs [ i ] == String . class ) { args [ i ] = Convert . toStr ( args [ i ] ) ; if ( StringUtils . endsWith ( ( String ) args [ i ] , \"<STR_LIT>\" ) ) { args [ i ] = StringUtils . substringBefore ( ( String ) args [ i ] , \"<STR_LIT>\" ) ; } } else if ( cs [ i ] == Integer . class ) { args [ i ] = Convert . toInt ( args [ i ] ) ; } else if ( cs [ i ] == Long . class ) { args [ i ] = Convert . toLong ( args [ i ] ) ; } else if ( cs [ i ] == Double . class ) { args [ i ] = Convert . toDouble ( args [ i ] ) ; } else if ( cs [ i ] == Float . class ) { args [ i ] = Convert . toFloat ( args [ i ] ) ; } else if ( cs [ i ] == Date . class ) { if ( args [ i ] instanceof String ) { args [ i ] = DateUtils . parseDate ( args [ i ] ) ; } else { args [ i ] = DateUtil . getJavaDate ( ( Double ) args [ i ] ) ; } } else if ( cs [ i ] == boolean . class || cs [ i ] == Boolean . class ) { args [ i ] = Convert . toBool ( args [ i ] ) ; } } } return ( E ) method . invoke ( obj , args ) ; } catch ( Exception e ) { String msg = \"<STR_LIT>\" + method + \"<STR_LIT>\" + obj + \"<STR_LIT>\" + args + \"<STR_LIT>\" ; throw convertReflectionExceptionToUnchecked ( msg , e ) ; } } public static Field getAccessibleField ( final Object obj , final String fieldName ) { if ( obj == null ) { return null ; } Validate . notBlank ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = obj . getClass ( ) ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { continue ; } } return null ; } public static Method getAccessibleMethod ( final Object obj , final String methodName , final Class < ? > ... parameterTypes ) { if ( obj == null ) { return null ; } Validate . notBlank ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = obj . getClass ( ) ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { try { Method method = searchType . getDeclaredMethod ( methodName , parameterTypes ) ; makeAccessible ( method ) ; return method ; } catch ( NoSuchMethodException e ) { continue ; } } return null ; } public static Method getAccessibleMethodByName ( final Object obj , final String methodName , int argsNum ) { if ( obj == null ) { return null ; } Validate . notBlank ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = obj . getClass ( ) ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) && method . getParameterTypes ( ) . length == argsNum ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static void makeAccessible ( Method method ) { if ( ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) && ! method . isAccessible ( ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) && ! field . isAccessible ( ) ) { field . setAccessible ( true ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > Class < T > getClassGenricType ( final Class clazz ) { return getClassGenricType ( clazz , <NUM_LIT> ) ; } public static Class getClassGenricType ( final Class clazz , final int index ) { Type genType = clazz . getGenericSuperclass ( ) ; if ( ! ( genType instanceof ParameterizedType ) ) { logger . debug ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } Type [ ] params = ( ( ParameterizedType ) genType ) . getActualTypeArguments ( ) ; if ( index >= params . length || index < <NUM_LIT> ) { logger . debug ( \"<STR_LIT>\" + index + \"<STR_LIT>\" + clazz . getSimpleName ( ) + \"<STR_LIT>\" + params . length ) ; return Object . class ; } if ( ! ( params [ index ] instanceof Class ) ) { logger . debug ( clazz . getSimpleName ( ) + \"<STR_LIT>\" ) ; return Object . class ; } return ( Class ) params [ index ] ; } public static Class < ? > getUserClass ( Object instance ) { if ( instance == null ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } Class clazz = instance . getClass ( ) ; if ( clazz != null && clazz . getName ( ) . contains ( CGLIB_CLASS_SEPARATOR ) ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass != null && ! Object . class . equals ( superClass ) ) { return superClass ; } } return clazz ; } public static RuntimeException convertReflectionExceptionToUnchecked ( String msg , Exception e ) { if ( e instanceof IllegalAccessException || e instanceof IllegalArgumentException || e instanceof NoSuchMethodException ) { return new IllegalArgumentException ( msg , e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( msg , ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } return new RuntimeException ( msg , e ) ; } }"}, {"input": "package com . xcs . wx . msg . impl ; import cn . hutool . core . lang . Opt ; import com . xcs . wx . domain . bo . CompressContentBO ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . domain . vo . WeAppInfoVO ; import com . xcs . wx . msg . MsgStrategy ; import com . xcs . wx . util . LZ4Util ; import com . xcs . wx . util . XmlUtil ; import org . springframework . stereotype . Service ; @ Service public class AppletMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && ( subType == <NUM_LIT> || subType == <NUM_LIT> ) ; } @ Override public void process ( MsgVO msgVO ) { Opt . ofNullable ( msgVO . getCompressContent ( ) ) . map ( compressContent -> LZ4Util . decompress ( msgVO . getCompressContent ( ) ) ) . map ( xmlContent -> XmlUtil . parseXml ( xmlContent , CompressContentBO . class ) ) . ifPresent ( msgBO -> Opt . ofNullable ( msgBO . getAppMsg ( ) ) . ifPresent ( appMsg -> { WeAppInfoVO weAppInfoVO = new WeAppInfoVO ( ) ; weAppInfoVO . setTitle ( msgBO . getAppMsg ( ) . getTitle ( ) ) ; weAppInfoVO . setSourceDisplayName ( msgBO . getAppMsg ( ) . getSourceDisplayName ( ) ) ; msgVO . setWeAppInfo ( weAppInfoVO ) ;", "output": "CompressContentBO . AppMsg . WeAppInfo weAppInfo = appMsg . getWeAppInfo ( ) ; if ( weAppInfo != null ) { weAppInfoVO . setWeAppIconUrl ( weAppInfo . getWeAppIconUrl ( ) ) ; weAppInfoVO . setWeAppPageThumbRawUrl ( weAppInfo . getWeAppPageThumbRawUrl ( ) ) ; } } ) ) ; } }"}, {"input": "package com . yf . system . modules . dict . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . dict . entity . SysDic ; public interface SysDicMapper extends BaseMapper < SysDic > {", "output": "}"}, {"input": "package me . zhengjie . modules . security . security ; import cn . hutool . core . date . DateField ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . crypto . digest . DigestUtil ; import io . jsonwebtoken . * ; import io . jsonwebtoken . io . Decoders ; import io . jsonwebtoken . security . Keys ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . utils . RedisUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . userdetails . User ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . security . Key ; import java . util . * ; import java . util . concurrent . TimeUnit ; @ Slf4j @ Component public class TokenProvider implements InitializingBean { private final SecurityProperties properties ; private final RedisUtils redisUtils ; public static final String AUTHORITIES_KEY = \"<STR_LIT>\" ; private JwtParser jwtParser ; private JwtBuilder jwtBuilder ; public TokenProvider ( SecurityProperties properties , RedisUtils redisUtils ) { this . properties = properties ; this . redisUtils = redisUtils ; } @ Override public void afterPropertiesSet ( ) { byte [ ] keyBytes = Decoders . BASE64 . decode ( properties . getBase64Secret ( ) ) ; Key key = Keys . hmacShaKeyFor ( keyBytes ) ; jwtParser = Jwts . parserBuilder ( ) . setSigningKey ( key ) . build ( ) ; jwtBuilder = Jwts . builder ( ) . signWith ( key , SignatureAlgorithm . HS512 ) ; } public String createToken ( Authentication authentication ) { return jwtBuilder . setId ( IdUtil . simpleUUID ( ) ) . claim ( AUTHORITIES_KEY , authentication . getName ( ) ) . setSubject ( authentication . getName ( ) ) . compact ( ) ; } Authentication getAuthentication ( String token ) { Claims claims = getClaims ( token ) ; User principal = new User ( claims . getSubject ( ) , \"<STR_LIT>\" , new ArrayList < > ( ) ) ; return new UsernamePasswordAuthenticationToken ( principal , token , new ArrayList < > ( ) ) ; } public Claims getClaims ( String token ) { return jwtParser . parseClaimsJws ( token ) . getBody ( ) ; } public void checkRenewal ( String token ) { String loginKey = loginKey ( token ) ; long time = redisUtils . getExpire ( loginKey ) * <NUM_LIT> ; Date expireDate = DateUtil . offset ( new Date ( ) , DateField . MILLISECOND , ( int ) time ) ; long differ = expireDate . getTime ( ) - System . currentTimeMillis ( ) ; if ( differ <= properties . getDetect ( ) ) { long renew = time + properties . getRenew ( ) ; redisUtils . expire ( loginKey , renew , TimeUnit . MILLISECONDS ) ; } } public String getToken ( HttpServletRequest request ) { final String requestHeader = request . getHeader ( properties . getHeader ( ) ) ; if ( requestHeader != null && requestHeader . startsWith ( properties . getTokenStartWith ( ) ) ) { return requestHeader . substring ( <NUM_LIT> ) ; } return null ; } public String loginKey ( String token ) { Claims claims = getClaims ( token ) ; String md5Token = DigestUtil . md5Hex ( token ) ; return properties . getOnlineKey ( ) + claims . getSubject ( ) + \"<STR_LIT>\" + md5Token ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . config ; import cn . hutool . core . util . ArrayUtil ; import cn . hutool . extra . spring . SpringUtil ; import com . oddfar . campus . common . exception . ServiceException ; import org . springframework . aop . interceptor . AsyncUncaughtExceptionHandler ; import org . springframework . boot . autoconfigure . AutoConfiguration ; import org . springframework . scheduling . annotation . AsyncConfigurer ; import org . springframework . scheduling . annotation . EnableAsync ; import java . util . Arrays ; import java . util . concurrent . Executor ; @ EnableAsync ( proxyTargetClass = true ) @ AutoConfiguration public class AsyncConfig implements AsyncConfigurer { @ Override public Executor getAsyncExecutor ( ) { return SpringUtil . getBean ( \"<STR_LIT>\" ) ; } @ Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler ( ) { return ( throwable , method , objects ) -> { throwable . printStackTrace ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<STR_LIT>\" ) . append ( throwable . getMessage ( ) ) . append ( \"<STR_LIT>\" ) . append ( method . getName ( ) ) ; if ( ArrayUtil . isNotEmpty ( objects ) ) { sb . append ( \"<STR_LIT>\" ) . append ( Arrays . toString ( objects ) ) ; } throw new ServiceException ( sb . toString ( ) ) ;", "output": "} ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . bo . UserBO ; import com . xcs . wx . domain . vo . UserInfoVO ; import org . mapstruct . Mapper ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface UserMapping { UserInfoVO convert ( UserBO userBO ) ;", "output": "}"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . vo . * ; import com . xcs . wx . service . DashboardService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class DashboardController { private final DashboardService dashBoardService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < StatsPanelVO > statsPanel ( ) { return ResponseVO . ok ( dashBoardService . statsPanel ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < MsgTypeDistributionVO > > msgTypeDistribution ( ) {", "output": "return ResponseVO . ok ( dashBoardService . msgTypeDistribution ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < CountRecentMsgsVO > > countRecentMsgs ( ) { return ResponseVO . ok ( dashBoardService . countRecentMsgs ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < TopContactsVO > > topContacts ( ) { return ResponseVO . ok ( dashBoardService . topContacts ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < RecentUsedKeyWordVO > > queryRecentUsedKeyWord ( ) { return ResponseVO . ok ( dashBoardService . queryRecentUsedKeyWord ( ) ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class PayReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String orderId ;", "output": "}"}, {"input": "package com . yf . system . modules . depart . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . depart . dto . request . DepartQueryReqDTO ; import com . yf . system . modules . depart . dto . response . SysDepartTreeDTO ; import com . yf . system . modules . depart . entity . SysDepart ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysDepartMapper extends BaseMapper < SysDepart > {", "output": "List < SysDepartTreeDTO > tree ( @ Param ( \"<STR_LIT>\" ) DepartQueryReqDTO query ) ; }"}, {"input": "package ginyi . common . exception ; import ginyi . common . result . StateCode ; import lombok . Data ; @ Data public class UnPermissionException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ;", "output": "}"}, {"input": "package com . yf . system . modules . dict . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . dict . entity . SysDicValue ; import org . apache . ibatis . annotations . Param ; public interface SysDicValueMapper extends BaseMapper < SysDicValue > { String findDictText ( @ Param ( \"<STR_LIT>\" ) String dicCode , @ Param ( \"<STR_LIT>\" ) String value ) ;", "output": "String findTableText ( @ Param ( \"<STR_LIT>\" ) String dicTable , @ Param ( \"<STR_LIT>\" ) String dicText , @ Param ( \"<STR_LIT>\" ) String dicCode , @ Param ( \"<STR_LIT>\" ) String value ) ; }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class FillRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleClass ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleParams ;", "output": "}"}, {"input": "package com . yf . system . modules . user . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . Date ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserBindDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String userId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String loginType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String openId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Date createTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Date updateTime ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Set ; @ Mapper public interface DeployMapper extends BaseMapper < Deploy > { Long countAll ( @ Param ( \"<STR_LIT>\" ) DeployQueryCriteria criteria ) ; List < Deploy > findAll ( @ Param ( \"<STR_LIT>\" ) DeployQueryCriteria criteria ) ;", "output": "Set < Long > getIdByAppIds ( @ Param ( \"<STR_LIT>\" ) Set < Long > appIds ) ; Deploy getDeployById ( @ Param ( \"<STR_LIT>\" ) Long deployId ) ; }"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserQueryReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > roleIds ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String deptCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > excludes ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer state ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String mobile ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . listener ; import cn . hutool . core . util . StrUtil ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import com . oddfar . campus . common . utils . spring . AopTargetUtils ; import com . oddfar . campus . framework . api . resource . ResourceCollectorApi ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . beans . factory . config . BeanPostProcessor ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . List ; public class ApiResourceScanner implements BeanPostProcessor { @ Value ( \"<STR_LIT>\" ) private String springApplicationName ; private final ResourceCollectorApi resourceCollectorApi ; public ApiResourceScanner ( ResourceCollectorApi resourceCollectorApi ) { this . resourceCollectorApi = resourceCollectorApi ; } @ Override public Object postProcessBeforeInitialization ( Object bean , String beanName ) throws BeansException { return bean ; } @ Override public Object postProcessAfterInitialization ( Object bean , String beanName ) throws BeansException { Object aopTarget = AopTargetUtils . getTarget ( bean ) ; if ( aopTarget == null ) { aopTarget = bean ; } Class < ? > clazz = aopTarget . getClass ( ) ; boolean controllerFlag = getControllerFlag ( clazz ) ; if ( ! controllerFlag ) { return bean ; } ApiResource classApiAnnotation = clazz . getAnnotation ( ApiResource . class ) ; if ( classApiAnnotation != null ) { List < SysResourceEntity > apiResources = doScan ( clazz ) ; resourceCollectorApi . collectResources ( apiResources ) ; } return bean ; } private boolean getControllerFlag ( Class < ? > clazz ) { Annotation [ ] annotations = clazz . getAnnotations ( ) ; for ( Annotation annotation : annotations ) { if ( RestController . class . equals ( annotation . annotationType ( ) ) ) { return true ; } } return false ; } private List < SysResourceEntity > doScan ( Class < ? > clazz ) { ArrayList < SysResourceEntity > apiResources = new ArrayList < > ( ) ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; if ( declaredMethods . length > <NUM_LIT> ) { for ( Method declaredMethod : declaredMethods ) { Annotation annotation = null ; Annotation [ ] annotations = declaredMethod . getAnnotations ( ) ; for ( Annotation a : annotations ) { if ( a . toString ( ) . contains ( \"<STR_LIT>\" ) ) { annotation = a ; } } if ( annotation != null ) { SysResourceEntity definition = createDefinition ( clazz , declaredMethod , annotation ) ; apiResources . add ( definition ) ; } } } return apiResources ; } private SysResourceEntity createDefinition ( Class < ? > controllerClass , Method method , Annotation annotation ) { SysResourceEntity resource = new SysResourceEntity ( ) ;", "output": "resource . setClassName ( controllerClass . getSimpleName ( ) ) ; resource . setMethodName ( method . getName ( ) ) ; String className = resource . getClassName ( ) ; int controllerIndex = className . indexOf ( \"<STR_LIT>\" ) ; if ( controllerIndex == - <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } String modular = className . substring ( <NUM_LIT> , controllerIndex ) ; resource . setModular_code ( modular ) ; ApiResource apiResource = controllerClass . getAnnotation ( ApiResource . class ) ; resource . setResourceBizType ( apiResource . resBizType ( ) . getCode ( ) ) ; resource . setModularName ( apiResource . name ( ) ) ; if ( StrUtil . isNotBlank ( apiResource . appCode ( ) ) ) { resource . setAppCode ( apiResource . appCode ( ) ) ; } else { resource . setAppCode ( springApplicationName ) ; } String resourceCode = StrUtil . toUnderlineCase ( resource . getAppCode ( ) ) + \"<STR_LIT>\" + StrUtil . toUnderlineCase ( modular ) + \"<STR_LIT>\" + StrUtil . toUnderlineCase ( resource . getMethodName ( ) ) ; resource . setResourceCode ( resourceCode ) ; PreAuthorize preAuthorize = method . getAnnotation ( PreAuthorize . class ) ; resource . setRequiredPermissionFlag ( Constants . NO ) ; if ( preAuthorize != null ) { if ( preAuthorize . value ( ) . contains ( \"<STR_LIT>\" ) ) { resource . setRequiredPermissionFlag ( Constants . YES ) ; } } String name = invokeAnnotationMethod ( annotation , \"<STR_LIT>\" , String . class ) ; if ( StringUtils . isNotEmpty ( name ) ) { resource . setResourceName ( name ) ; } else { resource . setResourceName ( resource . getMethodName ( ) ) ; } String [ ] value = invokeAnnotationMethod ( annotation , \"<STR_LIT>\" , String [ ] . class ) ; String controllerMethodPath = createControllerPath ( controllerClass , value ) ; resource . setUrl ( controllerMethodPath ) ; resource . setHttpMethod ( StringUtils . substringBetween ( annotation . toString ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) . toLowerCase ( ) ) ; return resource ; } private String createControllerPath ( Class < ? > clazz , String [ ] paths ) { String path = \"<STR_LIT>\" ; if ( paths . length > <NUM_LIT> ) { path = \"<STR_LIT>\" + paths [ <NUM_LIT> ] ; } String controllerPath ; RequestMapping controllerRequestMapping = clazz . getDeclaredAnnotation ( RequestMapping . class ) ; if ( controllerRequestMapping == null ) { controllerPath = \"<STR_LIT>\" ; } else { String [ ] values = controllerRequestMapping . value ( ) ; if ( values . length > <NUM_LIT> ) { controllerPath = values [ <NUM_LIT> ] ; } else { controllerPath = \"<STR_LIT>\" ; } } if ( ! controllerPath . startsWith ( \"<STR_LIT>\" ) ) { controllerPath = \"<STR_LIT>\" + controllerPath ; } return ( controllerPath + path ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } private < T > T invokeAnnotationMethod ( Annotation apiResource , String methodName , Class < T > resultType ) { try { Class < ? extends Annotation > annotationType = apiResource . annotationType ( ) ; Method method = annotationType . getMethod ( methodName ) ; return ( T ) method . invoke ( apiResource ) ; } catch ( NoSuchMethodException | IllegalAccessException | InvocationTargetException e ) { } throw new RuntimeException ( \"<STR_LIT>\" ) ; } }"}, {"input": "package me . zhengjie . exception . handler ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . exception . EntityNotFoundException ; import me . zhengjie . utils . ThrowableUtil ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . authentication . BadCredentialsException ; import org . springframework . validation . FieldError ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ExceptionHandler ; import org . springframework . web . bind . annotation . RestControllerAdvice ; import static org . springframework . http . HttpStatus . * ; @ Slf4j @ RestControllerAdvice public class GlobalExceptionHandler { @ ExceptionHandler ( Throwable . class ) public ResponseEntity < ApiError > handleException ( Throwable e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( e . getMessage ( ) ) ) ; } @ ExceptionHandler ( BadCredentialsException . class ) public ResponseEntity < ApiError > badCredentialsException ( BadCredentialsException e ) { String message = \"<STR_LIT>\" . equals ( e . getMessage ( ) ) ? \"<STR_LIT>\" : e . getMessage ( ) ; log . error ( message ) ; return buildResponseEntity ( ApiError . error ( message ) ) ; } @ ExceptionHandler ( value = BadRequestException . class ) public ResponseEntity < ApiError > badRequestException ( BadRequestException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( e . getStatus ( ) , e . getMessage ( ) ) ) ; } @ ExceptionHandler ( value = EntityExistException . class ) public ResponseEntity < ApiError > entityExistException ( EntityExistException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( e . getMessage ( ) ) ) ; } @ ExceptionHandler ( value = EntityNotFoundException . class ) public ResponseEntity < ApiError > entityNotFoundException ( EntityNotFoundException e ) {", "output": "log . error ( ThrowableUtil . getStackTrace ( e ) ) ; return buildResponseEntity ( ApiError . error ( NOT_FOUND . value ( ) , e . getMessage ( ) ) ) ; } @ ExceptionHandler ( MethodArgumentNotValidException . class ) public ResponseEntity < ApiError > handleMethodArgumentNotValidException ( MethodArgumentNotValidException e ) { log . error ( ThrowableUtil . getStackTrace ( e ) ) ; ObjectError objectError = e . getBindingResult ( ) . getAllErrors ( ) . get ( <NUM_LIT> ) ; String message = objectError . getDefaultMessage ( ) ; if ( objectError instanceof FieldError ) { message = ( ( FieldError ) objectError ) . getField ( ) + \"<STR_LIT>\" + message ; } return buildResponseEntity ( ApiError . error ( message ) ) ; } private ResponseEntity < ApiError > buildResponseEntity ( ApiError apiError ) { return new ResponseEntity < > ( apiError , HttpStatus . valueOf ( apiError . getStatus ( ) ) ) ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformField extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbFieldNameOld ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbIsNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dbPointLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dbDefaultVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldHref ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer fieldLength ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldExtendJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fieldDefaultValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isQuery ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowList ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isReadOnly ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mainField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer orderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String converter ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDefVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryDictTable ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryShowType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryConfigFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryValidType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMustInput ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sortFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long importFlag ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveShowUnfold ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long moveSpan ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer moveShowSort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowColumn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isShowSearch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String uniteFormKey ; @ TableField ( exist = false ) private String jsEnhance ; public static CgformField init ( CgformField field , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ;", "output": "field . setCreateUser ( userId ) ; field . setCreateDept ( Long . parseLong ( deptId ) ) ; field . setCreateTime ( DateUtil . now ( ) ) ; field . setTenantId ( tenantId ) ; return field ; } }"}, {"input": "package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . domain . EmailConfig ; public interface EmailService extends IService < EmailConfig > { EmailConfig config ( EmailConfig emailConfig , EmailConfig old ) throws Exception ; EmailConfig find ( ) ; void send ( EmailVo emailVo , EmailConfig emailConfig ) ;", "output": "}"}, {"input": "package ginyi . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . UserVo ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysUserMapper extends BaseMapper < SysUser > { public SysUser selectUserByUserName ( String userName ) ; public SysUser checkUserNameUnique ( String userName ) ; public int insertUser ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public int insertUserPostIds ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public int insertUserRoleIds ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public int updateUser ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public int updateUserPostIds ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public int updateUserRoleIds ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public UserVo selectUserByUserId ( String userId ) ; public IPage < UserVo > list ( @ Param ( \"<STR_LIT>\" ) UserDto userDto , Page page ) ; public void updateUserStatus ( @ Param ( \"<STR_LIT>\" ) UserDto userDto ) ; public List < SysUser > selectUserByDeptIds ( List < Long > deptIds ) ;", "output": "}"}, {"input": "package com . yf . ability . shiro . dto ; import com . yf . base . api . annon . Dict ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserLoginDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String avatar ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String realName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String idCard ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String email ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String mobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer dataScope ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer roleLevel ; @ Dict ( dictTable = \"<STR_LIT>\" , dicCode = \"<STR_LIT>\" , dicText = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String deptCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer roleType ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Boolean realPerson ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer state ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > roles ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > permissions ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String token ;", "output": "}"}, {"input": "package top . kangert . kspider . domain ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . GenerationType ; import javax . persistence . Id ; import javax . persistence . Table ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; import top . kangert . kspider . entity . BaseEntity ; @ Table ( name = \"<STR_LIT>\" ) @ Entity @ Getter @ Setter @ ToString public class Variable extends BaseEntity { @ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) @ Column ( updatable = false ) private Long varId ; private String name ; private String val ; private String description ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; @ Data @ AllArgsConstructor public class UserVO { private String wxId ; private String nickname ; private String avatar ; private boolean current ;", "output": "}"}, {"input": "package me . zhengjie . annotation ; import me . zhengjie . aspect . LimitType ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface Limit {", "output": "String name ( ) default \"<STR_LIT>\" ; String key ( ) default \"<STR_LIT>\" ; String prefix ( ) default \"<STR_LIT>\" ; int period ( ) ; int count ( ) ; LimitType limitType ( ) default LimitType . CUSTOMER ; }"}, {"input": "package io . github . chensheng . dddboot . tools . text ; import com . google . common . hash . Hashing ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . io . IOException ; import java . io . InputStream ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; import java . util . zip . CRC32 ; public class HashUtil { public static final int MURMUR_SEED = <NUM_LIT> ; private static final ThreadLocal < MessageDigest > MD5_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static final ThreadLocal < MessageDigest > SHA_1_DIGEST = createThreadLocalMessageDigest ( \"<STR_LIT>\" ) ; private static SecureRandom random = new SecureRandom ( ) ; private static ThreadLocal < MessageDigest > createThreadLocalMessageDigest ( final String digest ) { return new ThreadLocal < MessageDigest > ( ) { @ Override protected MessageDigest initialValue ( ) { try { return MessageDigest . getInstance ( digest ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( \"<STR_LIT>\" + digest + '<STR_LIT>' , e ) ; } } } ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input ) { return digest ( input , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , null , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , <NUM_LIT> ) ; } public static byte [ ] sha1 ( @ NotNull byte [ ] input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input , get ( SHA_1_DIGEST ) , salt , iterations ) ; } public static byte [ ] sha1 ( @ NotNull String input , @ Nullable byte [ ] salt , int iterations ) { return digest ( input . getBytes ( Charsets . UTF_8 ) , get ( SHA_1_DIGEST ) , salt , iterations ) ; } private static MessageDigest get ( ThreadLocal < MessageDigest > messageDigest ) { MessageDigest instance = messageDigest . get ( ) ; instance . reset ( ) ; return instance ; } private static byte [ ] digest ( @ NotNull byte [ ] input , MessageDigest digest , byte [ ] salt , int iterations ) { if ( salt != null ) { digest . update ( salt ) ; } byte [ ] result = digest . digest ( input ) ; for ( int i = <NUM_LIT> ; i < iterations ; i ++ ) { digest . reset ( ) ; result = digest . digest ( result ) ; } return result ; } public static byte [ ] generateSalt ( int numBytes ) { Validate . isTrue ( numBytes > <NUM_LIT> , \"<STR_LIT>\" , numBytes ) ; byte [ ] bytes = new byte [ numBytes ] ; random . nextBytes ( bytes ) ; return bytes ; } public static byte [ ] sha1File ( InputStream input ) throws IOException { return digestFile ( input , get ( SHA_1_DIGEST ) ) ; } public static byte [ ] md5File ( InputStream input ) throws IOException { return digestFile ( input , get ( MD5_DIGEST ) ) ; } private static byte [ ] digestFile ( InputStream input , MessageDigest messageDigest ) throws IOException { int bufferLength = <NUM_LIT> * <NUM_LIT> ; byte [ ] buffer = new byte [ bufferLength ] ; int read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; while ( read > - <NUM_LIT> ) { messageDigest . update ( buffer , <NUM_LIT> , read ) ; read = input . read ( buffer , <NUM_LIT> , bufferLength ) ; } return messageDigest . digest ( ) ;", "output": "} public static int crc32AsInt ( @ NotNull String input ) { return crc32AsInt ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static int crc32AsInt ( @ NotNull byte [ ] input ) { CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( input ) ; return ( int ) crc32 . getValue ( ) ; } public static long crc32AsLong ( @ NotNull String input ) { return crc32AsLong ( input . getBytes ( Charsets . UTF_8 ) ) ; } public static long crc32AsLong ( @ NotNull byte [ ] input ) { CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( input ) ; return crc32 . getValue ( ) ; } public static int murmur32AsInt ( @ NotNull byte [ ] input ) { return Hashing . murmur3_32 ( MURMUR_SEED ) . hashBytes ( input ) . asInt ( ) ; } public static int murmur32AsInt ( @ NotNull String input ) { return Hashing . murmur3_32 ( MURMUR_SEED ) . hashString ( input , Charsets . UTF_8 ) . asInt ( ) ; } public static long murmur128AsLong ( @ NotNull byte [ ] input ) { return Hashing . murmur3_128 ( MURMUR_SEED ) . hashBytes ( input ) . asLong ( ) ; } public static long murmur128AsLong ( @ NotNull String input ) { return Hashing . murmur3_128 ( MURMUR_SEED ) . hashString ( input , Charsets . UTF_8 ) . asLong ( ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class BaseListDTO < T > implements Serializable { @ JsonIgnore private String userId ; private List < T > items ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . rest ; import cn . hutool . core . collection . CollectionUtil ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . modules . system . domain . Menu ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . vo . MenuVo ; import me . zhengjie . modules . system . service . MenuService ; import me . zhengjie . modules . system . domain . vo . MenuQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . util . * ; import java . util . stream . Collectors ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class MenuController { private final MenuService menuService ; private static final String ENTITY_NAME = \"<STR_LIT>\" ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportMenu ( HttpServletResponse response , MenuQueryCriteria criteria ) throws Exception { menuService . download ( menuService . queryAll ( criteria , false ) , response ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < List < MenuVo > > buildMenus ( ) { List < Menu > menuList = menuService . findByUser ( SecurityUtils . getCurrentUserId ( ) ) ; List < Menu > menus = menuService . buildTree ( menuList ) ; return new ResponseEntity < > ( menuService . buildMenus ( menus ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < List < Menu > > queryAllMenu ( @ RequestParam Long pid ) { return new ResponseEntity < > ( menuService . getMenus ( pid ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > childMenu ( @ RequestParam Long id ) { Set < Menu > menuSet = new HashSet < > ( ) ; List < Menu > menuList = menuService . getMenus ( id ) ; menuSet . add ( menuService . getById ( id ) ) ; menuSet = menuService . getChildMenus ( menuList , menuSet ) ; Set < Long > ids = menuSet . stream ( ) . map ( Menu :: getId ) . collect ( Collectors . toSet ( ) ) ; return new ResponseEntity < > ( ids , HttpStatus . OK ) ; } @ GetMapping @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Menu > > queryMenu ( MenuQueryCriteria criteria ) throws Exception { List < Menu > menuList = menuService . queryAll ( criteria , true ) ; return new ResponseEntity < > ( PageUtil . toPage ( menuList ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < List < Menu > > getMenuSuperior ( @ RequestBody List < Long > ids ) { Set < Menu > menus = new LinkedHashSet < > ( ) ; if ( CollectionUtil . isNotEmpty ( ids ) ) { for ( Long id : ids ) { Menu menu = menuService . findById ( id ) ; List < Menu > menuList = menuService . getSuperior ( menu , new ArrayList < > ( ) ) ; for ( Menu data : menuList ) { if ( data . getId ( ) . equals ( menu . getPid ( ) ) ) { data . setSubCount ( data . getSubCount ( ) - <NUM_LIT> ) ; } } menus . addAll ( menuList ) ; } menus = menus . stream ( ) . filter ( i -> ! ids . contains ( i . getId ( ) ) ) . collect ( Collectors . toSet ( ) ) ; return new ResponseEntity < > ( menuService . buildTree ( new ArrayList < > ( menus ) ) , HttpStatus . OK ) ; } return new ResponseEntity < > ( menuService . getMenus ( null ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createMenu ( @ Validated @ RequestBody Menu resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( \"<STR_LIT>\" + ENTITY_NAME + \"<STR_LIT>\" ) ; } menuService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; }", "output": "@ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateMenu ( @ Validated ( Menu . Update . class ) @ RequestBody Menu resources ) { menuService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteMenu ( @ RequestBody Set < Long > ids ) { Set < Menu > menuSet = new HashSet < > ( ) ; for ( Long id : ids ) { List < Menu > menuList = menuService . getMenus ( id ) ; menuSet . add ( menuService . getById ( id ) ) ; menuSet = menuService . getChildMenus ( menuList , menuSet ) ; } menuService . delete ( menuSet ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package ginyi . server . admin . controller ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import ginyi . common . annotation . Log ; import ginyi . common . enums . BusinessType ; import ginyi . common . result . CommonResult ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . SysDept ; import ginyi . system . domain . model . dto . DeptDto ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . DeptVo ; import ginyi . system . service . ISysDeptService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; import java . util . Set ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysDeptController { @ Resource private ISysDeptService deptService ; @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . DELETE ) public CommonResult delete ( @ PathVariable ( \"<STR_LIT>\" ) Long deptId ) { deptService . removeDeptById ( deptId ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . DELETE ) public CommonResult delete ( @ RequestBody Set < Long > ids ) { deptService . removeDeptByIds ( ids ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < DeptVo > getDeptByDeptId ( @ PathVariable ( \"<STR_LIT>\" ) Long deptId ) { DeptVo deptVo = deptService . getDeptByDeptId ( deptId ) ; return CommonResult . success ( deptVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult < BaseVo < SysDept > > list ( @ RequestBody DeptDto deptDto , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long page , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long pageSize ) { BaseVo < SysDept > list = deptService . list ( deptDto , page , pageSize ) ; return CommonResult . success ( list ) ;", "output": "} @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . INSERT ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult addDept ( @ RequestBody @ Validated ( AddGroup . class ) DeptDto deptDto ) { deptService . addDept ( deptDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . UPDATE ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult update ( @ RequestBody @ Validated ( UpdateGroup . class ) DeptDto deptDto ) { deptService . updateDept ( deptDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . UPDATE ) @ ApiOperationSupport ( includeParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public CommonResult updateStatus ( @ RequestBody DeptDto deptDto ) { deptService . updateStatus ( deptDto ) ; return CommonResult . success ( ) ; } }"}, {"input": "package com . xcs . wx . repository ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . xcs . wx . domain . dto . ContactDTO ; import com . xcs . wx . domain . vo . AllContactVO ; import com . xcs . wx . domain . vo . ContactVO ; import com . xcs . wx . domain . vo . ExportContactVO ; import java . util . List ; import java . util . Map ; import java . util . Set ; public interface ContactRepository { Page < ContactVO > queryContact ( ContactDTO contactDTO ) ; List < AllContactVO > queryAllContact ( ) ;", "output": "String getContactNickname ( String userName ) ; String getNickName ( String userName ) ; Set < String > getContactWithMp ( ) ; Map < String , String > getContactNickname ( List < String > userNames ) ; int countContact ( ) ; List < ExportContactVO > exportContact ( ) ; }"}, {"input": "package com . yf . system . modules . plugin . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class PluginSchemaDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String schemaData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String groupId ;", "output": "}"}, {"input": "package top . kangert . kspider . domain ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; import top . kangert . kspider . entity . BaseEntity ; import javax . persistence . Column ; import javax . persistence . Entity ; import javax . persistence . GeneratedValue ; import javax . persistence . GenerationType ; import javax . persistence . Id ; import javax . persistence . Table ; @ Table ( name = \"<STR_LIT>\" ) @ Entity @ Getter @ Setter @ ToString public class Function extends BaseEntity { @ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) @ Column ( updatable = false ) private Long funcId ; private String name ; private String parameter ; @ Column ( columnDefinition = \"<STR_LIT>\" ) private String script ;", "output": "}"}, {"input": "package com . youlai . system . controller ; import com . youlai . system . common . result . Result ; import com . youlai . system . model . dto . FileInfo ; import com . youlai . system . service . OssService ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import io . swagger . v3 . oas . annotations . Operation ; import lombok . RequiredArgsConstructor ; import lombok . SneakyThrows ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class FileController { private final OssService ossService ; @ PostMapping @ Operation ( summary = \"<STR_LIT>\" ) public Result < FileInfo > uploadFile ( @ Parameter ( description = \"<STR_LIT>\" ) @ RequestParam ( value = \"<STR_LIT>\" ) MultipartFile file ) { FileInfo fileInfo = ossService . uploadFile ( file ) ;", "output": "return Result . success ( fileInfo ) ; } @ DeleteMapping @ Operation ( summary = \"<STR_LIT>\" ) @ SneakyThrows public Result deleteFile ( @ Parameter ( description = \"<STR_LIT>\" ) @ RequestParam String filePath ) { boolean result = ossService . deleteFile ( filePath ) ; return Result . judge ( result ) ; } }"}, {"input": "package ginyi . common . utils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; public class Threads { private static final Logger logger = LoggerFactory . getLogger ( Threads . class ) ; public static void sleep ( long milliseconds ) { try { Thread . sleep ( milliseconds ) ; } catch ( InterruptedException e ) { return ;", "output": "} } public static void shutdownAndAwaitTermination ( ExecutorService pool ) { if ( pool != null && ! pool . isShutdown ( ) ) { pool . shutdown ( ) ; try { if ( ! pool . awaitTermination ( <NUM_LIT> , TimeUnit . SECONDS ) ) { pool . shutdownNow ( ) ; if ( ! pool . awaitTermination ( <NUM_LIT> , TimeUnit . SECONDS ) ) { logger . info ( \"<STR_LIT>\" ) ; } } } catch ( InterruptedException ie ) { pool . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } } public static void printException ( Runnable r , Throwable t ) { if ( t == null && r instanceof Future < ? > ) { try { Future < ? > future = ( Future < ? > ) r ; if ( future . isDone ( ) ) { future . get ( ) ; } } catch ( CancellationException ce ) { t = ce ; } catch ( ExecutionException ee ) { t = ee . getCause ( ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; } } if ( t != null ) { logger . error ( t . getMessage ( ) , t ) ; } } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import org . apache . ibatis . type . ByteArrayTypeHandler ; @ Data @ TableName ( value = \"<STR_LIT>\" , autoResultMap = true ) public class HardLinkImageAttribute { @ TableId ( \"<STR_LIT>\" ) private Long md5Hash ; @ TableField ( \"<STR_LIT>\" ) private String dirId1 ; @ TableField ( \"<STR_LIT>\" ) private String dirId2 ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] md5 ; @ TableField ( \"<STR_LIT>\" ) private String modifyTime ; @ TableField ( \"<STR_LIT>\" ) private String fileName ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class ProxyChildParam extends Query { private String UID ; private String startDate ; private String endDate ;", "output": "}"}, {"input": "package com . yf . system . modules . user . dto ; import com . yf . base . api . annon . Dict ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String avatar ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String realName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String password ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String salt ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer state ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idCard ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String email ; @ Dict ( dictTable = \"<STR_LIT>\" , dicCode = \"<STR_LIT>\" , dicText = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date createTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date updateTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String createBy ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String updateBy ;", "output": "}"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Notice ; import cn . org . alan . exam . model . form . NoticeForm ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . model . vo . NoticeVO ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface NoticeConverter {", "output": "Notice formToEntity ( NoticeForm noticeForm ) ; Page < NoticeVO > pageEntityToVo ( Page < Notice > noticePage ) ; NoticeVO NoticeToNoticeVO ( Notice notice ) ; }"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . dto . ChatRoomDTO ; import com . xcs . wx . domain . vo . ChatRoomDetailVO ; import com . xcs . wx . domain . vo . ChatRoomVO ; import com . xcs . wx . domain . vo . PageVO ; public interface ChatRoomService { PageVO < ChatRoomVO > queryChatRoom ( ChatRoomDTO chatRoomDTO ) ; ChatRoomDetailVO queryChatRoomDetail ( String chatRoomName ) ;", "output": "String exportChatRoom ( ) ; }"}, {"input": "package me . zhengjie . exception ; import lombok . Getter ; import org . springframework . http . HttpStatus ; import static org . springframework . http . HttpStatus . BAD_REQUEST ; @ Getter public class BadRequestException extends RuntimeException { private Integer status = BAD_REQUEST . value ( ) ; public BadRequestException ( String msg ) { super ( msg ) ; } public BadRequestException ( HttpStatus status , String msg ) { super ( msg ) ; this . status = status . value ( ) ;", "output": "} }"}, {"input": "package com . yf . system . modules . menu . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . menu . dto . response . MenuTreeRespDTO ; import com . yf . system . modules . menu . dto . response . RouteRespDTO ; import com . yf . system . modules . menu . entity . SysMenu ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysMenuMapper extends BaseMapper < SysMenu > { List < MenuTreeRespDTO > listTree ( ) ; List < RouteRespDTO > listMenuByRoles ( @ Param ( \"<STR_LIT>\" ) List < String > roleIds ) ; List < String > listPermissionByRoles ( @ Param ( \"<STR_LIT>\" ) List < String > roleIds ) ; int findMaxSort ( @ Param ( \"<STR_LIT>\" ) String parentId ) ;", "output": "int incrSort ( @ Param ( \"<STR_LIT>\" ) String parentId , @ Param ( \"<STR_LIT>\" ) int start ) ; }"}, {"input": "package com . yf . system . modules . config . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . yf . system . modules . config . entity . CfgSwitch ; import com . yf . system . modules . config . mapper . CfgSwitchMapper ; import com . yf . system . modules . config . service . CfgSwitchService ; import com . yf . base . utils . CacheKey ; import org . springframework . cache . annotation . CacheEvict ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . util . CollectionUtils ; import org . springframework . util . StringUtils ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Service public class CfgSwitchServiceImpl extends ServiceImpl < CfgSwitchMapper , CfgSwitch > implements CfgSwitchService { @ Cacheable ( value = CacheKey . SWITCH , key = \"<STR_LIT>\" ) @ Override public Map < String , Object > allMap ( ) { Map < String , Object > map = new HashMap < > ( ) ; List < CfgSwitch > list = this . list ( ) ; if ( ! CollectionUtils . isEmpty ( list ) ) { for ( CfgSwitch item : list ) { String val = item . getVal ( ) ; if ( \"<STR_LIT>\" . equals ( val ) || \"<STR_LIT>\" . equals ( val ) ) { map . put ( item . getId ( ) , Boolean . valueOf ( val ) ) ; continue ; } if ( \"<STR_LIT>\" . equals ( val ) || \"<STR_LIT>\" . equals ( val ) ) { map . put ( item . getId ( ) , Integer . parseInt ( val ) ) ; continue ; } map . put ( item . getId ( ) , val ) ; } } return map ; } @ Cacheable ( value = CacheKey . SWITCH , key = \"<STR_LIT>\" ) @ Override public Boolean isOn ( String id ) { CfgSwitch cfgSwitch = this . getById ( id ) ; return cfgSwitch != null && ! StringUtils . isEmpty ( cfgSwitch . getVal ( ) ) && ( \"<STR_LIT>\" . equals ( cfgSwitch . getVal ( ) ) || \"<STR_LIT>\" . equals ( cfgSwitch . getVal ( ) ) ) ; } @ Cacheable ( value = CacheKey . SWITCH , key = \"<STR_LIT>\" ) @ Override public String val ( String id ) { CfgSwitch cfgSwitch = this . getById ( id ) ; if ( cfgSwitch != null ) { return cfgSwitch . getVal ( ) ; } return \"<STR_LIT>\" ; } @ CacheEvict ( value = CacheKey . SWITCH , allEntries = true ) @ Override public void save ( Map < String , Object > map ) { if ( map == null || map . isEmpty ( ) ) { return ; } List < CfgSwitch > list = this . list ( ) ; for ( String key : map . keySet ( ) ) { CfgSwitch item = new CfgSwitch ( ) ; item . setId ( key ) ; item . setVal ( String . valueOf ( map . get ( key ) ) ) ; list . add ( item ) ;", "output": "} this . saveOrUpdateBatch ( list ) ; } }"}, {"input": "package top . kangert . kspider . util ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . io . SeleniumResponse ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class SeleniumResponseHolder { private static Map < String , List < SeleniumResponse > > driverMap = new ConcurrentHashMap < > ( ) ; public static void clear ( SpiderContext context ) { List < SeleniumResponse > responses = driverMap . get ( context . getId ( ) ) ; if ( responses != null ) {", "output": "for ( SeleniumResponse response : responses ) { response . quit ( ) ; } } driverMap . remove ( context . getId ( ) ) ; } public synchronized static void add ( SpiderContext context , SeleniumResponse response ) { driverMap . computeIfAbsent ( context . getId ( ) , k -> new ArrayList < > ( ) ) . add ( response ) ; } }"}, {"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserQueryService ; import org . example . ddduser . domain . repository . SecurityRepository ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserQueryServiceImpl implements UserQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private SecurityRepository securityRepository ; @ Autowired private UserConvertor userConvertor ; @ Override public UserProfile profile ( ) { Long userId = securityRepository . findLoginUser ( ) ; UserEntity userEntity = userRepository . find ( userId ) ; return userConvertor . toDto ( userEntity ) ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . binder ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . properties . config . NacosConfigurationPropertiesBinder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . beans . factory . support . RootBeanDefinition ; import org . springframework . boot . context . properties . bind . Bindable ; import org . springframework . boot . context . properties . bind . Binder ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . ResolvableType ; import org . springframework . core . env . StandardEnvironment ; import java . lang . reflect . Method ; public class NacosBootConfigurationPropertiesBinder extends NacosConfigurationPropertiesBinder { private final ConfigurableApplicationContext applicationContext ; private final StandardEnvironment environment = new StandardEnvironment ( ) ; public NacosBootConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { super ( applicationContext ) ; this . applicationContext = applicationContext ; } @ Override protected void doBind ( Object bean , String beanName , String dataId , String groupId , String configType , NacosConfigurationProperties properties , String content , ConfigService configService ) { synchronized ( this ) { String name = \"<STR_LIT>\" + beanName ; NacosPropertySource propertySource = new NacosPropertySource ( dataId , groupId , name , content , configType ) ; environment . getPropertySources ( ) . addLast ( propertySource ) ; ObjectUtils . cleanMapOrCollectionField ( bean ) ; Binder binder = Binder . get ( environment ) ; ResolvableType type = getBeanType ( bean , beanName ) ; Bindable < ? > target = Bindable . of ( type ) . withExistingValue ( bean ) ; binder . bind ( properties . prefix ( ) , target ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; environment . getPropertySources ( ) . remove ( name ) ; } } private ResolvableType getBeanType ( Object bean , String beanName ) { Method factoryMethod = findFactoryMethod ( beanName ) ; if ( factoryMethod != null ) { return ResolvableType . forMethodReturnType ( factoryMethod ) ; } return ResolvableType . forClass ( bean . getClass ( ) ) ; } public Method findFactoryMethod ( String beanName ) { ConfigurableListableBeanFactory beanFactory = this . applicationContext . getBeanFactory ( ) ; if ( beanFactory . containsBeanDefinition ( beanName ) ) { BeanDefinition beanDefinition = beanFactory . getMergedBeanDefinition ( beanName ) ;", "output": "if ( beanDefinition instanceof RootBeanDefinition ) { return ( ( RootBeanDefinition ) beanDefinition ) . getResolvedFactoryMethod ( ) ; } } return null ; } }"}, {"input": "package com . youlai . system . model . vo ; import com . fasterxml . jackson . annotation . JsonFormat ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . util . Date ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class UserPageVO { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private String username ; @ Schema ( description = \"<STR_LIT>\" ) private String nickname ; @ Schema ( description = \"<STR_LIT>\" ) private String mobile ; @ Schema ( description = \"<STR_LIT>\" ) private String genderLabel ; @ Schema ( description = \"<STR_LIT>\" ) private String avatar ; @ Schema ( description = \"<STR_LIT>\" ) private String email ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" ) private String deptName ; @ Schema ( description = \"<STR_LIT>\" ) private String roleNames ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonFormat ( pattern = \"<STR_LIT>\" ) private Date createTime ;", "output": "}"}, {"input": "package org . example . domain . example . valueobject ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Builder ; import lombok . Getter ; @ Getter @ Builder public class ExampleAddress { private String country ; private String province ; private String city ; private String county ; private String detail ; public ExampleAddress ( String country , String province , String city , String county , String detail ) { if ( TextUtil . isNotBlank ( detail ) && ( TextUtil . isBlank ( country ) || TextUtil . isBlank ( province ) || TextUtil . isBlank ( city ) || TextUtil . isBlank ( county ) ) ) { throw new BizException ( \"<STR_LIT>\" ) ; } this . country = country ; this . province = province ; this . city = city ; this . county = county ; this . detail = detail ; }", "output": "public String getFullAddress ( ) { if ( TextUtil . isBlank ( detail ) ) { return null ; } return country + province + city + county + detail ; } }"}, {"input": "package ginyi . system . domain . model . vo ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data @ ApiModel ( \"<STR_LIT>\" ) public class UserVo extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long userId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String userName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long deptId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String nickName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String email ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phoneNumber ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String sex ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String avatar ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String password ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > postIds ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > roleIds ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . base . type ; public class UncheckedException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; public UncheckedException ( Throwable wrapped ) { super ( wrapped ) ;", "output": "} @ Override public String getMessage ( ) { return super . getCause ( ) . getMessage ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import java . lang . reflect . Field ; public class DataCellConfig { private int index ; private Field field ; private String format ; private CellValueType type ; private CellStyleConfig style ; public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } public Field getField ( ) { return field ;", "output": "} public void setField ( Field field ) { this . field = field ; } public String getFormat ( ) { return format ; } public void setFormat ( String format ) { this . format = format ; } public CellValueType getType ( ) { return type ; } public void setType ( CellValueType type ) { this . type = type ; } public CellStyleConfig getStyle ( ) { return style ; } public void setStyle ( CellStyleConfig style ) { this . style = style ; } }"}, {"input": "package com . oddfar . campus . common . domain . model ; import lombok . Data ; @ Data public class RegisterBody extends LoginBody { private String email ;", "output": "}"}, {"input": "package org . springblade . web . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . IdWorker ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . WalletConstant ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . log . exception . ServiceException ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . entity . * ; import org . springblade . plugin . message . feign . IMessageClient ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springblade . web . config . engine . contract . CoinMatchContractFactory ; import org . springblade . web . config . engine . contract . CoinMatchContractFactoryAll ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchange ; import org . springblade . web . config . engine . exchange . CoinMatchFactoryExchangeAll ; import org . springblade . web . model . param . TransParam ; import org . springblade . web . service . IMongoService ; import org . springblade . web . service . IWalletService ; import org . springblade . web . service . IWebService ; import org . springblade . web . utils . GeneratorUtil ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Lazy ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Service public class WalletServiceImpl implements IWalletService { @ Autowired private IMjkjBaseSqlService mjkjBaseSqlService ; @ Autowired private IWebService webService ; @ Autowired private IMongoService mongoService ; @ Autowired private IMessageClient messageClient ; @ Autowired private CoinMatchFactoryExchange coinMatchFactoryExchange ; @ Autowired private CoinMatchFactoryExchangeAll coinMatchFactoryXhqc ; @ Autowired private CoinMatchContractFactory coinMatchContractFactory ; @ Autowired private CoinMatchContractFactoryAll coinMatchContractFactoryAll ; @ Override public Map < String , Object > getWalletMap ( String type , String memberId , String coinId ) { if ( Func . isEmpty ( coinId ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } if ( Func . isEmpty ( type ) ) { type = WalletConstant . WALLET_TYPE_SPOT ; } String marginCode = \"<STR_LIT>\" ; String tableName = \"<STR_LIT>\" ; if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SPOT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARGIN_FIXED ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MAGIN_ALL ) ) { tableName = \"<STR_LIT>\" ; marginCode = GeneratorUtil . getOrderId ( \"<STR_LIT>\" ) ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WALLET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_SERVICE ) ) { tableName = \"<STR_LIT>\" ; Map < String , Object > serviceMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , memberId ) ; if ( Func . isNotEmpty ( serviceMap ) ) { memberId = MjkjUtils . getMap2Str ( serviceMap , \"<STR_LIT>\" ) ; } } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_CONTRACT ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_MARKET ) ) { tableName = \"<STR_LIT>\" ; } else if ( Func . equals ( type , WalletConstant . WALLET_TYPE_WEALTH ) ) { tableName = \"<STR_LIT>\" ; } QueryWrapper < Object > wrapper = new QueryWrapper < > ( ) ; wrapper . eq ( \"<STR_LIT>\" , memberId ) ; wrapper . eq ( \"<STR_LIT>\" , <NUM_LIT> ) ; wrapper . eq ( \"<STR_LIT>\" , coinId ) ; Map < String , Object > walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isEmpty ( walletMap ) ) { synchronized ( this ) { walletMap = mjkjBaseSqlService . getDataOneByFieldParams ( tableName , wrapper ) ; if ( Func . isNotEmpty ( walletMap ) ) { return walletMap ; } Map < String , Object > coinCoin = mjkjBaseSqlService . getTableById ( \"<STR_LIT>\" , coinId ) ; Map < String , Object > insertMap = new HashMap < > ( ) ; insertMap . put ( \"<STR_LIT>\" , IdWorker . getId ( ) ) ; insertMap . put ( \"<STR_LIT>\" , memberId ) ; insertMap . put ( \"<STR_LIT>\" , coinId ) ; insertMap . put ( \"<STR_LIT>\" , MjkjUtils . getMap2Str ( coinCoin , \"<STR_LIT>\" ) ) ; insertMap . put ( \"<STR_LIT>\" , BigDecimal . ZERO ) ; insertMap . put ( \"<STR_LIT>\" , BigDecimal . ZERO ) ;", "output": "if ( Func . isNotEmpty ( marginCode ) ) { insertMap . put ( \"<STR_LIT>\" , marginCode ) ; } mjkjBaseSqlService . baseInsertData ( tableName , insertMap ) ; return insertMap ; } } return walletMap ; } }"}, {"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . DesformHead ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; public interface IDesformHeadService extends BaseService < DesformHead > {", "output": "List < DesformHead > openList ( ) ; }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . ManualScore ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface ManualScoreMapper extends BaseMapper < ManualScore > { Integer deleteByUserIds ( List < Integer > userIds ) ; Integer insertList ( List < ManualScore > manualScores ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . service . impl ; import cn . hutool . core . date . BetweenFormatter . Level ; import cn . hutool . core . date . DateUtil ; import me . zhengjie . modules . system . service . MonitorService ; import me . zhengjie . utils . ElConstant ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . StringUtils ; import org . springframework . stereotype . Service ; import oshi . SystemInfo ; import oshi . hardware . * ; import oshi . software . os . FileSystem ; import oshi . software . os . OSFileStore ; import oshi . software . os . OperatingSystem ; import oshi . util . FormatUtil ; import oshi . util . Util ; import java . lang . management . ManagementFactory ; import java . text . DecimalFormat ; import java . util . * ; @ Service public class MonitorServiceImpl implements MonitorService { private final DecimalFormat df = new DecimalFormat ( \"<STR_LIT>\" ) ; @ Override public Map < String , Object > getServers ( ) { Map < String , Object > resultMap = new LinkedHashMap < > ( <NUM_LIT> ) ; try { SystemInfo si = new SystemInfo ( ) ; OperatingSystem os = si . getOperatingSystem ( ) ; HardwareAbstractionLayer hal = si . getHardware ( ) ; resultMap . put ( \"<STR_LIT>\" , getSystemInfo ( os ) ) ; resultMap . put ( \"<STR_LIT>\" , getCpuInfo ( hal . getProcessor ( ) ) ) ; resultMap . put ( \"<STR_LIT>\" , getMemoryInfo ( hal . getMemory ( ) ) ) ; resultMap . put ( \"<STR_LIT>\" , getSwapInfo ( hal . getMemory ( ) ) ) ; resultMap . put ( \"<STR_LIT>\" , getDiskInfo ( os ) ) ; resultMap . put ( \"<STR_LIT>\" , DateUtil . format ( new Date ( ) , \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return resultMap ; } private Map < String , Object > getDiskInfo ( OperatingSystem os ) { Map < String , Object > diskInfo = new LinkedHashMap < > ( ) ; FileSystem fileSystem = os . getFileSystem ( ) ; List < OSFileStore > fsArray = fileSystem . getFileStores ( ) ; String osName = System . getProperty ( \"<STR_LIT>\" ) ; long available = <NUM_LIT> , total = <NUM_LIT> ; for ( OSFileStore fs : fsArray ) { if ( osName . toLowerCase ( ) . startsWith ( ElConstant . WIN ) ) { available += fs . getUsableSpace ( ) ; total += fs . getTotalSpace ( ) ; } else { available = fs . getUsableSpace ( ) ; total = fs . getTotalSpace ( ) ; break ; } } long used = total - available ; diskInfo . put ( \"<STR_LIT>\" , total > <NUM_LIT> ? FileUtil . getSize ( total ) : \"<STR_LIT>\" ) ; diskInfo . put ( \"<STR_LIT>\" , FileUtil . getSize ( available ) ) ; diskInfo . put ( \"<STR_LIT>\" , FileUtil . getSize ( used ) ) ; if ( total != <NUM_LIT> ) { diskInfo . put ( \"<STR_LIT>\" , df . format ( used / ( double ) total * <NUM_LIT> ) ) ; } else { diskInfo . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; } return diskInfo ; } private Map < String , Object > getSwapInfo ( GlobalMemory memory ) { Map < String , Object > swapInfo = new LinkedHashMap < > ( ) ; VirtualMemory virtualMemory = memory . getVirtualMemory ( ) ; long total = virtualMemory . getSwapTotal ( ) ; long used = virtualMemory . getSwapUsed ( ) ; swapInfo . put ( \"<STR_LIT>\" , FormatUtil . formatBytes ( total ) ) ; swapInfo . put ( \"<STR_LIT>\" , FormatUtil . formatBytes ( used ) ) ; swapInfo . put ( \"<STR_LIT>\" , FormatUtil . formatBytes ( total - used ) ) ; if ( used == <NUM_LIT> ) { swapInfo . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; } else { swapInfo . put ( \"<STR_LIT>\" , df . format ( used / ( double ) total * <NUM_LIT> ) ) ; } return swapInfo ; } private Map < String , Object > getMemoryInfo ( GlobalMemory memory ) { Map < String , Object > memoryInfo = new LinkedHashMap < > ( ) ; memoryInfo . put ( \"<STR_LIT>\" , FormatUtil . formatBytes ( memory . getTotal ( ) ) ) ; memoryInfo . put ( \"<STR_LIT>\" , FormatUtil . formatBytes ( memory . getAvailable ( ) ) ) ; memoryInfo . put ( \"<STR_LIT>\" , FormatUtil . formatBytes ( memory . getTotal ( ) - memory . getAvailable ( ) ) ) ; memoryInfo . put ( \"<STR_LIT>\" , df . format ( ( memory . getTotal ( ) - memory . getAvailable ( ) ) / ( double ) memory . getTotal ( ) * <NUM_LIT> ) ) ; return memoryInfo ; } private Map < String , Object > getCpuInfo ( CentralProcessor processor ) { Map < String , Object > cpuInfo = new LinkedHashMap < > ( ) ; cpuInfo . put ( \"<STR_LIT>\" , processor . getProcessorIdentifier ( ) . getName ( ) ) ; cpuInfo . put ( \"<STR_LIT>\" , processor . getPhysicalPackageCount ( ) + \"<STR_LIT>\" ) ; cpuInfo . put ( \"<STR_LIT>\" , processor . getPhysicalProcessorCount ( ) + \"<STR_LIT>\" ) ; cpuInfo . put ( \"<STR_LIT>\" , processor . getPhysicalProcessorCount ( ) ) ; cpuInfo . put ( \"<STR_LIT>\" , processor . getLogicalProcessorCount ( ) + \"<STR_LIT>\" ) ; long [ ] prevTicks = processor . getSystemCpuLoadTicks ( ) ; long time = <NUM_LIT> ; Util . sleep ( time ) ; long [ ] ticks = processor . getSystemCpuLoadTicks ( ) ; while ( Arrays . toString ( prevTicks ) . equals ( Arrays . toString ( ticks ) ) && time < <NUM_LIT> ) { time += <NUM_LIT> ; Util . sleep ( <NUM_LIT> ) ; ticks = processor . getSystemCpuLoadTicks ( ) ; } long user = ticks [ CentralProcessor . TickType . USER . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . USER . getIndex ( ) ] ; long nice = ticks [ CentralProcessor . TickType . NICE . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . NICE . getIndex ( ) ] ; long sys = ticks [ CentralProcessor . TickType . SYSTEM . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . SYSTEM . getIndex ( ) ] ; long idle = ticks [ CentralProcessor . TickType . IDLE . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IDLE . getIndex ( ) ] ; long iowait = ticks [ CentralProcessor . TickType . IOWAIT . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IOWAIT . getIndex ( ) ] ; long irq = ticks [ CentralProcessor . TickType . IRQ . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IRQ . getIndex ( ) ] ; long softirq = ticks [ CentralProcessor . TickType . SOFTIRQ . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . SOFTIRQ . getIndex ( ) ] ; long steal = ticks [ CentralProcessor . TickType . STEAL . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . STEAL . getIndex ( ) ] ; long totalCpu = user + nice + sys + idle + iowait + irq + softirq + steal ; cpuInfo . put ( \"<STR_LIT>\" , df . format ( <NUM_LIT> * user / totalCpu + <NUM_LIT> * sys / totalCpu ) ) ; cpuInfo . put ( \"<STR_LIT>\" , df . format ( <NUM_LIT> * idle / totalCpu ) ) ; return cpuInfo ;", "output": "} private Map < String , Object > getSystemInfo ( OperatingSystem os ) { Map < String , Object > systemInfo = new LinkedHashMap < > ( ) ; long time = ManagementFactory . getRuntimeMXBean ( ) . getStartTime ( ) ; Date date = new Date ( time ) ; String formatBetween = DateUtil . formatBetween ( date , new Date ( ) , Level . HOUR ) ; systemInfo . put ( \"<STR_LIT>\" , os . toString ( ) ) ; systemInfo . put ( \"<STR_LIT>\" , formatBetween ) ; systemInfo . put ( \"<STR_LIT>\" , StringUtils . getLocalIp ( ) ) ; return systemInfo ; } }"}, {"input": "package com . oddfar . campus . common . utils ; public class LogUtils { public static String getBlock ( Object msg ) { if ( msg == null ) { msg = \"<STR_LIT>\" ; }", "output": "return \"<STR_LIT>\" + msg . toString ( ) + \"<STR_LIT>\" ; } }"}, {"input": "package top . kangert . kspider . dao ; import org . springframework . data . jpa . repository . JpaRepository ; import org . springframework . data . jpa . repository . JpaSpecificationExecutor ; import top . kangert . kspider . domain . SpiderFlow ; import java . util . List ; public interface SpiderFlowRepository extends JpaRepository < SpiderFlow , Long > , JpaSpecificationExecutor < SpiderFlow > { List < SpiderFlow > findByFlowIdNot ( Long flowId ) ; SpiderFlow findSpiderFlowByFlowId ( Long id ) ;", "output": "}"}, {"input": "package ginyi . common . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD }", "output": ") public @ interface CreateTime { String value ( ) default \"<STR_LIT>\" ; }"}, {"input": "package com . yf . system . modules . plugin . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . plugin . dto . PluginSchemaDTO ; import com . yf . system . modules . plugin . entity . PluginSchema ; import java . util . List ; public interface PluginSchemaService extends IService < PluginSchema > {", "output": "IPage < PluginSchemaDTO > paging ( PagingReqDTO < PluginSchemaDTO > reqDTO ) ; void save ( PluginSchemaDTO reqDTO ) ; void delete ( List < String > ids ) ; PluginSchemaDTO detail ( String id ) ; List < PluginSchemaDTO > list ( PluginSchemaDTO reqDTO ) ; }"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface ColumnInfoMapper extends BaseMapper < ColumnInfo > { IPage < TableInfo > getTables ( @ Param ( \"<STR_LIT>\" ) String tableName , Page < Object > page ) ; List < ColumnInfo > findByTableNameOrderByIdAsc ( @ Param ( \"<STR_LIT>\" ) String tableName ) ; List < ColumnInfo > getColumns ( @ Param ( \"<STR_LIT>\" ) String tableName ) ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import org . springblade . core . mp . base . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CheckRule extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleJson ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ruleDescription ;", "output": "}"}, {"input": "package com . yf . base . utils ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class HtmlUtils { public static String replaceRegx ( String regx , String input ) { Pattern pattern = Pattern . compile ( regx , Pattern . CASE_INSENSITIVE ) ;", "output": "Matcher matcher = pattern . matcher ( input ) ; return matcher . replaceAll ( \"<STR_LIT>\" ) ; } public static String splitAndFilterString ( String input , int length ) { if ( input == null || input . trim ( ) . equals ( \"<STR_LIT>\" ) ) { return \"<STR_LIT>\" ; } String str = input . trim ( ) ; str = replaceRegx ( \"<STR_LIT>\" , str ) ; str = replaceRegx ( \"<STR_LIT>\" , str ) ; str = replaceRegx ( \"<STR_LIT>\" , str ) ; int len = str . length ( ) ; if ( len <= length ) { return str ; } else { str = str . substring ( <NUM_LIT> , length ) ; str += \"<STR_LIT>\" ; } return str ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJs extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJs ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJsType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ;", "output": "}"}, {"input": "package com . yf . system . modules . depart . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . system . modules . depart . dto . SysDepartDTO ; import com . yf . system . modules . depart . dto . request . DepartSortReqDTO ; import com . yf . system . modules . depart . dto . response . SysDepartTreeDTO ; import com . yf . system . modules . depart . entity . SysDepart ; import java . util . List ; public interface SysDepartService extends IService < SysDepart > { void save ( SysDepartDTO reqDTO ) ; List < SysDepartTreeDTO > findTree ( boolean self ) ;", "output": "void sort ( DepartSortReqDTO reqDTO ) ; String syncDepart ( String str ) ; void delete ( List < String > ids ) ; }"}, {"input": "package com . oddfar . campus . common . exception . file ; public class FileNameLengthLimitExceededException extends FileException { private static final long serialVersionUID = <NUM_LIT> ; public FileNameLengthLimitExceededException ( int defaultFileNameLength ) { super ( \"<STR_LIT>\" , new Object [ ] { defaultFileNameLength } ) ;", "output": "} }"}, {"input": "package me . zhengjie . modules . quartz . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . service . QuartzJobService ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . SpringContextHolder ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ Slf4j @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class QuartzJobController { private static final String ENTITY_NAME = \"<STR_LIT>\" ; private final QuartzJobService quartzJobService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < QuartzJob > > queryQuartzJob ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( quartzJobService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportQuartzJob ( HttpServletResponse response , QuartzJobQueryCriteria criteria ) throws IOException { quartzJobService . download ( quartzJobService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportQuartzJobLog ( HttpServletResponse response , QuartzJobQueryCriteria criteria ) throws IOException { quartzJobService . downloadLog ( quartzJobService . queryAllLog ( criteria ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < QuartzLog > > queryQuartzJobLog ( QuartzJobQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( quartzJobService . queryAllLog ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createQuartzJob ( @ Validated @ RequestBody QuartzJob resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( \"<STR_LIT>\" + ENTITY_NAME + \"<STR_LIT>\" ) ; } checkBean ( resources . getBeanName ( ) ) ; quartzJobService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateQuartzJob ( @ Validated ( QuartzJob . Update . class ) @ RequestBody QuartzJob resources ) { checkBean ( resources . getBeanName ( ) ) ; quartzJobService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateQuartzJobStatus ( @ PathVariable Long id ) { quartzJobService . updateIsPause ( quartzJobService . getById ( id ) ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > executionQuartzJob ( @ PathVariable Long id ) { quartzJobService . execution ( quartzJobService . getById ( id ) ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteQuartzJob ( @ RequestBody Set < Long > ids ) { quartzJobService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } private void checkBean ( String beanName ) { if ( ! SpringContextHolder . getAllServiceBeanName ( ) . contains ( beanName ) ) {", "output": "throw new BadRequestException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package org . springblade . gateway . config ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . props . AuthProperties ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . http . HttpMethod ; import org . springframework . http . HttpStatus ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . http . server . reactive . ServerHttpResponse ; import org . springframework . web . cors . reactive . CorsUtils ; import org . springframework . web . server . ServerWebExchange ; import org . springframework . web . server . WebFilter ; import org . springframework . web . server . WebFilterChain ; import reactor . core . publisher . Mono ; @ Slf4j @ Configuration @ AllArgsConstructor @ EnableConfigurationProperties ( { AuthProperties . class } ) public class RouterFunctionConfiguration { private static final String ALLOWED_HEADERS = \"<STR_LIT>\" ; private static final String ALLOWED_METHODS = \"<STR_LIT>\" ; private static final String ALLOWED_ORIGIN = \"<STR_LIT>\" ; private static final String ALLOWED_EXPOSE = \"<STR_LIT>\" ; private static final String MAX_AGE = \"<STR_LIT>\" ; @ Bean public WebFilter corsFilter ( ) { return ( ServerWebExchange ctx , WebFilterChain chain ) -> { ServerHttpRequest request = ctx . getRequest ( ) ; if ( CorsUtils . isCorsRequest ( request ) ) { ServerHttpResponse response = ctx . getResponse ( ) ; HttpHeaders headers = response . getHeaders ( ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_HEADERS ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_METHODS ) ;", "output": "headers . add ( \"<STR_LIT>\" , ALLOWED_ORIGIN ) ; headers . add ( \"<STR_LIT>\" , ALLOWED_EXPOSE ) ; headers . add ( \"<STR_LIT>\" , MAX_AGE ) ; headers . add ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; if ( request . getMethod ( ) == HttpMethod . OPTIONS ) { response . setStatusCode ( HttpStatus . OK ) ; return Mono . empty ( ) ; } } return chain . filter ( ctx ) ; } ; } }"}, {"input": "package org . springblade . web . model ; import lombok . Data ; import java . math . BigDecimal ; import java . util . List ; @ Data public class EntrustModel { private String entrustCode ; private String entrustType ; private List < CalculationModel > calculationList ; @ Data public static class CalculationModel { private String rule ; private BigDecimal triggerPrice ;", "output": "} }"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . api . file . FileUploadUtils ; import com . oddfar . campus . framework . api . file . MimeTypeUtils ; import com . oddfar . campus . framework . api . sysconfig . ConfigExpander ; import com . oddfar . campus . framework . mapper . SysUserMapper ; import com . oddfar . campus . framework . service . SysUserService ; import com . oddfar . campus . framework . web . service . TokenService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import static com . oddfar . campus . common . utils . SecurityUtils . getLoginUser ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . SYSTEM ) public class SysProfileController { @ Autowired private SysUserService userService ; @ Autowired private SysUserMapper userMapper ; @ Autowired private TokenService tokenService ; @ GetMapping ( name = \"<STR_LIT>\" ) public R profile ( ) {", "output": "LoginUser loginUser = getLoginUser ( ) ; SysUserEntity user = loginUser . getUser ( ) ; R ajax = R . ok ( user ) ; ajax . put ( \"<STR_LIT>\" , userService . selectUserRoleGroup ( loginUser . getUsername ( ) ) ) ; return ajax ; } @ PutMapping ( name = \"<STR_LIT>\" ) public R updateProfile ( @ RequestBody SysUserEntity user ) { LoginUser loginUser = getLoginUser ( ) ; SysUserEntity sysUser = loginUser . getUser ( ) ; user . setUserName ( sysUser . getUserName ( ) ) ; if ( StringUtils . isNotEmpty ( user . getPhonenumber ( ) ) && ! ( userService . checkPhoneUnique ( user ) ) ) { return R . error ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } if ( StringUtils . isNotEmpty ( user . getEmail ( ) ) && ! ( userService . checkEmailUnique ( user ) ) ) { return R . error ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } user . setUserId ( sysUser . getUserId ( ) ) ; user . setPassword ( null ) ; user . setAvatar ( null ) ; if ( userService . updateUserProfile ( user ) > <NUM_LIT> ) { sysUser . setNickName ( user . getNickName ( ) ) ; sysUser . setPhonenumber ( user . getPhonenumber ( ) ) ; sysUser . setEmail ( user . getEmail ( ) ) ; sysUser . setSex ( user . getSex ( ) ) ; tokenService . setLoginUser ( loginUser ) ; return R . ok ( ) ; } return R . error ( \"<STR_LIT>\" ) ; } @ PutMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R updatePwd ( String oldPassword , String newPassword ) { SysUserEntity user = userMapper . selectById ( SecurityUtils . getUserId ( ) ) ; String userName = user . getUserName ( ) ; String password = user . getPassword ( ) ; if ( ! SecurityUtils . matchesPassword ( oldPassword , password ) ) { return R . error ( \"<STR_LIT>\" ) ; } if ( SecurityUtils . matchesPassword ( newPassword , password ) ) { return R . error ( \"<STR_LIT>\" ) ; } if ( userService . resetUserPwd ( userName , SecurityUtils . encryptPassword ( newPassword ) ) > <NUM_LIT> ) { return R . ok ( ) ; } return R . error ( \"<STR_LIT>\" ) ; } @ PostMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R avatar ( @ RequestParam ( \"<STR_LIT>\" ) MultipartFile file ) throws Exception { if ( ! file . isEmpty ( ) ) { LoginUser loginUser = getLoginUser ( ) ; String avatar = FileUploadUtils . upload ( ConfigExpander . getAvatarPath ( ) , file , MimeTypeUtils . IMAGE_EXTENSION ) ; if ( userService . updateUserAvatar ( loginUser . getUsername ( ) , avatar ) ) { R ajax = R . ok ( ) ; ajax . put ( \"<STR_LIT>\" , avatar ) ; loginUser . getUser ( ) . setAvatar ( avatar ) ; tokenService . setLoginUser ( loginUser ) ; return ajax ; } } return R . error ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . oddfar . campus . common . exception . user ; public class UserPasswordRetryLimitExceedException extends UserException { private static final long serialVersionUID = <NUM_LIT> ; public UserPasswordRetryLimitExceedException ( int retryLimitCount , int lockTime ) {", "output": "super ( \"<STR_LIT>\" , new Object [ ] { retryLimitCount , lockTime } ) ; } }"}, {"input": "package com . youlai . system . exception ; import cn . hutool . core . util . StrUtil ; import com . fasterxml . jackson . core . JsonProcessingException ; import com . youlai . system . common . result . Result ; import com . youlai . system . common . result . ResultCode ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . TypeMismatchException ; import org . springframework . context . support . DefaultMessageSourceResolvable ; import org . springframework . http . HttpStatus ; import org . springframework . http . converter . HttpMessageNotReadableException ; import org . springframework . jdbc . BadSqlGrammarException ; import org . springframework . security . access . AccessDeniedException ; import org . springframework . security . core . AuthenticationException ; import org . springframework . validation . BindException ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . MissingServletRequestParameterException ; import org . springframework . web . bind . annotation . ExceptionHandler ; import org . springframework . web . bind . annotation . ResponseStatus ; import org . springframework . web . bind . annotation . RestControllerAdvice ; import org . springframework . web . method . annotation . MethodArgumentTypeMismatchException ; import org . springframework . web . servlet . NoHandlerFoundException ; import jakarta . servlet . ServletException ; import jakarta . validation . ConstraintViolation ; import jakarta . validation . ConstraintViolationException ; import java . sql . SQLSyntaxErrorException ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; @ RestControllerAdvice @ Slf4j public class GlobalExceptionHandler { @ ExceptionHandler ( BindException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( BindException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; String msg = e . getAllErrors ( ) . stream ( ) . map ( DefaultMessageSourceResolvable :: getDefaultMessage ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ;", "output": "return Result . failed ( ResultCode . PARAM_ERROR , msg ) ; } @ ExceptionHandler ( ConstraintViolationException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( ConstraintViolationException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; String msg = e . getConstraintViolations ( ) . stream ( ) . map ( ConstraintViolation :: getMessage ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; return Result . failed ( ResultCode . PARAM_ERROR , msg ) ; } @ ExceptionHandler ( MethodArgumentNotValidException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( MethodArgumentNotValidException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; String msg = e . getBindingResult ( ) . getAllErrors ( ) . stream ( ) . map ( DefaultMessageSourceResolvable :: getDefaultMessage ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; return Result . failed ( ResultCode . PARAM_ERROR , msg ) ; } @ ExceptionHandler ( NoHandlerFoundException . class ) @ ResponseStatus ( HttpStatus . NOT_FOUND ) public < T > Result < T > processException ( NoHandlerFoundException e ) { log . error ( e . getMessage ( ) , e ) ; return Result . failed ( ResultCode . RESOURCE_NOT_FOUND ) ; } @ ExceptionHandler ( MissingServletRequestParameterException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( MissingServletRequestParameterException e ) { log . error ( e . getMessage ( ) , e ) ; return Result . failed ( ResultCode . PARAM_IS_NULL ) ; } @ ExceptionHandler ( MethodArgumentTypeMismatchException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( MethodArgumentTypeMismatchException e ) { log . error ( e . getMessage ( ) , e ) ; return Result . failed ( ResultCode . PARAM_ERROR , \"<STR_LIT>\" ) ; } @ ExceptionHandler ( ServletException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( ServletException e ) { log . error ( e . getMessage ( ) , e ) ; return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( IllegalArgumentException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > handleIllegalArgumentException ( IllegalArgumentException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) , e ) ; return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( JsonProcessingException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > handleJsonProcessingException ( JsonProcessingException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) , e ) ; return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( HttpMessageNotReadableException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( HttpMessageNotReadableException e ) { log . error ( e . getMessage ( ) , e ) ; String errorMessage = \"<STR_LIT>\" ; Throwable cause = e . getCause ( ) ; if ( cause != null ) { errorMessage = convertMessage ( cause ) ; } return Result . failed ( errorMessage ) ; } @ ExceptionHandler ( TypeMismatchException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > processException ( TypeMismatchException e ) { log . error ( e . getMessage ( ) , e ) ; return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( BadSqlGrammarException . class ) @ ResponseStatus ( HttpStatus . FORBIDDEN ) public < T > Result < T > handleBadSqlGrammarException ( BadSqlGrammarException e ) { log . error ( e . getMessage ( ) , e ) ; String errorMsg = e . getMessage ( ) ; if ( StrUtil . isNotBlank ( errorMsg ) && errorMsg . contains ( \"<STR_LIT>\" ) ) { return Result . failed ( ResultCode . FORBIDDEN_OPERATION ) ; } else { return Result . failed ( e . getMessage ( ) ) ; } } @ ExceptionHandler ( SQLSyntaxErrorException . class ) @ ResponseStatus ( HttpStatus . FORBIDDEN ) public < T > Result < T > processSQLSyntaxErrorException ( SQLSyntaxErrorException e ) { log . error ( e . getMessage ( ) , e ) ; return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( BusinessException . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > handleBizException ( BusinessException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; if ( e . getResultCode ( ) != null ) { return Result . failed ( e . getResultCode ( ) ) ; } return Result . failed ( e . getMessage ( ) ) ; } @ ExceptionHandler ( Exception . class ) @ ResponseStatus ( HttpStatus . BAD_REQUEST ) public < T > Result < T > handleException ( Exception e ) throws Exception { if ( e instanceof AccessDeniedException || e instanceof AuthenticationException ) { throw e ; } log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; e . printStackTrace ( ) ; return Result . failed ( e . getLocalizedMessage ( ) ) ; } private String convertMessage ( Throwable throwable ) { String error = throwable . toString ( ) ; String regulation = \"<STR_LIT>\" ; Pattern pattern = Pattern . compile ( regulation ) ; Matcher matcher = pattern . matcher ( error ) ; String group = \"<STR_LIT>\" ; if ( matcher . find ( ) ) { String matchString = matcher . group ( ) ; matchString = matchString . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; matchString = \"<STR_LIT>\" . formatted ( matchString . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; group += matchString ; } return group ; } }"}, {"input": "package me . zhengjie . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . service . GenConfigService ; import me . zhengjie . service . GeneratorService ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class GeneratorController { private final GeneratorService generatorService ; private final GenConfigService genConfigService ; @ Value ( \"<STR_LIT>\" ) private Boolean generatorEnabled ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < PageResult < TableInfo > > queryTables ( @ RequestParam ( defaultValue = \"<STR_LIT>\" ) String name , Page < Object > page ) { return new ResponseEntity < > ( generatorService . getTables ( name , page ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < PageResult < ColumnInfo > > queryColumns ( @ RequestParam String tableName ) { List < ColumnInfo > columnInfos = generatorService . getColumns ( tableName ) ; return new ResponseEntity < > ( PageUtil . toPage ( columnInfos ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping public ResponseEntity < HttpStatus > saveColumn ( @ RequestBody List < ColumnInfo > columnInfos ) { generatorService . save ( columnInfos ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < HttpStatus > syncColumn ( @ RequestBody List < String > tables ) { for ( String table : tables ) { generatorService . sync ( generatorService . getColumns ( table ) , generatorService . query ( table ) ) ; }", "output": "return new ResponseEntity < > ( HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > generatorCode ( @ PathVariable String tableName , @ PathVariable Integer type , HttpServletRequest request , HttpServletResponse response ) { if ( ! generatorEnabled && type == <NUM_LIT> ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } switch ( type ) { case <NUM_LIT> : generatorService . generator ( genConfigService . find ( tableName ) , generatorService . getColumns ( tableName ) ) ; break ; case <NUM_LIT> : return generatorService . preview ( genConfigService . find ( tableName ) , generatorService . getColumns ( tableName ) ) ; case <NUM_LIT> : generatorService . download ( genConfigService . find ( tableName ) , generatorService . getColumns ( tableName ) , request , response ) ; break ; default : throw new BadRequestException ( \"<STR_LIT>\" ) ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . UserExamsScore ; import cn . org . alan . exam . model . vo . score . GradeScoreVO ; import cn . org . alan . exam . model . vo . score . UserScoreVO ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import jakarta . servlet . http . HttpServletResponse ; public interface IUserExamsScoreService extends IService < UserExamsScore > { Result < IPage < UserScoreVO > > pagingScore ( Integer pageNum , Integer pageSize , Integer gradeId , Integer examId , String realName ) ; void exportScores ( HttpServletResponse response , Integer examId , Integer gradeId ) ;", "output": "Result < IPage < GradeScoreVO > > getExamScoreInfo ( Integer pageNum , Integer pageSize , String examTitle , Integer gradeId ) ; }"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . domain . entity . SysRoleMenuEntity ; import java . util . List ; public interface SysRoleMenuMapper extends BaseMapperX < SysRoleMenuEntity > { public int checkMenuExistRole ( Long menuId ) ; public int deleteRoleMenuByRoleId ( Long roleId ) ; public int deleteRoleMenu ( Long [ ] ids ) ; public int batchRoleMenu ( List < SysRoleMenuEntity > roleMenuList ) ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import com . alipay . api . AlipayApiException ; import com . alipay . api . internal . util . AlipaySignature ; import me . zhengjie . domain . AlipayConfig ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import java . text . SimpleDateFormat ; import java . util . Date ; import java . util . HashMap ; import java . util . Map ; @ Component public class AlipayUtils { public String getOrderCode ( ) { SimpleDateFormat sdf = new SimpleDateFormat ( \"<STR_LIT>\" ) ; int a = ( int ) ( Math . random ( ) * <NUM_LIT> ) + <NUM_LIT> ; System . out . println ( a ) ; Date date = new Date ( ) ; String str = sdf . format ( date ) ; String [ ] split = str . split ( \"<STR_LIT>\" ) ; String s = split [ <NUM_LIT> ] + split [ <NUM_LIT> ] + split [ <NUM_LIT> ] ; String [ ] split1 = s . split ( \"<STR_LIT>\" ) ; String s1 = split1 [ <NUM_LIT> ] + split1 [ <NUM_LIT> ] ; String [ ] split2 = s1 . split ( \"<STR_LIT>\" ) ; return split2 [ <NUM_LIT> ] + split2 [ <NUM_LIT> ] + split2 [ <NUM_LIT> ] + a ; } public boolean rsaCheck ( HttpServletRequest request , AlipayConfig alipay ) { Map < String , String > params = new HashMap < > ( <NUM_LIT> ) ; Map < String , String [ ] > requestParams = request . getParameterMap ( ) ; for ( Object o : requestParams . keySet ( ) ) { String name = ( String ) o ; String [ ] values = requestParams . get ( name ) ; String valueStr = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < values . length ; i ++ ) { valueStr = ( i == values . length - <NUM_LIT> ) ? valueStr + values [ i ] : valueStr + values [ i ] + \"<STR_LIT>\" ; } params . put ( name , valueStr ) ; } try { return AlipaySignature . rsaCheckV1 ( params , alipay . getPublicKey ( ) , alipay . getCharset ( ) , alipay . getSignType ( ) ) ; }", "output": "catch ( AlipayApiException e ) { return false ; } } }"}, {"input": "package ginyi . system . domain ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data public class SysFile { @ ApiModelProperty ( \"<STR_LIT>\" ) private String dirName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String typeName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double total ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double free ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double used ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double usage ;", "output": "}"}, {"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . entity . CgformIndex ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data public class CgformModel { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private CgformHead head ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformField > fields ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < CgformIndex > indexs ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > deleteFieldIds ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > deleteIndexIds ;", "output": "}"}, {"input": "package com . yf . system . modules . config . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CfgBaseDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String siteName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String loginLogo ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String loginBg ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String backLogo ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String copyRight ;", "output": "}"}, {"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . SQLException ; @ Slf4j public class CommonUtils { private static String DB_TYPE = \"<STR_LIT>\" ; public static String getDatabaseType ( ) { if ( Func . isNotEmpty ( DB_TYPE ) ) { return DB_TYPE ; } DataSource dataSource = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; try { return getDatabaseTypeByDataSource ( dataSource ) ; } catch ( SQLException e ) { log . warn ( e . getMessage ( ) ) ; return \"<STR_LIT>\" ; } } private static String getDatabaseTypeByDataSource ( DataSource dataSource ) throws SQLException { if ( \"<STR_LIT>\" . equals ( DB_TYPE ) ) { Connection connection = dataSource . getConnection ( ) ; try { DatabaseMetaData md = connection . getMetaData ( ) ; String dbType = md . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> || dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } else if ( dbType . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DB_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { throw new Exception ( \"<STR_LIT>\" + dbType + \"<STR_LIT>\" ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { connection . close ( ) ; }", "output": "} return DB_TYPE ; } }"}, {"input": "package ginyi . system . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import lombok . Data ; import org . apache . commons . lang3 . builder . ToStringBuilder ; import org . apache . commons . lang3 . builder . ToStringStyle ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; import java . util . Set ; @ Data public class SysRole extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId private Long roleId ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String roleName ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String roleKey ; @ NotNull ( message = \"<STR_LIT>\" ) private Integer sort ; @ TableField ( select = false , exist = false ) private String dataScope ; @ TableField ( select = false , exist = false ) private boolean menuCheckStrictly ; @ TableField ( select = false , exist = false ) private boolean deptCheckStrictly ; private String status ; @ TableLogic private String deleted ; @ TableField ( select = false , exist = false ) private boolean flag = false ; @ TableField ( select = false , exist = false ) private Long [ ] menuIds ; @ TableField ( select = false , exist = false ) private Long [ ] deptIds ; @ TableField ( select = false , exist = false ) private Set < String > permissions ; public boolean isAdmin ( ) { return isAdmin ( this . roleId ) ;", "output": "} public static boolean isAdmin ( Long roleId ) { return roleId != null && <NUM_LIT> == roleId ; } }"}, {"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . context . annotation . Lazy ; import org . springframework . stereotype . Component ; @ Component @ Lazy ( false ) public class ApplicationContextRegister implements ApplicationContextAware { private static ApplicationContext APPLICATION_CONTEXT ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { APPLICATION_CONTEXT = applicationContext ; }", "output": "public static ApplicationContext getApplicationContext ( ) { return APPLICATION_CONTEXT ; } }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . util . ObjectUtil ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . constant . UserConstants ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysConfigEntity ; import com . oddfar . campus . common . exception . ServiceException ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . mapper . SysConfigMapper ; import com . oddfar . campus . framework . service . SysConfigService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import javax . annotation . PostConstruct ; import javax . annotation . Resource ; import java . util . Collection ; import java . util . List ; @ Service public class SysConfigServiceImpl implements SysConfigService { @ Resource private SysConfigMapper configMapper ; @ Autowired private RedisCache redisCache ; @ PostConstruct public void init ( ) { loadingConfigCache ( ) ; } @ Override public PageResult < SysConfigEntity > page ( SysConfigEntity sysConfigEntity ) { return configMapper . selectPage ( sysConfigEntity ) ; } @ Override public SysConfigEntity selectConfigById ( Long configId ) { SysConfigEntity config = new SysConfigEntity ( ) ; config . setConfigId ( configId ) ; return configMapper . selectById ( config ) ; } @ Override public String selectConfigByKey ( String configKey ) {", "output": "String configValue = Convert . toStr ( redisCache . getCacheObject ( getCacheKey ( configKey ) ) ) ; if ( StringUtils . isNotEmpty ( configValue ) ) { return configValue ; } SysConfigEntity config = new SysConfigEntity ( ) ; config . setConfigKey ( configKey ) ; SysConfigEntity retConfig = configMapper . selectConfig ( config ) ; if ( StringUtils . isNotNull ( retConfig ) ) { redisCache . setCacheObject ( getCacheKey ( configKey ) , retConfig . getConfigValue ( ) ) ; return retConfig . getConfigValue ( ) ; } return StringUtils . EMPTY ; } @ Override public < T > T selectConfigByKey ( String configKey , Class < T > clazz ) { T configValue = redisCache . getCacheObject ( getCacheKey ( configKey ) ) ; if ( ObjectUtil . isNotEmpty ( configValue ) ) { return configValue ; } SysConfigEntity config = new SysConfigEntity ( ) ; config . setConfigKey ( configKey ) ; SysConfigEntity retConfig = configMapper . selectConfig ( config ) ; if ( ObjectUtil . isNotNull ( retConfig ) ) { redisCache . setCacheObject ( getCacheKey ( configKey ) , retConfig . getConfigValue ( ) ) ; return Convert . convert ( clazz , retConfig . getConfigValue ( ) ) ; } return null ; } @ Override public < T > T selectConfigByKey ( String configKey , Class < T > clazz , T defaultValue ) { T value = this . selectConfigByKey ( configKey , clazz ) ; return value == null ? defaultValue : value ; } @ Override public boolean selectCaptchaEnabled ( ) { String captchaEnabled = selectConfigByKey ( \"<STR_LIT>\" ) ; if ( StringUtils . isEmpty ( captchaEnabled ) ) { return true ; } return Convert . toBool ( captchaEnabled ) ; } @ Override public int insertConfig ( SysConfigEntity config ) { int row = configMapper . insert ( config ) ; if ( row > <NUM_LIT> ) { redisCache . setCacheObject ( getCacheKey ( config . getConfigKey ( ) ) , config . getConfigValue ( ) ) ; } return row ; } @ Override public int updateConfig ( SysConfigEntity config ) { int row = configMapper . updateById ( config ) ; if ( row > <NUM_LIT> ) { redisCache . setCacheObject ( getCacheKey ( config . getConfigKey ( ) ) , config . getConfigValue ( ) ) ; } return row ; } @ Override public void deleteConfigByIds ( Long [ ] configIds ) { for ( Long configId : configIds ) { SysConfigEntity config = selectConfigById ( configId ) ; if ( StringUtils . equals ( UserConstants . YES , config . getConfigType ( ) ) ) { throw new ServiceException ( String . format ( \"<STR_LIT>\" , config . getConfigKey ( ) ) ) ; } configMapper . deleteById ( configId ) ; redisCache . deleteObject ( getCacheKey ( config . getConfigKey ( ) ) ) ; } } @ Override public void loadingConfigCache ( ) { List < SysConfigEntity > configsList = configMapper . selectList ( ) ; for ( SysConfigEntity config : configsList ) { redisCache . setCacheObject ( getCacheKey ( config . getConfigKey ( ) ) , config . getConfigValue ( ) ) ; } } @ Override public boolean checkConfigKeyUnique ( SysConfigEntity config ) { Long configId = StringUtils . isNull ( config . getConfigId ( ) ) ? - <NUM_LIT> : config . getConfigId ( ) ; SysConfigEntity info = configMapper . checkConfigKeyUnique ( config ) ; if ( StringUtils . isNotNull ( info ) && info . getConfigId ( ) . longValue ( ) != configId . longValue ( ) ) { return false ; } return true ; } @ Override public void clearConfigCache ( ) { Collection < String > keys = redisCache . keys ( CacheConstants . SYS_CONFIG_KEY + \"<STR_LIT>\" ) ; redisCache . deleteObject ( keys ) ; } @ Override public void resetConfigCache ( ) { clearConfigCache ( ) ; loadingConfigCache ( ) ; } private String getCacheKey ( String configKey ) { return CacheConstants . SYS_CONFIG_KEY + configKey ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformEnhanceJs ; public interface CgformEnhanceJsMapper extends BaseMapper < CgformEnhanceJs > {", "output": "}"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . entity . SysUserRoleEntity ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . service . SysRoleService ; import com . oddfar . campus . framework . service . SysUserService ; import com . oddfar . campus . framework . web . service . SysPermissionService ; import com . oddfar . campus . framework . web . service . TokenService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . Arrays ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . SYSTEM ) public class SysRoleController { @ Autowired private SysRoleService roleService ; @ Autowired private SysUserService userService ; @ Autowired private SysPermissionService permissionService ; @ Autowired private TokenService tokenService ; @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public R list ( SysRoleEntity role ) { PageResult < SysRoleEntity > list = roleService . page ( role ) ; return R . ok ( ) . put ( list ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public R getInfo ( @ PathVariable Long roleId ) { return R . ok ( roleService . selectRoleById ( roleId ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PostMapping public R add ( @ Validated @ RequestBody SysRoleEntity role ) { if ( ! roleService . checkRoleNameUnique ( role ) ) { return R . error ( \"<STR_LIT>\" + role . getRoleName ( ) + \"<STR_LIT>\" ) ; } else if ( ! roleService . checkRoleKeyUnique ( role ) ) { return R . error ( \"<STR_LIT>\" + role . getRoleName ( ) + \"<STR_LIT>\" ) ; } return R . ok ( roleService . insertRole ( role ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping public R edit ( @ Validated @ RequestBody SysRoleEntity role ) { roleService . checkRoleAllowed ( role ) ; if ( ! roleService . checkRoleNameUnique ( role ) ) { return R . error ( \"<STR_LIT>\" + role . getRoleName ( ) + \"<STR_LIT>\" ) ; } else if ( ! roleService . checkRoleKeyUnique ( role ) ) { return R . error ( \"<STR_LIT>\" + role . getRoleName ( ) + \"<STR_LIT>\" ) ; } if ( roleService . updateRole ( role ) > <NUM_LIT> ) { LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNotNull ( loginUser . getUser ( ) ) && ! loginUser . getUser ( ) . isAdmin ( ) ) { loginUser . setPermissions ( permissionService . getMenuPermission ( loginUser . getUser ( ) ) ) ; loginUser . setUser ( userService . selectUserByUserName ( loginUser . getUser ( ) . getUserName ( ) ) ) ; tokenService . setLoginUser ( loginUser ) ; } permissionService . resetLoginUserRoleCache ( role . getRoleId ( ) ) ; return R . ok ( ) ; } return R . error ( \"<STR_LIT>\" + role . getRoleName ( ) + \"<STR_LIT>\" ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R changeStatus ( @ RequestBody SysRoleEntity role ) { roleService . checkRoleAllowed ( role ) ; roleService . updateRoleStatus ( role ) ; permissionService . resetLoginUserRoleCache ( role . getRoleId ( ) ) ; return R . ok ( ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ DeleteMapping ( \"<STR_LIT>\" ) public R remove ( @ PathVariable Long [ ] roleIds ) { roleService . deleteRoleByIds ( roleIds ) ; Arrays . stream ( roleIds ) . forEach ( id -> permissionService . resetLoginUserRoleCache ( id ) ) ; return R . ok ( ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public R allocatedList ( SysUserEntity user ) { Page < SysUserEntity > page = userService . selectAllocatedList ( user ) ; return R . ok ( ) . put ( page ) ;", "output": "} @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public R unallocatedList ( SysUserEntity user ) { Page < SysUserEntity > page = userService . selectUnallocatedList ( user ) ; return R . ok ( ) . put ( page ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R cancelAuthUser ( @ RequestBody SysUserRoleEntity userRole ) { int i = roleService . deleteAuthUser ( userRole ) ; permissionService . resetLoginUserRoleCache ( userRole . getRoleId ( ) ) ; return R . ok ( i ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R cancelAuthUserAll ( Long roleId , Long [ ] userIds ) { int i = roleService . deleteAuthUsers ( roleId , userIds ) ; permissionService . resetLoginUserRoleCache ( roleId ) ; return R . ok ( i ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R selectAuthUserAll ( Long roleId , Long [ ] userIds ) { return R . ok ( roleService . insertAuthUsers ( roleId , userIds ) ) ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class Exam implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private String title ; private Integer examDuration ; private Integer passedScore ; private Integer grossScore ; private Integer maxCount ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer certificateId ; private Integer radioCount ; private Integer radioScore ; private Integer multiCount ; private Integer multiScore ; private Integer judgeCount ; private Integer judgeScore ; private Integer saqCount ; private Integer saqScore ; private LocalDateTime startTime ; private LocalDateTime endTime ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) { this . isDeleted = isDeleted ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public Integer getExamDuration ( ) { return examDuration ; } public void setExamDuration ( Integer examDuration ) { this . examDuration = examDuration ; } public Integer getPassedScore ( ) { return passedScore ; } public void setPassedScore ( Integer passedScore ) { this . passedScore = passedScore ; } public Integer getGrossScore ( ) { return grossScore ; } public void setGrossScore ( Integer grossScore ) { this . grossScore = grossScore ; } public Integer getMaxCount ( ) { return maxCount ; } public void setMaxCount ( Integer maxCount ) { this . maxCount = maxCount ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getCertificateId ( ) { return certificateId ; } public void setCertificateId ( Integer certificateId ) { this . certificateId = certificateId ; } public Integer getRadioCount ( ) { return radioCount ; } public void setRadioCount ( Integer radioCount ) { this . radioCount = radioCount ; } public Integer getRadioScore ( ) { return radioScore ; } public void setRadioScore ( Integer radioScore ) { this . radioScore = radioScore ; } public Integer getMultiCount ( ) { return multiCount ; } public void setMultiCount ( Integer multiCount ) { this . multiCount = multiCount ;", "output": "} public Integer getMultiScore ( ) { return multiScore ; } public void setMultiScore ( Integer multilScore ) { this . multiScore = multilScore ; } public Integer getJudgeCount ( ) { return judgeCount ; } public void setJudgeCount ( Integer judgeCount ) { this . judgeCount = judgeCount ; } public Integer getJudgeScore ( ) { return judgeScore ; } public void setJudgeScore ( Integer judgeScore ) { this . judgeScore = judgeScore ; } public Integer getSaqCount ( ) { return saqCount ; } public void setSaqCount ( Integer saqCount ) { this . saqCount = saqCount ; } public Integer getSaqScore ( ) { return saqScore ; } public void setSaqScore ( Integer saqScore ) { this . saqScore = saqScore ; } public LocalDateTime getStartTime ( ) { return startTime ; } public void setStartTime ( LocalDateTime startTime ) { this . startTime = startTime ; } public LocalDateTime getEndTime ( ) { return endTime ; } public void setEndTime ( LocalDateTime endTime ) { this . endTime = endTime ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + title + '<STR_LIT>' + \"<STR_LIT>\" + examDuration + \"<STR_LIT>\" + passedScore + \"<STR_LIT>\" + grossScore + \"<STR_LIT>\" + maxCount + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + certificateId + \"<STR_LIT>\" + radioCount + \"<STR_LIT>\" + radioScore + \"<STR_LIT>\" + multiCount + \"<STR_LIT>\" + multiScore + \"<STR_LIT>\" + judgeCount + \"<STR_LIT>\" + judgeScore + \"<STR_LIT>\" + saqCount + \"<STR_LIT>\" + saqScore + \"<STR_LIT>\" + startTime + \"<STR_LIT>\" + endTime + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package com . oddfar . campus . framework . web . service ; import cn . hutool . core . date . DateUtil ; import cn . hutool . extra . spring . SpringUtil ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . event . LogininforEvent ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . exception . ServiceException ; import com . oddfar . campus . common . exception . user . CaptchaException ; import com . oddfar . campus . common . exception . user . CaptchaExpireException ; import com . oddfar . campus . common . exception . user . UserPasswordNotMatchException ; import com . oddfar . campus . common . utils . MessageUtils ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . common . utils . ip . IpUtils ; import com . oddfar . campus . common . utils . web . WebFrameworkUtils ; import com . oddfar . campus . framework . security . context . AuthenticationContextHolder ; import com . oddfar . campus . framework . service . SysConfigService ; import com . oddfar . campus . framework . service . SysUserService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . authentication . AuthenticationManager ; import org . springframework . security . authentication . BadCredentialsException ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; @ Component public class SysLoginService { @ Autowired private TokenService tokenService ; @ Resource private AuthenticationManager authenticationManager ; @ Autowired private RedisCache redisCache ; @ Autowired private SysUserService userService ; @ Autowired private SysConfigService configService ; public String login ( String username , String password , String code , String uuid ) { boolean captchaEnabled = configService . selectCaptchaEnabled ( ) ; if ( captchaEnabled ) { validateCaptcha ( username , code , uuid ) ; } Authentication authentication = null ; try { UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( username , password ) ; AuthenticationContextHolder . setContext ( authenticationToken ) ; authentication = authenticationManager . authenticate ( authenticationToken ) ; } catch ( Exception e ) { if ( e instanceof BadCredentialsException ) { LogininforEvent logininforEvent = new LogininforEvent ( ) ; logininforEvent . setUsername ( username ) ; logininforEvent . setStatus ( Constants . LOGIN_FAIL ) ; logininforEvent . setMessage ( MessageUtils . message ( \"<STR_LIT>\" ) ) ; logininforEvent . setRequest ( ServletUtils . getRequest2 ( ) ) ;", "output": "SpringUtil . getApplicationContext ( ) . publishEvent ( logininforEvent ) ; throw new UserPasswordNotMatchException ( ) ; } else { LogininforEvent logininforEvent = new LogininforEvent ( ) ; logininforEvent . setUsername ( username ) ; logininforEvent . setStatus ( Constants . LOGIN_FAIL ) ; logininforEvent . setMessage ( e . getMessage ( ) ) ; logininforEvent . setRequest ( ServletUtils . getRequest2 ( ) ) ; SpringUtil . getApplicationContext ( ) . publishEvent ( logininforEvent ) ; e . printStackTrace ( ) ; throw new ServiceException ( e . getMessage ( ) ) ; } } finally { AuthenticationContextHolder . clearContext ( ) ; } LoginUser loginUser = ( LoginUser ) authentication . getPrincipal ( ) ; WebFrameworkUtils . setLoginUserId ( ServletUtils . getRequest ( ) , loginUser . getUserId ( ) ) ; recordLoginInfo ( username , loginUser . getUserId ( ) , Constants . LOGIN_SUCCESS , MessageUtils . message ( \"<STR_LIT>\" ) ) ; return tokenService . createToken ( loginUser ) ; } public void validateCaptcha ( String username , String code , String uuid ) { String verifyKey = CacheConstants . CAPTCHA_CODE_KEY + StringUtils . nvl ( uuid , \"<STR_LIT>\" ) ; String captcha = redisCache . getCacheObject ( verifyKey ) ; redisCache . deleteObject ( verifyKey ) ; if ( captcha == null ) { throw new CaptchaExpireException ( ) ; } if ( ! code . equalsIgnoreCase ( captcha ) ) { throw new CaptchaException ( ) ; } } public void recordLoginInfo ( String username , Long userId , String status , String message ) { SysUserEntity sysUser = new SysUserEntity ( ) ; sysUser . setUserId ( userId ) ; sysUser . setLoginIp ( IpUtils . getIpAddr ( ServletUtils . getRequest ( ) ) ) ; sysUser . setLoginDate ( DateUtil . date ( ) ) ; userService . updateUserProfile ( sysUser ) ; LogininforEvent logininforEvent = new LogininforEvent ( ) ; logininforEvent . setUsername ( username ) ; logininforEvent . setUserId ( userId ) ; logininforEvent . setStatus ( status ) ; logininforEvent . setMessage ( message ) ; logininforEvent . setRequest ( ServletUtils . getRequest2 ( ) ) ; SpringUtil . getApplicationContext ( ) . publishEvent ( logininforEvent ) ; } }"}, {"input": "package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . NoArgsConstructor ; import lombok . Setter ; import java . io . Serializable ; @ Getter @ Setter @ NoArgsConstructor @ TableName ( \"<STR_LIT>\" ) public class ColumnInfo implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String columnName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String columnType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String keyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String extra ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean notNull ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean listShow = true ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean formShow = true ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictName ;", "output": "}"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . service . SysRoleService ; import com . oddfar . campus . framework . service . SysUserService ; import com . oddfar . campus . framework . web . service . SysPermissionService ; import org . apache . commons . lang3 . ArrayUtils ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . List ; import java . util . stream . Collectors ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . SYSTEM ) public class SysUserController { @ Autowired private SysUserService userService ; @ Autowired private SysRoleService roleService ; @ Autowired private SysPermissionService permissionService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public R page ( SysUserEntity sysUserEntity ) { PageResult < SysUserEntity > page = userService . page ( sysUserEntity ) ; return R . ok ( ) . put ( page ) ; } @ GetMapping ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) @ PreAuthorize ( \"<STR_LIT>\" ) public R getInfo ( @ PathVariable ( value = \"<STR_LIT>\" , required = false ) Long userId ) { R res = R . ok ( ) ; List < SysRoleEntity > roles = roleService . selectRoleAll ( ) ; res . put ( \"<STR_LIT>\" , SysUserEntity . isAdmin ( userId ) ? roles : roles . stream ( ) . filter ( r -> ! r . isAdmin ( ) ) . collect ( Collectors . toList ( ) ) ) ; if ( StringUtils . isNotNull ( userId ) ) { SysUserEntity sysUser = userService . selectUserById ( userId ) ; res . put ( \"<STR_LIT>\" , sysUser ) ; res . put ( \"<STR_LIT>\" , sysUser . getRoles ( ) . stream ( ) . map ( SysRoleEntity :: getRoleId ) . collect ( Collectors . toList ( ) ) ) ; } return res ;", "output": "} @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public R add ( @ Validated @ RequestBody SysUserEntity sysUserEntity ) { userService . insertUser ( sysUserEntity ) ; return R . ok ( ) ; } @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public R update ( @ Validated @ RequestBody SysUserEntity user ) { userService . checkUserAllowed ( user ) ; if ( ! ( userService . checkUserNameUnique ( user ) ) ) { return R . error ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } else if ( StringUtils . isNotEmpty ( user . getPhonenumber ( ) ) && ! ( userService . checkPhoneUnique ( user ) ) ) { return R . error ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } else if ( StringUtils . isNotEmpty ( user . getEmail ( ) ) && ! ( userService . checkEmailUnique ( user ) ) ) { return R . error ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } user . setPassword ( null ) ; return R . ok ( userService . updateUser ( user ) ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public R remove ( @ PathVariable Long [ ] userIds ) { if ( ArrayUtils . contains ( userIds , SecurityUtils . getUserId ( ) ) ) { return R . error ( \"<STR_LIT>\" ) ; } return R . ok ( userService . deleteUserByIds ( userIds ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public R authRole ( @ PathVariable ( \"<STR_LIT>\" ) Long userId ) { R res = R . ok ( ) ; SysUserEntity user = userService . selectUserById ( userId ) ; List < SysRoleEntity > roles = roleService . selectRolesByUserId ( userId ) ; res . put ( \"<STR_LIT>\" , user ) ; res . put ( \"<STR_LIT>\" , SysUserEntity . isAdmin ( userId ) ? roles : roles . stream ( ) . filter ( r -> ! r . isAdmin ( ) ) . collect ( Collectors . toList ( ) ) ) ; return res ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R insertAuthRole ( Long userId , Long [ ] roleIds ) { if ( ! SysUserEntity . isAdmin ( userId ) ) { userService . insertUserAuth ( userId , roleIds ) ; return R . ok ( ) ; } else { return R . error ( \"<STR_LIT>\" ) ; } } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R resetPwd ( @ RequestBody SysUserEntity user ) { userService . checkUserAllowed ( user ) ; user . setPassword ( SecurityUtils . encryptPassword ( user . getPassword ( ) ) ) ; return R . ok ( userService . resetPwd ( user ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public R changeStatus ( @ RequestBody SysUserEntity user ) { userService . checkUserAllowed ( user ) ; userService . updateUserStatus ( user ) ; permissionService . resetUserRoleAuthCache ( user . getUserId ( ) ) ; return R . ok ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfigResolver ; import java . io . InputStream ; public abstract class BaseExcelReader implements ExcelReader { @ Override public void read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception {", "output": "if ( inputStream == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( rowTypes == null || rowTypes . length == <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } WorkbookConfig workbookConfig = WorkbookConfigResolver . resolveWorkbook ( rowTypes ) ; doRead ( inputStream , rowReadingListener , workbookConfig ) ; } protected abstract void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception ; }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class WalletGetParam { String type ; String memberId ; String coinId ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . reflect ; import org . apache . commons . lang3 . ClassUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Field ; import java . lang . reflect . Method ; import java . util . * ; public class AnnotationUtil { public static Set < Annotation > getAllAnnotations ( final Class < ? > cls ) {", "output": "List < Class < ? > > allTypes = ClassUtil . getAllSuperclasses ( cls ) ; allTypes . addAll ( ClassUtil . getAllInterfaces ( cls ) ) ; allTypes . add ( cls ) ; Set < Annotation > anns = new HashSet < Annotation > ( ) ; for ( Class < ? > type : allTypes ) { anns . addAll ( Arrays . asList ( type . getDeclaredAnnotations ( ) ) ) ; } Set < Annotation > superAnnotations = new HashSet < Annotation > ( ) ; for ( Annotation ann : anns ) { getSuperAnnotations ( ann . annotationType ( ) , superAnnotations ) ; } anns . addAll ( superAnnotations ) ; return anns ; } private static < A extends Annotation > void getSuperAnnotations ( Class < A > annotationType , Set < Annotation > visited ) { Annotation [ ] anns = annotationType . getDeclaredAnnotations ( ) ; for ( Annotation ann : anns ) { if ( ! ann . annotationType ( ) . getName ( ) . startsWith ( \"<STR_LIT>\" ) && visited . add ( ann ) ) { getSuperAnnotations ( ann . annotationType ( ) , visited ) ; } } } public static < T extends Annotation > Set < Field > getAnnotatedPublicFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } return annotatedFields ; } public static < T extends Annotation > Set < Field > getAnnotatedFields ( Class < ? extends Object > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } Set < Field > annotatedFields = new HashSet < Field > ( ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( field . getAnnotation ( annotation ) != null ) { annotatedFields . add ( field ) ; } } annotatedFields . addAll ( getAnnotatedFields ( clazz . getSuperclass ( ) , annotation ) ) ; return annotatedFields ; } public static < T extends Annotation > Set < Method > getAnnotatedPublicMethods ( Class < ? > clazz , Class < T > annotation ) { if ( Object . class . equals ( clazz ) ) { return Collections . emptySet ( ) ; } List < Class < ? > > ifcs = ClassUtils . getAllInterfaces ( clazz ) ; Set < Method > annotatedMethods = new HashSet < Method > ( ) ; Method [ ] methods = clazz . getMethods ( ) ; for ( Method method : methods ) { if ( method . getAnnotation ( annotation ) != null || searchOnInterfaces ( method , annotation , ifcs ) ) { annotatedMethods . add ( method ) ; } } return annotatedMethods ; } private static < T extends Annotation > boolean searchOnInterfaces ( Method method , Class < T > annotationType , List < Class < ? > > ifcs ) { for ( Class < ? > iface : ifcs ) { try { Method equivalentMethod = iface . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; if ( equivalentMethod . getAnnotation ( annotationType ) != null ) { return true ; } } catch ( NoSuchMethodException ex ) { } } return false ; } }"}, {"input": "package top . kangert . kspider . executor . node . event ; import top . kangert . kspider . config . SpiderConfig ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . node . OutputExecutor ; import top . kangert . kspider . executor . node . event . OutputEventPublisher . OutputEventBean ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . model . SpiderOutput ; import top . kangert . kspider . support . DataSourceManager ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . csv . CSVFormat ; import org . apache . commons . csv . CSVPrinter ; import org . springframework . context . event . EventListener ; import org . springframework . jdbc . core . JdbcTemplate ; import org . springframework . stereotype . Component ; import cn . hutool . core . exceptions . ExceptionUtil ; import cn . hutool . core . util . StrUtil ; import javax . annotation . Resource ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStreamWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Component @ Slf4j public class OutputEventHandler { String OUTPUT_TABLE_NAME = \"<STR_LIT>\" ; String OUTPUT_CSV_NAME = \"<STR_LIT>\" ; String OUTPUT_CSV_ENCODING = \"<STR_LIT>\" ; @ Resource private SpiderConfig spiderConfig ; @ Resource private DataSourceManager dataSourceManager ; @ EventListener ( value = OutputEventBean . class , condition = \"<STR_LIT>\" ) private void outputDatabase ( OutputEventBean eventBean ) { SpiderNode node = eventBean . getNode ( ) ; List < SpiderOutput . OutputItem > outputItems = eventBean . getOutputItems ( ) ; String dsId = node . getJsonProperty ( Constants . DATASOURCE_ID ) ; String tableName = node . getJsonProperty ( OUTPUT_TABLE_NAME ) ; if ( StrUtil . isBlank ( dsId ) ) { log . warn ( \"<STR_LIT>\" ) ; } else if ( StrUtil . isBlank ( tableName ) ) { log . warn ( \"<STR_LIT>\" ) ; } else { if ( outputItems == null || outputItems . isEmpty ( ) ) { return ; } JdbcTemplate template = new JdbcTemplate ( dataSourceManager . getDataSource ( Long . parseLong ( dsId ) ) ) ; StringBuilder preSql = new StringBuilder ( \"<STR_LIT>\" ) ; preSql . append ( tableName ) ; preSql . append ( \"<STR_LIT>\" ) ; StringBuilder nextSql = new StringBuilder ( \"<STR_LIT>\" ) ; for ( int i = <NUM_LIT> ; i < outputItems . size ( ) ; i ++ ) { SpiderOutput . OutputItem item = outputItems . get ( i ) ; if ( StrUtil . isNotBlank ( item . getName ( ) ) ) { if ( i == outputItems . size ( ) - <NUM_LIT> ) { preSql . append ( item . getName ( ) ) ; preSql . append ( \"<STR_LIT>\" ) ; nextSql . append ( \"<STR_LIT>\" ) ; } else { preSql . append ( item . getName ( ) ) ; preSql . append ( \"<STR_LIT>\" ) ; nextSql . append ( \"<STR_LIT>\" ) ; } } } List < Object > values = outputItems . stream ( ) . map ( item -> item . getValue ( ) ) . collect ( Collectors . toList ( ) ) ; if ( ! values . isEmpty ( ) ) { try { template . update ( preSql . append ( nextSql ) . toString ( ) , values . toArray ( ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } }", "output": "} } @ EventListener ( value = OutputEventBean . class , condition = \"<STR_LIT>\" ) private void outputCSV ( OutputEventBean eventBean ) { SpiderContext context = eventBean . getContext ( ) ; SpiderNode node = eventBean . getNode ( ) ; List < SpiderOutput . OutputItem > outputItems = eventBean . getOutputItems ( ) ; String csvName = node . getJsonProperty ( OUTPUT_CSV_NAME ) ; if ( outputItems == null || outputItems . isEmpty ( ) ) { return ; } String key = context . getId ( ) + \"<STR_LIT>\" + node . getNodeId ( ) ; Map < String , CSVPrinter > cachePrinter = OutputExecutor . getCachePrinter ( ) ; CSVPrinter printer = cachePrinter . get ( key ) ; List < String > records = new ArrayList < > ( outputItems . size ( ) ) ; List < String > headers = outputItems . stream ( ) . map ( item -> item . getName ( ) ) . collect ( Collectors . toList ( ) ) ; try { if ( printer == null ) { synchronized ( cachePrinter ) { printer = cachePrinter . get ( key ) ; if ( printer == null ) { CSVFormat format = CSVFormat . DEFAULT . withHeader ( headers . toArray ( new String [ headers . size ( ) ] ) ) ; FileOutputStream os = new FileOutputStream ( spiderConfig . getWorkspace ( ) + File . separator + csvName ) ; String csvEncoding = node . getJsonProperty ( OUTPUT_CSV_ENCODING ) ; if ( \"<STR_LIT>\" . equals ( csvEncoding ) ) { csvEncoding = csvEncoding . substring ( <NUM_LIT> , <NUM_LIT> ) ; byte [ ] bom = { ( byte ) <NUM_LIT> , ( byte ) <NUM_LIT> , ( byte ) <NUM_LIT> } ; os . write ( bom ) ; os . flush ( ) ; } OutputStreamWriter osw = new OutputStreamWriter ( os , csvEncoding ) ; printer = new CSVPrinter ( osw , format ) ; cachePrinter . put ( key , printer ) ; } } } for ( int i = <NUM_LIT> ; i < headers . size ( ) ; i ++ ) { SpiderOutput . OutputItem item = outputItems . get ( i ) ; if ( item . getValue ( ) != null ) { records . add ( item . getValue ( ) . toString ( ) ) ; } } synchronized ( cachePrinter ) { if ( ! records . isEmpty ( ) ) { printer . printRecord ( records ) ; } } } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } } }"}, {"input": "package com . yf . base . utils . download . temp ; public class DownloadTempThread { private String threadName ; private long skip ; private long pos ; private long loaded ; public String getThreadName ( ) { return threadName ; } public void setThreadName ( String threadName ) { this . threadName = threadName ; } public long getSkip ( ) { return skip ; } public void setSkip ( long skip ) { this . skip = skip ; } public long getPos ( ) { return pos ; } public void setPos ( long pos ) { this . pos = pos ; } public long getLoaded ( ) { return loaded ; } public void setLoaded ( long loaded ) { this . loaded = loaded ; }", "output": "}"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . ExamQuAnswer ; import cn . org . alan . exam . model . form . examquanswer . ExamQuAnswerAddForm ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . springframework . stereotype . Component ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface ExamQuAnswerConverter { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) ExamQuAnswer formToEntity ( ExamQuAnswerAddForm examQuAnswerAddForm ) ;", "output": "}"}, {"input": "package com . xcs . wx . domain . bo ; import lombok . Builder ; import lombok . Data ; @ Data @ Builder public class UserBO { private String basePath ; private String wxId ; private String nickname ; private String version ; private String account ; private String mobile ;", "output": "}"}, {"input": "package me . zhengjie . config ; import org . apache . catalina . connector . Connector ; import org . springframework . boot . web . embedded . tomcat . TomcatConnectorCustomizer ; import org . springframework . context . annotation . Configuration ; @ Configuration ( proxyBeanMethods = false ) public class RelaxedQueryCharsConnectorCustomizer implements TomcatConnectorCustomizer { @ Override public void customize ( Connector connector ) {", "output": "connector . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package me . zhengjie . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface Log {", "output": "String value ( ) default \"<STR_LIT>\" ; }"}, {"input": "package com . youlai . system . security . service ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . StrUtil ; import com . youlai . system . common . constant . SecurityConstants ; import com . youlai . system . security . util . SecurityUtils ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . stereotype . Component ; import org . springframework . util . PatternMatchUtils ; import java . util . * ; @ Component ( \"<STR_LIT>\" ) @ RequiredArgsConstructor @ Slf4j public class PermissionService { private final RedisTemplate < String , Object > redisTemplate ; public boolean hasPerm ( String requiredPerm ) { if ( StrUtil . isBlank ( requiredPerm ) ) { return false ; } if ( SecurityUtils . isRoot ( ) ) { return true ; } Set < String > roleCodes = SecurityUtils . getRoles ( ) ; if ( CollectionUtil . isEmpty ( roleCodes ) ) { return false ; } Set < String > rolePerms = this . getRolePermsFormCache ( roleCodes ) ; if ( CollectionUtil . isEmpty ( rolePerms ) ) { return false ; } boolean hasPermission = rolePerms . stream ( ) . anyMatch ( rolePerm -> PatternMatchUtils . simpleMatch ( rolePerm , requiredPerm ) ) ; if ( ! hasPermission ) { log . error ( \"<STR_LIT>\" ) ; } return hasPermission ; } public Set < String > getRolePermsFormCache ( Set < String > roleCodes ) { if ( CollectionUtil . isEmpty ( roleCodes ) ) { return Collections . emptySet ( ) ; }", "output": "Set < String > perms = new HashSet < > ( ) ; Collection < Object > roleCodesAsObjects = new ArrayList < > ( roleCodes ) ; List < Object > rolePermsList = redisTemplate . opsForHash ( ) . multiGet ( SecurityConstants . ROLE_PERMS_PREFIX , roleCodesAsObjects ) ; for ( Object rolePermsObj : rolePermsList ) { if ( rolePermsObj instanceof Set ) { @ SuppressWarnings ( \"<STR_LIT>\" ) Set < String > rolePerms = ( Set < String > ) rolePermsObj ; perms . addAll ( rolePerms ) ; } } return perms ; } }"}, {"input": "package org . springblade . cgform . model . generate . file ; import lombok . extern . slf4j . Slf4j ; import java . io . File ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class FileVo { private String templatePath ; private List < File > templateRootDirs ; private String stylePath ; public FileVo ( String templatePath ) { this . templateRootDirs = new ArrayList < File > ( ) ; log . debug ( \"<STR_LIT>\" + templatePath ) ;", "output": "log . debug ( \"<STR_LIT>\" + this . stylePath ) ; this . templatePath = templatePath ; } private void setTemplateRootDirs ( File file ) { this . setTemplateRootDirs ( new File [ ] { file } ) ; } private void setTemplateRootDirs ( File ... array ) { this . templateRootDirs = Arrays . asList ( array ) ; } public String getStylePath ( ) { return this . stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public List < File > getTemplateRootDirs ( ) { String classpath = this . getClass ( ) . getResource ( this . templatePath ) . getFile ( ) . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; if ( classpath . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { classpath = System . getProperty ( \"<STR_LIT>\" ) + File . separator + \"<STR_LIT>\" . replace ( \"<STR_LIT>\" , File . separator ) ; log . debug ( \"<STR_LIT>\" + classpath ) ; } this . setTemplateRootDirs ( new File ( classpath ) ) ; return this . templateRootDirs ; } public void setTemplateRootDirs ( List < File > templateRootDirs ) { this . templateRootDirs = templateRootDirs ; } @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( this . templateRootDirs ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( this . stylePath ) ; sb . append ( \"<STR_LIT>\" ) ; return sb . toString ( ) ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . secure . BladeUser ; import org . springblade . core . tenant . mp . TenantEntity ; import org . springblade . core . tool . utils . DateUtil ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformHead extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tableVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableTxt ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tableRemark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isCheckbox ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDbSynch ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isPage ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTree ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idSequence ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String queryMode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer relationType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String subTableStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer tabOrderNum ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeParentIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeIdField ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String treeFieldname ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String formTemplateMobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer scroll ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyVersion ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer copyType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long physicId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String themeTemplate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isDesForm ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String desFormCode ; @ TableField ( exist = false ) private transient Integer hascopy ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexTitle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String indexShow ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideHeader ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String hideMenu ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String basicFunction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String menuStyle ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveFormId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isAuthBtn ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String isTableData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String moveTablePattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String searchPattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String nologinSelect ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noViewDataRole ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String noOperationDataRole ; public static CgformHead init ( CgformHead head , String tenantId , BladeUser createUser ) { String deptId = createUser . getDeptId ( ) ; Long userId = createUser . getUserId ( ) ; head . setCreateUser ( userId ) ; head . setCreateDept ( Long . parseLong ( deptId ) ) ;", "output": "head . setCreateTime ( DateUtil . now ( ) ) ; head . setTenantId ( tenantId ) ; head . setIsDbSynch ( \"<STR_LIT>\" ) ; head . setTableVersion ( <NUM_LIT> ) ; head . setCopyType ( <NUM_LIT> ) ; if ( head . getTableType ( ) == <NUM_LIT> && head . getTabOrderNum ( ) == null ) { head . setTabOrderNum ( <NUM_LIT> ) ; } return head ; } }"}, {"input": "package com . xcs . wx . repository ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . xcs . wx . domain . Feeds ; import com . xcs . wx . domain . dto . FeedsDTO ; public interface FeedsRepository { Page < Feeds > queryFeeds ( FeedsDTO feedsDTO ) ;", "output": "}"}, {"input": "package org . springblade . web . mapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . Constants ; import org . apache . ibatis . annotations . Param ; import org . springblade . web . model . ContractTrade ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface MarketMapper { List < Map < String , Object > > getGoodsList ( String level ) ;", "output": "BigDecimal getMyTotalInvitereward ( String memberId , String type , String time ) ; List < ContractTrade > getExchangeDetailList ( String symbolName ) ; }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformEnhanceJava ; public interface CgformEnhanceJavaMapper extends BaseMapper < CgformEnhanceJava > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; public class ApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext context ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { ApplicationContextHolder . context = applicationContext ; } public static ApplicationContext get ( ) {", "output": "return context ; } }"}, {"input": "package org . springblade . gateway . filter ; import io . jsonwebtoken . Claims ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . core . jwt . JwtUtil ; import org . springblade . gateway . provider . AuthProvider ; import org . springblade . gateway . provider . RequestProvider ; import org . springframework . boot . actuate . autoconfigure . endpoint . web . WebEndpointProperties ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . context . annotation . Configuration ; import org . springframework . core . Ordered ; import org . springframework . http . HttpHeaders ; import org . springframework . http . server . reactive . ServerHttpRequest ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Mono ; import java . util . ArrayList ; import java . util . List ; @ Slf4j @ Configuration @ RequiredArgsConstructor @ ConditionalOnProperty ( value = \"<STR_LIT>\" , havingValue = \"<STR_LIT>\" , matchIfMissing = true ) public class GlobalRequestLogFilter implements GlobalFilter , Ordered { private final WebEndpointProperties endpointProperties ; @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { ServerHttpRequest request = exchange . getRequest ( ) ; String path = request . getPath ( ) . pathWithinApplication ( ) . value ( ) ; String endpointBasePath = endpointProperties . getBasePath ( ) ; if ( StringUtils . isNotBlank ( endpointBasePath ) && path . startsWith ( endpointBasePath ) ) { return chain . filter ( exchange ) ; } String requestUrl = RequestProvider . getOriginalRequestUrl ( exchange ) ; StringBuilder beforeReqLog = new StringBuilder ( <NUM_LIT> ) ; List < Object > beforeReqArgs = new ArrayList < > ( ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; String requestMethod = request . getMethodValue ( ) ; beforeReqArgs . add ( requestMethod ) ; beforeReqArgs . add ( requestUrl ) ; HttpHeaders headers = request . getHeaders ( ) ; headers . forEach ( ( headerName , headerValue ) -> { beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName ) ; if ( AuthProvider . AUTH_KEY . toLowerCase ( ) . equals ( headerName ) ) { String value = headerValue . get ( <NUM_LIT> ) ; String token = JwtUtil . getToken ( value ) ; Claims claims = JwtUtil . parseJWT ( token ) ; beforeReqArgs . add ( ( claims == null ) ? \"<STR_LIT>\" : claims . toString ( ) ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; beforeReqArgs . add ( headerName . concat ( \"<STR_LIT>\" ) ) ; beforeReqArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ;", "output": "} else { beforeReqArgs . add ( StringUtils . join ( headerValue . toArray ( ) ) ) ; } } ) ; beforeReqLog . append ( \"<STR_LIT>\" ) ; log . info ( beforeReqLog . toString ( ) , beforeReqArgs . toArray ( ) ) ; return chain . filter ( exchange ) ; } @ Override public int getOrder ( ) { return Ordered . LOWEST_PRECEDENCE ; } }"}, {"input": "package me . zhengjie . modules . quartz . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . QuartzLog ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface QuartzJobService extends IService < QuartzJob > { PageResult < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzJob > queryAll ( QuartzJobQueryCriteria criteria ) ; PageResult < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzLog > queryAllLog ( QuartzJobQueryCriteria criteria ) ; void create ( QuartzJob resources ) ; void update ( QuartzJob resources ) ; void delete ( Set < Long > ids ) ;", "output": "void updateIsPause ( QuartzJob quartzJob ) ; void execution ( QuartzJob quartzJob ) ; void download ( List < QuartzJob > queryAll , HttpServletResponse response ) throws IOException ; void downloadLog ( List < QuartzLog > queryAllLog , HttpServletResponse response ) throws IOException ; void executionSubJob ( String [ ] tasks ) throws InterruptedException ; }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; import java . io . Serializable ; @ Data public class OrderParam extends Query implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String orderCode ; private String memberId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String status ;", "output": "}"}, {"input": "package com . yf . config . websocket ; import org . springframework . boot . autoconfigure . condition . ConditionalOnWebApplication ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . socket . config . annotation . EnableWebSocket ; import org . springframework . web . socket . server . standard . ServerEndpointExporter ; @ ConditionalOnWebApplication @ Configuration @ EnableWebSocket public class WebSocketConfig { @ Bean public CustomSpringConfigurator customSpringConfigurator ( ) { return new CustomSpringConfigurator ( ) ; } @ Bean public ServerEndpointExporter serverEndpointExporter ( ) {", "output": "return new ServerEndpointExporter ( ) ; } }"}, {"input": "package org . springblade . config . autopoi . poi . handler . inter ; import java . util . Map ; public interface IExcelDataHandler { public Object exportHandler ( Object obj , String name , Object value ) ; public String [ ] getNeedHandlerFields ( ) ; public Object importHandler ( Object obj , String name , Object value ) ; public void setNeedHandlerFields ( String [ ] fields ) ; public void setMapValue ( Map < String , Object > map , String originKey , Object value ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . mapper . ExamGradeMapper ; import cn . org . alan . exam . mapper . ExamMapper ; import cn . org . alan . exam . mapper . UserExamsScoreMapper ; import cn . org . alan . exam . model . entity . Exam ; import cn . org . alan . exam . model . entity . UserExamsScore ; import cn . org . alan . exam . model . vo . score . ExportScoreVO ; import cn . org . alan . exam . model . vo . score . GradeScoreVO ; import cn . org . alan . exam . model . vo . score . UserScoreVO ; import cn . org . alan . exam . service . IUserExamsScoreService ; import cn . org . alan . exam . util . SecurityUtil ; import cn . org . alan . exam . util . excel . ExcelUtils ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import jakarta . servlet . http . HttpServletResponse ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class UserExamsScoreServiceImpl extends ServiceImpl < UserExamsScoreMapper , UserExamsScore > implements IUserExamsScoreService { @ Resource private UserExamsScoreMapper userExamsScoreMapper ; @ Resource private ExamMapper examMapper ; @ Resource private ExamGradeMapper examGradeMapper ; @ Override public Result < IPage < UserScoreVO > > pagingScore ( Integer pageNum , Integer pageSize , Integer gradeId , Integer examId , String realName ) { IPage < UserScoreVO > page = new Page < > ( pageNum , pageSize ) ; page = userExamsScoreMapper . pagingScore ( page , gradeId , examId , realName ) ; return Result . success ( null , page ) ; } @ Override public void exportScores ( HttpServletResponse response , Integer examId , Integer gradeId ) { List < ExportScoreVO > scores = userExamsScoreMapper . selectScores ( examId , gradeId ) ; final int [ ] sort = { <NUM_LIT> } ; scores . forEach ( exportScoreVO -> exportScoreVO . setRanking ( ++ sort [ <NUM_LIT> ] ) ) ; LambdaQueryWrapper < Exam > wrapper = new LambdaQueryWrapper < Exam > ( ) . eq ( Exam :: getId , examId ) . select ( Exam :: getTitle ) ; Exam exam = examMapper . selectOne ( wrapper ) ; ExcelUtils . export ( response , exam . getTitle ( ) , scores , ExportScoreVO . class ) ; } @ Override public Result < IPage < GradeScoreVO > > getExamScoreInfo ( Integer pageNum , Integer pageSize , String examTitle , Integer gradeId ) { IPage < GradeScoreVO > page = new Page < > ( pageNum , pageSize ) ; if ( \"<STR_LIT>\" . equals ( SecurityUtil . getRole ( ) ) ) { page = userExamsScoreMapper . scoreStatistics ( page , gradeId , examTitle , SecurityUtil . getUserId ( ) , <NUM_LIT> ) ; } else { page = userExamsScoreMapper . scoreStatistics ( page , gradeId , examTitle , SecurityUtil . getUserId ( ) , <NUM_LIT> ) ; } return Result . success ( \"<STR_LIT>\" , page ) ;", "output": "} }"}, {"input": "package com . yf . base . utils ; import org . dozer . DozerBeanMapper ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . function . Function ; import java . util . stream . Collectors ; public class BeanMapper { private static DozerBeanMapper dozerBeanMapper = new DozerBeanMapper ( ) ; public static < T > T map ( Object source , Class < T > destinationClass ) { return dozerBeanMapper . map ( source , destinationClass ) ; } public static < T > List < T > mapList ( Iterable < ? > sourceList , Class < T > destinationClass ) { List < T > destinationList = new ArrayList ( ) ; for ( Object sourceObject : sourceList ) { T destinationObject = dozerBeanMapper . map ( sourceObject , destinationClass ) ; destinationList . add ( destinationObject ) ; } return destinationList ; } public static void copy ( Object source , Object destinationObject ) { if ( source != null ) { dozerBeanMapper . map ( source , destinationObject ) ;", "output": "} } public static < T , S > List < T > mapList ( Collection < S > source , Function < ? super S , ? extends T > mapper ) { return source . stream ( ) . map ( mapper ) . collect ( Collectors . toList ( ) ) ; } }"}, {"input": "package org . example . ddduser . api . web ; import org . example . ddduser . application . dto . command . ModifyAddressCommand ; import org . example . ddduser . application . dto . command . ModifyPasswordCommand ; import org . example . ddduser . application . dto . command . ModifyProfileCommand ; import org . example . ddduser . application . dto . command . UserRegisterCommand ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserCommandService ; import org . example . ddduser . application . service . UserQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import javax . validation . Valid ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserController { @ Autowired private UserCommandService userCommandService ; @ Autowired private UserQueryService userQueryService ; @ PostMapping public void register ( @ Valid @ RequestBody UserRegisterCommand command ) { userCommandService . register ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyProfile ( @ Valid @ RequestBody ModifyProfileCommand command ) { userCommandService . modifyProfile ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyPassword ( @ Valid @ RequestBody ModifyPasswordCommand command ) { userCommandService . modifyPassword ( command ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void modifyAddress ( @ Valid @ RequestBody ModifyAddressCommand command ) { userCommandService . modifyAddress ( command ) ; } @ GetMapping public UserProfile profile ( ) {", "output": "return userQueryService . profile ( ) ; } }"}, {"input": "package top . kangert . kspider . model ; import lombok . Getter ; import lombok . Setter ; import java . util . ArrayList ; import java . util . List ; import cn . hutool . core . exceptions . ExceptionUtil ; @ Getter @ Setter public class SpiderLog { private String level ; private String message ; private List < Object > variables ; public SpiderLog ( String level , String message , List < Object > variables ) { if ( variables != null && variables . size ( ) > <NUM_LIT> ) { List < Object > nVariables = new ArrayList < > ( variables . size ( ) ) ; for ( Object object : variables ) { if ( object instanceof Throwable ) { nVariables . add ( ExceptionUtil . getMessage ( ( Throwable ) object ) ) ; } else { nVariables . add ( object ) ; }", "output": "} this . variables = nVariables ; } this . level = level ; this . message = message ; } }"}, {"input": "package com . youlai . system . plugin . easyexcel ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . lang . Validator ; import cn . hutool . core . util . StrUtil ; import cn . hutool . extra . spring . SpringUtil ; import cn . hutool . json . JSONUtil ; import com . alibaba . excel . context . AnalysisContext ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . youlai . system . common . base . IBaseEnum ; import com . youlai . system . common . constant . SystemConstants ; import com . youlai . system . enums . GenderEnum ; import com . youlai . system . enums . StatusEnum ; import com . youlai . system . converter . UserConverter ; import com . youlai . system . model . dto . UserImportDTO ; import com . youlai . system . model . entity . SysDept ; import com . youlai . system . model . entity . SysRole ; import com . youlai . system . model . entity . SysUser ; import com . youlai . system . model . entity . SysUserRole ; import com . youlai . system . service . SysDeptService ; import com . youlai . system . service . SysRoleService ; import com . youlai . system . service . SysUserRoleService ; import com . youlai . system . service . SysUserService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . security . crypto . password . PasswordEncoder ; import java . util . List ; import java . util . stream . Collectors ; @ Slf4j public class UserImportListener extends MyAnalysisEventListener < UserImportDTO > { private int validCount ; private int invalidCount ; StringBuilder msg = new StringBuilder ( ) ; private final SysUserService userService ; private final PasswordEncoder passwordEncoder ; private final UserConverter userConverter ; private final SysRoleService roleService ; private final SysUserRoleService userRoleService ; private final SysDeptService deptService ; public UserImportListener ( ) { this . userService = SpringUtil . getBean ( SysUserService . class ) ; this . passwordEncoder = SpringUtil . getBean ( PasswordEncoder . class ) ; this . roleService = SpringUtil . getBean ( SysRoleService . class ) ; this . userRoleService = SpringUtil . getBean ( SysUserRoleService . class ) ; this . deptService = SpringUtil . getBean ( SysDeptService . class ) ; this . userConverter = SpringUtil . getBean ( UserConverter . class ) ; } @ Override public void invoke ( UserImportDTO userImportDTO , AnalysisContext analysisContext ) { log . info ( \"<STR_LIT>\" , JSONUtil . toJsonStr ( userImportDTO ) ) ; StringBuilder validationMsg = new StringBuilder ( ) ; String username = userImportDTO . getUsername ( ) ; if ( StrUtil . isBlank ( username ) ) { validationMsg . append ( \"<STR_LIT>\" ) ; } else { long count = userService . count ( new LambdaQueryWrapper < SysUser > ( ) . eq ( SysUser :: getUsername , username ) ) ; if ( count > <NUM_LIT> ) { validationMsg . append ( \"<STR_LIT>\" ) ; } } String nickname = userImportDTO . getNickname ( ) ; if ( StrUtil . isBlank ( nickname ) ) { validationMsg . append ( \"<STR_LIT>\" ) ; } String mobile = userImportDTO . getMobile ( ) ; if ( StrUtil . isBlank ( mobile ) ) { validationMsg . append ( \"<STR_LIT>\" ) ; } else { if ( ! Validator . isMobile ( mobile ) ) { validationMsg . append ( \"<STR_LIT>\" ) ; } } if ( validationMsg . isEmpty ( ) ) { SysUser entity = userConverter . toEntity ( userImportDTO ) ; entity . setPassword ( passwordEncoder . encode ( SystemConstants . DEFAULT_PASSWORD ) ) ; String genderLabel = userImportDTO . getGenderLabel ( ) ; if ( StrUtil . isNotBlank ( genderLabel ) ) { Integer genderValue = ( Integer ) IBaseEnum . getValueByLabel ( genderLabel , GenderEnum . class ) ; entity . setGender ( genderValue ) ; } String roleCodes = userImportDTO . getRoleCodes ( ) ; List < Long > roleIds = null ; if ( StrUtil . isNotBlank ( roleCodes ) ) { roleIds = roleService . list ( new LambdaQueryWrapper < SysRole > ( ) . in ( SysRole :: getCode , ( Object ) roleCodes . split ( \"<STR_LIT>\" ) ) . eq ( SysRole :: getStatus , StatusEnum . ENABLE . getValue ( ) ) . select ( SysRole :: getId ) ) . stream ( ) . map ( SysRole :: getId ) . collect ( Collectors . toList ( ) ) ; } String deptCode = userImportDTO . getDeptCode ( ) ; if ( StrUtil . isNotBlank ( deptCode ) ) { SysDept dept = deptService . getOne ( new LambdaQueryWrapper < SysDept > ( ) . eq ( SysDept :: getCode , deptCode ) . select ( SysDept :: getId ) ) ; if ( dept != null ) { entity . setDeptId ( dept . getId ( ) ) ; } } boolean saveResult = userService . save ( entity ) ; if ( saveResult ) { validCount ++ ; if ( CollectionUtil . isNotEmpty ( roleIds ) ) { List < SysUserRole > userRoles = roleIds . stream ( ) . map ( roleId -> new SysUserRole ( entity . getId ( ) , roleId ) ) . collect ( Collectors . toList ( ) ) ; userRoleService . saveBatch ( userRoles ) ; } } else { invalidCount ++ ; msg . append ( \"<STR_LIT>\" ) . append ( validCount + invalidCount ) . append ( \"<STR_LIT>\" ) ; } } else { invalidCount ++ ;", "output": "msg . append ( \"<STR_LIT>\" ) . append ( validCount + invalidCount ) . append ( \"<STR_LIT>\" ) . append ( validationMsg + \"<STR_LIT>\" ) ; } } @ Override public void doAfterAllAnalysed ( AnalysisContext analysisContext ) { log . info ( \"<STR_LIT>\" ) ; } @ Override public String getMsg ( ) { return StrUtil . format ( \"<STR_LIT>\" , validCount , invalidCount , msg ) ; } }"}, {"input": "package org . springblade . config . util ; import org . springblade . config . autopoi . poi . handler . impl . ExcelDataHandlerDefaultImpl ; import org . springblade . cgform . entity . CgformField ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public class ExcelDataHandlerDefaultUtil extends ExcelDataHandlerDefaultImpl { Map < String , CgformField > onlCgformFieldMap ; String online ; public ExcelDataHandlerDefaultUtil ( List < CgformField > fields ) { this . onlCgformFieldMap = this . getOnlCgformFieldMapByFields ( fields ) ; this . online = \"<STR_LIT>\" ; } private Map < String , CgformField > getOnlCgformFieldMapByFields ( List < CgformField > fields ) { Map < String , CgformField > result = new HashMap < > ( ) ; Iterator < CgformField > iterator = fields . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = iterator . next ( ) ; result . put ( field . getDbFieldTxt ( ) , field ) ; } return result ; } private String getKey ( String originKey ) { return this . onlCgformFieldMap . containsKey ( originKey ) ? \"<STR_LIT>\" + ( ( CgformField ) this . onlCgformFieldMap . get ( originKey ) ) . getDbFieldName ( ) : \"<STR_LIT>\" + originKey ; }", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . service . impl ; import cn . hutool . core . util . IdUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . mapper . DeployHistoryMapper ; import me . zhengjie . modules . mnt . service . DeployHistoryService ; import me . zhengjie . modules . mnt . domain . vo . DeployHistoryQueryCriteria ; import me . zhengjie . utils . DateUtil ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor public class DeployHistoryServiceImpl extends ServiceImpl < DeployHistoryMapper , DeployHistory > implements DeployHistoryService { private final DeployHistoryMapper deployhistoryMapper ; @ Override public PageResult < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( deployhistoryMapper . findAll ( criteria , page ) ) ; } @ Override public List < DeployHistory > queryAll ( DeployHistoryQueryCriteria criteria ) { return deployhistoryMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( DeployHistory resources ) { resources . setId ( IdUtil . simpleUUID ( ) ) ; resources . setDeployDate ( DateUtil . getTimeStamp ( ) ) ; save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < String > ids ) { removeBatchByIds ( ids ) ; } @ Override public void download ( List < DeployHistory > deployHistories , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( DeployHistory deployHistory : deployHistories ) { Map < String , Object > map = new LinkedHashMap < > ( ) ;", "output": "map . put ( \"<STR_LIT>\" , deployHistory . getDeployId ( ) ) ; map . put ( \"<STR_LIT>\" , deployHistory . getAppName ( ) ) ; map . put ( \"<STR_LIT>\" , deployHistory . getIp ( ) ) ; map . put ( \"<STR_LIT>\" , deployHistory . getDeployDate ( ) ) ; map . put ( \"<STR_LIT>\" , deployHistory . getDeployUser ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ThreadDumpper { private static final int DEFAULT_MAX_STACK_LEVEL = <NUM_LIT> ; private static final int DEFAULT_MIN_INTERVAL = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private static Logger logger = LoggerFactory . getLogger ( ThreadDumpper . class ) ; private int maxStackLevel ; private TimeIntervalLimiter timeIntervalLimiter ; public ThreadDumpper ( ) { this ( DEFAULT_MIN_INTERVAL , DEFAULT_MAX_STACK_LEVEL ) ; } public ThreadDumpper ( long leastIntervalMills , int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalMills , TimeUnit . MILLISECONDS ) ; } public void tryThreadDump ( ) { tryThreadDump ( null ) ; } public void tryThreadDump ( String reasonMsg ) { if ( timeIntervalLimiter . tryAcquire ( ) ) { threadDump ( reasonMsg ) ; } } public void threadDump ( String reasonMsg ) { logger . info ( \"<STR_LIT>\" + ( reasonMsg != null ? ( \"<STR_LIT>\" + reasonMsg ) : \"<STR_LIT>\" ) ) ; Map < Thread , StackTraceElement [ ] > threads = Thread . getAllStackTraces ( ) ; logger . info ( \"<STR_LIT>\" ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> * <NUM_LIT> ) . append ( '<STR_LIT>' ) ; for ( Entry < Thread , StackTraceElement [ ] > entry : threads . entrySet ( ) ) {", "output": "dumpThreadInfo ( entry . getKey ( ) , entry . getValue ( ) , sb ) ; } logger . info ( sb . toString ( ) ) ; } private String dumpThreadInfo ( Thread thread , StackTraceElement [ ] stackTrace , StringBuilder sb ) { sb . append ( '<STR_LIT>' ) . append ( thread . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( thread . getId ( ) ) . append ( '<STR_LIT>' ) . append ( thread . getState ( ) ) ; sb . append ( '<STR_LIT>' ) ; int i = <NUM_LIT> ; for ( ; i < Math . min ( maxStackLevel , stackTrace . length ) ; i ++ ) { StackTraceElement ste = stackTrace [ i ] ; sb . append ( \"<STR_LIT>\" ) . append ( ste ) . append ( '<STR_LIT>' ) ; } if ( i < stackTrace . length ) { sb . append ( \"<STR_LIT>\" ) . append ( '<STR_LIT>' ) ; } sb . append ( '<STR_LIT>' ) ; return sb . toString ( ) ; } public void setLeastInterval ( int leastIntervalSeconds ) { this . timeIntervalLimiter = new TimeIntervalLimiter ( leastIntervalSeconds , TimeUnit . MILLISECONDS ) ; } public void setMaxStackLevel ( int maxStackLevel ) { this . maxStackLevel = maxStackLevel ; } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class BuySellWalletParam { private RemoveWalletParam sellParam ; private AddWalletParam buyParam ;", "output": "}"}, {"input": "package org . springblade . gateway . provider ; import java . util . HashMap ; import java . util . Map ; public class ResponseProvider { public static Map < String , Object > success ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > fail ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > unAuth ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > error ( String message ) { return response ( <NUM_LIT> , message ) ; } public static Map < String , Object > response ( int status , String message ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; map . put ( \"<STR_LIT>\" , status ) ; map . put ( \"<STR_LIT>\" , message ) ;", "output": "map . put ( \"<STR_LIT>\" , null ) ; return map ; } }"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . youlai . system . mapper . SysUserRoleMapper ; import com . youlai . system . model . entity . SysUserRole ; import com . youlai . system . service . SysUserRoleService ; import org . springframework . stereotype . Service ; import java . util . List ; import java . util . stream . Collectors ; @ Service public class SysUserRoleServiceImpl extends ServiceImpl < SysUserRoleMapper , SysUserRole > implements SysUserRoleService { @ Override public boolean saveUserRoles ( Long userId , List < Long > roleIds ) { if ( userId == null || CollectionUtil . isEmpty ( roleIds ) ) { return false ; } List < Long > userRoleIds = this . list ( new LambdaQueryWrapper < SysUserRole > ( ) . eq ( SysUserRole :: getUserId , userId ) ) . stream ( ) . map ( SysUserRole :: getRoleId ) . collect ( Collectors . toList ( ) ) ; List < Long > saveRoleIds ; if ( CollectionUtil . isEmpty ( userRoleIds ) ) { saveRoleIds = roleIds ; } else { saveRoleIds = roleIds . stream ( ) . filter ( roleId -> ! userRoleIds . contains ( roleId ) ) . collect ( Collectors . toList ( ) ) ; } List < SysUserRole > saveUserRoles = saveRoleIds . stream ( ) . map ( roleId -> new SysUserRole ( userId , roleId ) ) . collect ( Collectors . toList ( ) ) ; this . saveBatch ( saveUserRoles ) ; if ( CollectionUtil . isNotEmpty ( userRoleIds ) ) { List < Long > removeRoleIds = userRoleIds . stream ( ) . filter ( roleId -> ! roleIds . contains ( roleId ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtil . isNotEmpty ( removeRoleIds ) ) { this . remove ( new LambdaQueryWrapper < SysUserRole > ( ) . eq ( SysUserRole :: getUserId , userId ) . in ( SysUserRole :: getRoleId , removeRoleIds ) ) ; } } return true ; } @ Override public boolean hasAssignedUsers ( Long roleId ) { int count = this . baseMapper . countUsersForRole ( roleId ) ; return count > <NUM_LIT> ;", "output": "} }"}, {"input": "package com . oddfar . campus . admin . config ; import com . google . code . kaptcha . impl . DefaultKaptcha ; import com . google . code . kaptcha . util . Config ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . Properties ; import static com . google . code . kaptcha . Constants . * ; @ Configuration public class CaptchaConfig { @ Bean ( name = \"<STR_LIT>\" ) public DefaultKaptcha getKaptchaBean ( ) { DefaultKaptcha defaultKaptcha = new DefaultKaptcha ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( KAPTCHA_BORDER , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_FONT_COLOR , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_IMAGE_WIDTH , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_IMAGE_HEIGHT , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_FONT_SIZE , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_SESSION_CONFIG_KEY , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_CHAR_LENGTH , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_FONT_NAMES , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_OBSCURIFICATOR_IMPL , \"<STR_LIT>\" ) ; Config config = new Config ( properties ) ; defaultKaptcha . setConfig ( config ) ; return defaultKaptcha ; } @ Bean ( name = \"<STR_LIT>\" ) public DefaultKaptcha getKaptchaBeanMath ( ) { DefaultKaptcha defaultKaptcha = new DefaultKaptcha ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( KAPTCHA_BORDER , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_BORDER_COLOR , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_FONT_COLOR , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_IMAGE_WIDTH , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_IMAGE_HEIGHT , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_FONT_SIZE , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_SESSION_CONFIG_KEY , \"<STR_LIT>\" ) ;", "output": "properties . setProperty ( KAPTCHA_TEXTPRODUCER_IMPL , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_CHAR_SPACE , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_CHAR_LENGTH , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_TEXTPRODUCER_FONT_NAMES , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_NOISE_COLOR , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_NOISE_IMPL , \"<STR_LIT>\" ) ; properties . setProperty ( KAPTCHA_OBSCURIFICATOR_IMPL , \"<STR_LIT>\" ) ; Config config = new Config ( properties ) ; defaultKaptcha . setConfig ( config ) ; return defaultKaptcha ; } }"}, {"input": "package org . springblade . plugin . message . model ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ Data @ Builder @ NoArgsConstructor @ AllArgsConstructor public class MessageStruct implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String message ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . userbook ; import com . baomidou . mybatisplus . annotation . FieldFill ; import com . baomidou . mybatisplus . annotation . TableField ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class UserPageBookVO { private String id ; private String title ; private String numberOfErrors ; private Integer examId ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import io . github . chensheng . dddboot . web . core . BizException ; import org . springframework . beans . factory . annotation . Autowired ; public abstract class DDDRepositoryImpl < E extends DDDEntity , D extends IDataObject , C extends DDDConvertor < E , D , ? > , M extends BaseMapper < D > > implements DDDRepository < E > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Long save ( E entity ) throws BizException { D dataObject = convertor . toDataObject ( entity ) ; if ( dataObject . getId ( ) == null ) { mapper . insert ( dataObject ) ; return dataObject . getId ( ) ; } D existingDataObject = mapper . selectById ( dataObject . getId ( ) ) ; if ( existingDataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } dataObject . beforeUpdate ( existingDataObject ) ; mapper . updateById ( dataObject ) ; return dataObject . getId ( ) ; } @ Override public E getById ( Long id ) throws BizException { if ( id == null ) {", "output": "throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } E entity = convertor . toEntity ( dataObject ) ; if ( entity == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return entity ; } @ Override public int remove ( E entity ) throws BizException { if ( entity . getId ( ) == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return mapper . deleteById ( entity . getId ( ) ) ; } }"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . group . CertificateGroup ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . Certificate ; import cn . org . alan . exam . model . form . CertificateForm ; import cn . org . alan . exam . model . vo . certificate . MyCertificateVO ; import cn . org . alan . exam . service . ICertificateService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class CertificateController { @ Resource private ICertificateService iCertificateService ; @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > addCertificate ( @ RequestBody @ Validated ( CertificateGroup . CertificateInsertGroup . class ) CertificateForm certificateForm ) { return iCertificateService . addCertificate ( certificateForm ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < Certificate > > pagingCertificate ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String certificateName , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String certificationUnit ) { return iCertificateService . pagingCertificate ( pageNum , pageSize , certificateName , certificationUnit ) ; } @ PutMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > updateCertificate ( @ PathVariable ( \"<STR_LIT>\" ) Integer id , @ RequestBody CertificateForm certificateForm ) { certificateForm . setId ( id ) ; return iCertificateService . updateCertificate ( certificateForm ) ; } @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < String > deleteCertificate ( @ PathVariable ( \"<STR_LIT>\" ) Integer id ) { return iCertificateService . deleteCertificate ( id ) ; }", "output": "@ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < MyCertificateVO > > getMyCertificate ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String examName ) { return iCertificateService . getMyCertificatePaging ( pageNum , pageSize , examName ) ; } }"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysUserRoleEntity implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( type = IdType . INPUT ) private Long userId ; private Long roleId ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingMaintainServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingMaintainService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; public NamingMaintainServiceBeanBuilder ( ) { super ( GlobalNacosPropertiesSource . MAINTAIN ) ; }", "output": "@ Override protected NamingMaintainService createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException { return nacosServiceFactory . createNamingMaintainService ( properties ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent ; import com . google . common . util . concurrent . RateLimiter ; import io . github . chensheng . dddboot . tools . concurrent . jsr166e . LongAdder ; import io . github . chensheng . dddboot . tools . concurrent . limiter . RateLimiterUtil ; import io . github . chensheng . dddboot . tools . concurrent . limiter . Sampler ; import io . github . chensheng . dddboot . tools . concurrent . limiter . TimeIntervalLimiter ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; public class Concurrents { public static LongAdder longAdder ( ) { return new LongAdder ( ) ;", "output": "} public static CountDownLatch countDownLatch ( int count ) { return new CountDownLatch ( count ) ; } public static CyclicBarrier cyclicBarrier ( int count ) { return new CyclicBarrier ( count ) ; } public static Semaphore nonFairSemaphore ( int permits ) { return new Semaphore ( permits ) ; } public static Semaphore fairSemaphore ( int permits ) { return new Semaphore ( permits , true ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond ) { return RateLimiter . create ( permitsPerSecond ) ; } public static RateLimiter rateLimiter ( int permitsPerSecond , int maxBurstSeconds ) throws ReflectiveOperationException { return RateLimiterUtil . create ( permitsPerSecond , maxBurstSeconds ) ; } public static Sampler sampler ( double selectPercent ) { return Sampler . create ( selectPercent ) ; } public static TimeIntervalLimiter timeIntervalLimiter ( long interval , TimeUnit timeUnit ) { return new TimeIntervalLimiter ( interval , timeUnit ) ; } }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysRoleMenuEntity ; import com . oddfar . campus . common . domain . entity . SysUserRoleEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import com . oddfar . campus . common . exception . ServiceException ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . api . resource . ResourceCollectorApi ; import com . oddfar . campus . framework . mapper . SysRoleMapper ; import com . oddfar . campus . framework . mapper . SysRoleMenuMapper ; import com . oddfar . campus . framework . mapper . SysUserRoleMapper ; import com . oddfar . campus . framework . service . SysMenuService ; import com . oddfar . campus . framework . service . SysResourceService ; import com . oddfar . campus . framework . service . SysRoleService ; import org . springframework . context . ApplicationContext ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . annotation . Resource ; import java . util . * ; import java . util . stream . Collectors ; @ Service public class SysRoleServiceImpl extends ServiceImpl < SysUserRoleMapper , SysUserRoleEntity > implements SysRoleService { @ Resource private SysRoleMapper roleMapper ; @ Resource private SysUserRoleMapper userRoleMapper ; @ Resource private SysRoleMenuMapper roleMenuMapper ; @ Resource private SysMenuService menuService ; @ Resource private SysResourceService resourceService ; @ Resource ApplicationContext applicationContext ; @ Override public PageResult < SysRoleEntity > page ( SysRoleEntity sysRoleEntity ) { return roleMapper . selectPage ( sysRoleEntity ) ; } @ Override public List < SysRoleEntity > selectRoleList ( SysRoleEntity role ) { return roleMapper . selectRoleList ( role ) ; } @ Override public Set < String > selectRolePermissionByUserId ( Long userId ) { List < SysRoleEntity > perms = roleMapper . selectRolePermissionByUserId ( userId ) ; Set < String > permsSet = new HashSet < > ( ) ; for ( SysRoleEntity perm : perms ) { if ( StringUtils . isNotNull ( perm ) ) { permsSet . addAll ( Arrays . asList ( perm . getRoleKey ( ) . trim ( ) . split ( \"<STR_LIT>\" ) ) ) ; }", "output": "} return permsSet ; } @ Override public SysRoleEntity selectRoleById ( Long roleId ) { return roleMapper . selectRoleById ( roleId ) ; } @ Override public List < SysRoleEntity > selectRoleAll ( ) { return this . selectRoleList ( new SysRoleEntity ( ) ) ; } @ Override public List < SysRoleEntity > selectRolesByUserId ( Long userId ) { List < SysRoleEntity > userRoles = roleMapper . selectRolePermissionByUserId ( userId ) ; List < SysRoleEntity > roles = selectRoleAll ( ) ; for ( SysRoleEntity role : roles ) { for ( SysRoleEntity userRole : userRoles ) { if ( role . getRoleId ( ) . longValue ( ) == userRole . getRoleId ( ) . longValue ( ) ) { role . setFlag ( true ) ; break ; } } } return roles ; } @ Override @ Transactional public int insertRole ( SysRoleEntity role ) { roleMapper . insert ( role ) ; return insertRoleMenu ( role ) ; } @ Override public int updateRole ( SysRoleEntity role ) { roleMapper . updateById ( role ) ; roleMenuMapper . deleteRoleMenuByRoleId ( role . getRoleId ( ) ) ; return insertRoleMenu ( role ) ; } @ Override public int updateRoleStatus ( SysRoleEntity role ) { return roleMapper . updateById ( role ) ; } @ Override @ Transactional public int deleteRoleByIds ( Long [ ] roleIds ) { for ( Long roleId : roleIds ) { checkRoleAllowed ( new SysRoleEntity ( roleId ) ) ; SysRoleEntity role = selectRoleById ( roleId ) ; if ( countUserRoleByRoleId ( roleId ) > <NUM_LIT> ) { throw new ServiceException ( String . format ( \"<STR_LIT>\" , role . getRoleName ( ) ) ) ; } } roleMenuMapper . deleteRoleMenu ( roleIds ) ; return roleMapper . deleteBatchIds ( Arrays . asList ( roleIds ) ) ; } @ Override public int deleteAuthUser ( SysUserRoleEntity userRole ) { return userRoleMapper . deleteUserRoleInfo ( userRole ) ; } @ Override public int deleteAuthUsers ( Long roleId , Long [ ] userIds ) { return userRoleMapper . deleteUserRoleInfos ( roleId , userIds ) ; } @ Override public boolean insertAuthUsers ( Long roleId , Long [ ] userIds ) { List < SysUserRoleEntity > list = new ArrayList < SysUserRoleEntity > ( ) ; for ( Long userId : userIds ) { SysUserRoleEntity ur = new SysUserRoleEntity ( ) ; ur . setUserId ( userId ) ; ur . setRoleId ( roleId ) ; list . add ( ur ) ; } return this . saveBatch ( list ) ; } @ Override public int countUserRoleByRoleId ( Long roleId ) { return userRoleMapper . countUserRoleByRoleId ( roleId ) ; } @ Override public boolean checkRoleNameUnique ( SysRoleEntity role ) { Long roleId = StringUtils . isNull ( role . getRoleId ( ) ) ? - <NUM_LIT> : role . getRoleId ( ) ; SysRoleEntity info = roleMapper . checkRoleNameUnique ( role . getRoleName ( ) ) ; if ( StringUtils . isNotNull ( info ) && info . getRoleId ( ) . longValue ( ) != roleId . longValue ( ) ) { return false ; } return true ; } @ Override public boolean checkRoleKeyUnique ( SysRoleEntity role ) { Long roleId = StringUtils . isNull ( role . getRoleId ( ) ) ? - <NUM_LIT> : role . getRoleId ( ) ; SysRoleEntity info = roleMapper . checkRoleKeyUnique ( role . getRoleKey ( ) ) ; if ( StringUtils . isNotNull ( info ) && info . getRoleId ( ) . longValue ( ) != roleId . longValue ( ) ) { return false ; } return true ; } @ Override public void checkRoleAllowed ( SysRoleEntity role ) { if ( StringUtils . isNotNull ( role . getRoleId ( ) ) && role . isAdmin ( ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } } @ Override public void resetRoleAuthCache ( ) { Map < Long , List < SysRoleAuth > > rolePermsMap = menuService . selectMenuPermsAll ( ) ; Map < Long , List < SysRoleAuth > > roleResourceMap = resourceService . selectSysRoleAuthAll ( ) . stream ( ) . collect ( Collectors . groupingBy ( SysRoleAuth :: getRoleID ) ) ; ResourceCollectorApi resourceCollectorApi = applicationContext . getBean ( ResourceCollectorApi . class ) ; resourceCollectorApi . setRoleAuthCache ( rolePermsMap , roleResourceMap ) ; } public int insertRoleMenu ( SysRoleEntity role ) { int rows = <NUM_LIT> ; List < SysRoleMenuEntity > list = new ArrayList < SysRoleMenuEntity > ( ) ; for ( Long menuId : role . getMenuIds ( ) ) { SysRoleMenuEntity rm = new SysRoleMenuEntity ( ) ; rm . setRoleId ( role . getRoleId ( ) ) ; rm . setMenuId ( menuId ) ; list . add ( rm ) ; } if ( list . size ( ) > <NUM_LIT> ) { rows = roleMenuMapper . batchRoleMenu ( list ) ; } return rows ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Certificate ; import cn . org . alan . exam . model . form . CertificateForm ; import cn . org . alan . exam . model . vo . certificate . MyCertificateVO ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . apache . ibatis . annotations . Param ; import org . springframework . stereotype . Repository ; import java . util . List ; @ Repository public interface CertificateMapper extends BaseMapper < Certificate > {", "output": "Page < MyCertificateVO > selectMyCertificate ( Page < MyCertificateVO > myCertificateVOPage , Integer pageNum , Integer pageSize , Integer userId , String examName ) ; int countByCondition ( Integer userId , String certificateName , String certificationUnit ) ; List < Integer > selectCertificateIdsPage ( Integer userId , String certificateName , String certificationUnit , Integer offset , Integer pageSize ) ; List < Certificate > batchSelectByIds ( List < Integer > missIds ) ; }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . domain . dto . ContactDTO ; import com . xcs . wx . domain . vo . * ; import com . xcs . wx . service . ContactService ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import java . util . List ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class ContactController { private final ContactService contactService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < ContactVO > > list ( ContactDTO contactDTO ) { PageVO < ContactVO > pageVO = contactService . queryContact ( contactDTO ) ; return ResponseVO . ok ( pageVO . getRecords ( ) , pageVO . getCurrent ( ) , pageVO . getTotal ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < AllContactVO > > all ( ) { return ResponseVO . ok ( contactService . queryAllContact ( ) ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < List < ContactLabelVO > > label ( ) { return ResponseVO . ok ( contactService . queryContactLabel ( ) ) ; }", "output": "@ GetMapping ( \"<STR_LIT>\" ) public ResponseVO < String > export ( ) { return ResponseVO . ok ( contactService . exportContact ( ) ) ; } }"}, {"input": "package com . youlai . system . exception ; import com . youlai . system . common . result . IResultCode ; import lombok . Getter ; import org . slf4j . helpers . MessageFormatter ; @ Getter public class BusinessException extends RuntimeException { public IResultCode resultCode ; public BusinessException ( IResultCode errorCode ) { super ( errorCode . getMsg ( ) ) ; this . resultCode = errorCode ; } public BusinessException ( String message , Throwable cause ) { super ( message , cause ) ; } public BusinessException ( Throwable cause ) { super ( cause ) ; } public BusinessException ( String message , Object ... args ) { super ( formatMessage ( message , args ) ) ; } private static String formatMessage ( String message , Object ... args ) { return MessageFormatter . arrayFormat ( message , args ) . getMessage ( ) ;", "output": "} }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . io . FileUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . extra . spring . SpringUtil ; import com . baomidou . dynamic . datasource . DynamicRoutingDataSource ; import com . baomidou . dynamic . datasource . creator . DataSourceProperty ; import com . baomidou . dynamic . datasource . creator . DefaultDataSourceCreator ; import com . baomidou . dynamic . datasource . creator . druid . DruidConfig ; import com . xcs . wx . constant . SqliteConstant ; import com . xcs . wx . domain . bo . DecryptBO ; import com . xcs . wx . domain . bo . UserBO ; import com . xcs . wx . domain . dto . DecryptDTO ; import com . xcs . wx . domain . vo . DatabaseVO ; import com . xcs . wx . domain . vo . DecryptVO ; import com . xcs . wx . domain . vo . ResponseVO ; import com . xcs . wx . service . DatabaseService ; import com . xcs . wx . service . DecryptService ; import com . xcs . wx . service . UserService ; import com . xcs . wx . service . WeChatService ; import com . xcs . wx . util . DSNameUtil ; import com . xcs . wx . util . DirUtil ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . boot . ApplicationArguments ; import org . springframework . boot . ApplicationRunner ; import org . springframework . http . MediaType ; import org . springframework . stereotype . Service ; import org . springframework . web . servlet . mvc . method . annotation . SseEmitter ; import javax . sql . DataSource ; import java . io . File ; import java . io . IOException ; import java . nio . file . FileSystems ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . Collections ; import java . util . List ; import java . util . stream . Collectors ; import java . util . stream . Stream ; @ Slf4j @ Service @ RequiredArgsConstructor public class DatabaseServiceImpl implements DatabaseService , ApplicationRunner { private final DecryptService decryptService ; private final WeChatService weChatService ; private final UserService userService ; @ Override public void decrypt ( SseEmitter emitter , DecryptDTO decryptDTO ) { String separator = FileSystems . getDefault ( ) . getSeparator ( ) ; String dbPath = decryptDTO . getBasePath ( ) + separator + decryptDTO . getWxId ( ) ; String key = weChatService . getKey ( decryptDTO . getPid ( ) , dbPath ) ; if ( StrUtil . isBlank ( key ) ) { try { emitter . send ( ResponseVO . error ( - <NUM_LIT> , \"<STR_LIT>\" ) , MediaType . APPLICATION_JSON ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { emitter . complete ( ) ; } return ; } String scanPath = dbPath + separator + \"<STR_LIT>\" ; String outputPath = DirUtil . getDbDir ( decryptDTO . getWxId ( ) ) ; try ( Stream < Path > stream = Files . walk ( Paths . get ( scanPath ) ) ) { List < DecryptBO > decryptBOList = getWeChatDb ( stream , outputPath ) ; for ( int i = <NUM_LIT> ; i < decryptBOList . size ( ) ; i ++ ) { DecryptBO decryptBO = decryptBOList . get ( i ) ; int currentProgress = ( ( i + <NUM_LIT> ) * <NUM_LIT> ) / decryptBOList . size ( ) ; File currentFile = new File ( decryptBO . getInput ( ) ) ; DecryptVO decryptVO = DecryptVO . builder ( ) . fileName ( FileUtil . getName ( currentFile ) ) . fileSize ( FileUtil . readableFileSize ( currentFile ) ) . total ( decryptBOList . size ( ) ) . currentProgress ( currentProgress ) . build ( ) ; try { emitter . send ( ResponseVO . ok ( decryptVO ) , MediaType . APPLICATION_JSON ) ; } catch ( IOException ignore ) { } decryptService . wechatDecrypt ( key , decryptBO ) ; registerDataSource ( decryptBO . getOutput ( ) ) ; } userService . saveUser ( UserBO . builder ( ) . basePath ( decryptDTO . getBasePath ( ) ) . account ( decryptDTO . getAccount ( ) ) . mobile ( decryptDTO . getMobile ( ) ) . version ( decryptDTO . getVersion ( ) ) . nickname ( decryptDTO . getNickname ( ) ) . wxId ( decryptDTO . getWxId ( ) ) . build ( ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } finally { emitter . complete ( ) ; } } @ Override public List < DatabaseVO > getDatabase ( String wxId ) { String dbPath = DirUtil . getDbDir ( wxId ) ; if ( ! FileUtil . exist ( dbPath ) ) { return Collections . emptyList ( ) ; } try ( Stream < Path > stream = Files . walk ( Paths . get ( dbPath ) ) ) { return stream . filter ( file -> file . toString ( ) . endsWith ( \"<STR_LIT>\" ) ) . map ( file -> { DatabaseVO databaseVO = new DatabaseVO ( ) ; databaseVO . setFilePath ( file . toString ( ) ) ; databaseVO . setFileSize ( FileUtil . readableFileSize ( file . toFile ( ) ) ) ; return databaseVO ; } ) . collect ( Collectors . toList ( ) ) ; }", "output": "catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } return Collections . emptyList ( ) ; } private List < DecryptBO > getWeChatDb ( Stream < Path > stream , String outputPath ) { return stream . filter ( file -> ! Files . isDirectory ( file ) ) . filter ( file -> file . toString ( ) . endsWith ( \"<STR_LIT>\" ) ) . map ( item -> new DecryptBO ( item . toString ( ) , outputPath + FileUtil . getName ( item . toString ( ) ) ) ) . collect ( Collectors . toList ( ) ) ; } @ Override public void run ( ApplicationArguments args ) { String dbPath = DirUtil . getDbDir ( ) ; Path dbDirectory = Paths . get ( dbPath ) ; if ( ! Files . exists ( dbDirectory ) ) { return ; } try ( Stream < Path > stream = Files . walk ( dbDirectory ) ) { stream . filter ( file -> ! Files . isDirectory ( file ) ) . filter ( file -> file . toString ( ) . endsWith ( \"<STR_LIT>\" ) ) . forEach ( dbFile -> registerDataSource ( dbFile . toString ( ) ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } } private void registerDataSource ( String dbPath ) { String wxId = FileUtil . getName ( FileUtil . getParent ( dbPath , <NUM_LIT> ) ) ; String dbName = FileUtil . getName ( dbPath ) ; DruidConfig druidConfig = new DruidConfig ( ) ; druidConfig . setInitialSize ( <NUM_LIT> ) ; druidConfig . setMinIdle ( <NUM_LIT> ) ; druidConfig . setMaxActive ( <NUM_LIT> ) ; druidConfig . setMaxWait ( <NUM_LIT> ) ; druidConfig . setValidationQuery ( \"<STR_LIT>\" ) ; druidConfig . setTestWhileIdle ( true ) ; druidConfig . setTestOnBorrow ( false ) ; druidConfig . setTestOnReturn ( false ) ; druidConfig . setPoolPreparedStatements ( true ) ; DataSourceProperty sourceProperty = new DataSourceProperty ( ) ; sourceProperty . setUrl ( SqliteConstant . URL_PREFIX + dbPath ) ; sourceProperty . setDriverClassName ( SqliteConstant . DRIVER_CLASS_NAME ) ; sourceProperty . setPoolName ( DSNameUtil . getDSName ( wxId , dbName ) ) ; DynamicRoutingDataSource dynamicRoutingDataSource = SpringUtil . getBean ( DynamicRoutingDataSource . class ) ; DefaultDataSourceCreator dataSourceCreator = SpringUtil . getBean ( DefaultDataSourceCreator . class ) ; DataSource dataSource = dataSourceCreator . createDataSource ( sourceProperty ) ; dynamicRoutingDataSource . addDataSource ( sourceProperty . getPoolName ( ) , dataSource ) ; } }"}, {"input": "package org . example . dddworkspace . infrastructure . convertor ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . domain . workspace . WorkspaceEntity ; import org . mapstruct . Mapper ; import org . mapstruct . MappingConstants ; @ Mapper ( componentModel = MappingConstants . ComponentModel . SPRING ) public interface WorkspaceConvertor {", "output": "WorkspaceResult toDto ( WorkspaceEntity entity ) ; }"}, {"input": "package com . oddfar . campus . common . utils ; import org . springframework . aop . framework . AopContext ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . config . BeanFactoryPostProcessor ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public final class SpringUtils implements BeanFactoryPostProcessor , ApplicationContextAware { private static ConfigurableListableBeanFactory beanFactory ; private static ApplicationContext applicationContext ; @ Override public void postProcessBeanFactory ( ConfigurableListableBeanFactory beanFactory ) throws BeansException {", "output": "SpringUtils . beanFactory = beanFactory ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { SpringUtils . applicationContext = applicationContext ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T getBean ( String name ) throws BeansException { return ( T ) beanFactory . getBean ( name ) ; } public static < T > T getBean ( Class < T > clz ) throws BeansException { T result = ( T ) beanFactory . getBean ( clz ) ; return result ; } public static boolean containsBean ( String name ) { return beanFactory . containsBean ( name ) ; } public static boolean isSingleton ( String name ) throws NoSuchBeanDefinitionException { return beanFactory . isSingleton ( name ) ; } public static Class < ? > getType ( String name ) throws NoSuchBeanDefinitionException { return beanFactory . getType ( name ) ; } public static String [ ] getAliases ( String name ) throws NoSuchBeanDefinitionException { return beanFactory . getAliases ( name ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T getAopProxy ( T invoker ) { return ( T ) AopContext . currentProxy ( ) ; } public static String [ ] getActiveProfiles ( ) { return applicationContext . getEnvironment ( ) . getActiveProfiles ( ) ; } public static String getActiveProfile ( ) { final String [ ] activeProfiles = getActiveProfiles ( ) ; return StringUtils . isNotEmpty ( activeProfiles ) ? activeProfiles [ <NUM_LIT> ] : null ; } public static String getRequiredProperty ( String key ) { return applicationContext . getEnvironment ( ) . getRequiredProperty ( key ) ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class ExamRepo implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer examId ; private Integer repoId ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) {", "output": "this . id = id ; } public Integer getExamId ( ) { return examId ; } public void setExamId ( Integer examId ) { this . examId = examId ; } public Integer getRepoId ( ) { return repoId ; } public void setRepoId ( Integer repoId ) { this . repoId = repoId ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + examId + \"<STR_LIT>\" + repoId + \"<STR_LIT>\" ; } }"}, {"input": "package com . yf . base . api . exception ; import com . yf . base . api . api . ApiError ; import com . yf . base . api . api . ApiRest ; import lombok . Data ; @ Data public class ServiceException extends RuntimeException { private Integer code ; private String msg ; public ServiceException ( ApiRest apiRest ) { this . code = apiRest . getCode ( ) ; this . msg = apiRest . getMsg ( ) ; } public ServiceException ( ApiError apiError ) { this . code = apiError . getCode ( ) ; this . msg = apiError . msg ; } public ServiceException ( String msg ) { this . code = <NUM_LIT> ; this . msg = msg ; } @ Override public String getMessage ( ) { return this . msg ; }", "output": "}"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . xcs . wx . domain . ChatRoom ; import com . xcs . wx . domain . dto . ChatRoomDTO ; import com . xcs . wx . domain . vo . ChatRoomVO ; import com . xcs . wx . domain . vo . ExportChatRoomVO ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface ChatRoomMapper extends BaseMapper < ChatRoom > { Page < ChatRoomVO > queryChatRoom ( Page < ChatRoomVO > page , @ Param ( \"<STR_LIT>\" ) ChatRoomDTO chatRoomDTO ) ;", "output": "int countChatRoom ( ) ; List < ExportChatRoomVO > exportChatRoom ( ) ; }"}, {"input": "package com . xcs . wx . domain . vo ; import com . alibaba . excel . annotation . ExcelProperty ; import com . alibaba . excel . annotation . write . style . ColumnWidth ; import com . alibaba . excel . annotation . write . style . ContentStyle ; import com . alibaba . excel . enums . poi . HorizontalAlignmentEnum ; import lombok . Data ; @ Data @ ContentStyle ( horizontalAlignment = HorizontalAlignmentEnum . CENTER ) public class ExportContactVO { @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String userName ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String alias ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String remark ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String nickName ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String describe ; @ ColumnWidth ( <NUM_LIT> ) @ ExcelProperty ( \"<STR_LIT>\" ) private String labelIdList ;", "output": "}"}, {"input": "package com . yf . base . utils ; import com . yf . base . api . exception . ServiceException ; public class DeptCodeGen { public static String gen ( int num ) { if ( num > <NUM_LIT> ) { throw new ServiceException ( \"<STR_LIT>\" ) ; } int index = num / <NUM_LIT> ;", "output": "int left = num % <NUM_LIT> ; String tag = AbcTags . get ( index ) ; StringBuffer sb = new StringBuffer ( tag ) ; if ( left < <NUM_LIT> ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( left ) ; return sb . toString ( ) ; } public static void main ( String [ ] args ) { for ( int i = <NUM_LIT> ; i <= <NUM_LIT> ; i ++ ) { System . out . println ( gen ( i ) ) ; } } }"}, {"input": "package com . youlai . system . common . model ; import com . fasterxml . jackson . annotation . JsonInclude ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data @ NoArgsConstructor public class Option < T > { public Option ( T value , String label ) { this . value = value ; this . label = label ; } public Option ( T value , String label , List < Option > children ) {", "output": "this . value = value ; this . label = label ; this . children = children ; } @ Schema ( description = \"<STR_LIT>\" ) private T value ; @ Schema ( description = \"<STR_LIT>\" ) private String label ; @ Schema ( description = \"<STR_LIT>\" ) @ JsonInclude ( value = JsonInclude . Include . NON_EMPTY ) private List < Option > children ; }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . UserExerciseRecord ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; public interface UserExerciseRecordMapper extends BaseMapper < UserExerciseRecord > {", "output": "}"}, {"input": "package top . kangert . kspider . config ; import lombok . Getter ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . context . annotation . Configuration ; @ Configuration @ Getter public class SpiderConfig { @ Value ( \"<STR_LIT>\" ) private Integer maxThreads ; @ Value ( \"<STR_LIT>\" ) private Integer defaultThreads ; @ Value ( \"<STR_LIT>\" ) private Integer deadCycle ; @ Value ( \"<STR_LIT>\" ) private String workspace ; @ Value ( \"<STR_LIT>\" ) private Boolean jobEnabled ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class DoubleConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return Double . class == fieldType || double . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { Class < ? > fieldType = field . getType ( ) ; Integer scale = NumericUtil . calculateScale ( format ) ; String text = NumericUtil . formatNumericInNeed ( cellContent , scale ) ; if ( TextUtil . isEmpty ( text ) ) { return Double . class == fieldType ? null : <NUM_LIT> ; } try { return Double . parseDouble ( text ) ; } catch ( NumberFormatException e ) {", "output": "return Double . class == fieldType ? null : <NUM_LIT> ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { Double value = ( Double ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent = NumericUtil . formatNumericInNeed ( String . valueOf ( value ) , scale ) ; cell . setCellType ( CellType . NUMERIC ) ; cell . setCellValue ( cellContent ) ; } }"}, {"input": "package io . github . chensheng . dddboot . openfeign . core ; import io . github . chensheng . dddboot . tools . time . DateFormatUtil ; import feign . Request ; import feign . RequestTemplate ; import feign . Util ; import feign . codec . EncodeException ; import feign . codec . Encoder ; import java . lang . reflect . Field ; import java . lang . reflect . Type ; import java . util . Date ; public class DefaultFormEncoder implements Encoder { private static final String FORM_DATETIME_FORMAT = \"<STR_LIT>\" ; @ Override public void encode ( Object object , Type bodyType , RequestTemplate template ) throws EncodeException { if ( object == null ) { return ; } Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; StringBuilder formBody = new StringBuilder ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; String name = field . getName ( ) ; Object value = null ; try { value = field . get ( object ) ; } catch ( IllegalAccessException e ) { continue ; } if ( value == null ) { continue ; } String valueStr ; if ( value instanceof Date ) { valueStr = DateFormatUtil . formatDate ( FORM_DATETIME_FORMAT , ( Date ) value ) ;", "output": "} else { valueStr = String . valueOf ( value ) ; } formBody . append ( name ) . append ( \"<STR_LIT>\" ) . append ( valueStr ) . append ( \"<STR_LIT>\" ) ; } template . body ( Request . Body . bodyTemplate ( formBody . toString ( ) , Util . UTF_8 ) ) ; } }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . io . FileUtil ; import cn . hutool . core . util . StrUtil ; import com . alibaba . excel . EasyExcel ; import com . xcs . wx . domain . dto . ContactDTO ; import com . xcs . wx . domain . vo . * ; import com . xcs . wx . mapping . ContactLabelMapping ; import com . xcs . wx . repository . ContactLabelRepository ; import com . xcs . wx . repository . ContactRepository ; import com . xcs . wx . service . ContactService ; import com . xcs . wx . util . DirUtil ; import lombok . RequiredArgsConstructor ; import org . springframework . stereotype . Service ; import java . io . File ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor public class ContactServiceImpl implements ContactService { private final ContactRepository contactRepository ; private final ContactLabelRepository contactLabelRepository ; private final ContactLabelMapping contactLabelMapping ; @ Override public PageVO < ContactVO > queryContact ( ContactDTO contactDTO ) { return Optional . ofNullable ( contactRepository . queryContact ( contactDTO ) ) . map ( page -> { Map < String , String > contactLabelMap = contactLabelRepository . queryContactLabelAsMap ( ) ; for ( ContactVO contactVO : page . getRecords ( ) ) { List < String > labels = Arrays . stream ( contactVO . getLabelIdList ( ) . split ( \"<STR_LIT>\" ) ) . map ( contactLabelMap :: get ) . filter ( StrUtil :: isNotBlank ) . collect ( Collectors . toList ( ) ) ; contactVO . setLabels ( labels ) ; } return new PageVO < > ( page . getCurrent ( ) , page . getSize ( ) , page . getTotal ( ) , page . getRecords ( ) ) ; }", "output": ") . orElse ( new PageVO < > ( contactDTO . getCurrent ( ) , contactDTO . getPageSize ( ) , <NUM_LIT> , null ) ) ; } @ Override public List < AllContactVO > queryAllContact ( ) { return contactRepository . queryAllContact ( ) ; } @ Override public List < ContactLabelVO > queryContactLabel ( ) { return Optional . ofNullable ( contactLabelRepository . queryContactLabelAsList ( ) ) . map ( contactLabelMapping :: convert ) . orElse ( Collections . emptyList ( ) ) ; } @ Override public String exportContact ( ) { String filePath = DirUtil . getExportDir ( \"<STR_LIT>\" ) ; FileUtil . mkdir ( new File ( filePath ) . getParent ( ) ) ; EasyExcel . write ( filePath , ExportContactVO . class ) . sheet ( \"<STR_LIT>\" ) . doWrite ( contactRepository :: exportContact ) ; return filePath ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; @ TableName ( \"<STR_LIT>\" ) public class Grade implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private String gradeName ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private String code ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) { this . isDeleted = isDeleted ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) {", "output": "this . id = id ; } public String getGradeName ( ) { return gradeName ; } public void setGradeName ( String gradeName ) { this . gradeName = gradeName ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + gradeName + '<STR_LIT>' + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + code + '<STR_LIT>' + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . oddfar . campus . common . domain . BaseEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . Pattern ; import javax . validation . constraints . Size ; @ Data @ EqualsAndHashCode ( callSuper = true ) @ TableName ( \"<STR_LIT>\" ) public class SysDictTypeEntity extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( \"<STR_LIT>\" ) private Long dictId ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String dictName ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String dictType ; private String status ; private String remark ;", "output": "}"}, {"input": "package ginyi . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import ginyi . system . domain . SysConfig ; public interface SysConfigMapper extends BaseMapper < SysConfig > {", "output": "}"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . entity . SysDict ; import com . youlai . system . model . query . DictPageQuery ; import com . youlai . system . model . vo . DictPageVO ; import org . apache . ibatis . annotations . Mapper ; @ Mapper public interface SysDictMapper extends BaseMapper < SysDict > { Page < DictPageVO > getDictPage ( Page < DictPageVO > page , DictPageQuery queryParams ) ;", "output": "}"}, {"input": "package cn . org . alan . exam . config ; import cn . org . alan . exam . filter . VerifyTokenFilter ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . util . ResponseUtil ; import jakarta . annotation . Resource ; import lombok . RequiredArgsConstructor ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . security . authentication . AuthenticationManager ; import org . springframework . security . config . annotation . authentication . configuration . AuthenticationConfiguration ; import org . springframework . security . config . annotation . method . configuration . EnableMethodSecurity ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . config . annotation . web . configuration . EnableWebSecurity ; import org . springframework . security . config . annotation . web . configuration . WebSecurityCustomizer ; import org . springframework . security . config . annotation . web . configurers . AbstractHttpConfigurer ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . security . web . SecurityFilterChain ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; @ Configuration @ EnableWebSecurity @ EnableMethodSecurity @ RequiredArgsConstructor public class SecurityConfig { @ Resource private ResponseUtil responseUtil ; @ Resource private VerifyTokenFilter verifyTokenFilter ; @ Bean public SecurityFilterChain securityFilterChain ( HttpSecurity http ) throws Exception { http . authorizeHttpRequests ( request -> { request . requestMatchers ( \"<STR_LIT>\" ) . permitAll ( ) ; request . requestMatchers ( \"<STR_LIT>\" ) . authenticated ( ) ; request . anyRequest ( ) . authenticated ( ) ; } ) ; http . formLogin ( AbstractHttpConfigurer :: disable ) ; http . exceptionHandling ( exceptionHandling -> exceptionHandling . accessDeniedHandler ( ( request , response , accessDeniedException ) -> responseUtil . response ( response , Result . failed ( \"<STR_LIT>\" ) ) ) ) ; http . addFilterBefore ( verifyTokenFilter , UsernamePasswordAuthenticationFilter . class ) ;", "output": "http . csrf ( AbstractHttpConfigurer :: disable ) ; return http . build ( ) ; } @ Bean public WebSecurityCustomizer webSecurityCustomizer ( ) { return ( web ) -> web . ignoring ( ) . requestMatchers ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Bean public PasswordEncoder passwordEncoder ( ) { return new BCryptPasswordEncoder ( ) ; } @ Bean public AuthenticationManager authenticationManager ( AuthenticationConfiguration authenticationConfiguration ) throws Exception { return authenticationConfiguration . getAuthenticationManager ( ) ; } }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysUser ; import java . util . Set ; public interface ISysPermissionService { public Set < String > getRolePermission ( SysUser user ) ; public Set < String > getMenuPermission ( SysUser user ) ;", "output": "}"}, {"input": "package ginyi . server . admin . controller ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import ginyi . common . annotation . Log ; import ginyi . common . enums . BusinessType ; import ginyi . common . result . CommonResult ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . SysMenu ; import ginyi . system . domain . model . dto . MenuDto ; import ginyi . system . domain . model . dto . UserDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . service . ISysMenuService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; import java . util . Set ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysMenuController { @ Resource private ISysMenuService menuService ; @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . DELETE ) public CommonResult delete ( @ PathVariable ( \"<STR_LIT>\" ) Long menuId ) { menuService . removeMenuById ( menuId ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . DELETE ) public CommonResult delete ( @ RequestBody Set < Long > ids ) {", "output": "menuService . removeMenuByIds ( ids ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < SysMenu > getMenuById ( @ PathVariable ( \"<STR_LIT>\" ) Long menuId ) { SysMenu menu = menuService . getMenuById ( menuId ) ; return CommonResult . success ( menu ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public CommonResult < BaseVo < SysMenu > > list ( ) { BaseVo < SysMenu > baseVo = menuService . selectMenuList ( ) ; return CommonResult . success ( baseVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult < BaseVo < SysMenu > > list ( @ RequestBody @ Validated MenuDto menuDto ) { BaseVo < SysMenu > baseVo = menuService . list ( menuDto ) ; return CommonResult . success ( baseVo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . INSERT ) @ PreAuthorize ( \"<STR_LIT>\" ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult add ( @ RequestBody @ Validated ( { AddGroup . class } ) MenuDto menuDto ) { menuService . addMenu ( menuDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . UPDATE ) @ ApiOperationSupport ( ignoreParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , } ) public CommonResult update ( @ RequestBody @ Validated ( { UpdateGroup . class } ) MenuDto menuDto ) { menuService . updateMenu ( menuDto ) ; return CommonResult . success ( ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) @ Log ( title = \"<STR_LIT>\" , businessType = BusinessType . UPDATE ) @ ApiOperationSupport ( includeParameters = { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public CommonResult updateStatus ( @ RequestBody MenuDto menuDto ) { menuService . updateStatus ( menuDto ) ; return CommonResult . success ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableRuntimeException extends RuntimeException implements Cloneable { private static final long serialVersionUID = <NUM_LIT> ; protected String message ; public CloneableRuntimeException ( ) { super ( ( Throwable ) null ) ; } public CloneableRuntimeException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableRuntimeException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableRuntimeException clone ( ) { try {", "output": "return ( CloneableRuntimeException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableRuntimeException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableRuntimeException clone ( String message ) { CloneableRuntimeException newException = this . clone ( ) ; newException . setMessage ( message ) ; return newException ; } public CloneableRuntimeException setMessage ( String message ) { this . message = message ; return this ; } }"}, {"input": "package ginyi . common . enums ; import org . springframework . lang . Nullable ; import java . util . HashMap ; import java . util . Map ; public enum HttpMethod { GET , HEAD , POST , PUT , PATCH , DELETE , OPTIONS , TRACE ; private static final Map < String , HttpMethod > mappings = new HashMap < > ( <NUM_LIT> ) ; static { for ( HttpMethod httpMethod : values ( ) ) { mappings . put ( httpMethod . name ( ) , httpMethod ) ; } } @ Nullable public static HttpMethod resolve ( @ Nullable String method ) {", "output": "return ( method != null ? mappings . get ( method ) : null ) ; } public boolean matches ( String method ) { return ( this == resolve ( method ) ) ; } }"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class TreeSelectProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String dict ; private String pidField ; private String pidValue ; private String hasChildField ; private String textField ; private Integer pidComponent = <NUM_LIT> ; public String getDict ( ) { return dict ; } public void setDict ( String dict ) { this . dict = dict ; } public String getPidField ( ) { return pidField ; } public void setPidField ( String pidField ) { this . pidField = pidField ; } public String getPidValue ( ) { return pidValue ; } public void setPidValue ( String pidValue ) { this . pidValue = pidValue ; } public String getHasChildField ( ) { return hasChildField ; } public void setHasChildField ( String hasChildField ) { this . hasChildField = hasChildField ; } public TreeSelectProperty ( ) { } public String getTextField ( ) { return textField ; } public void setTextField ( String textField ) { this . textField = textField ; } public Integer getPidComponent ( ) { return pidComponent ; } public void setPidComponent ( Integer pidComponent ) { this . pidComponent = pidComponent ; } public TreeSelectProperty ( String key , String title , String dict , String pidField , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . dict = dict ; this . pidField = pidField ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . pidValue = pidValue ; } public TreeSelectProperty ( String key , String title , String pidValue , String textField ) { this ( key , title , pidValue ) ; this . textField = textField ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; if ( dict != null ) { prop . put ( \"<STR_LIT>\" , dict ) ; } if ( pidField != null ) { prop . put ( \"<STR_LIT>\" , pidField ) ; } if ( pidValue != null ) { prop . put ( \"<STR_LIT>\" , pidValue ) ; } if ( textField != null ) { prop . put ( \"<STR_LIT>\" , textField ) ; } if ( hasChildField != null ) { prop . put ( \"<STR_LIT>\" , hasChildField ) ; } if ( pidComponent != null ) {", "output": "prop . put ( \"<STR_LIT>\" , pidComponent ) ; } map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import io . swagger . annotations . ApiParam ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; @ Data public class ResetParam { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String account ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String code ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String newPassword ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String confirmPassword ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class AppQueryCriteria { private String name ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . Role ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface RoleMapper extends BaseMapper < Role > { List < String > selectCodeById ( Integer roleId ) ;", "output": "}"}, {"input": "package top . kangert . kspider . domain . mapper ; import java . util . List ; public interface EntityMapper < E , D > {", "output": "D toDto ( E entity ) ; E toEntity ( D dto ) ; List < D > toDto ( List < E > entityList ) ; List < E > toEntity ( List < D > dtoList ) ; }"}, {"input": "package io . github . chensheng . dddboot . web . core ; public class BizException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private String code ; public BizException ( ) { this ( ResponseType . BIZ_ERROR . getMsg ( ) ) ; } public BizException ( String msg ) { this ( ResponseType . BIZ_ERROR . getCode ( ) , msg ) ; } public BizException ( String code , String msg ) { super ( msg ) ; this . code = code ; }", "output": "public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . io . FileUtil ; import cn . hutool . core . util . HexUtil ; import cn . hutool . core . util . IdUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HttpUtil ; import com . xcs . wx . repository . HardLinkImageAttributeRepository ; import com . xcs . wx . service . ImageService ; import com . xcs . wx . service . UserService ; import com . xcs . wx . util . DirUtil ; import com . xcs . wx . util . ImgDecoderUtil ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . core . io . InputStreamResource ; import org . springframework . core . io . Resource ; import org . springframework . http . MediaType ; import org . springframework . http . ResponseEntity ; import org . springframework . stereotype . Service ; import java . nio . file . Files ; import java . nio . file . Paths ; @ Slf4j @ Service @ RequiredArgsConstructor public class ImageServiceImpl implements ImageService { private final HardLinkImageAttributeRepository hardLinkImageAttributeRepository ; private final UserService userService ; @ Override public ResponseEntity < Resource > downloadImgMd5 ( String md5 ) { try { String imgUrl = hardLinkImageAttributeRepository . queryHardLinkImage ( HexUtil . decodeHex ( md5 ) ) ; if ( StrUtil . isBlank ( imgUrl ) ) { return ResponseEntity . notFound ( ) . build ( ) ; } String wxId = userService . currentUser ( ) ; String filePath = DirUtil . getDir ( userService . getBasePath ( wxId ) , wxId , imgUrl ) ;", "output": "if ( ! FileUtil . exist ( filePath ) ) { return ResponseEntity . notFound ( ) . build ( ) ; } String outPath = DirUtil . getImgDir ( wxId ) ; String imgPath = ImgDecoderUtil . decodeDat ( filePath , outPath ) ; if ( imgPath == null ) { return ResponseEntity . notFound ( ) . build ( ) ; } return ResponseEntity . ok ( ) . contentType ( MediaType . IMAGE_JPEG ) . body ( new InputStreamResource ( Files . newInputStream ( Paths . get ( imgPath ) ) ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } return ResponseEntity . notFound ( ) . build ( ) ; } @ Override public ResponseEntity < Resource > downloadImg ( String path ) { String wxId = userService . currentUser ( ) ; String destPath = DirUtil . getImgDirWithName ( wxId , IdUtil . fastSimpleUUID ( ) + \"<STR_LIT>\" ) ; try { HttpUtil . downloadFile ( path , destPath ) ; return ResponseEntity . ok ( ) . contentType ( MediaType . IMAGE_JPEG ) . body ( new InputStreamResource ( Files . newInputStream ( Paths . get ( destPath ) ) ) ) ; } catch ( Exception ignore ) { } return ResponseEntity . notFound ( ) . build ( ) ; } @ Override public ResponseEntity < Resource > downloadImgFormLocal ( String localPath ) { try { String wxId = userService . currentUser ( ) ; String filePath = DirUtil . getDir ( userService . getBasePath ( wxId ) , wxId , localPath ) ; if ( ! FileUtil . exist ( filePath ) ) { return ResponseEntity . notFound ( ) . build ( ) ; } String outPath = DirUtil . getImgDir ( wxId ) ; if ( ! FileUtil . exist ( outPath ) ) { FileUtil . mkdir ( outPath ) ; } String imgPath = ImgDecoderUtil . decodeDat ( filePath , outPath ) ; if ( imgPath == null ) { return ResponseEntity . notFound ( ) . build ( ) ; } return ResponseEntity . ok ( ) . contentType ( MediaType . IMAGE_JPEG ) . body ( new InputStreamResource ( Files . newInputStream ( Paths . get ( imgPath ) ) ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } return ResponseEntity . notFound ( ) . build ( ) ; } }"}, {"input": "package cn . org . alan . exam . model . form . exam ; import jakarta . validation . constraints . * ; import lombok . Data ; import org . springframework . format . annotation . DateTimeFormat ; import java . time . LocalDateTime ; @ Data public class ExamAddForm { @ NotBlank ( message = \"<STR_LIT>\" ) @ Size ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String title ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) private Integer examDuration ; private Integer maxCount ; @ Min ( value = <NUM_LIT> , message = \"<STR_LIT>\" ) @ NotNull ( message = \"<STR_LIT>\" ) private Integer passedScore ; @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime startTime ; @ Future ( message = \"<STR_LIT>\" ) @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private LocalDateTime endTime ; @ NotBlank ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String gradeIds ; @ NotNull ( message = \"<STR_LIT>\" ) private Integer repoId ; private Integer certificateId ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer radioCount ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer radioScore ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer multiCount ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer multiScore ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer judgeCount ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer judgeScore ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer saqCount ; @ NotNull ( message = \"<STR_LIT>\" ) @ Min ( value = <NUM_LIT> ) private Integer saqScore ;", "output": "}"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParamApi implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ;", "output": "}"}, {"input": "package cn . org . alan . exam . util ; import jakarta . annotation . Resource ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . data . redis . core . script . DefaultRedisScript ; import org . springframework . stereotype . Component ; import java . util . Collections ; @ Component public class RedisUtils { @ Resource private StringRedisTemplate stringRedisTemplate ; public void deleteKeysByPrefix ( String keyPrefix ) {", "output": "String luaScript = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; DefaultRedisScript < Long > redisScript = new DefaultRedisScript < > ( luaScript , Long . class ) ; Long deletedCount = stringRedisTemplate . execute ( redisScript , Collections . singletonList ( keyPrefix ) , keyPrefix ) ; System . out . println ( \"<STR_LIT>\" + deletedCount + \"<STR_LIT>\" + keyPrefix ) ; } }"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysLoginLogEntity ; import java . util . List ; public interface SysLoginLogMapper extends BaseMapperX < SysLoginLogEntity > { default PageResult < SysLoginLogEntity > selectLogininforPage ( SysLoginLogEntity logininfor ) {", "output": "return selectPage ( new LambdaQueryWrapperX < SysLoginLogEntity > ( ) . eqIfPresent ( SysLoginLogEntity :: getUserId , logininfor . getUserId ( ) ) . eqIfPresent ( SysLoginLogEntity :: getUserName , logininfor . getUserName ( ) ) . eqIfPresent ( SysLoginLogEntity :: getStatus , logininfor . getStatus ( ) ) . betweenIfPresent ( SysLoginLogEntity :: getLoginTime , logininfor . getParams ( ) ) . orderByDesc ( SysLoginLogEntity :: getInfoId ) ) ; } default List < SysLoginLogEntity > selectLogininforList ( SysLoginLogEntity logininfor ) { return selectList ( new LambdaQueryWrapperX < SysLoginLogEntity > ( ) . eqIfPresent ( SysLoginLogEntity :: getStatus , logininfor . getStatus ( ) ) . likeIfPresent ( SysLoginLogEntity :: getUserName , logininfor . getUserName ( ) ) . eqIfPresent ( SysLoginLogEntity :: getUserId , logininfor . getUserId ( ) ) ) ; } int cleanLogininfor ( ) ; }"}, {"input": "package com . youlai . system . service . impl ; import cn . hutool . core . date . DateUtil ; import cn . hutool . extra . template . Template ; import cn . hutool . extra . template . TemplateConfig ; import cn . hutool . extra . template . TemplateEngine ; import cn . hutool . extra . template . TemplateUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . mapper . DatabaseMapper ; import com . youlai . system . model . query . TablePageQuery ; import com . youlai . system . model . vo . TableColumnVO ; import com . youlai . system . model . vo . TableGeneratePreviewVO ; import com . youlai . system . model . vo . TablePageVO ; import com . youlai . system . service . GeneratorService ; import lombok . RequiredArgsConstructor ; import org . springframework . stereotype . Service ; import cn . hutool . extra . template . TemplateConfig . ResourceMode ; import java . io . File ; import java . util . * ; @ Service @ RequiredArgsConstructor public class GeneratorServiceImpl implements GeneratorService { private final DatabaseMapper databaseMapper ; public Page < TablePageVO > getTablePage ( TablePageQuery queryParams ) { Page < TablePageVO > page = new Page < > ( queryParams . getPageNum ( ) , queryParams . getPageSize ( ) ) ; return databaseMapper . getTablePage ( page , queryParams ) ; } @ Override public List < TableColumnVO > getTableColumns ( String tableName ) { return databaseMapper . getTableColumns ( tableName ) ; } @ Override public List < TableGeneratePreviewVO > getTablePreviewData ( String tableName ) { List < TableGeneratePreviewVO > list = new ArrayList < > ( ) ; TemplateConfig templateConfig = new TemplateConfig ( \"<STR_LIT>\" , ResourceMode . CLASSPATH ) ; TemplateEngine templateEngine = TemplateUtil . createEngine ( templateConfig ) ; Map < String , Object > bindingMap = new HashMap < > ( ) ; bindingMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bindingMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bindingMap . put ( \"<STR_LIT>\" , DateUtil . format ( new Date ( ) , \"<STR_LIT>\" ) ) ; bindingMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bindingMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bindingMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bindingMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Template template = templateEngine . getTemplate ( \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ) ;", "output": "String content = template . render ( bindingMap ) ; TableGeneratePreviewVO controller = new TableGeneratePreviewVO ( ) ; controller . setPath ( \"<STR_LIT>\" ) ; controller . setContent ( content ) ; controller . setFileName ( \"<STR_LIT>\" ) ; list . add ( controller ) ; TableGeneratePreviewVO vo = new TableGeneratePreviewVO ( ) ; vo . setPath ( \"<STR_LIT>\" ) ; vo . setContent ( content ) ; vo . setFileName ( \"<STR_LIT>\" ) ; list . add ( vo ) ; return list ; } private String generatePath ( ) { } }"}, {"input": "package ginyi . system . domain . model . vo ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data public class CacheKeyVo { @ ApiModelProperty ( \"<STR_LIT>\" ) private String key ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;", "output": "}"}, {"input": "package com . yf . system . modules . user . dto . response ; import com . fasterxml . jackson . annotation . JsonIgnore ; import com . yf . ability . excel . annotation . ExcelField ; import lombok . Data ; @ Data public class UserExportDTO { private static final long serialVersionUID = <NUM_LIT> ; @ JsonIgnore private String id ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String userName ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String realName ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> , dictTable = \"<STR_LIT>\" , dicText = \"<STR_LIT>\" , dictCode = \"<STR_LIT>\" ) private String deptCode ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String mobile ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String email ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String idCard ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String roleIds ; @ ExcelField ( title = \"<STR_LIT>\" , sort = <NUM_LIT> ) private String password ;", "output": "}"}, {"input": "package ginyi . system . domain . model . vo ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class NoticeVo extends BaseEntity { @ ApiModelProperty ( \"<STR_LIT>\" ) private Long noticeId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String title ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String content ; @ ApiModelProperty ( \"<STR_LIT>\" ) private boolean haveRead ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String status ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import static me . zhengjie . utils . EncryptUtils . * ; import static org . junit . jupiter . api . Assertions . assertEquals ; public class EncryptUtilsTest { @ Test public void testDesEncrypt ( ) { try { assertEquals ( \"<STR_LIT>\" , desEncrypt ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } @ Test public void testDesDecrypt ( ) { try {", "output": "assertEquals ( \"<STR_LIT>\" , desDecrypt ( \"<STR_LIT>\" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }"}, {"input": "package me . zhengjie . exception ; import org . springframework . util . StringUtils ; public class EntityNotFoundException extends RuntimeException { public EntityNotFoundException ( Class clazz , String field , String val ) { super ( EntityNotFoundException . generateMessage ( clazz . getSimpleName ( ) , field , val ) ) ;", "output": "} private static String generateMessage ( String entity , String field , String val ) { return StringUtils . capitalize ( entity ) + \"<STR_LIT>\" + field + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; } }"}, {"input": "package org . springblade . cgform . model ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DuplicateCheckVo implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String tableName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String fieldVal ; @ ApiModelProperty ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String dataId ;", "output": "}"}, {"input": "package com . youlai . system . common . util ; import cn . hutool . json . JSONUtil ; import com . youlai . system . common . result . Result ; import com . youlai . system . common . result . ResultCode ; import jakarta . servlet . http . HttpServletResponse ; import lombok . extern . slf4j . Slf4j ; import org . springframework . http . HttpStatus ; import org . springframework . http . MediaType ; import java . io . IOException ; import java . io . PrintWriter ; import java . nio . charset . StandardCharsets ; @ Slf4j public class ResponseUtils { public static void writeErrMsg ( HttpServletResponse response , ResultCode resultCode ) { int status = switch ( resultCode ) { case ACCESS_UNAUTHORIZED , TOKEN_INVALID -> HttpStatus . UNAUTHORIZED . value ( ) ; case TOKEN_ACCESS_FORBIDDEN -> HttpStatus . FORBIDDEN . value ( ) ; default -> HttpStatus . BAD_REQUEST . value ( ) ; }", "output": "; response . setStatus ( status ) ; response . setContentType ( MediaType . APPLICATION_JSON_VALUE ) ; response . setCharacterEncoding ( StandardCharsets . UTF_8 . name ( ) ) ; try ( PrintWriter writer = response . getWriter ( ) ) { String jsonResponse = JSONUtil . toJsonStr ( Result . failed ( resultCode ) ) ; writer . print ( jsonResponse ) ; writer . flush ( ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , e ) ; } } }"}, {"input": "package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import java . time . LocalDateTime ; import java . util . Date ; public class DateUtilsTest { @ Test public void test1 ( ) { long l = System . currentTimeMillis ( ) / <NUM_LIT> ; LocalDateTime localDateTime = DateUtil . fromTimeStamp ( l ) ; System . out . print ( DateUtil . localDateTimeFormatyMdHms ( localDateTime ) ) ; }", "output": "@ Test public void test2 ( ) { LocalDateTime now = LocalDateTime . now ( ) ; System . out . println ( DateUtil . localDateTimeFormatyMdHms ( now ) ) ; Date date = DateUtil . toDate ( now ) ; LocalDateTime localDateTime = DateUtil . toLocalDateTime ( date ) ; System . out . println ( DateUtil . localDateTimeFormatyMdHms ( localDateTime ) ) ; LocalDateTime localDateTime1 = DateUtil . fromTimeStamp ( date . getTime ( ) / <NUM_LIT> ) ; System . out . println ( DateUtil . localDateTimeFormatyMdHms ( localDateTime1 ) ) ; } }"}, {"input": "package ginyi . common . annotation ; import java . lang . annotation . * ; @ Inherited @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface RepeatSubmit { public int interval ( ) default <NUM_LIT> ; public String message ( ) default \"<STR_LIT>\" ;", "output": "}"}, {"input": "package org . springblade . config . autopoi . poi . cache . manager ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . ByteArrayOutputStream ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; class FileLoade {", "output": "private static final Logger LOGGER = LoggerFactory . getLogger ( FileLoade . class ) ; }"}, {"input": "package io . github . chensheng . dddboot . tools . net ; import com . google . common . annotations . Beta ; import io . github . chensheng . dddboot . tools . base . Platforms ; import io . github . chensheng . dddboot . tools . base . SystemPropertiesUtil ; import io . github . chensheng . dddboot . tools . collection . MapUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import javax . net . ServerSocketFactory ; import java . net . * ; import java . util . Enumeration ; import java . util . Map ; import java . util . Random ; @ Beta public class NetUtil { private static Logger logger = LoggerFactory . getLogger ( NetUtil . class ) ; public static final int PORT_RANGE_MIN = <NUM_LIT> ; public static final int PORT_RANGE_MAX = <NUM_LIT> ; private static Random random = new Random ( ) ; public static InetAddress getLocalAddress ( ) { return LocalAddressHoler . INSTANCE . localInetAddress ; } public static String getLocalHost ( ) { return LocalAddressHoler . INSTANCE . localHost ; } public static String getHostName ( ) { return LocalAddressHoler . INSTANCE . hostName ; } private static class LocalAddressHoler { static final LocalAddress INSTANCE = new LocalAddress ( ) ; } private static class LocalAddress { private InetAddress localInetAddress ; private String localHost ; private String hostName ; public LocalAddress ( ) { initLocalAddress ( ) ; hostName = Platforms . IS_WINDOWS ? System . getenv ( \"<STR_LIT>\" ) : System . getenv ( \"<STR_LIT>\" ) ; } private void initLocalAddress ( ) { NetworkInterface nic = null ; try { localInetAddress = InetAddress . getLocalHost ( ) ; nic = NetworkInterface . getByInetAddress ( localInetAddress ) ; } catch ( Exception ignored ) { } if ( localInetAddress == null || nic == null || localInetAddress . isLoopbackAddress ( ) || localInetAddress instanceof Inet6Address ) { InetAddress lookedUpAddr = findLocalAddressViaNetworkInterface ( ) ; try { localInetAddress = lookedUpAddr != null ? lookedUpAddr : InetAddress . getByName ( \"<STR_LIT>\" ) ; } catch ( UnknownHostException ignored ) { } } localHost = IPUtil . toIpString ( localInetAddress ) ; logger . info ( \"<STR_LIT>\" , localHost ) ;", "output": "} private static InetAddress findLocalAddressViaNetworkInterface ( ) { String preferNamePrefix = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String defaultNicList = SystemPropertiesUtil . getString ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; InetAddress resultAddress = null ; Map < String , NetworkInterface > candidateInterfaces = MapUtil . newHashMap ( ) ; try { for ( Enumeration < NetworkInterface > allInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; allInterfaces . hasMoreElements ( ) ; ) { NetworkInterface nic = allInterfaces . nextElement ( ) ; try { if ( ! nic . isUp ( ) || ! nic . supportsMulticast ( ) ) { continue ; } } catch ( SocketException ignored ) { continue ; } String name = nic . getName ( ) ; if ( name . startsWith ( preferNamePrefix ) ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } else { candidateInterfaces . put ( name , nic ) ; } } for ( String nifName : defaultNicList . split ( \"<STR_LIT>\" ) ) { NetworkInterface nic = candidateInterfaces . get ( nifName ) ; if ( nic != null ) { resultAddress = findAvailableInetAddress ( nic ) ; if ( resultAddress != null ) { return resultAddress ; } } } } catch ( SocketException e ) { return null ; } return null ; } private static InetAddress findAvailableInetAddress ( NetworkInterface nic ) { for ( Enumeration < InetAddress > indetAddresses = nic . getInetAddresses ( ) ; indetAddresses . hasMoreElements ( ) ; ) { InetAddress inetAddress = indetAddresses . nextElement ( ) ; if ( ! ( inetAddress instanceof Inet6Address ) && ! inetAddress . isLoopbackAddress ( ) ) { return inetAddress ; } } return null ; } } public static boolean isPortAvailable ( int port ) { try { ServerSocket serverSocket = ServerSocketFactory . getDefault ( ) . createServerSocket ( port , <NUM_LIT> , InetAddress . getByName ( \"<STR_LIT>\" ) ) ; serverSocket . close ( ) ; return true ; } catch ( Exception ex ) { return false ; } } public static int findRandomAvailablePort ( ) { return findRandomAvailablePort ( PORT_RANGE_MIN , PORT_RANGE_MAX ) ; } public static int findRandomAvailablePort ( int minPort , int maxPort ) { int portRange = maxPort - minPort ; int candidatePort ; int searchCounter = <NUM_LIT> ; do { if ( ++ searchCounter > portRange ) { throw new IllegalStateException ( String . format ( \"<STR_LIT>\" , minPort , maxPort , searchCounter ) ) ; } candidatePort = minPort + random . nextInt ( portRange + <NUM_LIT> ) ; } while ( ! isPortAvailable ( candidatePort ) ) ; return candidatePort ; } public static int findAvailablePortFrom ( int minPort ) { for ( int port = minPort ; port < PORT_RANGE_MAX ; port ++ ) { if ( isPortAvailable ( port ) ) { return port ; } } throw new IllegalStateException ( String . format ( \"<STR_LIT>\" , minPort , PORT_RANGE_MAX ) ) ; } }"}, {"input": "package org . springblade . config . autopoi . poi . util ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Row ; import org . apache . poi . ss . usermodel . Sheet ; public class PoiSheetUtility extends Object { public static void deleteColumn ( Sheet sheet , int columnToDelete ) { int maxColumn = <NUM_LIT> ; for ( int r = <NUM_LIT> ; r < sheet . getLastRowNum ( ) + <NUM_LIT> ; r ++ ) { Row row = sheet . getRow ( r ) ; if ( row == null ) continue ; int lastColumn = row . getLastCellNum ( ) ; if ( lastColumn > maxColumn ) maxColumn = lastColumn ; if ( lastColumn < columnToDelete ) continue ; for ( int x = columnToDelete + <NUM_LIT> ; x < lastColumn + <NUM_LIT> ; x ++ ) { Cell oldCell = row . getCell ( x - <NUM_LIT> ) ; if ( oldCell != null ) row . removeCell ( oldCell ) ; Cell nextCell = row . getCell ( x ) ; if ( nextCell != null ) {", "output": "Cell newCell = row . createCell ( x - <NUM_LIT> , nextCell . getCellTypeEnum ( ) ) ; cloneCell ( newCell , nextCell ) ; } } } for ( int c = <NUM_LIT> ; c < maxColumn ; c ++ ) { sheet . setColumnWidth ( c , sheet . getColumnWidth ( c + <NUM_LIT> ) ) ; } } private static void cloneCell ( Cell cNew , Cell cOld ) { cNew . setCellComment ( cOld . getCellComment ( ) ) ; cNew . setCellStyle ( cOld . getCellStyle ( ) ) ; switch ( cNew . getCellTypeEnum ( ) ) { case BOOLEAN : { cNew . setCellValue ( cOld . getBooleanCellValue ( ) ) ; break ; } case NUMERIC : { cNew . setCellValue ( cOld . getNumericCellValue ( ) ) ; break ; } case STRING : { cNew . setCellValue ( cOld . getStringCellValue ( ) ) ; break ; } case ERROR : { cNew . setCellValue ( cOld . getErrorCellValue ( ) ) ; break ; } case FORMULA : { cNew . setCellFormula ( cOld . getCellFormula ( ) ) ; break ; } default : cNew . setCellValue ( cOld . getStringCellValue ( ) ) ; break ; } } }"}, {"input": "package me . zhengjie . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class SysLogQueryCriteria { private String blurry ; private String username ; private String logType ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package com . yf . system . modules . user . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysUser extends Model < SysUser > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String userName ; private String avatar ; @ TableField ( \"<STR_LIT>\" ) private String realName ; private String password ; private String salt ; private Integer state ; @ TableField ( \"<STR_LIT>\" ) private String idCard ; private String mobile ; private String email ; @ TableField ( \"<STR_LIT>\" ) private String deptCode ; @ TableField ( \"<STR_LIT>\" ) private Date createTime ; @ TableField ( \"<STR_LIT>\" ) private Date updateTime ; @ TableField ( \"<STR_LIT>\" ) private String createBy ; @ TableField ( \"<STR_LIT>\" ) private String updateBy ;", "output": "}"}, {"input": "package me . zhengjie . modules . quartz . config ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . mapper . QuartzJobMapper ; import me . zhengjie . modules . quartz . utils . QuartzManage ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . boot . ApplicationArguments ; import org . springframework . boot . ApplicationRunner ; import org . springframework . stereotype . Component ; import java . util . List ; @ Component @ RequiredArgsConstructor public class JobRunner implements ApplicationRunner { private static final Logger log = LoggerFactory . getLogger ( JobRunner . class ) ; private final QuartzJobMapper quartzJobMapper ; private final QuartzManage quartzManage ; @ Override public void run ( ApplicationArguments applicationArguments ) { List < QuartzJob > quartzJobs = quartzJobMapper . findByIsPauseIsFalse ( ) ;", "output": "quartzJobs . forEach ( quartzManage :: addJob ) ; log . info ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . yf . system . modules . menu . controller ; import com . yf . base . api . annon . DataProtect ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . base . api . api . dto . BaseIdReqDTO ; import com . yf . base . api . api . dto . BaseIdsReqDTO ; import com . yf . base . utils . BeanMapper ; import com . yf . system . modules . depart . dto . request . DepartSortReqDTO ; import com . yf . system . modules . menu . dto . SysMenuDTO ; import com . yf . system . modules . menu . dto . response . MenuTreeRespDTO ; import com . yf . system . modules . menu . dto . response . RouteRespDTO ; import com . yf . system . modules . menu . entity . SysMenu ; import com . yf . system . modules . menu . service . SysMenuService ; import com . yf . system . modules . user . UserUtils ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . apache . shiro . authz . annotation . Logical ; import org . apache . shiro . authz . annotation . RequiresPermissions ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import java . util . List ; @ Api ( tags = { \"<STR_LIT>\" } ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysMenuController extends BaseController { @ Autowired private SysMenuService baseService ; @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) public ApiRest < List < RouteRespDTO > > routes ( ) { List < String > roles = UserUtils . getRoles ( ) ; List < RouteRespDTO > list = baseService . listMenuByRoles ( roles ) ; return super . success ( list ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" } , logical = Logical . OR ) @ DataProtect ( clazz = SysMenu . class , update = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = {", "output": "RequestMethod . POST } ) public ApiRest save ( @ RequestBody SysMenuDTO reqDTO ) { baseService . save ( reqDTO ) ; return super . success ( ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ DataProtect ( clazz = SysMenu . class , delete = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest delete ( @ RequestBody BaseIdsReqDTO reqDTO ) { baseService . delete ( reqDTO . getIds ( ) ) ; return super . success ( ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < SysMenuDTO > find ( @ RequestBody BaseIdReqDTO reqDTO ) { SysMenu entity = baseService . getById ( reqDTO . getId ( ) ) ; SysMenuDTO dto = new SysMenuDTO ( ) ; BeanMapper . copy ( entity , dto ) ; return super . success ( dto ) ; } @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest < List < MenuTreeRespDTO > > tree ( ) { List < MenuTreeRespDTO > list = baseService . listTree ( ) ; return super . success ( list ) ; } @ RequiresPermissions ( value = { \"<STR_LIT>\" } ) @ DataProtect ( clazz = SysMenu . class , update = true ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = { RequestMethod . POST } ) public ApiRest sort ( @ RequestBody DepartSortReqDTO reqDTO ) { baseService . sort ( reqDTO ) ; return super . success ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . base . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Target ; @ Target ( { ElementType . PARAMETER , ElementType . FIELD , ElementType . METHOD } ) public @ interface NotNull {", "output": "}"}, {"input": "package com . oddfar . campus . framework . config ; import com . baomidou . mybatisplus . annotation . DbType ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import com . oddfar . campus . framework . handler . MyDBFieldHandler ; import org . mybatis . spring . annotation . MapperScan ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ MapperScan ( \"<STR_LIT>\" ) public class MybatisPlusConfig { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; interceptor . addInnerInterceptor ( new PaginationInnerInterceptor ( DbType . MYSQL ) ) ;", "output": "return interceptor ; } @ Bean public MetaObjectHandler defaultMetaObjectHandler ( ) { return new MyDBFieldHandler ( ) ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeRole implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleAlias ; @ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;", "output": "}"}, {"input": "package ginyi . common . result ; public enum StateCode { SUCCESS ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_SYSTEM ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_UNAUTHENTICATION ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_TIMEOUT_REQUEST ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_TIMEOUT_TOKEN ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_INVALID_SIGN ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_AUTHENTICATION_VALID ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_NOT_PERMISSION ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_LIMITED ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_BUSINESS ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_PARAMS ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_REQUEST_PARAMS ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_PARAMS_SERVICE ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_DATA_FORMAT ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_EXIST ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_NOT_EXIST ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_NOT_SUPPORT ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_LIMIT_EXCEEDED ( <NUM_LIT> , \"<STR_LIT>\" ) , ERROR_MULTIPART ( <NUM_LIT> , \"<STR_LIT>\" ) , ; private final int code ; private final String message ; StateCode ( final int code , final String message ) { this . code = code ; this . message = message ; } public int getCode ( ) { return this . code ; } public String getMessage ( ) { return message ;", "output": "} }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . CertificateUserMapper ; import cn . org . alan . exam . model . entity . CertificateUser ; import cn . org . alan . exam . service . ICertificateUserService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class CertificateUserServiceImpl extends ServiceImpl < CertificateUserMapper , CertificateUser > implements ICertificateUserService {", "output": "}"}, {"input": "package com . youlai . system . controller ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . enums . LogModuleEnum ; import com . youlai . system . plugin . norepeat . annotation . PreventRepeatSubmit ; import com . youlai . system . common . model . Option ; import com . youlai . system . common . result . PageResult ; import com . youlai . system . common . result . Result ; import com . youlai . system . model . form . RoleForm ; import com . youlai . system . model . query . RolePageQuery ; import com . youlai . system . model . vo . RolePageVO ; import com . youlai . system . plugin . syslog . annotation . LogAnnotation ; import com . youlai . system . service . SysRoleService ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import io . swagger . v3 . oas . annotations . Operation ; import lombok . RequiredArgsConstructor ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import jakarta . validation . Valid ; import java . util . List ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class SysRoleController { private final SysRoleService roleService ; @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ LogAnnotation ( value = \"<STR_LIT>\" , module = LogModuleEnum . ROLE ) public PageResult < RolePageVO > getRolePage ( RolePageQuery queryParams ) { Page < RolePageVO > result = roleService . getRolePage ( queryParams ) ; return PageResult . success ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < Option > > listRoleOptions ( ) { List < Option > list = roleService . listRoleOptions ( ) ; return Result . success ( list ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) @ PreventRepeatSubmit public Result addRole ( @ Valid @ RequestBody RoleForm roleForm ) { boolean result = roleService . saveRole ( roleForm ) ; return Result . judge ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < RoleForm > getRoleForm ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable Long roleId ) { RoleForm roleForm = roleService . getRoleForm ( roleId ) ; return Result . success ( roleForm ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result updateRole ( @ Valid @ RequestBody RoleForm roleForm ) { boolean result = roleService . saveRole ( roleForm ) ; return Result . judge ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ DeleteMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result deleteRoles ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable String ids ) { boolean result = roleService . deleteRoles ( ids ) ; return Result . judge ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PutMapping ( value = \"<STR_LIT>\" ) public Result updateRoleStatus ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable Long roleId , @ Parameter ( description = \"<STR_LIT>\" ) @ RequestParam Integer status ) { boolean result = roleService . updateRoleStatus ( roleId , status ) ; return Result . judge ( result ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < Long > > getRoleMenuIds ( @ Parameter ( description = \"<STR_LIT>\" ) @ PathVariable Long roleId ) { List < Long > menuIds = roleService . getRoleMenuIds ( roleId ) ; return Result . success ( menuIds ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ PutMapping ( \"<STR_LIT>\" ) public Result assignMenusToRole ( @ PathVariable Long roleId , @ RequestBody List < Long > menuIds ) {", "output": "boolean result = roleService . assignMenusToRole ( roleId , menuIds ) ; return Result . judge ( result ) ; } }"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . common . model . Option ; import com . youlai . system . model . entity . SysDict ; import com . youlai . system . model . form . DictForm ; import com . youlai . system . model . query . DictPageQuery ; import com . youlai . system . model . vo . DictPageVO ; import java . util . List ; public interface SysDictService extends IService < SysDict > { Page < DictPageVO > getDictPage ( DictPageQuery queryParams ) ; DictForm getDictForm ( Long id ) ; boolean saveDict ( DictForm dictForm ) ;", "output": "boolean updateDict ( Long id , DictForm dictForm ) ; void deleteDictByIds ( String idsStr ) ; List < Option > listDictItemsByCode ( String code ) ; }"}, {"input": "package com . oddfar . campus . common . utils ; import org . springframework . context . MessageSource ; import org . springframework . context . i18n . LocaleContextHolder ; public class MessageUtils { public static String message ( String code , Object ... args ) { MessageSource messageSource = SpringUtils . getBean ( MessageSource . class ) ;", "output": "return messageSource . getMessage ( code , args , LocaleContextHolder . getLocale ( ) ) ; } }"}, {"input": "package org . springblade . config . pool ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . model . AccumulatorRecursiveActionParam ; import org . springblade . cgform . service . ICgformEnhanceSqlService ; import org . springblade . config . exception . BusinessException ; import org . springframework . web . context . request . ServletRequestAttributes ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . RecursiveAction ; @ Slf4j public class AccumulatorRecursiveAction extends RecursiveAction { private final int start ; private final int end ; private AccumulatorRecursiveActionParam param ; private final int LIMIT = <NUM_LIT> ; private ICgformEnhanceSqlService sqlService ; private ServletRequestAttributes sra ; public AccumulatorRecursiveAction ( int start , int end , AccumulatorRecursiveActionParam param , ServletRequestAttributes sra ) {", "output": "this . start = start ; this . end = end ; this . param = param ; this . sqlService = param . getSqlService ( ) ; this . sra = sra ; } @ Override protected void compute ( ) { } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ProfitParam { private String tableName ; private String walletId ; private BigDecimal addProfit ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . CellType ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; import java . math . BigDecimal ; import java . math . RoundingMode ; public class BigDecimalConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return BigDecimal . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { try { Integer scale = NumericUtil . calculateScale ( format ) ; if ( scale == null ) { return new BigDecimal ( cellContent ) ; } else { return new BigDecimal ( cellContent ) . setScale ( scale , RoundingMode . HALF_UP ) ; }", "output": "} catch ( NumberFormatException e ) { return null ; } } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) { BigDecimal value = ( BigDecimal ) cellValue ; Integer scale = NumericUtil . calculateScale ( format ) ; String cellContent ; if ( scale != null ) { cellContent = new BigDecimal ( value . toPlainString ( ) ) . setScale ( scale , RoundingMode . HALF_UP ) . toPlainString ( ) ; } else { cellContent = value . toPlainString ( ) ; } cell . setCellType ( CellType . NUMERIC ) ; cell . setCellValue ( cellContent ) ; } }"}, {"input": "package com . youlai . system . common . util ; import cn . hutool . core . date . DateTime ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . util . ReflectUtil ; import cn . hutool . core . util . StrUtil ; import org . springframework . format . annotation . DateTimeFormat ; import java . lang . reflect . Field ; public class DateUtils { public static void toDatabaseFormat ( Object obj , String startTimeFieldName , String endTimeFieldName ) { Field startTimeField = ReflectUtil . getField ( obj . getClass ( ) , startTimeFieldName ) ; Field endTimeField = ReflectUtil . getField ( obj . getClass ( ) , endTimeFieldName ) ; if ( startTimeField != null ) { processDateTimeField ( obj , startTimeField , startTimeFieldName , \"<STR_LIT>\" ) ; } if ( endTimeField != null ) { processDateTimeField ( obj , endTimeField , endTimeFieldName , \"<STR_LIT>\" ) ; } }", "output": "private static void processDateTimeField ( Object obj , Field field , String fieldName , String targetPattern ) { Object fieldValue = ReflectUtil . getFieldValue ( obj , fieldName ) ; if ( fieldValue != null ) { String pattern = field . isAnnotationPresent ( DateTimeFormat . class ) ? field . getAnnotation ( DateTimeFormat . class ) . pattern ( ) : \"<STR_LIT>\" ; DateTime dateTime = DateUtil . parse ( StrUtil . toString ( fieldValue ) , pattern ) ; ReflectUtil . setFieldValue ( obj , fieldName , dateTime . toString ( targetPattern ) ) ; } } }"}, {"input": "package org . example . dddworkspace . test ; import io . github . chensheng . dddboot . test . ArchitectureTest ; import org . junit . Test ; public class DDDArchitectureTest { @ Test public void testDDDArchitecture ( ) { ArchitectureTest . validateDDD ( \"<STR_LIT>\" ) ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . excel . converter ; import io . github . chensheng . dddboot . excel . core . CellValueType ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import org . apache . poi . ss . usermodel . Cell ; import org . apache . poi . ss . usermodel . Workbook ; import java . lang . reflect . Field ; public class StringConverter implements Converter { @ Override public boolean support ( Field field , CellValueType type ) { Class < ? > fieldType = field . getType ( ) ; return String . class == fieldType ; } @ Override public Object fromCellContent ( String cellContent , Field field , String format , boolean use1904DateWindowing ) { return NumericUtil . formatNumericInNeed ( cellContent , null ) ; } @ Override public void setCellContent ( Workbook workbook , Cell cell , Object cellValue , String format ) {", "output": "String value = ( String ) cellValue ; cell . setCellValue ( value ) ; } }"}, {"input": "package me . zhengjie . modules . mnt . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . domain . vo . AppQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface AppMapper extends BaseMapper < App > {", "output": "IPage < App > queryAll ( @ Param ( \"<STR_LIT>\" ) AppQueryCriteria criteria , Page < Object > page ) ; List < App > queryAll ( @ Param ( \"<STR_LIT>\" ) AppQueryCriteria criteria ) ; }"}, {"input": "package com . oddfar . campus . framework . api . sysconfig ; import cn . hutool . extra . spring . SpringUtil ; import com . oddfar . campus . framework . service . SysConfigService ; public class ConfigContext { public static SysConfigService me ( ) { return SpringUtil . getBean ( SysConfigService . class ) ; }", "output": "}"}, {"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class CheckboxFieldCommentConverter extends FieldFieldCommentConverter { public CheckboxFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ; } this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isEmpty ( txt ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = txt . split ( \"<STR_LIT>\" ) ; for ( String s : strings ) { String s1 = super . converterToVal ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isEmpty ( val ) ) { return null ; } else { List < String > arrayList = new ArrayList < > ( ) ; String [ ] strings = val . split ( \"<STR_LIT>\" ) ;", "output": "int length = strings . length ; for ( int i = <NUM_LIT> ; i < length ; ++ i ) { String s = strings [ i ] ; String s1 = super . converterToTxt ( s ) ; if ( s1 != null ) { arrayList . add ( s1 ) ; } } return String . join ( \"<STR_LIT>\" , arrayList ) ; } } }"}, {"input": "package com . xcs . wx . msg ; import cn . hutool . extra . spring . SpringUtil ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MsgStrategyFactory { private MsgStrategyFactory ( ) { } public static MsgStrategy getStrategy ( Integer type , Integer subType ) { Map < String , MsgStrategy > msgStrategyList = SpringUtil . getBeansOfType ( MsgStrategy . class ) ; AtomicReference < MsgStrategy > findMsgStrategy = new AtomicReference < > ( ) ; msgStrategyList . forEach ( ( key , msgStrategy ) -> { if ( msgStrategy . support ( type , subType ) ) { findMsgStrategy . set ( msgStrategy ) ; }", "output": "} ) ; return findMsgStrategy . get ( ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import jakarta . validation . constraints . Max ; import jakarta . validation . constraints . Min ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . NotNull ; import lombok . Data ; @ Data public class OptionVO { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer quId ; private String image ; @ NotBlank ( message = \"<STR_LIT>\" ) private String content ; private Boolean checkout ; private Integer sort ;", "output": "}"}, {"input": "package com . xcs . wx . config ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . servlet . config . annotation . EnableWebMvc ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; @ Configuration @ EnableWebMvc public class UseStaticResourceConfig implements WebMvcConfigurer { @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) ; }", "output": "}"}, {"input": "package org . springblade . config . tenant ; import com . baomidou . mybatisplus . extension . plugins . handler . TenantLineHandler ; import com . baomidou . mybatisplus . extension . plugins . inner . TenantLineInnerInterceptor ; import lombok . AllArgsConstructor ; import org . springblade . core . mp . config . MybatisPlusConfiguration ; import org . springblade . core . tenant . * ; import org . springblade . core . tenant . aspect . BladeTenantAspect ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Primary ; @ Configuration ( proxyBeanMethods = false ) @ AllArgsConstructor @ AutoConfigureBefore ( MybatisPlusConfiguration . class ) @ EnableConfigurationProperties ( BladeTenantProperties . class ) public class MjkjTenantConfiguration { @ Bean @ Primary public TenantLineHandler bladeTenantHandler ( BladeTenantProperties tenantProperties ) { return new BladeTenantHandler ( tenantProperties ) ; } @ Bean @ Primary public TenantLineInnerInterceptor tenantLineInnerInterceptor ( TenantLineHandler tenantHandler , BladeTenantProperties tenantProperties ) { MjkjTenantInterceptor tenantInterceptor = new MjkjTenantInterceptor ( ) ;", "output": "tenantInterceptor . setTenantLineHandler ( tenantHandler ) ; tenantInterceptor . setTenantProperties ( tenantProperties ) ; return tenantInterceptor ; } @ Bean @ ConditionalOnMissingBean ( TenantId . class ) public TenantId tenantId ( ) { return new BladeTenantId ( ) ; } @ Bean public BladeTenantAspect bladeTenantAspect ( ) { return new BladeTenantAspect ( ) ; } }"}, {"input": "package com . oddfar . campus . common . domain . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysRoleResourceEntity implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String resourceCode ; @ TableId ( type = IdType . INPUT ) private Long roleId ;", "output": "}"}, {"input": "package com . oddfar . campus . common . filter ; import com . alibaba . fastjson2 . filter . SimplePropertyPreFilter ; public class PropertyPreExcludeFilter extends SimplePropertyPreFilter { public PropertyPreExcludeFilter ( ) { }", "output": "public PropertyPreExcludeFilter addExcludes ( String ... filters ) { for ( int i = <NUM_LIT> ; i < filters . length ; i ++ ) { this . getExcludes ( ) . add ( filters [ i ] ) ; } return this ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . reflect ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . base . ObjectUtil ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . Validate ; import org . apache . commons . lang3 . reflect . ConstructorUtils ; import org . apache . commons . lang3 . reflect . MethodUtils ; import java . lang . reflect . * ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class ReflectionUtil { private static final String SETTER_PREFIX = \"<STR_LIT>\" ; private static final String GETTER_PREFIX = \"<STR_LIT>\" ; private static final String IS_PREFIX = \"<STR_LIT>\" ; public static Method getSetterMethod ( Class < ? > clazz , String propertyName , Class < ? > parameterType ) { String setterMethodName = SETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; return getMethod ( clazz , setterMethodName , parameterType ) ; } public static Method getGetterMethod ( Class < ? > clazz , String propertyName ) { String getterMethodName = GETTER_PREFIX + StringUtils . capitalize ( propertyName ) ; Method method = getMethod ( clazz , getterMethodName ) ; if ( method == null ) { getterMethodName = IS_PREFIX + StringUtils . capitalize ( propertyName ) ; method = getMethod ( clazz , getterMethodName ) ; } return method ; } public static Method getMethod ( final Class < ? > clazz , final String methodName , Class < ? > ... parameterTypes ) { Method method = MethodUtils . getMatchingMethod ( clazz , methodName , parameterTypes ) ; if ( method != null ) { makeAccessible ( method ) ; } return method ; } public static Method getAccessibleMethodByName ( final Class clazz , final String methodName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( methodName , \"<STR_LIT>\" ) ; for ( Class < ? > searchType = clazz ; searchType != Object . class ; searchType = searchType . getSuperclass ( ) ) { Method [ ] methods = searchType . getDeclaredMethods ( ) ; for ( Method method : methods ) { if ( method . getName ( ) . equals ( methodName ) ) { makeAccessible ( method ) ; return method ; } } } return null ; } public static Field getField ( final Class clazz , final String fieldName ) { Validate . notNull ( clazz , \"<STR_LIT>\" ) ; Validate . notEmpty ( fieldName , \"<STR_LIT>\" ) ; for ( Class < ? > superClass = clazz ; superClass != Object . class ; superClass = superClass . getSuperclass ( ) ) { try { Field field = superClass . getDeclaredField ( fieldName ) ; makeAccessible ( field ) ; return field ; } catch ( NoSuchFieldException e ) { } } return null ; } public static < T > T invokeGetter ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return invokeMethod ( obj , method ) ; } public static void invokeSetter ( Object obj , String propertyName , Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + propertyName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } invokeMethod ( obj , method , value ) ; } public static < T > T getFieldValue ( final Object obj , final String fieldName ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } return getFieldValue ( obj , field ) ; } public static < T > T getFieldValue ( final Object obj , final Field field ) { try { return ( T ) field . get ( obj ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static void setFieldValue ( final Object obj , final String fieldName , final Object value ) { Field field = getField ( obj . getClass ( ) , fieldName ) ; if ( field == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" + obj + '<STR_LIT>' ) ; } setField ( obj , field , value ) ; } public static void setField ( final Object obj , Field field , final Object value ) { try { field . set ( obj , value ) ; } catch ( Exception e ) { throw convertReflectionExceptionToUnchecked ( e ) ; } } public static < T > T getProperty ( Object obj , String propertyName ) { Method method = getGetterMethod ( obj . getClass ( ) , propertyName ) ; if ( method != null ) { return invokeMethod ( obj , method ) ; } else { return getFieldValue ( obj , propertyName ) ; } } public static void setProperty ( Object obj , String propertyName , final Object value ) { Method method = getSetterMethod ( obj . getClass ( ) , propertyName , value . getClass ( ) ) ; if ( method != null ) { invokeMethod ( obj , method , value ) ; } else { setFieldValue ( obj , propertyName , value ) ; } } public static < T > T invokeMethod ( Object obj , String methodName , Object ... args ) { Object [ ] theArgs = ArrayUtils . nullToEmpty ( args ) ; final Class < ? > [ ] parameterTypes = ClassUtils . toClass ( theArgs ) ; return invokeMethod ( obj , methodName , theArgs , parameterTypes ) ; } public static < T > T invokeMethod ( final Object obj , final String methodName , final Object [ ] args , final Class < ? > [ ] parameterTypes ) { Method method = getMethod ( obj . getClass ( ) , methodName , parameterTypes ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + ObjectUtil . toPrettyString ( parameterTypes ) + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethodByName ( final Object obj , final String methodName , final Object [ ] args ) { Method method = getAccessibleMethodByName ( obj . getClass ( ) , methodName ) ; if ( method == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + methodName + \"<STR_LIT>\" + obj . getClass ( ) + '<STR_LIT>' ) ; } return invokeMethod ( obj , method , args ) ; } public static < T > T invokeMethod ( final Object obj , Method method , Object ... args ) { try { return ( T ) method . invoke ( obj , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static < T > T invokeConstructor ( final Class < T > cls , Object ... args ) { try { return ConstructorUtils . invokeConstructor ( cls , args ) ; } catch ( Exception e ) { throw ExceptionUtil . unwrapAndUnchecked ( e ) ; } } public static void makeAccessible ( Method method ) { if ( ! method . isAccessible ( ) && ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) ) { method . setAccessible ( true ) ; } } public static void makeAccessible ( Field field ) { if ( ! field . isAccessible ( ) && ( ! Modifier . isPublic ( field . getModifiers ( ) ) || ! Modifier . isPublic ( field . getDeclaringClass ( ) . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) ) { field . setAccessible ( true ) ; } } public static RuntimeException convertReflectionExceptionToUnchecked ( Exception e ) { if ( ( e instanceof IllegalAccessException ) || ( e instanceof NoSuchMethodException ) ) { return new IllegalArgumentException ( e ) ; } else if ( e instanceof InvocationTargetException ) { return new RuntimeException ( ( ( InvocationTargetException ) e ) . getTargetException ( ) ) ; } else if ( e instanceof RuntimeException ) { return ( RuntimeException ) e ; } return new UncheckedException ( e ) ; } public static Class < ? > findGenericType ( Object object , Class < ? > parameterizedSuperclass , String typeParamName ) { if ( object == null ) { return null ; } Class < ? > thisClass = object . getClass ( ) ; Class < ? > currentClass = thisClass ; for ( ; ; ) { if ( currentClass . getSuperclass ( ) == parameterizedSuperclass ) { int typeParamIndex = - <NUM_LIT> ; TypeVariable < ? > [ ] typeParams = currentClass . getSuperclass ( ) . getTypeParameters ( ) ; for ( int i = <NUM_LIT> ; i < typeParams . length ; i ++ ) { if ( typeParamName . equals ( typeParams [ i ] . getName ( ) ) ) { typeParamIndex = i ; break ; } } if ( typeParamIndex < <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" + typeParamName + \"<STR_LIT>\" + parameterizedSuperclass ) ; } Type genericSuperType = currentClass . getGenericSuperclass ( ) ; if ( ! ( genericSuperType instanceof ParameterizedType ) ) { return Object . class ; } Type [ ] actualTypeParams = ( ( ParameterizedType ) genericSuperType ) . getActualTypeArguments ( ) ; Type actualTypeParam = actualTypeParams [ typeParamIndex ] ; if ( actualTypeParam instanceof ParameterizedType ) { actualTypeParam = ( ( ParameterizedType ) actualTypeParam ) . getRawType ( ) ; } if ( actualTypeParam instanceof Class ) { return ( Class < ? > ) actualTypeParam ; } if ( actualTypeParam instanceof GenericArrayType ) { Type componentType = ( ( GenericArrayType ) actualTypeParam ) . getGenericComponentType ( ) ; if ( componentType instanceof ParameterizedType ) {", "output": "componentType = ( ( ParameterizedType ) componentType ) . getRawType ( ) ; } if ( componentType instanceof Class ) { return Array . newInstance ( ( Class < ? > ) componentType , <NUM_LIT> ) . getClass ( ) ; } } if ( actualTypeParam instanceof TypeVariable ) { TypeVariable < ? > v = ( TypeVariable < ? > ) actualTypeParam ; currentClass = thisClass ; if ( ! ( v . getGenericDeclaration ( ) instanceof Class ) ) { return Object . class ; } parameterizedSuperclass = ( Class < ? > ) v . getGenericDeclaration ( ) ; typeParamName = v . getName ( ) ; if ( parameterizedSuperclass . isAssignableFrom ( thisClass ) ) { continue ; } else { return Object . class ; } } return null ; } currentClass = currentClass . getSuperclass ( ) ; if ( currentClass == null ) { return null ; } } } }"}, {"input": "package org . example . application . example . dto . command ; import lombok . Data ; import javax . validation . constraints . NotEmpty ; import javax . validation . constraints . Pattern ; @ Data public class ExampleRegisterCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String username ; @ NotEmpty ( message = \"<STR_LIT>\" ) @ Pattern ( regexp = \"<STR_LIT>\" , message = \"<STR_LIT>\" ) private String password ;", "output": "}"}, {"input": "package top . kangert . kspider . repository ; import org . springframework . data . jpa . repository . JpaRepository ; import org . springframework . data . jpa . repository . JpaSpecificationExecutor ; import org . springframework . stereotype . Repository ; import top . kangert . kspider . entity . User ; public interface UserRepository extends JpaRepository < User , Integer > , JpaSpecificationExecutor < User > {", "output": "User findByUsername ( String username ) ; }"}, {"input": "package top . kangert . kspider . driver ; import org . openqa . selenium . WebDriver ; import top . kangert . kspider . model . SpiderNode ; import java . net . MalformedURLException ; public interface DriverProvider { String DEFAULT_REMOTE_WEBDRIVER_URL = \"<STR_LIT>\" ; String REMOTE_WEBDRIVER_URL = \"<STR_LIT>\" ; String JAVASCRIPT_DISABLED = \"<STR_LIT>\" ; String USER_AGENT = \"<STR_LIT>\" ; String HEADLESS = \"<STR_LIT>\" ; String IMAGE_DISABLED = \"<STR_LIT>\" ; String HIDE_SCROLLBAR = \"<STR_LIT>\" ; String PLUGIN_DISABLE = \"<STR_LIT>\" ; String JAVA_DISABLE = \"<STR_LIT>\" ; String INCOGNITO = \"<STR_LIT>\" ;", "output": "String NO_SANDBOX = \"<STR_LIT>\" ; String WINDOW_SIZE = \"<STR_LIT>\" ; String MAXIMIZED = \"<STR_LIT>\" ; String GPU_DISABLE = \"<STR_LIT>\" ; String ARGUMENTS = \"<STR_LIT>\" ; String support ( ) ; WebDriver getWebDriver ( SpiderNode node , String proxyStr ) throws MalformedURLException ; }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util . parse ; import com . alibaba . nacos . api . config . ConfigType ; import io . github . chensheng . dddboot . nacos . spring . util . AbstractConfigParse ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . core . io . ByteArrayResource ; import org . springframework . core . io . Resource ; import org . springframework . util . Assert ; import org . springframework . util . ObjectUtils ; import org . springframework . util . StringUtils ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . LineNumberReader ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . LinkedHashMap ; import java . util . Map ; public class DefaultPropertiesConfigParse extends AbstractConfigParse { private static final Logger logger = LoggerFactory . getLogger ( DefaultPropertiesConfigParse . class ) ; @ Override public Map < String , Object > parse ( String configText ) { OriginTrackedPropertiesLoader loader = new OriginTrackedPropertiesLoader ( new ByteArrayResource ( configText . getBytes ( Charset . defaultCharset ( ) ) ) ) ; try { if ( StringUtils . hasText ( configText ) ) { return loader . load ( ) ; } return new LinkedHashMap < String , Object > ( ) ; } catch ( IOException e ) { throw new ConfigParseException ( e ) ; } } @ Override public String processType ( ) { return ConfigType . PROPERTIES . getType ( ) ; } public interface OriginProvider { Origin getOrigin ( ) ; } public abstract static class Origin { static Origin from ( Object source ) { if ( source instanceof Origin ) { return ( Origin ) source ; } Origin origin = null ; if ( source != null && source instanceof OriginProvider ) { origin = ( ( OriginProvider ) source ) . getOrigin ( ) ; } if ( origin == null && source != null && source instanceof Throwable ) { return from ( ( ( Throwable ) source ) . getCause ( ) ) ; } return origin ; } } public static class OriginTrackedValue implements OriginProvider { private final Object value ; private final Origin origin ; private OriginTrackedValue ( Object value , Origin origin ) { this . value = value ; this . origin = origin ; } public static OriginTrackedValue of ( Object value ) { return of ( value , null ) ; } public static OriginTrackedValue of ( Object value , Origin origin ) { if ( value == null ) { return null ; } if ( value instanceof CharSequence ) { return new OriginTrackedCharSequence ( ( CharSequence ) value , origin ) ; } return new OriginTrackedValue ( value , origin ) ; } public Object getValue ( ) { return this . value ; } @ Override public Origin getOrigin ( ) { return this . origin ; } @ Override public String toString ( ) { return ( this . value != null ? this . value . toString ( ) : null ) ; } @ Override public int hashCode ( ) { return ObjectUtils . nullSafeHashCode ( this . value ) ; } @ Override public boolean equals ( Object obj ) { if ( obj == null || obj . getClass ( ) != getClass ( ) ) { return false ; } return ObjectUtils . nullSafeEquals ( this . value , ( ( OriginTrackedValue ) obj ) . value ) ; } private static class OriginTrackedCharSequence extends OriginTrackedValue implements CharSequence { OriginTrackedCharSequence ( CharSequence value , Origin origin ) { super ( value , origin ) ; } @ Override public int length ( ) { return getValue ( ) . length ( ) ; } @ Override public char charAt ( int index ) { return getValue ( ) . charAt ( index ) ; } @ Override public CharSequence subSequence ( int start , int end ) { return getValue ( ) . subSequence ( start , end ) ; } @ Override public CharSequence getValue ( ) { return ( CharSequence ) super . getValue ( ) ; } } } static class Location { private final int line ; private final int column ; public Location ( int line , int column ) {", "output": "this . line = line ; this . column = column ; } public int getLine ( ) { return this . line ; } public int getColumn ( ) { return this . column ; } @ Override public int hashCode ( ) { return ( <NUM_LIT> * this . line ) + this . column ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || getClass ( ) != obj . getClass ( ) ) { return false ; } Location other = ( Location ) obj ; boolean result = true ; result = result && this . line == other . line ; result = result && this . column == other . column ; return result ; } @ Override public String toString ( ) { return ( this . line + <NUM_LIT> ) + \"<STR_LIT>\" + ( this . column + <NUM_LIT> ) ; } } class OriginTrackedPropertiesLoader { private final Resource resource ; OriginTrackedPropertiesLoader ( Resource resource ) { Assert . notNull ( resource , \"<STR_LIT>\" ) ; this . resource = resource ; } public Map < String , Object > load ( ) throws IOException { return load ( true ) ; } public Map < String , Object > load ( boolean expandLists ) throws IOException { CharacterReader reader = new CharacterReader ( this . resource ) ; try { Map < String , Object > result = new LinkedHashMap < String , Object > ( ) ; StringBuilder buffer = new StringBuilder ( ) ; while ( reader . read ( ) ) { String key = loadKey ( buffer , reader ) . trim ( ) ; if ( expandLists && key . endsWith ( \"<STR_LIT>\" ) ) { key = key . substring ( <NUM_LIT> , key . length ( ) - <NUM_LIT> ) ; int index = <NUM_LIT> ; do { OriginTrackedValue value = loadValue ( buffer , reader , true ) ; put ( result , key + \"<STR_LIT>\" + ( index ++ ) + \"<STR_LIT>\" , value ) ; if ( ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } } while ( ! reader . isEndOfLine ( ) ) ; } else { OriginTrackedValue value = loadValue ( buffer , reader , false ) ; put ( result , key , value ) ; } } return result ; } finally { reader . close ( ) ; } } private void put ( Map < String , Object > result , String key , OriginTrackedValue value ) { if ( ! key . isEmpty ( ) ) { result . put ( key , value . value ) ; } } private String loadKey ( StringBuilder buffer , CharacterReader reader ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; boolean previousWhitespace = false ; while ( ! reader . isEndOfLine ( ) ) { if ( reader . isPropertyDelimiter ( ) ) { reader . read ( ) ; return buffer . toString ( ) ; } if ( ! reader . isWhiteSpace ( ) && previousWhitespace ) { return buffer . toString ( ) ; } previousWhitespace = reader . isWhiteSpace ( ) ; buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } return buffer . toString ( ) ; } private OriginTrackedValue loadValue ( StringBuilder buffer , CharacterReader reader , boolean splitLists ) throws IOException { buffer . setLength ( <NUM_LIT> ) ; while ( reader . isWhiteSpace ( ) && ! reader . isEndOfLine ( ) ) { reader . read ( ) ; } Location location = reader . getLocation ( ) ; while ( ! reader . isEndOfLine ( ) && ! ( splitLists && reader . isListDelimiter ( ) ) ) { buffer . append ( reader . getCharacter ( ) ) ; reader . read ( ) ; } TextResourceOrigin origin = new TextResourceOrigin ( this . resource , location ) ; return OriginTrackedValue . of ( buffer . toString ( ) , origin ) ; } private class CharacterReader implements Closeable { private final String [ ] ESCAPES = { \"<STR_LIT>\" , \"<STR_LIT>\" } ; private final LineNumberReader reader ; private int columnNumber = - <NUM_LIT> ; private boolean escaped ; private int character ; CharacterReader ( Resource resource ) throws IOException { this . reader = new LineNumberReader ( new InputStreamReader ( resource . getInputStream ( ) , StandardCharsets . UTF_8 ) ) ; } @ Override public void close ( ) throws IOException { this . reader . close ( ) ; } public boolean read ( ) throws IOException { return read ( false ) ; } public boolean read ( boolean wrappedLine ) throws IOException { this . escaped = false ; this . character = this . reader . read ( ) ; this . columnNumber ++ ; if ( this . columnNumber == <NUM_LIT> ) { skipLeadingWhitespace ( ) ; if ( ! wrappedLine ) { skipComment ( ) ; } } if ( this . character == '<STR_LIT>' ) { this . escaped = true ; readEscaped ( ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; } return ! isEndOfFile ( ) ; } private void skipLeadingWhitespace ( ) throws IOException { while ( isWhiteSpace ( ) ) { this . character = this . reader . read ( ) ; this . columnNumber ++ ; } } private void skipComment ( ) throws IOException { if ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) { while ( this . character != '<STR_LIT>' && this . character != - <NUM_LIT> ) { this . character = this . reader . read ( ) ; } this . columnNumber = - <NUM_LIT> ; read ( ) ; } } private void readEscaped ( ) throws IOException { this . character = this . reader . read ( ) ; int escapeIndex = ESCAPES [ <NUM_LIT> ] . indexOf ( this . character ) ; if ( escapeIndex != - <NUM_LIT> ) { this . character = ESCAPES [ <NUM_LIT> ] . charAt ( escapeIndex ) ; } else if ( this . character == '<STR_LIT>' ) { this . columnNumber = - <NUM_LIT> ; read ( true ) ; } else if ( this . character == '<STR_LIT>' ) { readUnicode ( ) ; } } private void readUnicode ( ) throws IOException { this . character = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { int digit = this . reader . read ( ) ; if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else if ( digit >= '<STR_LIT>' && digit <= '<STR_LIT>' ) { this . character = ( this . character << <NUM_LIT> ) + digit - '<STR_LIT>' + <NUM_LIT> ; } else { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } public boolean isWhiteSpace ( ) { return ! this . escaped && ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) ; } public boolean isEndOfFile ( ) { return this . character == - <NUM_LIT> ; } public boolean isEndOfLine ( ) { return this . character == - <NUM_LIT> || ( ! this . escaped && this . character == '<STR_LIT>' ) ; } public boolean isListDelimiter ( ) { return ! this . escaped && this . character == '<STR_LIT>' ; } public boolean isPropertyDelimiter ( ) { return ! this . escaped && ( this . character == '<STR_LIT>' || this . character == '<STR_LIT>' ) ; } public char getCharacter ( ) { return ( char ) this . character ; } public Location getLocation ( ) { return new Location ( this . reader . getLineNumber ( ) , this . columnNumber ) ; } } } public class TextResourceOrigin extends Origin { private final Resource resource ; private final Location location ; public TextResourceOrigin ( Resource resource , Location location ) { this . resource = resource ; this . location = location ; } public Resource getResource ( ) { return this . resource ; } public Location getLocation ( ) { return this . location ; } @ Override public int hashCode ( ) { int result = <NUM_LIT> ; result = <NUM_LIT> * result + ObjectUtils . nullSafeHashCode ( this . resource ) ; result = <NUM_LIT> * result + ObjectUtils . nullSafeHashCode ( this . location ) ; return result ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( obj instanceof TextResourceOrigin ) { TextResourceOrigin other = ( TextResourceOrigin ) obj ; boolean result = true ; result = result && ObjectUtils . nullSafeEquals ( this . resource , other . resource ) ; result = result && ObjectUtils . nullSafeEquals ( this . location , other . location ) ; return result ; } return super . equals ( obj ) ; } @ Override public String toString ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( this . resource != null ? this . resource . getDescription ( ) : \"<STR_LIT>\" ) ; if ( this . location != null ) { result . append ( \"<STR_LIT>\" ) . append ( this . location ) ; } return result . toString ( ) ; } } }"}, {"input": "package ginyi . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import ginyi . system . domain . SysRole ; import ginyi . system . domain . model . dto . RoleDto ; import ginyi . system . domain . model . vo . RoleVo ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysRoleMapper extends BaseMapper < SysRole > { public List < SysRole > selectRolePermissionByUserId ( Long userId ) ; public IPage < RoleVo > list ( @ Param ( \"<STR_LIT>\" ) RoleDto roleDto , Page page ) ; public void insertRole ( @ Param ( \"<STR_LIT>\" ) RoleDto roleDto ) ; public void insertRoleMenu ( @ Param ( \"<STR_LIT>\" ) RoleDto roleDto ) ; public void updateRole ( @ Param ( \"<STR_LIT>\" ) RoleDto roleDto ) ; public void updateRoleMenu ( @ Param ( \"<STR_LIT>\" ) RoleDto roleDto ) ; public RoleVo selectRoleByRoleId ( Long roleId ) ; public void updateRoleStatus ( @ Param ( \"<STR_LIT>\" ) RoleDto roleDto ) ;", "output": "}"}, {"input": "package top . kangert . kspider . support ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import javax . annotation . PostConstruct ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Component public class ExecutorFactory { @ Autowired private List < NodeExecutor > executors ; private Map < String , NodeExecutor > executor_map ; @ PostConstruct public void initialize ( ) { executor_map = this . executors . stream ( ) . collect ( Collectors . toMap ( NodeExecutor :: supportType , v -> v ) ) ; } public NodeExecutor getExecutor ( String type ) { return executor_map . get ( type ) ; } public List < Shape > shapes ( ) { return executors . stream ( ) . filter ( e -> e . shape ( ) != null ) . map ( executor -> executor . shape ( ) ) . collect ( Collectors . toList ( ) ) ; } public List < ConfigItem > configItemList ( String executorName ) { NodeExecutor nodeExecutor = getExecutor ( executorName ) ; List < ConfigItem > configItems = Collections . emptyList ( ) ; if ( nodeExecutor != null ) { configItems = nodeExecutor . configItems ( ) ; } return configItems ;", "output": "} }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractLeverageParam { private String symbol ; private String type ; private BigDecimal cou ; private String pattern ; private String patternType ;", "output": "}"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . constant . UserConstants ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysMenuEntity ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . service . SysMenuService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . List ; import static com . oddfar . campus . common . utils . SecurityUtils . getUserId ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . SYSTEM ) public class SysMenuController { @ Autowired private SysMenuService menuService ; @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R list ( SysMenuEntity menu ) { List < SysMenuEntity > menus = menuService . selectMenuList ( menu , getUserId ( ) ) ; return R . ok ( menus ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R getInfo ( @ PathVariable Long menuId ) { return R . ok ( menuService . selectMenuById ( menuId ) ) ; } @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R treeSelect ( SysMenuEntity menu ) { List < SysMenuEntity > menus = menuService . selectMenuList ( menu , getUserId ( ) ) ; return R . ok ( menuService . buildMenuTreeSelect ( menus ) ) ; } @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R roleMenuTreeselect ( @ PathVariable ( \"<STR_LIT>\" ) Long roleId ) { List < SysMenuEntity > menus = menuService . selectMenuList ( getUserId ( ) ) ; R ajax = R . ok ( ) ; ajax . put ( \"<STR_LIT>\" , menuService . selectMenuListByRoleId ( roleId ) ) ; ajax . put ( \"<STR_LIT>\" , menuService . buildMenuTreeSelect ( menus ) ) ; return ajax ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PostMapping ( name = \"<STR_LIT>\" ) public R add ( @ Validated @ RequestBody SysMenuEntity menu ) { if ( ! menuService . checkMenuNameUnique ( menu ) ) { return R . error ( \"<STR_LIT>\" + menu . getMenuName ( ) + \"<STR_LIT>\" ) ; } else if ( UserConstants . YES_FRAME . equals ( menu . getIsFrame ( ) ) && ! StringUtils . ishttp ( menu . getPath ( ) ) ) { return R . error ( \"<STR_LIT>\" + menu . getMenuName ( ) + \"<STR_LIT>\" ) ; } return R . ok ( menuService . insertMenu ( menu ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( name = \"<STR_LIT>\" ) public R edit ( @ Validated @ RequestBody SysMenuEntity menu ) { if ( ! menuService . checkMenuNameUnique ( menu ) ) { return R . error ( \"<STR_LIT>\" + menu . getMenuName ( ) + \"<STR_LIT>\" ) ; } else if ( UserConstants . YES_FRAME . equals ( menu . getIsFrame ( ) ) && ! StringUtils . ishttp ( menu . getPath ( ) ) ) { return R . error ( \"<STR_LIT>\" + menu . getMenuName ( ) + \"<STR_LIT>\" ) ; } else if ( menu . getMenuId ( ) . equals ( menu . getParentId ( ) ) ) { return R . error ( \"<STR_LIT>\" + menu . getMenuName ( ) + \"<STR_LIT>\" ) ; } return R . ok ( menuService . updateMenu ( menu ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ DeleteMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R remove ( @ PathVariable ( \"<STR_LIT>\" ) Long menuId ) { if ( menuService . hasChildByMenuId ( menuId ) ) { return R . error ( \"<STR_LIT>\" ) ; } if ( menuService . checkMenuExistRole ( menuId ) ) { return R . error ( \"<STR_LIT>\" ) ; } return R . ok ( menuService . deleteMenuById ( menuId ) ) ; }", "output": "}"}, {"input": "package me . zhengjie . modules . security . security ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . UserCacheManager ; import org . springframework . security . config . annotation . SecurityConfigurerAdapter ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . web . DefaultSecurityFilterChain ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; @ RequiredArgsConstructor public class TokenConfigurer extends SecurityConfigurerAdapter < DefaultSecurityFilterChain , HttpSecurity > { private final TokenProvider tokenProvider ; private final SecurityProperties properties ; private final OnlineUserService onlineUserService ; private final UserCacheManager userCacheManager ; @ Override public void configure ( HttpSecurity http ) { TokenFilter customFilter = new TokenFilter ( tokenProvider , properties , onlineUserService , userCacheManager ) ; http . addFilterBefore ( customFilter , UsernamePasswordAuthenticationFilter . class ) ; }", "output": "}"}, {"input": "package org . springblade . common . constant ; public interface CommonConstant { String SWORD_NAME = \"<STR_LIT>\" ; String SABER_NAME = \"<STR_LIT>\" ; Long TOP_PARENT_ID = <NUM_LIT> ; String TOP_PARENT_NAME = \"<STR_LIT>\" ; Integer NOT_SEALED_ID = <NUM_LIT> ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ;", "output": "String DEFAULT_PARAM_PASSWORD = \"<STR_LIT>\" ; String SORT_FIELD = \"<STR_LIT>\" ; Integer DATA_SCOPE_CATEGORY = <NUM_LIT> ; Integer API_SCOPE_CATEGORY = <NUM_LIT> ; }"}, {"input": "package com . youlai . system . model . vo ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import java . util . Set ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class UserInfoVO { @ Schema ( description = \"<STR_LIT>\" ) private Long userId ; @ Schema ( description = \"<STR_LIT>\" ) private String username ; @ Schema ( description = \"<STR_LIT>\" ) private String nickname ; @ Schema ( description = \"<STR_LIT>\" ) private String avatar ; @ Schema ( description = \"<STR_LIT>\" ) private Set < String > roles ; @ Schema ( description = \"<STR_LIT>\" ) private Set < String > perms ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . io ; import com . google . common . base . Predicate ; import com . google . common . collect . TreeTraverser ; import com . google . common . io . Files ; import io . github . chensheng . dddboot . tools . text . WildcardMatcher ; import java . io . File ; import java . util . List ; import java . util . regex . Pattern ; public class FileTreeWalker { public static List < File > listAll ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . toList ( ) ; } public static List < File > listFile ( File rootDir ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( Files . isFile ( ) ) . toList ( ) ; } public static List < File > listFileWithExtension ( final File rootDir , final String extension ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new FileExtensionFilter ( extension ) ) . toList ( ) ; }", "output": "public static List < File > listFileWithWildcardFileName ( final File rootDir , final String fileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new WildcardFileNameFilter ( fileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithRegexFileName ( final File rootDir , final String regexFileNamePattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new RegexFileNameFilter ( regexFileNamePattern ) ) . toList ( ) ; } public static List < File > listFileWithAntPath ( final File rootDir , final String antPathPattern ) { return Files . fileTreeTraverser ( ) . preOrderTraversal ( rootDir ) . filter ( new AntPathFilter ( FilePathUtil . concat ( rootDir . getAbsolutePath ( ) , antPathPattern ) ) ) . toList ( ) ; } public static TreeTraverser < File > fileTreeTraverser ( ) { return Files . fileTreeTraverser ( ) ; } public static final class RegexFileNameFilter implements Predicate < File > { private final Pattern pattern ; private RegexFileNameFilter ( String pattern ) { this . pattern = Pattern . compile ( pattern ) ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && pattern . matcher ( input . getName ( ) ) . matches ( ) ; } } public static final class WildcardFileNameFilter implements Predicate < File > { private final String pattern ; private WildcardFileNameFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && WildcardMatcher . match ( input . getName ( ) , pattern ) ; } } public static final class FileExtensionFilter implements Predicate < File > { private final String extension ; private FileExtensionFilter ( String extension ) { this . extension = extension ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && extension . equals ( FileUtil . getFileExtension ( input ) ) ; } } public static final class AntPathFilter implements Predicate < File > { private final String pattern ; private AntPathFilter ( String pattern ) { this . pattern = pattern ; } @ Override public boolean apply ( File input ) { return input . isFile ( ) && WildcardMatcher . matchPath ( input . getAbsolutePath ( ) , pattern ) ; } } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class EntrustContractXjwtCloseParam { String type ; String concatCoinId ; String memberId ; String contractType ; String direction ; String entrustCode ; String orderCode ; BigDecimal price ;", "output": "BigDecimal amount ; String logContractId ; Boolean executeNow ; }"}, {"input": "package org . springblade . web . utils ; import java . util . Random ; import java . util . UUID ; public class GeneratorUtil { public static int getRandomNumber ( int from , int to ) { float a = from + ( to - from ) * ( new Random ( ) . nextFloat ( ) ) ; int b = ( int ) a ; return ( ( a - b ) > <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> ) + b ; } public static String getPromotionCode ( Long uid ) { String seed = \"<STR_LIT>\" ; long num = uid + <NUM_LIT> ; long mod = <NUM_LIT> ; StringBuffer code = new StringBuffer ( ) ; while ( num > <NUM_LIT> ) { mod = num % <NUM_LIT> ; num = ( num - mod ) / <NUM_LIT> ;", "output": "code . insert ( <NUM_LIT> , seed . charAt ( Integer . parseInt ( String . valueOf ( mod ) ) ) ) ; } while ( code . length ( ) < <NUM_LIT> ) { code . insert ( <NUM_LIT> , \"<STR_LIT>\" ) ; } return code . toString ( ) ; } public static String getNonceString ( int len ) { String seed = \"<STR_LIT>\" ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = <NUM_LIT> ; i < len ; i ++ ) { tmp . append ( seed . charAt ( getRandomNumber ( <NUM_LIT> , <NUM_LIT> ) ) ) ; } return tmp . toString ( ) ; } public static String getUUID ( ) { UUID uuid = UUID . randomUUID ( ) ; return uuid . toString ( ) ; } public static String getOrderId ( String prefix ) { String body = String . valueOf ( System . currentTimeMillis ( ) ) ; return prefix + body + getRandomNumber ( <NUM_LIT> , <NUM_LIT> ) ; } }"}, {"input": "package com . oddfar . campus . common . annotation ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import java . lang . annotation . * ; @ Target ( { ElementType . METHOD , ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface ApiResource { String code ( ) default \"<STR_LIT>\" ; String appCode ( ) default \"<STR_LIT>\" ; String name ( ) default \"<STR_LIT>\" ; ResBizTypeEnum resBizType ( ) default ResBizTypeEnum . BUSINESS ;", "output": "}"}, {"input": "package me . zhengjie . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . domain . SysLog ; import me . zhengjie . service . SysLogService ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . SecurityUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class SysLogController { private final SysLogService sysLogService ; @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportLog ( HttpServletResponse response , SysLogQueryCriteria criteria ) throws IOException { criteria . setLogType ( \"<STR_LIT>\" ) ; sysLogService . download ( sysLogService . queryAll ( criteria ) , response ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportErrorLog ( HttpServletResponse response , SysLogQueryCriteria criteria ) throws IOException { criteria . setLogType ( \"<STR_LIT>\" ) ; sysLogService . download ( sysLogService . queryAll ( criteria ) , response ) ; } @ GetMapping @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < SysLog > > queryLog ( SysLogQueryCriteria criteria , Page < SysLog > page ) { criteria . setLogType ( \"<STR_LIT>\" ) ; return new ResponseEntity < > ( sysLogService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < SysLog > > queryUserLog ( SysLogQueryCriteria criteria , Page < SysLog > page ) { criteria . setLogType ( \"<STR_LIT>\" ) ; criteria . setUsername ( SecurityUtils . getCurrentUsername ( ) ) ; return new ResponseEntity < > ( sysLogService . queryAllByUser ( criteria , page ) , HttpStatus . OK ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < SysLog > > queryErrorLog ( SysLogQueryCriteria criteria , Page < SysLog > page ) { criteria . setLogType ( \"<STR_LIT>\" ) ; return new ResponseEntity < > ( sysLogService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > queryErrorLogDetail ( @ PathVariable Long id ) { return new ResponseEntity < > ( sysLogService . findByErrDetail ( id ) , HttpStatus . OK ) ;", "output": "} @ DeleteMapping ( value = \"<STR_LIT>\" ) @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > delAllErrorLog ( ) { sysLogService . delAllByError ( ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ DeleteMapping ( value = \"<STR_LIT>\" ) @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > delAllInfoLog ( ) { sysLogService . delAllByInfo ( ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . mapper ; import io . github . chensheng . dddboot . tools . collection . ArrayUtil ; import org . dozer . DozerBeanMapper ; import org . dozer . Mapper ; import java . util . ArrayList ; import java . util . List ; public class BeanMapper { private static Mapper mapper = new DozerBeanMapper ( ) ; public static < S , D > D map ( S source , Class < D > destinationClass ) { return mapper . map ( source , destinationClass ) ; } public static < S , D > List < D > mapList ( Iterable < S > sourceList , Class < D > destinationClass ) { List < D > destinationList = new ArrayList < D > ( ) ; for ( S source : sourceList ) { if ( source != null ) { destinationList . add ( mapper . map ( source , destinationClass ) ) ; } } return destinationList ; } public static < S , D > D [ ] mapArray ( final S [ ] sourceArray , final Class < D > destinationClass ) { D [ ] destinationArray = ArrayUtil . newArray ( destinationClass , sourceArray . length ) ; int i = <NUM_LIT> ; for ( S source : sourceArray ) { if ( source != null ) { destinationArray [ i ] = mapper . map ( sourceArray [ i ] , destinationClass ) ; i ++ ; } }", "output": "return destinationArray ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . support ; import io . github . chensheng . dddboot . nacos . spring . env . AbstractNacosPropertySourceBuilder ; import io . github . chensheng . dddboot . nacos . spring . env . NacosPropertySource ; import io . github . chensheng . dddboot . nacos . spring . util . ConfigParseUtils ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . parse . DefaultYamlConfigParse ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . boot . SpringApplication ; import org . springframework . boot . env . EnvironmentPostProcessor ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Map ; import java . util . concurrent . atomic . AtomicReference ; public class MultiProfilesYamlConfigParseSupport extends DefaultYamlConfigParse implements EnvironmentPostProcessor { private static final String SPRING_PROFILES = \"<STR_LIT>\" ; private static String [ ] profileArray = { } ; @ Override public void postProcessEnvironment ( ConfigurableEnvironment environment , SpringApplication application ) { String [ ] profiles = environment . getActiveProfiles ( ) ; if ( profiles . length == <NUM_LIT> ) { profiles = environment . getDefaultProfiles ( ) ; } if ( profileArray . length == <NUM_LIT> ) { profileArray = profiles ; } } @ Override public Map < String , Object > parse ( String configText ) { final AtomicReference < Map < String , Object > > result = new AtomicReference < > ( ) ; process ( map -> { if ( result . get ( ) == null ) { result . set ( map ) ; } else { setFromOtherBlock ( result , map ) ; } } , createYaml ( ) , configText ) ; return result . get ( ) ; } private void setFromOtherBlock ( AtomicReference < Map < String , Object > > result , Map < String , Object > map ) {", "output": "if ( map . get ( SPRING_PROFILES ) == null ) { result . get ( ) . putAll ( map ) ; return ; } for ( String profile : profileArray ) { if ( profile . equals ( map . get ( SPRING_PROFILES ) ) ) { result . get ( ) . putAll ( map ) ; } } } static void setProfileArray ( String [ ] profiles ) { profileArray = profiles ; } }"}, {"input": "package com . oddfar . campus . framework . mapper ; import cn . hutool . core . util . ObjectUtil ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysMenuEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysMenuMapper extends BaseMapperX < SysMenuEntity > { default PageResult < SysMenuEntity > selectPage ( SysMenuEntity sysMenuEntity ) { return selectPage ( new LambdaQueryWrapperX < SysMenuEntity > ( ) ) ; } default List < SysMenuEntity > selectMenuList ( SysMenuEntity menu ) { return selectList ( new LambdaQueryWrapperX < SysMenuEntity > ( ) . like ( ObjectUtil . isNotNull ( menu . getMenuName ( ) ) , SysMenuEntity :: getMenuName , menu . getMenuName ( ) ) . eq ( ObjectUtil . isNotNull ( menu . getVisible ( ) ) , SysMenuEntity :: getVisible , menu . getVisible ( ) ) . eq ( ObjectUtil . isNotNull ( menu . getStatus ( ) ) , SysMenuEntity :: getStatus , menu . getStatus ( ) ) ) ; } List < SysMenuEntity > selectMenuListByUserId ( SysMenuEntity menu ) ;", "output": "List < SysMenuEntity > selectMenuTreeAll ( ) ; List < SysMenuEntity > selectMenuTreeByUserId ( Long userId ) ; List < String > selectMenuPermsByRoleId ( Long roleId ) ; List < SysRoleAuth > getMenuPermsAll ( ) ; List < String > selectMenuPermsByUserId ( Long userId ) ; List < Long > selectMenuListByRoleId ( @ Param ( \"<STR_LIT>\" ) Long roleId , @ Param ( \"<STR_LIT>\" ) boolean menuCheckStrictly ) ; default SysMenuEntity checkMenuNameUnique ( SysMenuEntity menu ) { return selectOne ( new LambdaQueryWrapperX < SysMenuEntity > ( ) . eq ( SysMenuEntity :: getMenuName , menu . getMenuName ( ) ) . eq ( SysMenuEntity :: getParentId , menu . getParentId ( ) ) ) ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class GradeExercise implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer repoId ; private Integer gradeId ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getRepoId ( ) { return repoId ; } public void setRepoId ( Integer repoId ) { this . repoId = repoId ; } public Integer getGradeId ( ) { return gradeId ; } public void setGradeId ( Integer gradeId ) { this . gradeId = gradeId ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public LocalDateTime getCreateTime ( ) {", "output": "return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + repoId + \"<STR_LIT>\" + gradeId + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; import java . util . List ; @ Data public class ContactVO { private String userName ; private String alias ; private String remark ; private String nickName ; private String describe ; private String headImgUrl ; private String labelIdList ; private List < String > labels ;", "output": "}"}, {"input": "package org . springblade . web . config . rabbitmq ; import org . springframework . stereotype . Component ; import java . io . IOException ; import java . math . BigDecimal ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Component public class DetailBbwQueueHandler {", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import lombok . Data ; @ Data public class ExamQuestionVO { private Integer id ; private Integer examId ; private Integer questionId ; private Integer score ; private Integer sort ; private Integer type ; private Boolean checkout ;", "output": "}"}, {"input": "package ginyi . server . admin . controller ; import ginyi . common . result . CommonResult ; import ginyi . system . domain . SysLogLogin ; import ginyi . system . domain . SysLogOperation ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . service . ISysLogService ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class SysLogController { @ Resource private ISysLogService logService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < BaseVo < SysLogLogin > > loginLogList ( @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long page , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long pageSize ) { BaseVo < SysLogLogin > list = logService . getLoginLogList ( page , pageSize ) ; return CommonResult . success ( list ) ; }", "output": "@ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public CommonResult < BaseVo < SysLogOperation > > operationLogList ( @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long page , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Long pageSize ) { BaseVo < SysLogOperation > list = logService . getOperationLogList ( page , pageSize ) ; return CommonResult . success ( list ) ; } }"}, {"input": "package org . springblade . gateway . dynamic ; import com . alibaba . cloud . nacos . NacosConfigProperties ; import com . alibaba . cloud . nacos . NacosDiscoveryProperties ; import com . alibaba . fastjson . JSON ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . PropertyKeyConst ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . props . BladeProperties ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . core . annotation . Order ; import org . springframework . stereotype . Component ; import java . util . List ; import java . util . Properties ; import java . util . concurrent . Executor ; @ Order @ Slf4j @ Component public class DynamicRouteServiceListener { private final DynamicRouteService dynamicRouteService ; private final NacosDiscoveryProperties nacosDiscoveryProperties ; private final NacosConfigProperties nacosConfigProperties ; private final BladeProperties bladeProperties ; public DynamicRouteServiceListener ( DynamicRouteService dynamicRouteService , NacosDiscoveryProperties nacosDiscoveryProperties , NacosConfigProperties nacosConfigProperties , BladeProperties bladeProperties ) { this . dynamicRouteService = dynamicRouteService ;", "output": "this . nacosDiscoveryProperties = nacosDiscoveryProperties ; this . nacosConfigProperties = nacosConfigProperties ; this . bladeProperties = bladeProperties ; dynamicRouteServiceListener ( ) ; } private void dynamicRouteServiceListener ( ) { try { String dataId = NacosConstant . dataId ( bladeProperties . getName ( ) , bladeProperties . getEnv ( ) , NacosConstant . NACOS_CONFIG_JSON_FORMAT ) ; String group = nacosConfigProperties . getGroup ( ) ; Properties properties = new Properties ( ) ; properties . setProperty ( PropertyKeyConst . SERVER_ADDR , nacosDiscoveryProperties . getServerAddr ( ) ) ; properties . setProperty ( PropertyKeyConst . NAMESPACE , nacosDiscoveryProperties . getNamespace ( ) ) ; ConfigService configService = NacosFactory . createConfigService ( properties ) ; configService . addListener ( dataId , group , new Listener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { List < RouteDefinition > routeDefinitions = JSON . parseArray ( configInfo , RouteDefinition . class ) ; dynamicRouteService . updateList ( routeDefinitions ) ; } @ Override public Executor getExecutor ( ) { return null ; } } ) ; String configInfo = configService . getConfig ( dataId , group , <NUM_LIT> ) ; if ( configInfo != null ) { List < RouteDefinition > routeDefinitions = JSON . parseArray ( configInfo , RouteDefinition . class ) ; dynamicRouteService . updateList ( routeDefinitions ) ; } } catch ( NacosException ignored ) { } } }"}, {"input": "package me . zhengjie . utils . enums ; import lombok . AllArgsConstructor ; import lombok . Getter ; @ Getter @ AllArgsConstructor public enum DataScopeEnum { ALL ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , THIS_LEVEL ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , CUSTOMIZE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private final String value ; private final String description ; public static DataScopeEnum find ( String val ) { for ( DataScopeEnum dataScopeEnum : DataScopeEnum . values ( ) ) { if ( dataScopeEnum . getValue ( ) . equals ( val ) ) { return dataScopeEnum ;", "output": "} } return null ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; @ Data @ AllArgsConstructor public class StatsPanelVO { private Integer contact ; private Integer chatRoom ; private Integer sent ; private Integer received ;", "output": "}"}, {"input": "package me . zhengjie . modules . security . service . dto ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import org . springframework . security . core . GrantedAuthority ; @ Data @ NoArgsConstructor @ AllArgsConstructor public class AuthorityDto implements GrantedAuthority { private String authority ;", "output": "}"}, {"input": "package top . kangert . kspider . util ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; public class IoUtils { public static String readStreamToString ( InputStream input ) { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( input ) ) ; StringBuilder stringBuilder = new StringBuilder ( ) ; String line ;", "output": "try { while ( ( line = bufferedReader . readLine ( ) ) != null ) { stringBuilder . append ( line ) ; } return stringBuilder . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } }"}, {"input": "package top . kangert . kspider . service ; import top . kangert . kspider . domain . SpiderFlow ; import top . kangert . kspider . io . Line ; import top . kangert . kspider . util . PageInfo ; import java . util . List ; import java . util . Map ; public interface SpiderFlowService { PageInfo < SpiderFlow > queryItems ( Map < String , Object > params ) ; SpiderFlow queryItem ( Long id ) ; SpiderFlow addItem ( Map < String , Object > params ) ; void editItem ( Map < String , Object > params ) ; void deleteItem ( Map < String , Object > params ) ; void removeById ( Long id ) ; SpiderFlow getById ( Long id ) ; List < SpiderFlow > findOtherFlows ( Long id ) ; List < String > getRecentTriggerTime ( String cron , int numTimes ) ; List < Line > log ( Long id , Long taskId , String keywords , Long index , Integer count , Boolean reversed , Boolean matchCase , Boolean regex ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . security . rest ; import cn . hutool . core . util . IdUtil ; import com . wf . captcha . base . Captcha ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . annotation . Log ; import me . zhengjie . annotation . rest . AnonymousDeleteMapping ; import me . zhengjie . annotation . rest . AnonymousGetMapping ; import me . zhengjie . annotation . rest . AnonymousPostMapping ; import me . zhengjie . config . RsaProperties ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . security . config . bean . LoginCodeEnum ; import me . zhengjie . modules . security . config . bean . LoginProperties ; import me . zhengjie . modules . security . config . bean . SecurityProperties ; import me . zhengjie . modules . security . security . TokenProvider ; import me . zhengjie . modules . security . service . dto . AuthUserDto ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . utils . RsaUtils ; import me . zhengjie . utils . RedisUtils ; import me . zhengjie . utils . SecurityUtils ; import me . zhengjie . utils . StringUtils ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . config . annotation . authentication . builders . AuthenticationManagerBuilder ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . core . userdetails . UserDetails ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ Slf4j @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) public class AuthorizationController { private final SecurityProperties properties ; private final RedisUtils redisUtils ; private final OnlineUserService onlineUserService ; private final TokenProvider tokenProvider ; private final AuthenticationManagerBuilder authenticationManagerBuilder ; @ Resource private LoginProperties loginProperties ; @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ AnonymousPostMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > login ( @ Validated @ RequestBody AuthUserDto authUser , HttpServletRequest request ) throws Exception { String password = RsaUtils . decryptByPrivateKey ( RsaProperties . privateKey , authUser . getPassword ( ) ) ; String code = ( String ) redisUtils . get ( authUser . getUuid ( ) ) ; redisUtils . del ( authUser . getUuid ( ) ) ; if ( StringUtils . isBlank ( code ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } if ( StringUtils . isBlank ( authUser . getCode ( ) ) || ! authUser . getCode ( ) . equalsIgnoreCase ( code ) ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( authUser . getUsername ( ) , password ) ; Authentication authentication = authenticationManagerBuilder . getObject ( ) . authenticate ( authenticationToken ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; String token = tokenProvider . createToken ( authentication ) ; final JwtUserDto jwtUserDto = ( JwtUserDto ) authentication . getPrincipal ( ) ; Map < String , Object > authInfo = new HashMap < String , Object > ( <NUM_LIT> ) { { put ( \"<STR_LIT>\" , properties . getTokenStartWith ( ) + token ) ; put ( \"<STR_LIT>\" , jwtUserDto ) ; } } ; if ( loginProperties . isSingleLogin ( ) ) { onlineUserService . kickOutForUsername ( authUser . getUsername ( ) ) ; } onlineUserService . save ( jwtUserDto , token , request ) ; return ResponseEntity . ok ( authInfo ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < UserDetails > getUserInfo ( ) { return ResponseEntity . ok ( SecurityUtils . getCurrentUser ( ) ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ AnonymousGetMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > getCode ( ) { Captcha captcha = loginProperties . getCaptcha ( ) ; String uuid = properties . getCodeKey ( ) + IdUtil . simpleUUID ( ) ; String captchaValue = captcha . text ( ) ; if ( captcha . getCharType ( ) - <NUM_LIT> == LoginCodeEnum . ARITHMETIC . ordinal ( ) && captchaValue . contains ( \"<STR_LIT>\" ) ) { captchaValue = captchaValue . split ( \"<STR_LIT>\" ) [ <NUM_LIT> ] ; } redisUtils . set ( uuid , captchaValue , loginProperties . getLoginCode ( ) . getExpiration ( ) , TimeUnit . MINUTES ) ; Map < String , Object > imgResult = new HashMap < String , Object > ( <NUM_LIT> ) { { put ( \"<STR_LIT>\" , captcha . toBase64 ( ) ) ; put ( \"<STR_LIT>\" , uuid ) ; } } ; return ResponseEntity . ok ( imgResult ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ AnonymousDeleteMapping ( value = \"<STR_LIT>\" ) public ResponseEntity < Object > logout ( HttpServletRequest request ) {", "output": "String token = tokenProvider . getToken ( request ) ; onlineUserService . logout ( token ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package org . springblade . cgform . service ; import org . springblade . cgform . entity . SysDictItem ; import org . springblade . cgform . model . DictModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; public interface IDictItemService extends BaseService < SysDictItem > {", "output": "List < DictModel > queryDictItemsByCode ( String code ) ; }"}, {"input": "package com . yf . ability . redis . service ; import java . util . List ; import java . util . Map ; public interface RedisService { boolean tryLock ( String key , Long ms , int tryCount , long tryWait ) ; boolean tryLock ( String key , Long ms ) ; public void unlock ( String key ) ; void del ( String ... keys ) ; Map < String , Object > getJson ( String key ) ; String getString ( String key ) ; boolean set ( String key , String data ) ; boolean set ( String key , String value , Long time ) ; boolean putList ( String key , String value ) ; boolean removeList ( String key , String value ) ; List < String > findList ( String key ) ;", "output": "boolean hasKey ( String key ) ; }"}, {"input": "package com . youlai . system . common . base ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Data @ Schema public class BasePageQuery { @ Schema ( description = \"<STR_LIT>\" , requiredMode = Schema . RequiredMode . REQUIRED , example = \"<STR_LIT>\" ) private int pageNum = <NUM_LIT> ; @ Schema ( description = \"<STR_LIT>\" , requiredMode = Schema . RequiredMode . REQUIRED , example = \"<STR_LIT>\" ) private int pageSize = <NUM_LIT> ;", "output": "}"}, {"input": "package top . kangert . kspider . expression . interpreter ; import java . io . IOException ; import java . util . List ; import top . kangert . kspider . expression . ExpressionError ; import top . kangert . kspider . expression . ExpressionTemplate ; import top . kangert . kspider . expression . ExpressionTemplateContext ; import top . kangert . kspider . expression . ExpressionError . * ; import top . kangert . kspider . expression . parsing . Ast ; import top . kangert . kspider . expression . parsing . Ast . * ; public class AstInterpreter { public static Object interpret ( ExpressionTemplate template , ExpressionTemplateContext context ) { try { return interpretNodeList ( template . getNodes ( ) , template , context ) ; } catch ( Throwable t ) { if ( t instanceof TemplateException ) { throw ( TemplateException ) t ; } else { ExpressionError . error ( \"<STR_LIT>\" + t . getMessage ( ) , template . getNodes ( ) . get ( <NUM_LIT> ) . getSpan ( ) , t ) ; return null ; } } } public static Object interpretNodeList ( List < Node > nodes , ExpressionTemplate template , ExpressionTemplateContext context ) throws IOException { String result = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> , n = nodes . size ( ) ;", "output": "i < n ; i ++ ) { Node node = nodes . get ( i ) ; Object value = node . evaluate ( template , context ) ; if ( node instanceof Text ) { result += node . getSpan ( ) . getText ( ) ; } else if ( value == null ) { if ( i == <NUM_LIT> && i + <NUM_LIT> == n ) { return null ; } result += \"<STR_LIT>\" ; } else { if ( i == <NUM_LIT> && i + <NUM_LIT> == n ) { return value ; } result += value ; } } return result ; } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class SubWalletParam { private String tableName ; private String walletId ; private BigDecimal subBalance ; private BigDecimal feeAmount = BigDecimal . ZERO ; private String serviceType ; private String remark ; private BigDecimal borrowBalance = BigDecimal . ZERO ; private BigDecimal subBorrowBalance = BigDecimal . ZERO ; private String contractSymbolName ; private boolean messageRefreshFlag = true ;", "output": "}"}, {"input": "package com . yf . system . modules . user . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . yf . system . modules . user . dto . request . SysUserQueryReqDTO ; import com . yf . system . modules . user . dto . response . UserExportDTO ; import com . yf . system . modules . user . dto . response . UserListRespDTO ; import com . yf . system . modules . user . entity . SysUser ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysUserMapper extends BaseMapper < SysUser > { List < UserExportDTO > listForExport ( @ Param ( \"<STR_LIT>\" ) SysUserQueryReqDTO reqDTO ) ;", "output": "IPage < UserListRespDTO > paging ( Page page , @ Param ( \"<STR_LIT>\" ) SysUserQueryReqDTO reqDTO ) ; }"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . domain . entity . SysUserRoleEntity ; import org . apache . ibatis . annotations . Param ; public interface SysUserRoleMapper extends BaseMapperX < SysUserRoleEntity > { default int deleteUserRoleByUserId ( Long userId ) { return delete ( new QueryWrapper < SysUserRoleEntity > ( ) . eq ( \"<STR_LIT>\" , userId ) ) ; } default int deleteUserRoleInfo ( SysUserRoleEntity userRole ) { return delete ( new QueryWrapper < SysUserRoleEntity > ( ) . eq ( \"<STR_LIT>\" , userRole . getUserId ( ) ) . eq ( \"<STR_LIT>\" , userRole . getRoleId ( ) ) ) ; }", "output": "default int deleteUserRoleInfos ( @ Param ( \"<STR_LIT>\" ) Long roleId , @ Param ( \"<STR_LIT>\" ) Long [ ] userIds ) { return delete ( new QueryWrapper < SysUserRoleEntity > ( ) . eq ( \"<STR_LIT>\" , roleId ) . in ( \"<STR_LIT>\" , userIds ) ) ; } default int countUserRoleByRoleId ( Long roleId ) { return selectCount ( \"<STR_LIT>\" , roleId ) . intValue ( ) ; } void deleteUserRole ( Long [ ] userIds ) ; }"}, {"input": "package org . springblade . config . util . converter . impl ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . CommonEntity ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class LinkDownFieldCommentConverter extends TableFieldCommentConverter { private String linkField ; public LinkDownFieldCommentConverter ( CgformField onlCgformField ) { String dictTable = onlCgformField . getDictTable ( ) ; CommonEntity linkDown = JSONObject . parseObject ( dictTable , CommonEntity . class ) ; this . setTable ( linkDown . getTable ( ) ) ; this . setCode ( linkDown . getKey ( ) ) ; this . setText ( linkDown . getTxt ( ) ) ; this . linkField = linkDown . getLinkField ( ) ; }", "output": "@ Override public Map < String , String > getConfig ( ) { Map < String , String > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , this . linkField ) ; return hashMap ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . type ; import java . util . HashMap ; import java . util . Map ; public class ThreadLocalContext { private static ThreadLocal < Map < String , Object > > contextMap = new ThreadLocal < Map < String , Object > > ( ) { @ Override protected Map < String , Object > initialValue ( ) { return new HashMap < String , Object > ( <NUM_LIT> , <NUM_LIT> ) ;", "output": "} } ; public static void put ( String key , Object value ) { contextMap . get ( ) . put ( key , value ) ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T get ( String key ) { return ( T ) ( contextMap . get ( ) . get ( key ) ) ; } public static void reset ( ) { contextMap . get ( ) . clear ( ) ; } }"}, {"input": "package ginyi . system . domain ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data public class SysJvm { @ ApiModelProperty ( \"<STR_LIT>\" ) private double total ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double max ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double free ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String version ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String home ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double used ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double usage ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String inputArgs ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String runTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String startTime ;", "output": "}"}, {"input": "package org . example . ddduser . application . service . impl ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . service . UserMsQueryService ; import org . example . ddduser . domain . repository . UserRepository ; import org . example . ddduser . domain . user . UserEntity ; import org . example . ddduser . infrastructure . convertor . UserConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMsQueryServiceImpl implements UserMsQueryService { @ Autowired private UserRepository userRepository ; @ Autowired private UserConvertor userConvertor ; @ Override public UserProfile findByUserId ( Long userId ) { UserEntity userEntity = userRepository . find ( userId ) ;", "output": "return userConvertor . toDto ( userEntity ) ; } }"}, {"input": "package org . springblade . entity ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class SendPhoneParam implements Serializable { private String phone ; private String content ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import com . alibaba . excel . annotation . ExcelIgnore ; import com . alibaba . excel . annotation . ExcelProperty ; import com . alibaba . excel . annotation . write . style . ColumnWidth ; import lombok . Data ; @ Data public class RecoverContactVO { @ ExcelIgnore private Integer docId ; @ ExcelProperty ( \"<STR_LIT>\" ) @ ColumnWidth ( <NUM_LIT> ) private String alias ; @ ExcelProperty ( \"<STR_LIT>\" ) @ ColumnWidth ( <NUM_LIT> ) private String nickname ; @ ExcelProperty ( \"<STR_LIT>\" ) @ ColumnWidth ( <NUM_LIT> ) private String remark ;", "output": "}"}, {"input": "package com . oddfar . campus . common . domain . model ; import com . oddfar . campus . common . domain . entity . SysRoleResourceEntity ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ AllArgsConstructor @ NoArgsConstructor public class SysRoleAuth { Long roleID ; String perms ; String resourceCode ;", "output": "public SysRoleAuth ( SysRoleResourceEntity roleResourceEntity ) { this . roleID = roleResourceEntity . getRoleId ( ) ; this . resourceCode = roleResourceEntity . getResourceCode ( ) ; } }"}, {"input": "package org . springblade . config . service . impl ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . util . ColumnMeta ; import org . springblade . config . util . ConvertUtils ; public class SqlServerTableHandle implements DbTableHandleI { public SqlServerTableHandle ( ) { } public String getAddColumnSql ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + this . getSql ( columnMeta ) + \"<STR_LIT>\" ; } public String getReNameFieldName ( ColumnMeta columnMeta ) { return \"<STR_LIT>\" + columnMeta . getTableName ( ) + \"<STR_LIT>\" + columnMeta . getOldColumnName ( ) + \"<STR_LIT>\" + columnMeta . getColumnName ( ) + \"<STR_LIT>\" ; } public String getUpdateColumnSql ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return \"<STR_LIT>\" + this . getSql ( cgformcolumnMeta , datacolumnMeta ) + \"<STR_LIT>\" ; } public String getMatchClassTypeByDataType ( String dataType , int digits ) { String var3 = \"<STR_LIT>\" ; if ( ! dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && ! dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } else if ( ! dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) && ! dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { if ( dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) || dataType . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var3 = \"<STR_LIT>\" ; } } else { var3 = \"<STR_LIT>\" ; } } else { var3 = \"<STR_LIT>\" ; } return var3 ; } public String dropTableSQL ( String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ; } public String getDropColumnSql ( String fieldName ) { return \"<STR_LIT>\" + fieldName + \"<STR_LIT>\" ; } private String getSql ( ColumnMeta var1 , ColumnMeta var2 ) { String sql = \"<STR_LIT>\" ;", "output": "if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } return sql ; } private String getSql ( ColumnMeta var1 ) { String sql = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + var1 . getDecimalDigits ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { sql = var1 . getColumnName ( ) + \"<STR_LIT>\" ; } return sql ; } private String b ( ColumnMeta var1 ) { String var2 = \"<STR_LIT>\" ; if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + var1 . getColumnSize ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } else if ( var1 . getColunmType ( ) . equalsIgnoreCase ( \"<STR_LIT>\" ) ) { var2 = var1 . getColumnName ( ) + \"<STR_LIT>\" + ( \"<STR_LIT>\" . equals ( var1 . getIsNullable ( ) ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; } return var2 ; } public String getCommentSql ( ColumnMeta columnMeta ) { StringBuffer var2 = new StringBuffer ( \"<STR_LIT>\" ) ; if ( ConvertUtils . isEmpty ( columnMeta . getOldColumnName ( ) ) ) { var2 . append ( \"<STR_LIT>\" ) ; } else { var2 . append ( \"<STR_LIT>\" ) ; } var2 . append ( \"<STR_LIT>\" ) ; var2 . append ( columnMeta . getComment ( ) ) ; var2 . append ( \"<STR_LIT>\" ) ; var2 . append ( columnMeta . getTableName ( ) ) ; var2 . append ( \"<STR_LIT>\" ) ; var2 . append ( columnMeta . getColumnName ( ) + \"<STR_LIT>\" ) ; return var2 . toString ( ) ; } public String getSpecialHandle ( ColumnMeta cgformcolumnMeta , ColumnMeta datacolumnMeta ) { return null ; } public String dropIndexs ( String indexName , String tableName ) { return \"<STR_LIT>\" + indexName + \"<STR_LIT>\" + tableName ; } public String countIndex ( String indexName , String tableName ) { return \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + indexName + \"<STR_LIT>\" ; } }"}, {"input": "package com . xcs . wx . repository . impl ; import cn . hutool . core . collection . CollUtil ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . FTSRecentUsed ; import com . xcs . wx . mapper . FTSRecentUsedMapper ; import com . xcs . wx . repository . FTSRecentUsedRepository ; import org . springframework . stereotype . Repository ; import java . util . Collections ; import java . util . List ; import java . util . stream . Collectors ; @ Repository @ DS ( value = DataSourceType . FTS_CONTACT_DB ) public class FTSRecentUsedRepositoryImpl extends ServiceImpl < FTSRecentUsedMapper , FTSRecentUsed > implements FTSRecentUsedRepository { @ Override public List < String > queryRecentUsedKeyWord ( ) { LambdaQueryWrapper < FTSRecentUsed > wrapper = Wrappers . < FTSRecentUsed > lambdaQuery ( ) . select ( FTSRecentUsed :: getQueryText ) ; List < FTSRecentUsed > keyWords = super . list ( wrapper ) ; if ( CollUtil . isEmpty ( keyWords ) ) { return Collections . emptyList ( ) ;", "output": "} return keyWords . stream ( ) . map ( FTSRecentUsed :: getQueryText ) . collect ( Collectors . toList ( ) ) ; } }"}, {"input": "package com . oddfar . campus . framework . web . service ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . exception . user . UserPasswordNotMatchException ; import com . oddfar . campus . common . exception . user . UserPasswordRetryLimitExceedException ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . framework . security . context . AuthenticationContextHolder ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . security . core . Authentication ; import org . springframework . stereotype . Component ; import java . util . concurrent . TimeUnit ; @ Component public class SysPasswordService { @ Autowired private RedisCache redisCache ; @ Value ( value = \"<STR_LIT>\" ) private int maxRetryCount ; @ Value ( value = \"<STR_LIT>\" ) private int lockTime ; private String getCacheKey ( String username ) { return CacheConstants . PWD_ERR_CNT_KEY + username ; } public void validate ( SysUserEntity user ) { Authentication usernamePasswordAuthenticationToken = AuthenticationContextHolder . getContext ( ) ; String username = usernamePasswordAuthenticationToken . getName ( ) ; String password = usernamePasswordAuthenticationToken . getCredentials ( ) . toString ( ) ; Integer retryCount = redisCache . getCacheObject ( getCacheKey ( username ) ) ; if ( retryCount == null ) { retryCount = <NUM_LIT> ; } if ( retryCount >= Integer . valueOf ( maxRetryCount ) . intValue ( ) ) { throw new UserPasswordRetryLimitExceedException ( maxRetryCount , lockTime ) ; } if ( ! matches ( user , password ) ) { retryCount = retryCount + <NUM_LIT> ; redisCache . setCacheObject ( getCacheKey ( username ) , retryCount , lockTime , TimeUnit . MINUTES ) ; throw new UserPasswordNotMatchException ( ) ; } else { clearLoginRecordCache ( username ) ; } } public boolean matches ( SysUserEntity user , String rawPassword ) { return SecurityUtils . matchesPassword ( rawPassword , user . getPassword ( ) ) ; }", "output": "public void clearLoginRecordCache ( String loginName ) { if ( redisCache . hasKey ( getCacheKey ( loginName ) ) ) { redisCache . deleteObject ( getCacheKey ( loginName ) ) ; } } }"}, {"input": "package com . oddfar . campus . framework . manager ; import com . oddfar . campus . common . utils . SpringUtils ; import com . oddfar . campus . common . utils . Threads ; import java . util . TimerTask ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; public class AsyncManager { private final int OPERATE_DELAY_TIME = <NUM_LIT> ; private ScheduledExecutorService executor = SpringUtils . getBean ( \"<STR_LIT>\" ) ; private AsyncManager ( ) { } private static AsyncManager me = new AsyncManager ( ) ; public static AsyncManager me ( ) { return me ; }", "output": "public void execute ( TimerTask task ) { executor . schedule ( task , OPERATE_DELAY_TIME , TimeUnit . MILLISECONDS ) ; } public void shutdown ( ) { Threads . shutdownAndAwaitTermination ( executor ) ; } }"}, {"input": "package me . zhengjie . modules . mnt . websocket ; import com . alibaba . fastjson . JSON ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Component ; import javax . websocket . * ; import javax . websocket . server . PathParam ; import javax . websocket . server . ServerEndpoint ; import java . io . IOException ; import java . util . Objects ; import java . util . concurrent . CopyOnWriteArraySet ; @ ServerEndpoint ( \"<STR_LIT>\" ) @ Slf4j @ Component public class WebSocketServer { private static final CopyOnWriteArraySet < WebSocketServer > webSocketSet = new CopyOnWriteArraySet < WebSocketServer > ( ) ; private Session session ; private String sid = \"<STR_LIT>\" ; @ OnOpen public void onOpen ( Session session , @ PathParam ( \"<STR_LIT>\" ) String sid ) { this . session = session ; webSocketSet . removeIf ( webSocket -> webSocket . sid . equals ( sid ) ) ; webSocketSet . add ( this ) ; this . sid = sid ; } @ OnClose public void onClose ( ) { webSocketSet . remove ( this ) ; } @ OnMessage public void onMessage ( String message , Session session ) { log . info ( \"<STR_LIT>\" + sid + \"<STR_LIT>\" + message ) ; for ( WebSocketServer item : webSocketSet ) { try { item . sendMessage ( message ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } } @ OnError public void onError ( Session session , Throwable error ) { log . error ( \"<STR_LIT>\" ) ; error . printStackTrace ( ) ; } private void sendMessage ( String message ) throws IOException { this . session . getBasicRemote ( ) . sendText ( message ) ; } public static void sendInfo ( SocketMsg socketMsg , @ PathParam ( \"<STR_LIT>\" ) String sid ) throws IOException { String message = JSON . toJSONString ( socketMsg ) ; log . info ( \"<STR_LIT>\" + sid + \"<STR_LIT>\" + message ) ; for ( WebSocketServer item : webSocketSet ) { try { if ( sid == null ) { item . sendMessage ( message ) ; } else if ( item . sid . equals ( sid ) ) { item . sendMessage ( message ) ; } } catch ( IOException ignored ) { } }", "output": "} @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } WebSocketServer that = ( WebSocketServer ) o ; return Objects . equals ( session , that . session ) && Objects . equals ( sid , that . sid ) ; } @ Override public int hashCode ( ) { return Objects . hash ( session , sid ) ; } }"}, {"input": "package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) public class AlipayConfig implements Serializable { @ TableId ( \"<STR_LIT>\" ) private Long id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String appId ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String privateKey ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String publicKey ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String signType = \"<STR_LIT>\" ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String gatewayUrl = \"<STR_LIT>\" ; @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String charset = \"<STR_LIT>\" ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String notifyUrl ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String returnUrl ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String format = \"<STR_LIT>\" ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String sysServiceProviderId ;", "output": "}"}, {"input": "package org . example . dddworkspace . application . service . impl ; import org . example . dddworkspace . application . dto . command . WorkspaceCreateCommand ; import org . example . dddworkspace . application . dto . result . WorkspaceResult ; import org . example . dddworkspace . application . service . WorkspaceMsCommandService ; import org . example . dddworkspace . domain . workspace . WorkspaceEntity ; import org . example . dddworkspace . infrastructure . convertor . WorkspaceConvertor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ Transactional public class WorkspaceMsCommandServiceImpl implements WorkspaceMsCommandService { @ Autowired private WorkspaceConvertor workspaceConvertor ; @ Override public WorkspaceResult create ( WorkspaceCreateCommand command ) { WorkspaceEntity workspace = WorkspaceEntity . create ( command . getOwner ( ) ) ; return workspaceConvertor . toDto ( workspace ) ; }", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class DepositWithdrawalLogParam extends Query { @ ApiModelProperty ( \"<STR_LIT>\" ) private String id ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String coinId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String type ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class PluginGroup extends Model < PluginGroup > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; private String title ; private Boolean single ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . node ; import cn . hutool . core . exceptions . ExceptionUtil ; import cn . hutool . json . JSONConfig ; import cn . hutool . json . JSONUtil ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . executor . node . event . OutputEventPublisher ; import top . kangert . kspider . io . SpiderResponse ; import top . kangert . kspider . listener . SpiderListener ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . model . SpiderOutput ; import top . kangert . kspider . support . ExpressionEngine ; import top . kangert . kspider . websocket . WebSocketEvent ; import lombok . Getter ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . csv . CSVPrinter ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; import java . io . IOException ; import java . util . * ; @ Component @ Slf4j public class OutputExecutor implements NodeExecutor , SpiderListener { String OUTPUT_OTHERS = \"<STR_LIT>\" ; String OUTPUT_NAME = \"<STR_LIT>\" ; String OUTPUT_VALUE = \"<STR_LIT>\" ; @ Resource private ExpressionEngine expressionEngine ; @ Resource private OutputEventPublisher outputEventPublisher ; @ Getter private static Map < String , CSVPrinter > cachePrinter = new HashMap < > ( ) ; @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { SpiderOutput output = new SpiderOutput ( ) ; output . setNodeName ( node . getNodeName ( ) ) ; output . setNodeId ( node . getNodeId ( ) ) ; boolean outputOthers = Constants . YES . equals ( node . getJsonProperty ( OUTPUT_OTHERS ) ) ; if ( outputOthers ) { this . outputOtherVariables ( output , variables ) ; } List < SpiderOutput . OutputItem > outputItems = this . getOutputItems ( variables , context , node ) ; outputEventPublisher . publish ( context , node , outputItems ) ; output . getOutputItems ( ) . addAll ( outputItems ) ; context . addOutput ( output ) ; } private List < SpiderOutput . OutputItem > getOutputItems ( Map < String , Object > variables , SpiderContext context , SpiderNode node ) { List < SpiderOutput . OutputItem > outputItems = new ArrayList < > ( ) ; List < Map < String , String > > items = node . getJsonArrayProperty ( OUTPUT_NAME , OUTPUT_VALUE ) ; for ( Map < String , String > item : items ) { Object value = null ; String itemName = item . get ( OUTPUT_NAME ) ; String itemValue = item . get ( OUTPUT_VALUE ) ; try { value = expressionEngine . execute ( itemValue , variables ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , itemName , value ) ;", "output": "log . debug ( \"<STR_LIT>\" , itemName , value ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , itemName , e ) ; } outputItems . add ( new SpiderOutput . OutputItem ( itemName , value ) ) ; } return outputItems ; } private void outputOtherVariables ( SpiderOutput output , Map < String , Object > variables ) { for ( Map . Entry < String , Object > item : variables . entrySet ( ) ) { Object value = item . getValue ( ) ; if ( value instanceof SpiderResponse ) { SpiderResponse resp = ( SpiderResponse ) value ; output . addItem ( item . getKey ( ) + \"<STR_LIT>\" , resp . getHtml ( ) ) ; continue ; } if ( Constants . EXCEPTION_VARIABLE . equals ( item . getKey ( ) ) ) { continue ; } try { JSONUtil . toJsonStr ( value , JSONConfig . create ( ) ) ; } catch ( Exception e ) { continue ; } output . addItem ( item . getKey ( ) , item . getValue ( ) ) ; } } @ Override public void beforeStart ( SpiderContext context ) { } @ Override public void afterEnd ( SpiderContext context ) { String key = context . getId ( ) ; this . releasePrinter ( key ) ; } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { return new Shape ( supportType ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } private void releasePrinter ( String key ) { log . debug ( \"<STR_LIT>\" , key ) ; for ( Iterator < Map . Entry < String , CSVPrinter > > iterator = cachePrinter . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , CSVPrinter > entry = iterator . next ( ) ; CSVPrinter printer = entry . getValue ( ) ; if ( entry . getKey ( ) . contains ( key ) ) { if ( printer != null ) { try { printer . flush ( ) ; printer . close ( ) ; iterator . remove ( ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , e ) ; ExceptionUtil . wrapAndThrow ( e ) ; } } } } } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class CancelExchangeParam implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > idList ;", "output": "}"}, {"input": "package com . youlai . system . common . result ; import lombok . AllArgsConstructor ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ AllArgsConstructor @ NoArgsConstructor public enum ResultCode implements IResultCode , Serializable { SUCCESS ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , REPEAT_SUBMIT_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_LOGIN_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_NOT_EXIST ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_ACCOUNT_LOCKED ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_ACCOUNT_INVALID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USERNAME_OR_PASSWORD_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , PASSWORD_ENTER_EXCEED_LIMIT ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , CLIENT_AUTHENTICATION_FAILED ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , VERIFY_CODE_TIMEOUT ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , VERIFY_CODE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , TOKEN_INVALID ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , TOKEN_ACCESS_FORBIDDEN ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , AUTHORIZED_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , ACCESS_UNAUTHORIZED ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , FORBIDDEN_OPERATION ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , PARAM_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , RESOURCE_NOT_FOUND ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , PARAM_IS_NULL ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_UPLOAD_FILE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_UPLOAD_FILE_TYPE_NOT_MATCH ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_UPLOAD_FILE_SIZE_EXCEEDS ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_UPLOAD_IMAGE_SIZE_EXCEEDS ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_EXECUTION_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_EXECUTION_TIMEOUT ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_ORDER_PROCESSING_TIMEOUT ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_DISASTER_RECOVERY_TRIGGER ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , FLOW_LIMITING ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DEGRADATION ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_RESOURCE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_RESOURCE_EXHAUSTION ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_RESOURCE_ACCESS_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYSTEM_READ_DISK_FILE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , CALL_THIRD_PARTY_SERVICE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , MIDDLEWARE_SERVICE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , INTERFACE_NOT_EXIST ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , MESSAGE_SERVICE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , MESSAGE_DELIVERY_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , MESSAGE_CONSUMPTION_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , MESSAGE_SUBSCRIPTION_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , MESSAGE_GROUP_NOT_FOUND ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATABASE_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATABASE_TABLE_NOT_EXIST ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATABASE_COLUMN_NOT_EXIST ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATABASE_DUPLICATE_COLUMN_NAME ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATABASE_DEADLOCK ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATABASE_PRIMARY_KEY_CONFLICT ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "@ Override public String getCode ( ) { return code ; } @ Override public String getMsg ( ) { return msg ; } private String code ; private String msg ; @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + code + '<STR_LIT>' + \"<STR_LIT>\" + msg + '<STR_LIT>' + '<STR_LIT>' ; } public static ResultCode getValue ( String code ) { for ( ResultCode value : values ( ) ) { if ( value . getCode ( ) . equals ( code ) ) { return value ; } } return SYSTEM_EXECUTION_ERROR ; } }"}, {"input": "package org . springblade . cgform . model . query ; import java . io . Serializable ; public class QueryCondition implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String field ; private String type ; private String rule ; private String val ; public String getField ( ) { return field ; } public void setField ( String field ) { this . field = field ;", "output": "} public String getType ( ) { return type ; } public void setType ( String type ) { this . type = type ; } public String getRule ( ) { return rule ; } public void setRule ( String rule ) { this . rule = rule ; } public String getVal ( ) { return val ; } public void setVal ( String val ) { this . val = val ; } @ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; if ( field == null || \"<STR_LIT>\" . equals ( field ) ) { return \"<STR_LIT>\" ; } sb . append ( this . field ) . append ( \"<STR_LIT>\" ) . append ( this . rule ) . append ( \"<STR_LIT>\" ) . append ( this . type ) . append ( \"<STR_LIT>\" ) . append ( this . val ) ; return sb . toString ( ) ; } }"}, {"input": "package me . zhengjie ; import org . junit . jupiter . api . Test ; import org . springframework . boot . test . context . SpringBootTest ; @ SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) public class EladminSystemApplicationTests { @ Test public void contextLoads ( ) { }", "output": "public static void main ( String [ ] args ) { } }"}, {"input": "package com . xcs . wx . repository ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . xcs . wx . domain . ChatRoom ; import com . xcs . wx . domain . dto . ChatRoomDTO ; import com . xcs . wx . domain . vo . ChatRoomVO ; import com . xcs . wx . domain . vo . ExportChatRoomVO ; import java . util . List ; public interface ChatRoomRepository { Page < ChatRoomVO > queryChatRoom ( ChatRoomDTO chatRoomDTO ) ; ChatRoom queryChatRoomDetail ( String chatRoomName ) ; int countChatRoom ( ) ;", "output": "List < ExportChatRoomVO > exportChatRoom ( ) ; }"}, {"input": "package me . zhengjie . modules . mnt . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface DatabaseService extends IService < Database > { PageResult < Database > queryAll ( DatabaseQueryCriteria criteria , Page < Object > page ) ; List < Database > queryAll ( DatabaseQueryCriteria criteria ) ;", "output": "void create ( Database resources ) ; void update ( Database resources ) ; void delete ( Set < String > ids ) ; boolean testConnection ( Database resources ) ; void download ( List < Database > queryAll , HttpServletResponse response ) throws IOException ; }"}, {"input": "package top . kangert . kspider . model ; import lombok . AllArgsConstructor ; import lombok . Data ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import cn . hutool . core . convert . Convert ; import cn . hutool . json . JSONUtil ; @ Data @ AllArgsConstructor public class ConfigItem { private String labelName = \"<STR_LIT>\" ; private ComponentType componentType = ComponentType . EL_INPUT ; public DataType dataType = DataType . STRING ; private String propName = \"<STR_LIT>\" ; private String placeholder = \"<STR_LIT>\" ; private Object value ; private Map < String , Object > attributes = new HashMap < String , Object > ( ) ; private List < SelectItem > childrenItem = Collections . emptyList ( ) ; private Boolean required = false ; public ConfigItem ( String labelName , ComponentType componentType , DataType dataType , String propName , String placeholder , Object value , Map < String , Object > attributes , List < SelectItem > childrenItem ) { this . labelName = labelName ; this . componentType = componentType ; this . dataType = dataType ; this . propName = propName ; this . placeholder = placeholder ; this . value = value ; this . attributes = attributes ; this . childrenItem = childrenItem ; } @ Override public String toString ( ) { Map < String , Object > data = new HashMap < > ( ) ; data . put ( \"<STR_LIT>\" , this . labelName ) ; data . put ( \"<STR_LIT>\" , this . componentType . toString ( ) ) ; data . put ( \"<STR_LIT>\" , this . propName ) ; data . put ( \"<STR_LIT>\" , transform ( this . value , this . dataType ) ) ; data . put ( \"<STR_LIT>\" , this . attributes ) ; data . put ( \"<STR_LIT>\" , this . childrenItem . toString ( ) ) ; return JSONUtil . parseObj ( data ) . toString ( ) ; } @ Data @ AllArgsConstructor public static class SelectItem { private String labelName = \"<STR_LIT>\" ; public Object value = null ; public DataType dataType = DataType . INT ; @ Override public String toString ( ) { Map < String , Object > data = new HashMap < > ( ) ; data . put ( \"<STR_LIT>\" , this . labelName ) ; data . put ( \"<STR_LIT>\" , transform ( this . value , this . dataType ) ) ; return JSONUtil . parseObj ( data ) . toString ( ) ; } } public enum ComponentType { EL_SELECT ( \"<STR_LIT>\" ) , EL_MULT_SELECT ( \"<STR_LIT>\" ) , EL_SWITCH ( \"<STR_LIT>\" ) , EL_INPUT ( \"<STR_LIT>\" ) , CUSTOM_MULT_KEY_VALUE ( \"<STR_LIT>\" ) , CUSTOM_MULT_VALUE ( \"<STR_LIT>\" ) , EL_NUMBER_INPUT ( \"<STR_LIT>\" ) ; private String name = \"<STR_LIT>\" ; ComponentType ( String name ) { this . name = name ; } @ Override public String toString ( ) {", "output": "return this . name ; } } public enum DataType { STRING ( \"<STR_LIT>\" ) , DOUBLE ( \"<STR_LIT>\" ) , INT ( \"<STR_LIT>\" ) , LIST_STRING ( \"<STR_LIT>\" ) , LIST_DOUBLE ( \"<STR_LIT>\" ) , LIST_INT ( \"<STR_LIT>\" ) , LIST_MAP ( \"<STR_LIT>\" ) , BOOLEAN ( \"<STR_LIT>\" ) ; private String name ; DataType ( String name ) { this . name = name ; } @ Override public String toString ( ) { return this . name ; } } public static Object transform ( Object str , DataType dataType ) { Object tempVal = null ; switch ( dataType ) { case STRING : tempVal = str ; break ; case DOUBLE : tempVal = Convert . toDouble ( str ) ; break ; case INT : tempVal = Convert . toInt ( str ) ; break ; case LIST_STRING : tempVal = Convert . toList ( String . class , str ) ; break ; case LIST_DOUBLE : break ; case LIST_INT : break ; case LIST_MAP : tempVal = Convert . toList ( Map . class , str ) ; break ; case BOOLEAN : tempVal = Convert . toBool ( str ) ; break ; default : break ; } return tempVal ; } public static Object transform ( Object str , String dataType ) { DataType tempDatType = DataType . valueOf ( dataType ) ; Object transform = transform ( str , tempDatType ) ; return transform ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . ExamGrade ; import cn . org . alan . exam . model . vo . stat . AllStatsVO ; import cn . org . alan . exam . model . vo . stat . DailyVO ; import cn . org . alan . exam . model . vo . stat . GradeExamVO ; import cn . org . alan . exam . model . vo . stat . GradeStudentVO ; import com . baomidou . mybatisplus . extension . service . IService ; import java . util . List ; public interface IStatService extends IService < ExamGrade > {", "output": "Result < List < GradeStudentVO > > getStudentGradeCount ( ) ; Result < List < GradeExamVO > > getExamGradeCount ( ) ; Result < AllStatsVO > getAllCount ( ) ; Result < List < DailyVO > > getDaily ( ) ; }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . TableInfoHelper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . ContactLabel ; import com . xcs . wx . mapper . ContactLabelMapper ; import com . xcs . wx . repository . ContactLabelRepository ; import com . xcs . wx . repository . SqliteMasterRepository ; import lombok . RequiredArgsConstructor ; import org . springframework . stereotype . Repository ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Optional ; import java . util . stream . Collectors ; @ Repository @ RequiredArgsConstructor @ DS ( value = DataSourceType . MICRO_MSG_DB ) public class ContactLabelRepositoryImpl extends ServiceImpl < ContactLabelMapper , ContactLabel > implements ContactLabelRepository { private final SqliteMasterRepository sqliteMasterRepository ; @ Override public Map < String , String > queryContactLabelAsMap ( ) { return Optional . ofNullable ( queryContactLabelAsList ( ) ) . map ( headImgUrls -> headImgUrls . stream ( ) . collect ( Collectors . toMap ( ContactLabel :: getLabelId , ContactLabel :: getLabelName ) ) ) . orElse ( Collections . emptyMap ( ) ) ; } @ Override public List < ContactLabel > queryContactLabelAsList ( ) { String contactLabelTableName = TableInfoHelper . getTableInfo ( ContactLabel . class ) . getTableName ( ) ; if ( ! sqliteMasterRepository . isTableExists ( contactLabelTableName ) ) { return Collections . emptyList ( ) ;", "output": "} LambdaQueryWrapper < ContactLabel > wrapper = Wrappers . < ContactLabel > lambdaQuery ( ) . select ( ContactLabel :: getLabelId , ContactLabel :: getLabelName ) ; return super . list ( wrapper ) ; } }"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class ScopedSlots { private String customRender ; public ScopedSlots ( String customRender ) { this . customRender = customRender ; }", "output": "}"}, {"input": "package top . kangert . kspider . domain . dto ; import com . fasterxml . jackson . annotation . JsonProperty ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; import javax . validation . constraints . NotBlank ; import java . util . Date ; @ Getter @ Setter @ ToString public class DataSourceDTO { private Long id ; @ NotBlank ( message = \"<STR_LIT>\" , groups = Save . class ) private String name ; @ NotBlank ( message = \"<STR_LIT>\" , groups = { Test . class , Save . class } ) private String driverClassName ; @ NotBlank ( message = \"<STR_LIT>\" , groups = { Test . class , Save . class } ) private String jdbcUrl ; private String username ; @ JsonProperty ( access = JsonProperty . Access . WRITE_ONLY ) private String password ; private Date createTime ;", "output": "public interface Test { } public interface Save { } }"}, {"input": "package org . springblade . web . config . engine . contract ; import lombok . Data ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . core . tool . utils . Func ; import org . springblade . web . model . ForceModelContractAll ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class CoinMatchContractAll { private Map < String , ForceModelContractAll > forceMap ; private boolean isTriggerComplete = true ; private boolean isSelfPriceTriggerComplete = true ; public CoinMatchContractAll ( ) {", "output": "this . forceMap = new HashMap < > ( ) ; } public void init ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { this . addAllForceContrct ( baseSqlService ) ; } } public void resetAll ( IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } } public ForceModelContractAll reset ( String memberId , IMjkjBaseSqlService baseSqlService ) { synchronized ( this ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isNotEmpty ( model ) ) { forceMap . put ( memberId , model ) ; } return model ; } } private void addAllForceContrct ( IMjkjBaseSqlService baseSqlService ) { List < String > memberIdList = baseSqlService . getAllContractMemberId ( ) ; if ( Func . isEmpty ( memberIdList ) ) { return ; } for ( String memberId : memberIdList ) { ForceModelContractAll model = this . getForceModelAll ( memberId , baseSqlService ) ; if ( Func . isEmpty ( model ) ) { continue ; } forceMap . put ( memberId , model ) ; } } private ForceModelContractAll getForceModelAll ( String memberId , IMjkjBaseSqlService baseSqlService ) { List < String > symbolNameList = baseSqlService . getMyAllContractSymbolName ( memberId ) ; if ( Func . isEmpty ( symbolNameList ) ) { forceMap . remove ( memberId ) ; return null ; } ForceModelContractAll model = new ForceModelContractAll ( ) ; model . setMemberId ( memberId ) ; model . setContractLogSymbolNameList ( symbolNameList ) ; return model ; } }"}, {"input": "package top . kangert . kspider . dao ; import org . springframework . data . jpa . repository . JpaRepository ; import org . springframework . data . jpa . repository . JpaSpecificationExecutor ; import top . kangert . kspider . domain . Function ; public interface FunctionRepository extends JpaRepository < Function , Long > , JpaSpecificationExecutor < Function > {", "output": "Function findFunctionByFuncId ( Long id ) ; }"}, {"input": "package ginyi . framework . core . config ; import lombok . Data ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Component public class GinyiConfig { @ Value ( \"<STR_LIT>\" ) public static String profile ; public static String getImportPath ( ) { return profile + \"<STR_LIT>\" ; } public static String getAvatarPath ( ) {", "output": "return profile + \"<STR_LIT>\" ; } public static String getDownloadPath ( ) { return profile + \"<STR_LIT>\" ; } public static String getUploadPath ( ) { return profile + \"<STR_LIT>\" ; } }"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . RandomUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; @ Component public class RandomFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) {", "output": "return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static int randomInt ( int min , int max ) { return RandomUtil . randomInt ( min , max ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static double randomDouble ( double min , double max ) { return RandomUtil . randomDouble ( min , max ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static long randomLong ( long min , long max ) { return RandomUtil . randomLong ( min , max ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String string ( String chars , int length ) { if ( chars != null ) { char [ ] newChars = new char [ length ] ; int len = chars . length ( ) ; for ( int i = <NUM_LIT> ; i < length ; i ++ ) { newChars [ i ] = chars . charAt ( randomInt ( <NUM_LIT> , len ) ) ; } return new String ( newChars ) ; } return null ; } }"}, {"input": "package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . QiniuConfig ; public interface QiNiuConfigService extends IService < QiniuConfig > { QiniuConfig getConfig ( ) ;", "output": "void saveConfig ( QiniuConfig type ) ; void updateType ( String type ) ; }"}, {"input": "package com . youlai . system . config ; import cn . hutool . core . util . StrUtil ; import cn . hutool . jwt . JWTPayload ; import cn . hutool . jwt . JWTUtil ; import com . youlai . system . common . constant . SecurityConstants ; import lombok . extern . slf4j . Slf4j ; import org . springframework . context . annotation . Configuration ; import org . springframework . http . HttpHeaders ; import org . springframework . messaging . Message ; import org . springframework . messaging . MessageChannel ; import org . springframework . messaging . simp . config . ChannelRegistration ; import org . springframework . messaging . simp . config . MessageBrokerRegistry ; import org . springframework . messaging . simp . stomp . StompCommand ; import org . springframework . messaging . simp . stomp . StompHeaderAccessor ; import org . springframework . messaging . support . ChannelInterceptor ; import org . springframework . messaging . support . MessageHeaderAccessor ; import org . springframework . web . socket . config . annotation . EnableWebSocketMessageBroker ; import org . springframework . web . socket . config . annotation . StompEndpointRegistry ; import org . springframework . web . socket . config . annotation . WebSocketMessageBrokerConfigurer ; @ EnableWebSocketMessageBroker @ Configuration @ Slf4j public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @ Override public void registerStompEndpoints ( StompEndpointRegistry registry ) { registry . addEndpoint ( \"<STR_LIT>\" ) . setAllowedOriginPatterns ( \"<STR_LIT>\" ) . withSockJS ( ) ;", "output": "registry . addEndpoint ( \"<STR_LIT>\" ) . setAllowedOriginPatterns ( \"<STR_LIT>\" ) ; } @ Override public void configureMessageBroker ( MessageBrokerRegistry registry ) { registry . setApplicationDestinationPrefixes ( \"<STR_LIT>\" ) ; registry . enableSimpleBroker ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; registry . setUserDestinationPrefix ( \"<STR_LIT>\" ) ; } @ Override public void configureClientInboundChannel ( ChannelRegistration registration ) { registration . interceptors ( new ChannelInterceptor ( ) { @ Override public Message < ? > preSend ( Message < ? > message , MessageChannel channel ) { StompHeaderAccessor accessor = MessageHeaderAccessor . getAccessor ( message , StompHeaderAccessor . class ) ; if ( accessor != null && StompCommand . CONNECT . equals ( accessor . getCommand ( ) ) ) { String bearerToken = accessor . getFirstNativeHeader ( HttpHeaders . AUTHORIZATION ) ; if ( StrUtil . isNotBlank ( bearerToken ) && bearerToken . startsWith ( \"<STR_LIT>\" ) ) { try { bearerToken = bearerToken . substring ( SecurityConstants . JWT_TOKEN_PREFIX . length ( ) ) ; String username = JWTUtil . parseToken ( bearerToken ) . getPayloads ( ) . getStr ( JWTPayload . SUBJECT ) ; if ( StrUtil . isNotBlank ( username ) ) { accessor . setUser ( ( ) -> username ) ; return message ; } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e ) ; } } } return ChannelInterceptor . super . preSend ( message , channel ) ; } } ) ; } }"}, {"input": "package ginyi . server . web . swagger ; import ginyi . common . swagger . Swagger2Config ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; @ EnableSwagger2 @ Configuration public class WebSwagger2Config extends Swagger2Config {", "output": "}"}, {"input": "package me . zhengjie . utils ; import cn . hutool . core . util . StrUtil ; import cn . hutool . extra . template . * ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . domain . ColumnInfo ; import org . springframework . util . ObjectUtils ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . Writer ; import java . time . LocalDate ; import java . util . * ; import static me . zhengjie . utils . FileUtil . SYS_TEM_DIR ; @ Slf4j @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) public class GenUtil { private static final String TIMESTAMP = \"<STR_LIT>\" ; private static final String BIGDECIMAL = \"<STR_LIT>\" ; public static final String PK = \"<STR_LIT>\" ; public static final String EXTRA = \"<STR_LIT>\" ; private static List < String > getAdminTemplateNames ( ) { List < String > templateNames = new ArrayList < > ( ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; return templateNames ; } private static List < String > getFrontTemplateNames ( ) { List < String > templateNames = new ArrayList < > ( ) ; templateNames . add ( \"<STR_LIT>\" ) ; templateNames . add ( \"<STR_LIT>\" ) ; return templateNames ; } public static List < Map < String , Object > > preview ( List < ColumnInfo > columns , GenConfig genConfig ) { Map < String , Object > genMap = getGenMap ( columns , genConfig ) ; List < Map < String , Object > > genList = new ArrayList < > ( ) ; List < String > templates = getAdminTemplateNames ( ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( \"<STR_LIT>\" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; for ( String templateName : templates ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; Template template = engine . getTemplate ( \"<STR_LIT>\" + templateName + \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , template . render ( genMap ) ) ; map . put ( \"<STR_LIT>\" , templateName . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) ; genList . add ( map ) ; } templates = getFrontTemplateNames ( ) ; for ( String templateName : templates ) { Map < String , Object > map = new HashMap < > ( <NUM_LIT> ) ; Template template = engine . getTemplate ( \"<STR_LIT>\" + templateName + \"<STR_LIT>\" ) ; map . put ( templateName , template . render ( genMap ) ) ; map . put ( \"<STR_LIT>\" , template . render ( genMap ) ) ; map . put ( \"<STR_LIT>\" , templateName ) ; genList . add ( map ) ; } return genList ; } public static String download ( List < ColumnInfo > columns , GenConfig genConfig ) throws IOException { String tempPath = SYS_TEM_DIR + \"<STR_LIT>\" + File . separator + genConfig . getTableName ( ) + File . separator ; Map < String , Object > genMap = getGenMap ( columns , genConfig ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( \"<STR_LIT>\" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; List < String > templates = getAdminTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( \"<STR_LIT>\" + templateName + \"<STR_LIT>\" ) ; String filePath = getAdminFilePath ( templateName , genConfig , genMap . get ( \"<STR_LIT>\" ) . toString ( ) , tempPath + \"<STR_LIT>\" + File . separator ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } templates = getFrontTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( \"<STR_LIT>\" + templateName + \"<STR_LIT>\" ) ; String path = tempPath + \"<STR_LIT>\" + File . separator ; String apiPath = path + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator ; String srcPath = path + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + genMap . get ( \"<STR_LIT>\" ) . toString ( ) + File . separator ; String filePath = getFrontFilePath ( templateName , apiPath , srcPath , genMap . get ( \"<STR_LIT>\" ) . toString ( ) ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } return tempPath ; } public static void generatorCode ( List < ColumnInfo > columnInfos , GenConfig genConfig ) throws IOException { Map < String , Object > genMap = getGenMap ( columnInfos , genConfig ) ; TemplateEngine engine = TemplateUtil . createEngine ( new TemplateConfig ( \"<STR_LIT>\" , TemplateConfig . ResourceMode . CLASSPATH ) ) ; List < String > templates = getAdminTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( \"<STR_LIT>\" + templateName + \"<STR_LIT>\" ) ; String rootPath = System . getProperty ( \"<STR_LIT>\" ) ; String filePath = getAdminFilePath ( templateName , genConfig , genMap . get ( \"<STR_LIT>\" ) . toString ( ) , rootPath ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } templates = getFrontTemplateNames ( ) ; for ( String templateName : templates ) { Template template = engine . getTemplate ( \"<STR_LIT>\" + templateName + \"<STR_LIT>\" ) ; String filePath = getFrontFilePath ( templateName , genConfig . getApiPath ( ) , genConfig . getPath ( ) , genMap . get ( \"<STR_LIT>\" ) . toString ( ) ) ; assert filePath != null ; File file = new File ( filePath ) ; if ( ! genConfig . getCover ( ) && FileUtil . exist ( file ) ) { continue ; } genFile ( file , template , genMap ) ; } } private static Map < String , Object > getGenMap ( List < ColumnInfo > columnInfos , GenConfig genConfig ) { Map < String , Object > genMap = new HashMap < > ( <NUM_LIT> ) ; genMap . put ( \"<STR_LIT>\" , genConfig . getApiAlias ( ) ) ; genMap . put ( \"<STR_LIT>\" , genConfig . getPack ( ) ) ; genMap . put ( \"<STR_LIT>\" , genConfig . getModuleName ( ) ) ; genMap . put ( \"<STR_LIT>\" , genConfig . getAuthor ( ) ) ; genMap . put ( \"<STR_LIT>\" , LocalDate . now ( ) . toString ( ) ) ; genMap . put ( \"<STR_LIT>\" , genConfig . getTableName ( ) ) ; String className = StringUtils . toCapitalizeCamelCase ( genConfig . getTableName ( ) ) ; String changeClassName = StringUtils . toCamelCase ( genConfig . getTableName ( ) ) ; if ( StringUtils . isNotEmpty ( genConfig . getPrefix ( ) ) ) { className = StringUtils . toCapitalizeCamelCase ( StrUtil . removePrefix ( genConfig . getTableName ( ) , genConfig . getPrefix ( ) ) ) ; changeClassName = StringUtils . toCamelCase ( StrUtil . removePrefix ( genConfig . getTableName ( ) , genConfig . getPrefix ( ) ) ) ; changeClassName = StringUtils . uncapitalize ( changeClassName ) ; } genMap . put ( \"<STR_LIT>\" , className ) ; genMap . put ( \"<STR_LIT>\" , changeClassName ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , false ) ; genMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; genMap . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; List < Map < String , Object > > columns = new ArrayList < > ( ) ; List < Map < String , Object > > queryColumns = new ArrayList < > ( ) ; List < String > dicts = new ArrayList < > ( ) ; List < Map < String , Object > > betweens = new ArrayList < > ( ) ; List < Map < String , Object > > isNotNullColumns = new ArrayList < > ( ) ; for ( ColumnInfo column : columnInfos ) { Map < String , Object > listMap = new HashMap < > ( <NUM_LIT> ) ; listMap . put ( \"<STR_LIT>\" , column . getRemark ( ) ) ; listMap . put ( \"<STR_LIT>\" , column . getKeyType ( ) ) ;", "output": "String colType = ColUtil . cloToJava ( column . getColumnType ( ) ) ; String changeColumnName = StringUtils . toCamelCase ( column . getColumnName ( ) ) ; String capitalColumnName = StringUtils . toCapitalizeCamelCase ( column . getColumnName ( ) ) ; if ( PK . equals ( column . getKeyType ( ) ) ) { genMap . put ( \"<STR_LIT>\" , colType ) ; genMap . put ( \"<STR_LIT>\" , changeColumnName ) ; genMap . put ( \"<STR_LIT>\" , capitalColumnName ) ; genMap . put ( \"<STR_LIT>\" , column . getColumnName ( ) ) ; } if ( TIMESTAMP . equals ( colType ) ) { genMap . put ( \"<STR_LIT>\" , true ) ; } if ( BIGDECIMAL . equals ( colType ) ) { genMap . put ( \"<STR_LIT>\" , true ) ; } if ( EXTRA . equals ( column . getExtra ( ) ) ) { genMap . put ( \"<STR_LIT>\" , true ) ; } if ( StringUtils . isNotBlank ( column . getDictName ( ) ) ) { genMap . put ( \"<STR_LIT>\" , true ) ; if ( ! dicts . contains ( column . getDictName ( ) ) ) dicts . add ( column . getDictName ( ) ) ; } listMap . put ( \"<STR_LIT>\" , colType ) ; listMap . put ( \"<STR_LIT>\" , column . getColumnName ( ) ) ; listMap . put ( \"<STR_LIT>\" , column . getNotNull ( ) ) ; listMap . put ( \"<STR_LIT>\" , column . getListShow ( ) ) ; listMap . put ( \"<STR_LIT>\" , column . getFormShow ( ) ) ; listMap . put ( \"<STR_LIT>\" , StringUtils . isNotBlank ( column . getFormType ( ) ) ? column . getFormType ( ) : \"<STR_LIT>\" ) ; listMap . put ( \"<STR_LIT>\" , changeColumnName ) ; listMap . put ( \"<STR_LIT>\" , capitalColumnName ) ; listMap . put ( \"<STR_LIT>\" , column . getDictName ( ) ) ; if ( column . getNotNull ( ) ) { isNotNullColumns . add ( listMap ) ; } if ( ! StringUtils . isBlank ( column . getQueryType ( ) ) ) { listMap . put ( \"<STR_LIT>\" , column . getQueryType ( ) ) ; genMap . put ( \"<STR_LIT>\" , true ) ; if ( TIMESTAMP . equals ( colType ) ) { genMap . put ( \"<STR_LIT>\" , true ) ; } if ( BIGDECIMAL . equals ( colType ) ) { genMap . put ( \"<STR_LIT>\" , true ) ; } if ( \"<STR_LIT>\" . equalsIgnoreCase ( column . getQueryType ( ) ) ) { betweens . add ( listMap ) ; } else { queryColumns . add ( listMap ) ; } } columns . add ( listMap ) ; } genMap . put ( \"<STR_LIT>\" , columns ) ; genMap . put ( \"<STR_LIT>\" , queryColumns ) ; genMap . put ( \"<STR_LIT>\" , dicts ) ; genMap . put ( \"<STR_LIT>\" , betweens ) ; genMap . put ( \"<STR_LIT>\" , isNotNullColumns ) ; return genMap ; } private static String getAdminFilePath ( String templateName , GenConfig genConfig , String className , String rootPath ) { String projectPath = rootPath + File . separator + genConfig . getModuleName ( ) ; String packagePath = projectPath + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator ; String mpXmlPath = projectPath + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator ; if ( ! ObjectUtils . isEmpty ( genConfig . getPack ( ) ) ) { packagePath += genConfig . getPack ( ) . replace ( \"<STR_LIT>\" , File . separator ) + File . separator ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return packagePath + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return packagePath + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return packagePath + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return packagePath + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return packagePath + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return packagePath + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return mpXmlPath + \"<STR_LIT>\" + File . separator + className + \"<STR_LIT>\" ; } return null ; } private static String getFrontFilePath ( String templateName , String apiPath , String path , String apiName ) { if ( \"<STR_LIT>\" . equals ( templateName ) ) { return apiPath + File . separator + apiName + \"<STR_LIT>\" ; } if ( \"<STR_LIT>\" . equals ( templateName ) ) { return path + File . separator + \"<STR_LIT>\" ; } return null ; } private static void genFile ( File file , Template template , Map < String , Object > map ) throws IOException { Writer writer = null ; try { FileUtil . touch ( file ) ; writer = new FileWriter ( file ) ; template . render ( map , writer ) ; } catch ( TemplateException | IOException e ) { throw new RuntimeException ( e ) ; } finally { assert writer != null ; writer . close ( ) ; } } }"}, {"input": "package me . zhengjie . modules . security . config . bean ; import lombok . Data ; @ Data public class SecurityProperties { private String header ; private String tokenStartWith ; private String base64Secret ; private Long tokenValidityInSeconds ; private String onlineKey ; private String codeKey ; private Long detect ; private Long renew ; public String getTokenStartWith ( ) { return tokenStartWith + \"<STR_LIT>\" ; }", "output": "}"}, {"input": "package com . yf . system . modules . plugin . dto ; import com . fasterxml . jackson . databind . annotation . JsonDeserialize ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . yf . base . api . annon . Dict ; import com . yf . base . utils . jackson . DesensitizeSerializer ; import com . yf . base . utils . jackson . RawJsonDeserializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . io . Serializable ; @ AllArgsConstructor @ NoArgsConstructor @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class PluginDataDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String code ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String title ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String schemaId ; @ Dict ( dicCode = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String groupId ; @ JsonSerialize ( using = DesensitizeSerializer . class ) @ JsonDeserialize ( using = RawJsonDeserializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String configData ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceClazz ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String component ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Boolean inUse ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String state ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . mnt . domain . Database ; import me . zhengjie . modules . mnt . service . DatabaseService ; import me . zhengjie . modules . mnt . domain . vo . DatabaseQueryCriteria ; import me . zhengjie . modules . mnt . util . SqlUtils ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . IOException ; import java . util . Set ; @ Api ( tags = \"<STR_LIT>\" ) @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class DatabaseController { private final String fileSavePath = FileUtil . getTmpDirPath ( ) + \"<STR_LIT>\" ; private final DatabaseService databaseService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportDatabase ( HttpServletResponse response , DatabaseQueryCriteria criteria ) throws IOException { databaseService . download ( databaseService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( value = \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Database > > queryDatabase ( DatabaseQueryCriteria criteria , Page < Object > page ) { return new ResponseEntity < > ( databaseService . queryAll ( criteria , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createDatabase ( @ Validated @ RequestBody Database resources ) { databaseService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ;", "output": "} @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateDatabase ( @ Validated @ RequestBody Database resources ) { databaseService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteDatabase ( @ RequestBody Set < String > ids ) { databaseService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > testConnect ( @ Validated @ RequestBody Database resources ) { return new ResponseEntity < > ( databaseService . testConnection ( resources ) , HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" ) @ PostMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > uploadDatabase ( @ RequestBody MultipartFile file , HttpServletRequest request ) throws Exception { String id = request . getParameter ( \"<STR_LIT>\" ) ; Database database = databaseService . getById ( id ) ; String fileName ; if ( database != null ) { fileName = file . getOriginalFilename ( ) ; File executeFile = new File ( fileSavePath + fileName ) ; FileUtil . del ( executeFile ) ; file . transferTo ( executeFile ) ; String result = SqlUtils . executeFile ( database . getJdbcUrl ( ) , database . getUserName ( ) , database . getPwd ( ) , executeFile ) ; return new ResponseEntity < > ( result , HttpStatus . OK ) ; } else { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package com . youlai . system . converter ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . bo . UserBO ; import com . youlai . system . model . entity . SysUser ; import com . youlai . system . model . form . UserForm ; import com . youlai . system . model . dto . UserImportDTO ; import com . youlai . system . model . vo . UserInfoVO ; import com . youlai . system . model . vo . UserPageVO ; import org . mapstruct . InheritInverseConfiguration ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . Mappings ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface UserConverter { @ Mappings ( { @ Mapping ( target = \"<STR_LIT>\" , expression = \"<STR_LIT>\" ) } ) UserPageVO toPageVo ( UserBO bo ) ; Page < UserPageVO > toPageVo ( Page < UserBO > bo ) ; UserForm toForm ( SysUser entity ) ; @ InheritInverseConfiguration ( name = \"<STR_LIT>\" ) SysUser toEntity ( UserForm entity ) ; @ Mappings ( {", "output": "@ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) } ) UserInfoVO toUserInfoVo ( SysUser entity ) ; SysUser toEntity ( UserImportDTO vo ) ; }"}, {"input": "package com . youlai . system . config ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . connection . RedisConnectionFactory ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . data . redis . serializer . RedisSerializer ; @ Configuration public class RedisConfig { @ Bean public RedisTemplate < String , Object > redisTemplate ( RedisConnectionFactory redisConnectionFactory ) { RedisTemplate < String , Object > redisTemplate = new RedisTemplate < > ( ) ; redisTemplate . setConnectionFactory ( redisConnectionFactory ) ; redisTemplate . setKeySerializer ( RedisSerializer . string ( ) ) ; redisTemplate . setValueSerializer ( RedisSerializer . json ( ) ) ;", "output": "redisTemplate . setHashKeySerializer ( RedisSerializer . string ( ) ) ; redisTemplate . setHashValueSerializer ( RedisSerializer . json ( ) ) ; redisTemplate . afterPropertiesSet ( ) ; return redisTemplate ; } }"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import com . oddfar . campus . framework . service . SysResourceService ; import com . oddfar . campus . framework . web . service . SysPermissionService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; import java . util . List ; import static com . oddfar . campus . common . utils . SecurityUtils . getUserId ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . SYSTEM ) public class SysApiResourceController { @ Autowired private SysResourceService resourceService ; @ Autowired private SysPermissionService permissionService ; @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R roleMenuTreeSelect ( @ PathVariable ( \"<STR_LIT>\" ) Long roleId ) { List < SysResourceEntity > resources = resourceService . selectApiResourceList ( getUserId ( ) ) ; R ajax = R . ok ( ) ; ajax . put ( \"<STR_LIT>\" , resourceService . selectResourceListByRoleId ( roleId ) ) ; ajax . put ( \"<STR_LIT>\" , resourceService . buildResourceTreeSelect ( resources ) ) ; return ajax ; } @ PutMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R editRoleResource ( Long roleId , Long [ ] resourceIds ) { resourceService . editRoleResource ( roleId , resourceIds ) ; permissionService . resetLoginUserRoleCache ( roleId ) ;", "output": "return R . ok ( ) ; } }"}, {"input": "package org . springblade . web . service ; import org . springblade . config . exception . BusinessException ; import org . springblade . web . model . EntrustModel ; import org . springblade . web . model . param . * ; import java . math . BigDecimal ; import java . util . List ; import java . util . Map ; public interface IWebService { String getLanguage ( String code ) ; String getLanguage ( String lang , String code ) ; void handleEntrust ( List < EntrustModel > entrustList , BigDecimal nowPrice , String symbolName ) ;", "output": "String getMemberId ( ) ; Map < String , Object > getMemberData ( ) ; Boolean accountVerificationBinding ( AccountBindingParam param ) throws BusinessException ; List < Map < String , Object > > getLoginLog ( ) ; List < Map < String , Object > > getLoginDevice ( ) ; Boolean deleteDevice ( String id ) ; Boolean updateDevice ( AccountBindingParam param ) throws BusinessException ; Boolean verified ( VerifiedParam param ) throws BusinessException ; Map < String , Object > getGoogleVerification ( String type ) ; Boolean googleVerificationBindingOrReset ( String type , String code ) throws BusinessException ; void tradePwd ( TradePwdParam param ) throws BusinessException ; void antiCode ( AntiCodeParam param ) throws BusinessException ; BigDecimal coinConversion ( String coinSymbol , BigDecimal amount ) ; void payment ( PaymentParam paymentParam ) throws BusinessException ; List < Map < String , Object > > getPayment ( ) throws BusinessException ; void auditBusiness ( Integer codeType , String code , String name , String email , String coinSymbol , String coinCou , Integer status ) ; List < Map < String , Object > > getMemeberTgInfo ( ) throws BusinessException ; List < Map < String , Object > > getMemeberTgList ( String type ) throws BusinessException ; public void validation ( Integer codeType , String code ) ; Map < String , Map < String , Object > > getCoinMap ( ) ; Map < String , Map < String , Object > > getFiatMap ( ) ; Map < String , Map < String , Object > > getPaymentMap ( ) ; String getAreaCode ( String phone ) ; void tradePwdVerification ( TradePwdVerificationParam param ) ; Boolean tradePwdVerification ( ) ; String getXhExchangeModel ( String symbolName ) ; }"}, {"input": "package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . security . service . dto . AuthorityDto ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . modules . system . domain . vo . RoleQueryCriteria ; import me . zhengjie . utils . PageResult ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; public interface RoleService extends IService < Role > { List < Role > queryAll ( ) ;", "output": "Role findById ( long id ) ; void create ( Role resources ) ; void update ( Role resources ) ; void delete ( Set < Long > ids ) ; List < Role > findByUsersId ( Long userId ) ; Integer findByRoles ( Set < Role > roles ) ; void updateMenu ( Role resources ) ; PageResult < Role > queryAll ( RoleQueryCriteria criteria , Page < Object > page ) ; List < Role > queryAll ( RoleQueryCriteria criteria ) ; void download ( List < Role > roles , HttpServletResponse response ) throws IOException ; List < AuthorityDto > mapToGrantedAuthorities ( User user ) ; void verification ( Set < Long > ids ) ; List < Role > findByMenuId ( Long menuId ) ; }"}, {"input": "package me . zhengjie . utils ; public interface CacheKey { String USER_ID = \"<STR_LIT>\" ; String DATA_USER = \"<STR_LIT>\" ; String MENU_ID = \"<STR_LIT>\" ; String MENU_USER = \"<STR_LIT>\" ; String ROLE_AUTH = \"<STR_LIT>\" ; String ROLE_ID = \"<STR_LIT>\" ; String DEPT_ID = \"<STR_LIT>\" ;", "output": "String JOB_ID = \"<STR_LIT>\" ; String DICT_NAME = \"<STR_LIT>\" ; }"}, {"input": "package com . youlai . system . model . dto ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . AllArgsConstructor ; import lombok . Builder ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Schema ( description = \"<STR_LIT>\" ) @ Builder @ Data @ AllArgsConstructor @ NoArgsConstructor public class CaptchaResult { @ Schema ( description = \"<STR_LIT>\" ) private String captchaKey ; @ Schema ( description = \"<STR_LIT>\" ) private String captchaBase64 ;", "output": "}"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . HardLinkVideoAttribute ; import org . apache . ibatis . annotations . Param ; public interface HardLinkVideoAttributeMapper extends BaseMapper < HardLinkVideoAttribute > { String queryHardLinkVideo ( @ Param ( \"<STR_LIT>\" ) byte [ ] md5 ) ;", "output": "}"}, {"input": "package com . oddfar . campus . common . exception . user ; public class CaptchaException extends UserException { private static final long serialVersionUID = <NUM_LIT> ; public CaptchaException ( ) { super ( \"<STR_LIT>\" , null ) ;", "output": "} }"}, {"input": "package ginyi . framework . security . service ; import cn . hutool . captcha . CaptchaUtil ; import cn . hutool . captcha . CircleCaptcha ; import cn . hutool . crypto . SecureUtil ; import cn . hutool . extra . servlet . ServletUtil ; import ginyi . common . constant . CacheConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . result . StateCode ; import ginyi . common . utils . Constants ; import ginyi . common . utils . StringUtils ; import ginyi . system . service . ISysConfigService ; import ginyi . system . service . IVerifyService ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . concurrent . TimeUnit ; @ Service public class SysVerifyServiceImpl implements IVerifyService { @ Resource private HttpServletRequest request ; @ Resource private RedisCache redisCache ; @ Resource private ISysConfigService configService ; @ Override public String captcha ( ) { boolean captchaEnabled = configService . selectCaptchaEnabled ( ) ; if ( ! captchaEnabled ) { return null ; } CircleCaptcha captcha = CaptchaUtil . createCircleCaptcha ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; String img = captcha . getImageBase64 ( ) ; String code = captcha . getCode ( ) ; String clientIP = ServletUtil . getClientIP ( request ) ; String userAgent = ServletUtil . getHeader ( request , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String verifyKey = CacheConstants . CAPTCHA_CODE_KEY + SecureUtil . md5 ( clientIP + userAgent ) ; redisCache . setCacheObject ( verifyKey , code , Constants . CAPTCHA_EXPIRATION , TimeUnit . MINUTES ) ; return img ; } @ Override public void checkImgCode ( String code ) { String clientIP = ServletUtil . getClientIP ( request ) ; String userAgent = ServletUtil . getHeader ( request , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String verifyKey = CacheConstants . CAPTCHA_CODE_KEY + SecureUtil . md5 ( clientIP + userAgent ) ; String captcha = redisCache . getCacheObject ( verifyKey , String . class ) ; if ( StringUtils . isNull ( code ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . SYS_CAPTCHA_NOT_EXIST ) ; } if ( captcha == null ) { throw new CommonException ( StateCode . ERROR_PARAMS_SERVICE , CommonMessageConstants . VERIFY_EXPIRE ) ; } if ( ! captcha . equalsIgnoreCase ( code ) ) { throw new CommonException ( StateCode . ERROR_PARAMS_SERVICE , CommonMessageConstants . VERiFY_INCORRECT ) ; } else { redisCache . removeCacheObject ( verifyKey ) ; }", "output": "} }"}, {"input": "package ginyi . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import ginyi . system . domain . SysPost ; import ginyi . system . domain . model . dto . PostDto ; import ginyi . system . domain . model . vo . PostVo ; import org . apache . ibatis . annotations . Param ; public interface SysPostMapper extends BaseMapper < SysPost > { public IPage < PostVo > list ( @ Param ( \"<STR_LIT>\" ) PostDto postDto , Page page ) ; public void insertPost ( @ Param ( \"<STR_LIT>\" ) PostDto postDto ) ; public void updatePost ( @ Param ( \"<STR_LIT>\" ) PostDto postDto ) ; public void updatePostStatus ( @ Param ( \"<STR_LIT>\" ) PostDto postDto ) ;", "output": "}"}, {"input": "package com . yf . base . utils . passwd ; public class PassInfo { private String salt ; private String password ; public PassInfo ( String salt , String password ) { super ( ) ; this . salt = salt ; this . password = password ; }", "output": "public String getSalt ( ) { return salt ; } public void setSalt ( String salt ) { this . salt = salt ; } public String getPassword ( ) { return password ; } public void setPassword ( String password ) { this . password = password ; } }"}, {"input": "package org . springblade . web . utils . googleauth ; import com . google . zxing . * ; import com . google . zxing . client . j2se . BufferedImageLuminanceSource ; import com . google . zxing . common . BitMatrix ; import com . google . zxing . common . HybridBinarizer ; import com . google . zxing . qrcode . decoder . ErrorCorrectionLevel ; import javax . imageio . ImageIO ; import javax . servlet . http . HttpServletResponse ; import java . awt . * ; import java . awt . geom . RoundRectangle2D ; import java . awt . image . BufferedImage ; import java . io . * ; import java . net . HttpURLConnection ; import java . net . URL ; import java . util . Hashtable ; public class QRCodeUtil { private static final String CHARSET = \"<STR_LIT>\" ; private static final String FORMAT_NAME = \"<STR_LIT>\" ; private static final int QRCODE_SIZE = <NUM_LIT> ; private static final int WIDTH = <NUM_LIT> ; private static final int HEIGHT = <NUM_LIT> ; private static BufferedImage createImage ( String content , String imgPath , boolean needCompress ) throws Exception { Hashtable < EncodeHintType , Object > hints = new Hashtable < EncodeHintType , Object > ( ) ; hints . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . H ) ; hints . put ( EncodeHintType . CHARACTER_SET , CHARSET ) ; hints . put ( EncodeHintType . MARGIN , <NUM_LIT> ) ; BitMatrix bitMatrix = new MultiFormatWriter ( ) . encode ( content , BarcodeFormat . QR_CODE , QRCODE_SIZE , QRCODE_SIZE , hints ) ; int [ ] rec = bitMatrix . getEnclosingRectangle ( ) ; if ( rec != null ) { int resWidth = rec [ <NUM_LIT> ] + <NUM_LIT> ; int resHeight = rec [ <NUM_LIT> ] + <NUM_LIT> ; BitMatrix resMatrix = new BitMatrix ( resWidth , resHeight ) ; resMatrix . clear ( ) ; for ( int i = <NUM_LIT> ; i < resWidth ; i ++ ) { for ( int j = <NUM_LIT> ; j < resHeight ; j ++ ) { if ( bitMatrix . get ( i + rec [ <NUM_LIT> ] , j + rec [ <NUM_LIT> ] ) ) { resMatrix . set ( i , j ) ; } } } } int width = bitMatrix . getWidth ( ) ; int height = bitMatrix . getHeight ( ) ; BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = <NUM_LIT> ; x < width ; x ++ ) { for ( int y = <NUM_LIT> ; y < height ; y ++ ) { image . setRGB ( x , y , bitMatrix . get ( x , y ) ? <NUM_LIT> : <NUM_LIT> ) ; } } if ( imgPath == null || \"<STR_LIT>\" . equals ( imgPath ) ) { return image ; } QRCodeUtil . insertImage ( image , imgPath , needCompress ) ; return image ; } private static void insertImage ( BufferedImage source , String imgPath , boolean needCompress ) throws Exception { URL url = new URL ( imgPath ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setRequestMethod ( \"<STR_LIT>\" ) ; conn . setConnectTimeout ( <NUM_LIT> * <NUM_LIT> ) ; InputStream inStream = conn . getInputStream ( ) ; byte [ ] data = readInputStream ( inStream ) ; File tmpFile = createTmpFile ( ) ; FileOutputStream outStream = new FileOutputStream ( tmpFile ) ; outStream . write ( data ) ; outStream . close ( ) ; Image src = ImageIO . read ( tmpFile ) ; if ( src != null ) { int width = src . getWidth ( null ) ; int height = src . getHeight ( null ) ; if ( needCompress ) { if ( width > WIDTH ) { width = WIDTH ; } if ( height > HEIGHT ) { height = HEIGHT ; } Image image = src . getScaledInstance ( width , height , Image . SCALE_SMOOTH ) ; BufferedImage tag = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = tag . getGraphics ( ) ; g . drawImage ( image , <NUM_LIT> , <NUM_LIT> , null ) ; g . dispose ( ) ; src = image ; } Graphics2D graph = source . createGraphics ( ) ; int x = ( QRCODE_SIZE - width ) / <NUM_LIT> ; int y = ( QRCODE_SIZE - height ) / <NUM_LIT> ; graph . drawImage ( src , x , y , width , height , null ) ; Shape shape = new RoundRectangle2D . Float ( x , y , width , width , <NUM_LIT> , <NUM_LIT> ) ; graph . setStroke ( new BasicStroke ( <NUM_LIT> ) ) ; graph . draw ( shape ) ; graph . dispose ( ) ; } } private static File createTmpFile ( ) { String path = \"<STR_LIT>\" ; File f = new File ( path ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } String fileName = \"<STR_LIT>\" ; File tmpFile = new File ( f , fileName ) ; if ( ! tmpFile . exists ( ) ) { try { tmpFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; }", "output": "} return tmpFile ; } public static byte [ ] readInputStream ( InputStream inStream ) throws Exception { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <NUM_LIT> ] ; int len = <NUM_LIT> ; while ( ( len = inStream . read ( buffer ) ) != - <NUM_LIT> ) { outStream . write ( buffer , <NUM_LIT> , len ) ; } inStream . close ( ) ; return outStream . toByteArray ( ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp , boolean needCompress ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; ImageIO . write ( image , FORMAT_NAME , resp . getOutputStream ( ) ) ; } public static void encode ( String content , String imgPath , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , imgPath , resp , false ) ; } public static void encode ( String content , HttpServletResponse resp , boolean needCompress ) throws Exception { QRCodeUtil . encode ( content , null , resp , needCompress ) ; } public static void encode ( String content , HttpServletResponse resp ) throws Exception { QRCodeUtil . encode ( content , null , resp , false ) ; } public static void encode ( String content , String imgPath , OutputStream output , boolean needCompress , String realPath ) throws Exception { BufferedImage image = QRCodeUtil . createImage ( content , imgPath , needCompress ) ; File file = new File ( realPath + \"<STR_LIT>\" ) ; if ( ! file . exists ( ) && ! file . isDirectory ( ) ) { file . mkdirs ( ) ; } ImageIO . setCacheDirectory ( file ) ; ImageIO . write ( image , FORMAT_NAME , output ) ; } public static void encode ( String content , OutputStream output ) throws Exception { QRCodeUtil . encode ( content , null , output , false , \"<STR_LIT>\" ) ; } public static String decode ( File file ) throws Exception { BufferedImage image ; image = ImageIO . read ( file ) ; if ( image == null ) { return null ; } BufferedImageLuminanceSource source = new BufferedImageLuminanceSource ( image ) ; BinaryBitmap bitmap = new BinaryBitmap ( new HybridBinarizer ( source ) ) ; Result result ; Hashtable < DecodeHintType , Object > hints = new Hashtable < DecodeHintType , Object > ( ) ; hints . put ( DecodeHintType . CHARACTER_SET , CHARSET ) ; result = new MultiFormatReader ( ) . decode ( bitmap , hints ) ; String resultStr = result . getText ( ) ; return resultStr ; } public static String decode ( String path ) throws Exception { return QRCodeUtil . decode ( new File ( path ) ) ; } }"}, {"input": "package me . zhengjie . utils ; import org . junit . jupiter . api . Test ; import org . springframework . mock . web . MockMultipartFile ; import static me . zhengjie . utils . FileUtil . * ; import static org . junit . jupiter . api . Assertions . assertEquals ; public class FileUtilTest { @ Test public void testToFile ( ) { long retval = toFile ( new MockMultipartFile ( \"<STR_LIT>\" , ( byte [ ] ) null ) ) . getTotalSpace ( ) ; assertEquals ( <NUM_LIT> , retval ) ; } @ Test public void testGetExtensionName ( ) { assertEquals ( \"<STR_LIT>\" , getExtensionName ( \"<STR_LIT>\" ) ) ; assertEquals ( \"<STR_LIT>\" , getExtensionName ( \"<STR_LIT>\" ) ) ; } @ Test public void testGetFileNameNoEx ( ) { assertEquals ( \"<STR_LIT>\" , getFileNameNoEx ( \"<STR_LIT>\" ) ) ;", "output": "assertEquals ( \"<STR_LIT>\" , getFileNameNoEx ( \"<STR_LIT>\" ) ) ; } @ Test public void testGetSize ( ) { assertEquals ( \"<STR_LIT>\" , getSize ( <NUM_LIT> ) ) ; assertEquals ( \"<STR_LIT>\" , getSize ( <NUM_LIT> ) ) ; assertEquals ( \"<STR_LIT>\" , getSize ( <NUM_LIT> ) ) ; assertEquals ( \"<STR_LIT>\" , getSize ( <NUM_LIT> ) ) ; } }"}, {"input": "package org . springblade . cgform . model ; import com . fasterxml . jackson . annotation . JsonIgnoreProperties ; import lombok . Data ; import lombok . EqualsAndHashCode ; import lombok . experimental . Accessors ; import java . io . Serializable ; @ Data @ EqualsAndHashCode ( callSuper = false ) @ Accessors ( chain = true ) @ JsonIgnoreProperties ( ignoreUnknown = true ) public class DictModel implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; public DictModel ( ) { } public DictModel ( String value , String text ) { this . value = value ; this . text = text ; } private String value ; private String text ; private String label ; private String id ;", "output": "private String key ; public void setText ( String text ) { this . text = text ; this . label = text ; } public void setValue ( String value ) { this . value = value ; this . id = value ; this . key = value ; } public String getTitle ( ) { return this . text ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection ; import com . google . common . base . Preconditions ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import org . apache . commons . lang3 . Validate ; import java . util . * ; import java . util . Map . Entry ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; @ SuppressWarnings ( \"<STR_LIT>\" ) public class MapUtil { public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; public static boolean isEmpty ( final Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } public static boolean isNotEmpty ( final Map < ? , ? > map ) { return ( map != null ) && ! map . isEmpty ( ) ; } public static < K , V > V putIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , final V value ) { final V result = map . putIfAbsent ( key , value ) ; return result != null ? result : value ; } public static < K , V > V createIfAbsentReturnLast ( @ NotNull final ConcurrentMap < K , V > map , final K key , @ NotNull final ValueCreator < ? extends V > creator ) { final V value = map . get ( key ) ; if ( value == null ) { return putIfAbsentReturnLast ( map , key , creator . get ( ) ) ; } return value ; } public interface ValueCreator < T > { T get ( ) ; } @ Deprecated public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; }", "output": "public static < K , V > HashMap < K , V > newHashMapWithCapacity ( int expectedSize , float loadFactor ) { int finalSize = ( int ) ( expectedSize / loadFactor + <NUM_LIT> ) ; return new HashMap < K , V > ( finalSize , loadFactor ) ; } public static < K , V > HashMap < K , V > newHashMap ( final K key , final V value ) { HashMap < K , V > map = new HashMap < K , V > ( ) ; map . put ( key , value ) ; return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final K [ ] keys , @ NotNull final V [ ] values ) { Validate . isTrue ( keys . length == values . length , \"<STR_LIT>\" , keys . length , values . length ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . length * <NUM_LIT> ) ; for ( int i = <NUM_LIT> ; i < keys . length ; i ++ ) { map . put ( keys [ i ] , values [ i ] ) ; } return map ; } public static < K , V > HashMap < K , V > newHashMap ( @ NotNull final List < K > keys , @ NotNull final List < V > values ) { Validate . isTrue ( keys . size ( ) == values . size ( ) , \"<STR_LIT>\" , keys . size ( ) , values . size ( ) ) ; HashMap < K , V > map = new HashMap < K , V > ( keys . size ( ) * <NUM_LIT> ) ; Iterator < K > keyIt = keys . iterator ( ) ; Iterator < V > valueIt = values . iterator ( ) ; while ( keyIt . hasNext ( ) ) { map . put ( keyIt . next ( ) , valueIt . next ( ) ) ; } return map ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < K extends Comparable , V > TreeMap < K , V > newSortedMap ( ) { return new TreeMap < K , V > ( ) ; } public static < C , K extends C , V > TreeMap < K , V > newSortedMap ( @ Nullable Comparator < C > comparator ) { return Maps . newTreeMap ( comparator ) ; } public static < K extends Enum < K > , V > EnumMap < K , V > newEnumMap ( @ NotNull Class < K > type ) { return new EnumMap < K , V > ( Preconditions . checkNotNull ( type ) ) ; } public static < K , V > ConcurrentHashMap < K , V > newConcurrentHashMap ( ) { return new ConcurrentHashMap < K , V > ( ) ; } public static < K , V > ConcurrentSkipListMap < K , V > newConcurrentSortedMap ( ) { return new ConcurrentSkipListMap < K , V > ( ) ; } public static final < K , V > Map < K , V > emptyMap ( ) { return Collections . emptyMap ( ) ; } public static < K , V > Map < K , V > emptyMapIfNull ( final Map < K , V > map ) { return map == null ? ( Map < K , V > ) Collections . EMPTY_MAP : map ; } public static < K , V > Map < K , V > singletonMap ( final K key , final V value ) { return Collections . singletonMap ( key , value ) ; } public static < K , V > Map < K , V > unmodifiableMap ( final Map < ? extends K , ? extends V > m ) { return Collections . unmodifiableMap ( m ) ; } public static < K , V > SortedMap < K , V > unmodifiableSortedMap ( final SortedMap < K , ? extends V > m ) { return Collections . unmodifiableSortedMap ( m ) ; } public static < K , V > MapDifference < K , V > difference ( Map < ? extends K , ? extends V > left , Map < ? extends K , ? extends V > right ) { return Maps . difference ( left , right ) ; } public static < K , V extends Comparable > Map < K , V > sortByValue ( Map < K , V > map , final boolean reverse ) { return sortByValueInternal ( map , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > sortByValue ( Map < K , V > map , final Comparator < ? super V > comparator ) { return sortByValueInternal ( map , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > sortByValueInternal ( Map < K , V > map , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; for ( Entry < K , V > entry : entryArray ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } public static < K , V extends Comparable > Map < K , V > topNByValue ( Map < K , V > map , final boolean reverse , int n ) { return topNByValueInternal ( map , n , reverse ? Ordering . from ( new ComparableEntryValueComparator < K , V > ( ) ) . reverse ( ) : new ComparableEntryValueComparator < K , V > ( ) ) ; } public static < K , V > Map < K , V > topNByValue ( Map < K , V > map , final Comparator < ? super V > comparator , int n ) { return topNByValueInternal ( map , n , new EntryValueComparator < K , V > ( comparator ) ) ; } private static < K , V > Map < K , V > topNByValueInternal ( Map < K , V > map , int n , Comparator < Entry < K , V > > comparator ) { Set < Entry < K , V > > entrySet = map . entrySet ( ) ; Entry < K , V > [ ] entryArray = entrySet . toArray ( new Entry [ <NUM_LIT> ] ) ; Arrays . sort ( entryArray , comparator ) ; Map < K , V > result = new LinkedHashMap < K , V > ( ) ; int size = Math . min ( n , entryArray . length ) ; for ( int i = <NUM_LIT> ; i < size ; i ++ ) { Entry < K , V > entry = entryArray [ i ] ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } private static final class ComparableEntryValueComparator < K , V extends Comparable > implements Comparator < Entry < K , V > > { @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { return ( o1 . getValue ( ) ) . compareTo ( o2 . getValue ( ) ) ; } } private static final class EntryValueComparator < K , V > implements Comparator < Entry < K , V > > { private final Comparator < ? super V > comparator ; private EntryValueComparator ( Comparator < ? super V > comparator2 ) { this . comparator = comparator2 ; } @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { return comparator . compare ( o1 . getValue ( ) , o2 . getValue ( ) ) ; } } }"}, {"input": "package com . oddfar . campus . common . config . properties ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . stereotype . Component ; @ Data @ Component @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class CampusConfig { private String name ; private String version ;", "output": "}"}, {"input": "package com . yf . plugins . upload . local . config ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class LocalConfig implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String localDir ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String visitUrl ;", "output": "}"}, {"input": "package com . oddfar . campus . common . domain . model ; import lombok . Data ; @ Data public class LoginUserToken { private Long userId ; private String token ; private Long loginTime ; private Long expireTime ; private String ipaddr ; private String loginLocation ; private String browser ; private String os ; public LoginUserToken ( ) { } public LoginUserToken ( LoginUser loginUser ) { this . userId = loginUser . getUserId ( ) ; this . token = loginUser . getToken ( ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . model . form ; import cn . org . alan . exam . common . group . UserGroup ; import cn . org . alan . exam . util . excel . ExcelImport ; import com . alibaba . excel . annotation . ExcelProperty ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . Pattern ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class UserForm { private Integer id ; private LocalDateTime createTime ; @ NotBlank ( groups = { UserGroup . CreateUserGroup . class , UserGroup . RegisterGroup . class } , message = \"<STR_LIT>\" ) @ ExcelImport ( value = \"<STR_LIT>\" , unique = true , required = true ) private String userName ; @ NotBlank ( groups = UserGroup . RegisterGroup . class , message = \"<STR_LIT>\" ) private String password ; @ NotBlank ( groups = { UserGroup . CreateUserGroup . class , UserGroup . RegisterGroup . class } , message = \"<STR_LIT>\" ) @ ExcelImport ( value = \"<STR_LIT>\" ) private String realName ; @ ExcelImport ( value = \"<STR_LIT>\" ) private Integer roleId ;", "output": "@ NotBlank ( groups = { UserGroup . UpdatePasswordGroup . class } , message = \"<STR_LIT>\" ) private String originPassword ; @ NotBlank ( groups = { UserGroup . UpdatePasswordGroup . class } , message = \"<STR_LIT>\" ) private String newPassword ; @ NotBlank ( groups = { UserGroup . UpdatePasswordGroup . class , UserGroup . RegisterGroup . class } , message = \"<STR_LIT>\" ) private String checkedPassword ; }"}, {"input": "package com . youlai . system . model . query ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class MenuQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ;", "output": "}"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . RoleMapper ; import cn . org . alan . exam . model . entity . Role ; import cn . org . alan . exam . service . IRoleService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class RoleServiceImpl extends ServiceImpl < RoleMapper , Role > implements IRoleService {", "output": "}"}, {"input": "package ginyi . system . domain ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data public class SysMemory { @ ApiModelProperty ( \"<STR_LIT>\" ) private double total ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double used ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double free ; @ ApiModelProperty ( \"<STR_LIT>\" ) private double usage ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . util . BeanUtils ; import org . springframework . beans . factory . InitializingBean ; import org . springframework . beans . factory . NoSuchBeanDefinitionException ; import org . springframework . beans . factory . annotation . InjectionMetadata ; import org . springframework . beans . factory . config . ConfigurableListableBeanFactory ; import org . springframework . core . annotation . AnnotationAttributes ; import java . util . * ; import static java . lang . String . format ; import static java . util . Collections . unmodifiableMap ; public class AnnotationNacosInjectedBeanPostProcessor extends AbstractAnnotationBeanPostProcessor implements InitializingBean { public static final String BEAN_NAME = \"<STR_LIT>\" ; private Map < Class < ? > , AbstractNacosServiceBeanBuilder > nacosServiceBeanBuilderMap ; public AnnotationNacosInjectedBeanPostProcessor ( ) { super ( NacosInjected . class ) ; } @ Override public final void afterPropertiesSet ( ) { ConfigurableListableBeanFactory beanFactory = getBeanFactory ( ) ; initNacosServiceBeanBuilderMap ( beanFactory ) ;", "output": "} private void initNacosServiceBeanBuilderMap ( ConfigurableListableBeanFactory beanFactory ) { Class < AbstractNacosServiceBeanBuilder > builderClass = AbstractNacosServiceBeanBuilder . class ; String [ ] beanNames = BeanUtils . getBeanNames ( beanFactory , builderClass ) ; if ( beanNames . length == <NUM_LIT> ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Collection < AbstractNacosServiceBeanBuilder > serviceBeanBuilders = new ArrayList < AbstractNacosServiceBeanBuilder > ( beanNames . length ) ; for ( String beanName : beanNames ) { serviceBeanBuilders . add ( beanFactory . getBean ( beanName , builderClass ) ) ; } if ( serviceBeanBuilders . isEmpty ( ) ) { throw new NoSuchBeanDefinitionException ( builderClass , format ( \"<STR_LIT>\" , builderClass ) ) ; } Map < Class < ? > , AbstractNacosServiceBeanBuilder > builderMap = new HashMap < Class < ? > , AbstractNacosServiceBeanBuilder > ( serviceBeanBuilders . size ( ) ) ; for ( AbstractNacosServiceBeanBuilder serviceBeanBuilder : serviceBeanBuilders ) { Class < ? > type = serviceBeanBuilder . getType ( ) ; builderMap . put ( type , serviceBeanBuilder ) ; } this . nacosServiceBeanBuilderMap = unmodifiableMap ( builderMap ) ; } @ Override protected Object doGetInjectedBean ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) throws Exception { AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; return serviceBeanBuilder . build ( nacosProperties ) ; } @ Override protected String buildInjectedObjectCacheKey ( AnnotationAttributes attributes , Object bean , String beanName , Class < ? > injectedType , InjectionMetadata . InjectedElement injectedElement ) { StringBuilder keyBuilder = new StringBuilder ( injectedType . getSimpleName ( ) ) ; AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap . get ( injectedType ) ; if ( serviceBeanBuilder == null ) { throw new UnsupportedOperationException ( format ( \"<STR_LIT>\" , nacosServiceBeanBuilderMap . keySet ( ) , injectedType , injectedElement . getMember ( ) ) ) ; } Map < String , Object > nacosProperties = getNacosProperties ( attributes ) ; Properties properties = serviceBeanBuilder . resolveProperties ( nacosProperties ) ; keyBuilder . append ( properties ) ; return keyBuilder . toString ( ) ; } private Map < String , Object > getNacosProperties ( AnnotationAttributes attributes ) { return ( Map < String , Object > ) attributes . get ( \"<STR_LIT>\" ) ; } }"}, {"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . SheetConfig ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . RowDataAssembler ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . apache . poi . hssf . eventusermodel . * ; import org . apache . poi . hssf . eventusermodel . dummyrecord . LastCellOfRowDummyRecord ; import org . apache . poi . hssf . eventusermodel . dummyrecord . MissingCellDummyRecord ; import org . apache . poi . hssf . model . HSSFFormulaParser ; import org . apache . poi . hssf . record . * ; import org . apache . poi . hssf . usermodel . HSSFWorkbook ; import org . apache . poi . poifs . filesystem . POIFSFileSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class XlsSheetProcessor implements HSSFListener { private static final Logger logger = LoggerFactory . getLogger ( XlsSheetProcessor . class ) ; private RowReadingListener rowReadingListener ; private WorkbookConfig workbookConfig ; private boolean use1904DateWindowing ; private EventWorkbookBuilder . SheetRecordCollectingListener workbookBuildingListener ; private HSSFWorkbook stubWorkbook ; private SSTRecord sstRecord ; private FormatTrackingHSSFListener formatListener ; private int lastRowNumber ; private int lastColumnNumber ; private int nextRow ; private int nextColumn ; private boolean outputNextStringRecord ; private int sheetIndex = - <NUM_LIT> ; private List < String > records ; private boolean notAllEmpty = false ; private BoundSheetRecord [ ] orderedBSRs ; private List < BoundSheetRecord > boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; private boolean outputFormulaValues = true ; private boolean trimContent ; private HSSFEventFactory hssfEventFactory ; public XlsSheetProcessor ( RowReadingListener rowReadingListener , WorkbookConfig workbookConfig , boolean use1904DateWindowing ) { if ( rowReadingListener == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( workbookConfig == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( CollectionUtil . isEmpty ( workbookConfig . getSheets ( ) ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . rowReadingListener = rowReadingListener ; this . workbookConfig = workbookConfig ; this . use1904DateWindowing = use1904DateWindowing ; init ( ) ; MissingRecordAwareHSSFListener listener = new MissingRecordAwareHSSFListener ( this ) ; formatListener = new FormatTrackingHSSFListener ( listener ) ; hssfEventFactory = new HSSFEventFactory ( ) ; } public void execute ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return ; } POIFSFileSystem fs = new POIFSFileSystem ( inputStream ) ; HSSFRequest request = new HSSFRequest ( ) ; if ( outputFormulaValues ) { request . addListenerForAllRecords ( formatListener ) ; } else { workbookBuildingListener = new EventWorkbookBuilder . SheetRecordCollectingListener ( formatListener ) ; request . addListenerForAllRecords ( workbookBuildingListener ) ; } hssfEventFactory . processWorkbookEvents ( request , fs ) ; } @ Override public void processRecord ( Record record ) { int processingRowIndex = - <NUM_LIT> ; int processingColumnIndex = - <NUM_LIT> ; String processingContent = null ; switch ( record . getSid ( ) ) { case BoundSheetRecord . sid : boundSheetRecords . add ( ( BoundSheetRecord ) record ) ; break ; case BOFRecord . sid : doProcessBOFRecord ( ( BOFRecord ) record ) ; break ; case SSTRecord . sid : sstRecord = ( SSTRecord ) record ; break ; case BlankRecord . sid : BlankRecord blankRecord = ( BlankRecord ) record ; processingRowIndex = blankRecord . getRow ( ) ; processingColumnIndex = blankRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case BoolErrRecord . sid : BoolErrRecord boolErrRecord = ( BoolErrRecord ) record ; processingRowIndex = boolErrRecord . getRow ( ) ; processingColumnIndex = boolErrRecord . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case FormulaRecord . sid : FormulaRecord formulaRecord = ( FormulaRecord ) record ; processingRowIndex = formulaRecord . getRow ( ) ; processingColumnIndex = formulaRecord . getColumn ( ) ; processingContent = doResolveContentForFormulaRecord ( formulaRecord ) ; break ; case StringRecord . sid : if ( outputNextStringRecord ) { StringRecord srec = ( StringRecord ) record ; processingContent = srec . getString ( ) ; processingRowIndex = nextRow ; processingColumnIndex = nextColumn ; outputNextStringRecord = false ; } break ; case LabelRecord . sid : LabelRecord lrec = ( LabelRecord ) record ; processingRowIndex = lrec . getRow ( ) ; processingColumnIndex = lrec . getColumn ( ) ; processingContent = lrec . getValue ( ) ; break ; case LabelSSTRecord . sid : LabelSSTRecord lsrec = ( LabelSSTRecord ) record ; processingRowIndex = lsrec . getRow ( ) ; processingColumnIndex = lsrec . getColumn ( ) ; if ( sstRecord == null ) { processingContent = \"<STR_LIT>\" ; } else { processingContent = sstRecord . getString ( lsrec . getSSTIndex ( ) ) . toString ( ) ; } break ; case NoteRecord . sid : NoteRecord nrec = ( NoteRecord ) record ; processingRowIndex = nrec . getRow ( ) ; processingColumnIndex = nrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; case NumberRecord . sid : NumberRecord numrec = ( NumberRecord ) record ; processingRowIndex = numrec . getRow ( ) ; processingRowIndex = numrec . getColumn ( ) ; processingContent = formatListener . formatNumberDateCell ( numrec ) ; break ; case RKRecord . sid : RKRecord rkrec = ( RKRecord ) record ; processingRowIndex = rkrec . getRow ( ) ; processingColumnIndex = rkrec . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; break ; default : break ; } if ( processingRowIndex != - <NUM_LIT> && processingRowIndex != lastRowNumber ) { lastColumnNumber = - <NUM_LIT> ; } if ( record instanceof MissingCellDummyRecord ) { MissingCellDummyRecord mc = ( MissingCellDummyRecord ) record ; processingRowIndex = mc . getRow ( ) ; processingColumnIndex = mc . getColumn ( ) ; processingContent = \"<STR_LIT>\" ; } if ( processingContent != null ) { if ( trimContent ) { processingContent = processingContent . trim ( ) ; } if ( ! \"<STR_LIT>\" . equals ( processingContent ) ) { notAllEmpty = true ; } records . add ( processingContent ) ; } if ( processingRowIndex > - <NUM_LIT> ) { lastRowNumber = processingRowIndex ; } if ( processingColumnIndex > - <NUM_LIT> ) { lastColumnNumber = processingColumnIndex ; } if ( record instanceof LastCellOfRowDummyRecord ) { int rowIndex = ( ( LastCellOfRowDummyRecord ) record ) . getRow ( ) ; doEndRow ( rowIndex ) ; } } private void init ( ) { lastRowNumber = <NUM_LIT> ; lastColumnNumber = <NUM_LIT> ; nextRow = <NUM_LIT> ; nextColumn = <NUM_LIT> ; sheetIndex = <NUM_LIT> ; records = new ArrayList < String > ( ) ; notAllEmpty = false ; orderedBSRs = null ; boundSheetRecords = new ArrayList < BoundSheetRecord > ( ) ; } private void doProcessBOFRecord ( BOFRecord record ) { if ( record . getType ( ) != BOFRecord . TYPE_WORKSHEET ) { return ; } if ( workbookBuildingListener != null && stubWorkbook == null ) { stubWorkbook = workbookBuildingListener . getStubHSSFWorkbook ( ) ; } if ( orderedBSRs == null ) { orderedBSRs = BoundSheetRecord . orderByBofPosition ( boundSheetRecords ) ; } sheetIndex ++ ; init ( ) ; } private String doResolveContentForFormulaRecord ( FormulaRecord record ) { if ( ! outputFormulaValues ) { return HSSFFormulaParser . toFormulaString ( stubWorkbook , record . getParsedExpression ( ) ) ; } if ( Double . isNaN ( record . getValue ( ) ) ) { outputNextStringRecord = true ; nextRow = record . getRow ( ) ; nextColumn = record . getColumn ( ) ; return null ; } else { return formatListener . formatNumberDateCell ( record ) ; } } private void doEndRow ( int rowIndex ) { if ( sheetIndex >= <NUM_LIT> && sheetIndex < workbookConfig . getSheets ( ) . size ( ) ) { try { String [ ] rowContent = new String [ records . size ( ) ] ; records . toArray ( rowContent ) ; SheetConfig sheetConfig = workbookConfig . getSheets ( ) . get ( sheetIndex ) ; Object rowData = RowDataAssembler . assemble ( sheetConfig . getRowType ( ) , sheetConfig . getDataRowConfig ( ) , rowContent , use1904DateWindowing ) ; rowReadingListener . onFinish ( sheetConfig , rowData , rowIndex ) ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ;", "output": "} } records . clear ( ) ; lastColumnNumber = - <NUM_LIT> ; notAllEmpty = false ; } }"}, {"input": "package com . xcs . wx . service . impl ; import com . xcs . wx . repository . ContactHeadImgRepository ; import com . xcs . wx . service . ContactHeadImgService ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Service ; @ Slf4j @ Service @ RequiredArgsConstructor public class ContactHeadImgServiceImpl implements ContactHeadImgService { private final ContactHeadImgRepository contactHeadImgService ; @ Override public byte [ ] avatar ( String userName ) { return contactHeadImgService . getContactHeadImg ( userName ) ; }", "output": "}"}, {"input": "package com . yf . system . aspect . mybatis ; import com . baomidou . mybatisplus . extension . plugins . PaginationInterceptor ; import com . yf . ability . shiro . dto . SysUserLoginDTO ; import com . yf . base . enums . DataScope ; import lombok . extern . log4j . Log4j2 ; import net . sf . jsqlparser . expression . Alias ; import net . sf . jsqlparser . expression . Expression ; import net . sf . jsqlparser . expression . Parenthesis ; import net . sf . jsqlparser . expression . operators . conditional . AndExpression ; import net . sf . jsqlparser . parser . CCJSqlParserManager ; import net . sf . jsqlparser . parser . CCJSqlParserUtil ; import net . sf . jsqlparser . schema . Table ; import net . sf . jsqlparser . statement . select . PlainSelect ; import net . sf . jsqlparser . statement . select . Select ; import org . apache . commons . lang3 . StringUtils ; import org . apache . ibatis . executor . statement . StatementHandler ; import org . apache . ibatis . mapping . MappedStatement ; import org . apache . ibatis . mapping . SqlCommandType ; import org . apache . ibatis . plugin . * ; import org . apache . ibatis . reflection . DefaultReflectorFactory ; import org . apache . ibatis . reflection . MetaObject ; import org . apache . ibatis . reflection . SystemMetaObject ; import org . apache . shiro . SecurityUtils ; import java . io . StringReader ; import java . sql . Connection ; import java . util . Properties ; @ Log4j2 @ Intercepts ( { @ Signature ( type = StatementHandler . class , method = \"<STR_LIT>\" , args = { Connection . class , Integer . class } ) , } ) public class QueryInterceptor extends PaginationInterceptor implements Interceptor { private static final String USER_FILTER = \"<STR_LIT>\" ; private static final String FILTER_SELF = \"<STR_LIT>\" ; private static final String FILTER_DEPT = \"<STR_LIT>\" ; private static final String FILTER_DEPT_DOWN = \"<STR_LIT>\" ; private static final String [ ] FILTER_MAPPERS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private boolean needFilter ( String id ) { for ( String item : FILTER_MAPPERS ) { if ( id . contains ( item ) ) { return true ; } } return false ; } @ Override public Object intercept ( Invocation invocation ) throws Throwable { StatementHandler statementHandler = ( StatementHandler ) invocation . getTarget ( ) ; MetaObject metaObject = MetaObject . forObject ( statementHandler , SystemMetaObject . DEFAULT_OBJECT_FACTORY , SystemMetaObject . DEFAULT_OBJECT_WRAPPER_FACTORY , new DefaultReflectorFactory ( ) ) ; MappedStatement mappedStatement = ( MappedStatement ) metaObject . getValue ( \"<STR_LIT>\" ) ; SqlCommandType sqlCommandType = mappedStatement . getSqlCommandType ( ) ; String id = mappedStatement . getId ( ) ; if ( SqlCommandType . SELECT == sqlCommandType ) { String sql = statementHandler . getBoundSql ( ) . getSql ( ) ; if ( sql . contains ( USER_FILTER ) ) { sql = sql . replace ( USER_FILTER , currentId ( ) ) ; } if ( this . needFilter ( id ) ) { sql = this . parseSql ( sql ) ; } metaObject . setValue ( \"<STR_LIT>\" , sql ) ; return super . intercept ( invocation ) ; } return super . intercept ( invocation ) ; } @ Override public Object plugin ( Object target ) { return Plugin . wrap ( target , this ) ; } @ Override public void setProperties ( Properties properties ) { } private SysUserLoginDTO currentUser ( ) { try { return SecurityUtils . getSubject ( ) . getPrincipal ( ) != null ? ( SysUserLoginDTO ) SecurityUtils . getSubject ( ) . getPrincipal ( ) : null ; } catch ( Exception e ) { return null ; } } private String currentId ( ) { SysUserLoginDTO user = this . currentUser ( ) ; if ( user != null ) { return user . getId ( ) ; } return \"<STR_LIT>\" ; } private String parseSql ( String src ) { log . info ( \"<STR_LIT>\" + src ) ; CCJSqlParserManager parserManager = new CCJSqlParserManager ( ) ; try { Select select = ( Select ) parserManager . parse ( new StringReader ( src ) ) ; PlainSelect selectBody = ( PlainSelect ) select . getSelectBody ( ) ; Table table = ( Table ) selectBody . getFromItem ( ) ; String alias ; if ( table . getAlias ( ) == null ) { alias = \"<STR_LIT>\" ; table . setAlias ( new Alias ( alias ) ) ; } else { alias = table . getAlias ( ) . getName ( ) ; } String appendSql = this . generateAppend ( alias ) ; if ( ! StringUtils . isBlank ( appendSql ) ) { if ( selectBody . getWhere ( ) == null ) { selectBody . setWhere ( CCJSqlParserUtil . parseCondExpression ( appendSql ) ) ; } else { Expression whereExpression = CCJSqlParserUtil . parseCondExpression ( appendSql ) ; selectBody . setWhere ( new AndExpression ( selectBody . getWhere ( ) , new Parenthesis ( whereExpression ) ) ) ; } } String out = selectBody . toString ( ) ; log . info ( \"<STR_LIT>\" + out ) ; return out ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return src ; }", "output": "private String generateAppend ( String alias ) { SysUserLoginDTO user = this . currentUser ( ) ; if ( user == null ) { return \"<STR_LIT>\" ; } if ( DataScope . SCOPE_SELF . equals ( user . getDataScope ( ) ) ) { return FILTER_SELF . replace ( \"<STR_LIT>\" , alias ) . replace ( \"<STR_LIT>\" , this . currentId ( ) ) ; } if ( DataScope . SCOPE_DEPT . equals ( user . getDataScope ( ) ) ) { return FILTER_DEPT . replace ( \"<STR_LIT>\" , alias ) . replace ( \"<STR_LIT>\" , user . getDeptCode ( ) ) ; } if ( DataScope . SCOPE_DEPT_DOWN . equals ( user . getDataScope ( ) ) ) { return FILTER_DEPT_DOWN . replace ( \"<STR_LIT>\" , alias ) . replace ( \"<STR_LIT>\" , user . getDeptCode ( ) ) ; } return \"<STR_LIT>\" ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . collection ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . LinkedList ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . LinkedBlockingQueue ; public class QueueUtil { public static < E > ArrayDeque < E > newArrayDeque ( int initSize ) { return new ArrayDeque < E > ( initSize ) ; } public static < E > LinkedList < E > newLinkedDeque ( ) { return new LinkedList < E > ( ) ; } public static < E > ConcurrentLinkedQueue < E > newConcurrentNonBlockingQueue ( ) { return new ConcurrentLinkedQueue < E > ( ) ; } public static < E > Deque < E > newConcurrentNonBlockingDeque ( ) { return new java . util . concurrent . ConcurrentLinkedDeque < E > ( ) ; } public static < E > LinkedBlockingQueue < E > newBlockingUnlimitQueue ( ) { return new LinkedBlockingQueue < E > ( ) ; } public static < E > LinkedBlockingDeque < E > newBlockingUnlimitDeque ( ) { return new LinkedBlockingDeque < E > ( ) ; } public static < E > ArrayBlockingQueue < E > newArrayBlockingQueue ( int capacity ) { return new ArrayBlockingQueue < E > ( capacity ) ; } public static < E > LinkedBlockingQueue < E > newLinkedBlockingQueue ( int capacity ) {", "output": "return new LinkedBlockingQueue < E > ( capacity ) ; } public static < E > LinkedBlockingDeque < E > newBlockingDeque ( int capacity ) { return new LinkedBlockingDeque < E > ( capacity ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import cn . org . alan . exam . model . entity . Option ; import lombok . Data ; import java . util . List ; @ Data public class ExamQuDetailVO { private static final long serialVersionUID = <NUM_LIT> ; private String image ; private String content ; private List < OptionVO > answerList ; private Integer quType ; private Integer sort ;", "output": "}"}, {"input": "package ginyi . framework . security . handle ; import com . alibaba . fastjson2 . JSON ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . result . CommonResult ; import ginyi . common . result . StateCode ; import ginyi . common . utils . ServletUtils ; import org . springframework . security . core . AuthenticationException ; import org . springframework . security . web . AuthenticationEntryPoint ; import org . springframework . stereotype . Component ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . io . Serializable ; @ Component public class AuthenticationEntryPointImpl implements AuthenticationEntryPoint , Serializable { private static final long serialVersionUID = - <NUM_LIT> ; @ Override public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException e ) throws IOException {", "output": "ServletUtils . renderString ( response , JSON . toJSONString ( CommonResult . error ( StateCode . ERROR_AUTHENTICATION_VALID , CommonMessageConstants . SYS_AUTHENTICATION_VALID ) ) ) ; } }"}, {"input": "package com . xcs . wx . msg . impl ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import org . springframework . stereotype . Service ; @ Service public class VideoMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ; } @ Override public void process ( MsgVO msgVO ) { msgVO . setStrContent ( \"<STR_LIT>\" ) ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosConfigBeanDefinitionRegistrar . class ) public @ interface EnableNacosConfig { String CONFIG_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ;", "output": "String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ; String CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_LONG_POLL_TIMEOUT + \"<STR_LIT>\" + NacosProperties . CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER + \"<STR_LIT>\" ; String CONFIG_RETRY_TIME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + CONFIG_RETRY_TIME + \"<STR_LIT>\" + NacosProperties . CONFIG_RETRY_TIME_PLACEHOLDER + \"<STR_LIT>\" ; String MAX_RETRY_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + MAX_RETRY + \"<STR_LIT>\" + NacosProperties . MAX_RETRY_PLACEHOLDER + \"<STR_LIT>\" ; String USERNAME_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + USERNAME + \"<STR_LIT>\" + NacosProperties . USERNAME_PLACEHOLDER + \"<STR_LIT>\" ; String PASSWORD_PLACEHOLDER = \"<STR_LIT>\" + CONFIG_PREFIX + PASSWORD + \"<STR_LIT>\" + NacosProperties . PASSWORD_PLACEHOLDER + \"<STR_LIT>\" ; NacosProperties globalProperties ( ) default @ NacosProperties ( username = USERNAME_PLACEHOLDER , password = PASSWORD_PLACEHOLDER , endpoint = ENDPOINT_PLACEHOLDER , namespace = NAMESPACE_PLACEHOLDER , accessKey = ACCESS_KEY_PLACEHOLDER , secretKey = SECRET_KEY_PLACEHOLDER , serverAddr = SERVER_ADDR_PLACEHOLDER , contextPath = CONTEXT_PATH_PLACEHOLDER , clusterName = CLUSTER_NAME_PLACEHOLDER , encode = ENCODE_PLACEHOLDER , configLongPollTimeout = CONFIG_LONG_POLL_TIMEOUT_PLACEHOLDER , configRetryTime = CONFIG_RETRY_TIME_PLACEHOLDER , maxRetry = MAX_RETRY_PLACEHOLDER ) ; }"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . youlai . system . model . entity . SysDictItem ; public interface SysDictItemService extends IService < SysDictItem > {", "output": "}"}, {"input": "package me . zhengjie . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import me . zhengjie . utils . PageResult ; import org . springframework . http . ResponseEntity ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . util . List ; public interface GeneratorService extends IService < ColumnInfo > { PageResult < TableInfo > getTables ( String name , Page < Object > page ) ;", "output": "List < ColumnInfo > getColumns ( String name ) ; void sync ( List < ColumnInfo > columnInfos , List < ColumnInfo > columnInfoList ) ; void save ( List < ColumnInfo > columnInfos ) ; void generator ( GenConfig genConfig , List < ColumnInfo > columns ) ; ResponseEntity < Object > preview ( GenConfig genConfig , List < ColumnInfo > columns ) ; void download ( GenConfig genConfig , List < ColumnInfo > columns , HttpServletRequest request , HttpServletResponse response ) ; List < ColumnInfo > query ( String table ) ; }"}, {"input": "package org . springblade . cgform . model . database . util ; import org . apache . commons . lang . StringUtils ; import java . util . List ; public class StringArrUtil { public static String a ( String [ ] array ) { final StringBuffer sb = new StringBuffer ( ) ; for ( final String s : array ) { if ( StringUtils . isNotBlank ( s ) ) { sb . append ( \"<STR_LIT>\" ) ; sb . append ( \"<STR_LIT>\" ) ; sb . append ( s . trim ( ) ) ; sb . append ( \"<STR_LIT>\" ) ; } } return sb . toString ( ) . substring ( <NUM_LIT> ) ; } public static String a ( String string ) { if ( StringUtils . isNotBlank ( string ) ) { string = string . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + string . substring ( <NUM_LIT> ) ; } return string ; } public static Integer a ( Integer n ) { if ( n == null ) { return <NUM_LIT> ; } return n ; } public static boolean isInclude ( String s , String [ ] array ) {", "output": "if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } public static boolean a ( String s , List < String > list ) { String [ ] array = new String [ <NUM_LIT> ] ; if ( list != null ) { array = ( String [ ] ) list . toArray ( ) ; } if ( array == null || array . length == <NUM_LIT> ) { return false ; } for ( int i = <NUM_LIT> ; i < array . length ; ++ i ) { if ( array [ i ] . equals ( s ) ) { return true ; } } return false ; } }"}, {"input": "package com . youlai . system . converter ; import com . youlai . system . model . entity . SysDept ; import com . youlai . system . model . form . DeptForm ; import com . youlai . system . model . vo . DeptVO ; import org . mapstruct . Mapper ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface DeptConverter {", "output": "DeptForm toForm ( SysDept entity ) ; DeptVO convertToVo ( SysDept entity ) ; SysDept toEntity ( DeptForm deptForm ) ; }"}, {"input": "package top . kangert . kspider . support ; import lombok . Data ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Component ; import org . springframework . util . ClassUtils ; import cn . hutool . core . io . IoUtil ; import cn . hutool . core . util . RandomUtil ; import cn . hutool . json . JSONUtil ; import javax . annotation . PostConstruct ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . List ; @ Component @ Slf4j public class UserAgentManager { private static final String USERAGENT_FILE_PATH = \"<STR_LIT>\" ; private static List < BrowserUserAgent > user_agents ; @ PostConstruct private void initialize ( ) { try { InputStream userAgentFileInputStream = ClassUtils . getDefaultClassLoader ( ) . getResourceAsStream ( USERAGENT_FILE_PATH ) ; byte [ ] readBytes = IoUtil . readBytes ( userAgentFileInputStream ) ; ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; output . write ( readBytes ) ; String json = IoUtil . toStr ( output , StandardCharsets . UTF_8 ) ; user_agents = JSONUtil . parseArray ( json ) . toList ( BrowserUserAgent . class ) ; } catch ( IOException e ) { log . error ( \"<STR_LIT>\" , USERAGENT_FILE_PATH , e ) ; } } @ Data static class BrowserUserAgent { private String browser ; private List < String > useragent = new ArrayList < > ( ) ; } public String getRandom ( ) { int browserIndex = RandomUtil . randomInt ( <NUM_LIT> , user_agents . size ( ) ) ; List < String > userAgents = user_agents . get ( browserIndex ) . useragent ; int useragentIndex = RandomUtil . randomInt ( <NUM_LIT> , userAgents . size ( ) ) ; return user_agents . get ( browserIndex ) . useragent . get ( useragentIndex ) ; } public String getNewest ( ) { int browserIndex = RandomUtil . randomInt ( <NUM_LIT> , user_agents . size ( ) ) ;", "output": "return user_agents . get ( browserIndex ) . useragent . get ( <NUM_LIT> ) ; } public String getChromeNewest ( ) { return user_agents . get ( <NUM_LIT> ) . useragent . get ( <NUM_LIT> ) ; } public String getFireFoxNewest ( ) { return user_agents . get ( <NUM_LIT> ) . useragent . get ( <NUM_LIT> ) ; } public String getEdgeNewest ( ) { return user_agents . get ( <NUM_LIT> ) . useragent . get ( <NUM_LIT> ) ; } }"}, {"input": "package me . zhengjie . modules . system . rest ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . Dict ; import me . zhengjie . modules . system . service . DictService ; import me . zhengjie . modules . system . domain . vo . DictQueryCriteria ; import me . zhengjie . utils . PageResult ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . List ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class DictController { private final DictService dictService ; private static final String ENTITY_NAME = \"<STR_LIT>\" ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportDict ( HttpServletResponse response , DictQueryCriteria criteria ) throws IOException { dictService . download ( dictService . queryAll ( criteria ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < List < Dict > > queryAllDict ( ) { return new ResponseEntity < > ( dictService . queryAll ( new DictQueryCriteria ( ) ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Dict > > queryDict ( DictQueryCriteria resources , Page < Object > page ) { return new ResponseEntity < > ( dictService . queryAll ( resources , page ) , HttpStatus . OK ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createDict ( @ Validated @ RequestBody Dict resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( \"<STR_LIT>\" + ENTITY_NAME + \"<STR_LIT>\" ) ; } dictService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateDict ( @ Validated ( Dict . Update . class ) @ RequestBody Dict resources ) {", "output": "dictService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteDict ( @ RequestBody Set < Long > ids ) { dictService . delete ( ids ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package com . yf . system . modules . config . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class CfgSwitch extends Model < CfgSwitch > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String val ;", "output": "}"}, {"input": "package top . kangert . kspider . vo ; public class PageVo { private int pageSize = <NUM_LIT> ; private int currentPage = <NUM_LIT> ; private int pageNums = <NUM_LIT> ; private int total = <NUM_LIT> ; public int getPageSize ( ) { return pageSize ; } public void setPageSize ( int pageSize ) { this . pageSize = pageSize ; } public int getCurrentPage ( ) { return currentPage ; } public void setCurrentPage ( int currentPage ) { this . currentPage = currentPage ; } public int getPageNums ( ) { return pageNums ; }", "output": "public void setPageNums ( int pageNums ) { this . pageNums = pageNums ; } public int getTotal ( ) { return total ; } public void setTotal ( int total ) { this . total = total ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class TopContactsVO { private String userName ; private String nickName ; private String headImgUrl ; private Long total ;", "output": "}"}, {"input": "package com . yf . system . modules . dict . service ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . system . modules . dict . dto . SysDicValueDTO ; import com . yf . system . modules . dict . dto . ext . DicValueTreeDTO ; import com . yf . system . modules . dict . dto . request . SysDicValueReqDTO ; import com . yf . system . modules . dict . entity . SysDicValue ; import java . util . List ; import java . util . Map ; public interface SysDicValueService extends IService < SysDicValue > { List < DicValueTreeDTO > findTree ( SysDicValueReqDTO reqDTO ) ; void save ( SysDicValueDTO reqDTO ) ; Map < String , String > findDictMap ( String dictCode ) ; void removeByDict ( List < String > codes ) ; String findDictText ( String dicCode , String value ) ; String findTableText ( String dicTable , String dicText , String dicCode , String value ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . config . logging ; import com . alibaba . nacos . client . logging . NacosLogging ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigPropertiesUtils ; import org . springframework . boot . context . event . ApplicationEnvironmentPreparedEvent ; import org . springframework . context . ApplicationEvent ; import org . springframework . context . event . GenericApplicationListener ; import org . springframework . core . Ordered ; import org . springframework . core . ResolvableType ; public class NacosLoggingListener implements GenericApplicationListener { @ Override public boolean supportsEventType ( ResolvableType resolvableType ) { Class < ? > type = resolvableType . getRawClass ( ) ; if ( type != null ) { return ApplicationEnvironmentPreparedEvent . class . isAssignableFrom ( type ) ;", "output": "} return false ; } @ Override public boolean supportsSourceType ( Class < ? > aClass ) { return true ; } @ Override public void onApplicationEvent ( ApplicationEvent applicationEvent ) { ApplicationEnvironmentPreparedEvent applicationEnvironmentPreparedEvent = ( ApplicationEnvironmentPreparedEvent ) applicationEvent ; NacosConfigProperties nacosConfigProperties = NacosConfigPropertiesUtils . buildNacosConfigProperties ( applicationEnvironmentPreparedEvent . getEnvironment ( ) ) ; if ( nacosConfigProperties . getBootstrap ( ) . isLogEnable ( ) ) { NacosLogging . getInstance ( ) . loadConfiguration ( ) ; } } @ Override public int getOrder ( ) { return Ordered . HIGHEST_PRECEDENCE + <NUM_LIT> ; } }"}, {"input": "package ginyi . system . domain . model . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import org . hibernate . validator . constraints . Length ; import javax . validation . constraints . NotEmpty ; @ Data @ ApiModel ( \"<STR_LIT>\" ) public class LoginDto { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) @ NotEmpty ( message = \"<STR_LIT>\" ) @ Length ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String username ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) @ NotEmpty ( message = \"<STR_LIT>\" ) @ Length ( min = <NUM_LIT> , max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String password ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String code ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . limiter ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; public class TimeIntervalLimiter { private final AtomicLong lastTimeAtom = new AtomicLong ( <NUM_LIT> ) ; private long windowSizeMillis ; public TimeIntervalLimiter ( long interval , TimeUnit timeUnit ) { this . windowSizeMillis = timeUnit . toMillis ( interval ) ; } public boolean tryAcquire ( ) { long currentTime = System . currentTimeMillis ( ) ; long lastTime = lastTimeAtom . get ( ) ; return currentTime - lastTime >= windowSizeMillis && lastTimeAtom . compareAndSet ( lastTime , currentTime ) ; }", "output": "}"}, {"input": "package ginyi . framework . security . filter ; import ginyi . common . utils . StringUtils ; import ginyi . framework . security . utils . SecurityUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . service . ITokenService ; import org . springframework . security . authentication . UsernamePasswordAuthenticationToken ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . web . authentication . WebAuthenticationDetailsSource ; import org . springframework . stereotype . Component ; import org . springframework . web . filter . OncePerRequestFilter ; import javax . annotation . Resource ; import javax . servlet . FilterChain ; import javax . servlet . ServletException ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Component public class JwtAuthenticationTokenFilter extends OncePerRequestFilter { @ Resource private ITokenService tokenService ; @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain chain ) throws ServletException , IOException { LoginUser loginUser = tokenService . getLoginUser ( request ) ; if ( StringUtils . isNotNull ( loginUser ) && StringUtils . isNull ( SecurityUtils . getAuthentication ( ) ) ) { tokenService . verifyToken ( loginUser ) ; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( loginUser , null , loginUser . getAuthorities ( ) ) ; authenticationToken . setDetails ( new WebAuthenticationDetailsSource ( ) . buildDetails ( request ) ) ;", "output": "SecurityContextHolder . getContext ( ) . setAuthentication ( authenticationToken ) ; } chain . doFilter ( request , response ) ; } }"}, {"input": "package com . yf . system . modules . dict . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDicValueReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dicCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > excludes ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . web . core ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . http . ResponseEntity ; import org . springframework . util . CollectionUtils ; import org . springframework . validation . BindException ; import org . springframework . validation . ObjectError ; import org . springframework . web . bind . MethodArgumentNotValidException ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . bind . annotation . ExceptionHandler ; import java . util . List ; @ ControllerAdvice public class CustomWebExceptionHandler { private final Log logger = LogFactory . getLog ( getClass ( ) ) ; @ ExceptionHandler public ResponseEntity < CommonResponse > handleException ( Throwable except ) { if ( except instanceof BizException ) { return this . doHandleBusinessException ( ( BizException ) except ) ; } else if ( except instanceof BindException ) { return this . doHandleBindException ( ( BindException ) except ) ; } else if ( except instanceof MethodArgumentNotValidException ) { return this . doMethodArgumentNotValidException ( ( MethodArgumentNotValidException ) except ) ; } else { logger . error ( \"<STR_LIT>\" , except ) ; return ResponseEntity . ok ( CommonResponse . sysError ( except . getMessage ( ) != null ? except . getMessage ( ) : except . toString ( ) ) ) ; } } private ResponseEntity < CommonResponse > doHandleBusinessException ( BizException except ) { String code = except . getCode ( ) ; String msg = except . getMessage ( ) ;", "output": "if ( isBlank ( code ) ) { code = ResponseType . BIZ_ERROR . getCode ( ) ; } if ( isBlank ( msg ) ) { msg = ResponseType . BIZ_ERROR . getMsg ( ) ; } return ResponseEntity . ok ( new CommonResponse ( code , msg ) ) ; } private ResponseEntity < CommonResponse > doHandleBindException ( BindException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; List < ObjectError > allErrors = except . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) { if ( ! isBlank ( error . getDefaultMessage ( ) ) ) { msg = error . getDefaultMessage ( ) ; break ; } } } return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ; } private ResponseEntity < CommonResponse > doMethodArgumentNotValidException ( MethodArgumentNotValidException except ) { String msg = ResponseType . BIZ_ERROR . getMsg ( ) ; if ( except . getBindingResult ( ) == null ) { return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ; } List < ObjectError > allErrors = except . getBindingResult ( ) . getAllErrors ( ) ; if ( ! CollectionUtils . isEmpty ( allErrors ) ) { for ( ObjectError error : allErrors ) { if ( ! isBlank ( error . getDefaultMessage ( ) ) ) { msg = error . getDefaultMessage ( ) ; break ; } } } return ResponseEntity . ok ( CommonResponse . bizError ( msg ) ) ; } private boolean isBlank ( String text ) { if ( text == null || text . trim ( ) . equals ( \"<STR_LIT>\" ) ) { return true ; } return false ; } }"}, {"input": "package org . springblade . config . autopoi . poi . handler . impl ; import org . springblade . config . autopoi . poi . handler . inter . IExcelDataHandler ; import java . util . Map ; public abstract class ExcelDataHandlerDefaultImpl implements IExcelDataHandler { private String [ ] needHandlerFields ; @ Override public Object exportHandler ( Object obj , String name , Object value ) { return value ; } @ Override public String [ ] getNeedHandlerFields ( ) {", "output": "return needHandlerFields ; } @ Override public Object importHandler ( Object obj , String name , Object value ) { return value ; } @ Override public void setNeedHandlerFields ( String [ ] needHandlerFields ) { this . needHandlerFields = needHandlerFields ; } @ Override public void setMapValue ( Map < String , Object > map , String originKey , Object value ) { map . put ( originKey , value ) ; } }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . ContactHeadImgUrl ; import com . xcs . wx . mapper . ContactHeadImgUrlMapper ; import com . xcs . wx . repository . ContactHeadImgUrlRepository ; import org . springframework . stereotype . Repository ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Optional ; import java . util . stream . Collectors ; @ Repository @ DS ( value = DataSourceType . MICRO_MSG_DB ) public class ContactHeadImgUrlRepositoryImpl extends ServiceImpl < ContactHeadImgUrlMapper , ContactHeadImgUrl > implements ContactHeadImgUrlRepository { @ Override public Map < String , String > queryHeadImgUrl ( List < String > usrNames ) { Wrapper < ContactHeadImgUrl > wrapper = Wrappers . < ContactHeadImgUrl > lambdaQuery ( ) . select ( ContactHeadImgUrl :: getUsrName , ContactHeadImgUrl :: getSmallHeadImgUrl ) . in ( ContactHeadImgUrl :: getUsrName , usrNames ) ; return Optional . ofNullable ( super . list ( wrapper ) ) . map ( headImgUrls -> headImgUrls . stream ( ) . collect ( Collectors . toMap ( ContactHeadImgUrl :: getUsrName , ContactHeadImgUrl :: getSmallHeadImgUrl ) ) ) . orElse ( Collections . emptyMap ( ) ) ; } @ Override public String queryHeadImgUrlByUserName ( String userName ) { Wrapper < ContactHeadImgUrl > wrapper = Wrappers . < ContactHeadImgUrl > lambdaQuery ( ) . select ( ContactHeadImgUrl :: getUsrName , ContactHeadImgUrl :: getSmallHeadImgUrl ) . eq ( ContactHeadImgUrl :: getUsrName , userName ) ; return Optional . ofNullable ( super . getOne ( wrapper ) ) . map ( ContactHeadImgUrl :: getSmallHeadImgUrl ) . orElse ( null ) ; }", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class WeAppInfoVO { private String title ; private String sourceDisplayName ; private String weAppIconUrl ; private String weAppPageThumbRawUrl ;", "output": "}"}, {"input": "package top . kangert . kspider . controller ; import top . kangert . kspider . controller . BaseController ; import top . kangert . kspider . domain . Function ; import top . kangert . kspider . service . FunctionService ; import top . kangert . kspider . util . BaseResponse ; import top . kangert . kspider . util . PageInfo ; import java . util . Map ; import javax . annotation . Resource ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class FunctionController extends BaseController { @ Resource private FunctionService functionService ; @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse quryFunc ( @ RequestBody Map < String , Object > params ) { PageInfo < Function > pageInfo = functionService . queryItems ( params ) ; return successResponse ( pageInfo ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse addFunc ( @ RequestBody Map < String , Object > params ) { functionService . addItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse editFunc ( @ RequestBody Map < String , Object > params ) { functionService . editItem ( params ) ; return successResponse ( ) ;", "output": "} @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse delFunc ( @ RequestBody Map < String , Object > params ) { functionService . deleteItem ( params ) ; return successResponse ( ) ; } }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class Question implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; private Integer quType ; private String image ; private String content ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; private String analysis ; private Integer repoId ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) {", "output": "this . isDeleted = isDeleted ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getQuType ( ) { return quType ; } public void setQuType ( Integer quType ) { this . quType = quType ; } public String getImage ( ) { return image ; } public void setImage ( String image ) { this . image = image ; } public String getContent ( ) { return content ; } public void setContent ( String content ) { this . content = content ; } public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } public String getAnalysis ( ) { return analysis ; } public void setAnalysis ( String analysis ) { this . analysis = analysis ; } public Integer getRepoId ( ) { return repoId ; } public void setRepoId ( Integer repoId ) { this . repoId = repoId ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + quType + \"<STR_LIT>\" + image + '<STR_LIT>' + \"<STR_LIT>\" + content + '<STR_LIT>' + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" + analysis + '<STR_LIT>' + \"<STR_LIT>\" + repoId + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package cn . org . alan . exam . model . vo . answer ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class UncorrectedUserVO { private Integer userId ; private String userName ; private String examTitle ; private Integer examId ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime limitTime ; private String corrected ;", "output": "}"}, {"input": "package com . youlai . system . enums ; import com . youlai . system . common . base . IBaseEnum ; import lombok . Getter ; public enum StatusEnum implements IBaseEnum < Integer > { ENABLE ( <NUM_LIT> , \"<STR_LIT>\" ) , DISABLE ( <NUM_LIT> , \"<STR_LIT>\" ) ; @ Getter private Integer value ; @ Getter private String label ; StatusEnum ( Integer value , String label ) { this . value = value ; this . label = label ;", "output": "} }"}, {"input": "package top . kangert . kspider . executor . function . extension ; import org . openqa . selenium . OutputType ; import org . openqa . selenium . WebElement ; import org . springframework . stereotype . Component ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; @ Component public class WebElementFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return WebElement . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static WebElement sendKeys ( WebElement element , String keys ) { element . sendKeys ( keys ) ; return element ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String html ( WebElement element ) { return element . getAttribute ( \"<STR_LIT>\" ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String text ( WebElement element ) { return element . getText ( ) ; }", "output": "@ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String attr ( WebElement element , String attributeName ) { return element . getAttribute ( attributeName ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] screenshot ( WebElement element ) { return element . getScreenshotAs ( OutputType . BYTES ) ; } }"}, {"input": "package org . springblade . config . market ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . constant . CoinhouseConfig ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . utils . DateUtil ; import org . springblade . core . tool . utils . Func ; import java . util . Calendar ; import java . util . Date ; import java . util . List ; import java . util . Map ; @ Slf4j public class MarketKlineUtils { private static KlineTimeModel preKlineTimeModel ; private static String [ ] PERIOD_HUOBI = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static String [ ] PERIOD_BINANCE = { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; public static String [ ] getKLinePeriodStr ( String jysName ) { if ( jysName . equals ( MarketConstant . MARKET_JYS_HUOBI ) ) { return PERIOD_HUOBI ; } else if ( jysName . equals ( MarketConstant . MARKET_JYS_BINANCE ) ) { return PERIOD_BINANCE ; } else { return null ; } } public static Integer clientId = <NUM_LIT> ; public static synchronized Integer getMaxClientId ( ) { ++ clientId ; return clientId ; } public static String getNowJys ( ) { return CoinhouseConfig . getMarketJysName ( ) ; } public static String getHuobiPeriod ( String period ) { if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } return period ; } public static String getBinancePeriod ( String period ) { if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } else if ( Func . equals ( period , \"<STR_LIT>\" ) ) { period = \"<STR_LIT>\" ; } return period ; } public static String getNowUseJys ( String type , String symbolName ) { try { if ( ! Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_XH_TYPE ) ) { return CoinhouseConfig . getMarketJysName ( ) ; } BladeRedis bladeRedis = SpringContextUtils . getBean ( BladeRedis . class ) ; String redisKey = \"<STR_LIT>\" + symbolName ; if ( bladeRedis . exists ( redisKey ) ) { Object result = bladeRedis . get ( redisKey ) ; return Func . toStr ( result ) ; } IMjkjBaseSqlService mjkjBaseSqlService = SpringContextUtils . getBean ( IMjkjBaseSqlService . class ) ; Map < String , Object > dataMap = mjkjBaseSqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , symbolName ) ; String exchangeType = MjkjUtils . getMap2Str ( dataMap , \"<STR_LIT>\" ) ; if ( Func . equals ( exchangeType , \"<STR_LIT>\" ) ) { bladeRedis . setEx ( redisKey , MarketConstant . MARKET_JYS_COINHOUSE , <NUM_LIT> ) ; return MarketConstant . MARKET_JYS_COINHOUSE ; } bladeRedis . setEx ( redisKey , CoinhouseConfig . getMarketJysName ( ) , <NUM_LIT> ) ; } catch ( Exception e ) { log . info ( \"<STR_LIT>\" + e . getMessage ( ) ) ; e . printStackTrace ( ) ; }", "output": "return CoinhouseConfig . getMarketJysName ( ) ; } public static String getKLineMongdbKey ( String type , String symbolName , String period ) { String jys = getNowUseJys ( type , symbolName ) ; String startTitle = \"<STR_LIT>\" ; if ( Func . equals ( jys . toUpperCase ( ) , MarketConstant . MARKET_JYS_HUOBI ) ) { startTitle = \"<STR_LIT>\" ; } else if ( Func . equals ( jys . toUpperCase ( ) , MarketConstant . MARKET_JYS_BINANCE ) ) { startTitle = \"<STR_LIT>\" ; } else if ( Func . equals ( jys . toUpperCase ( ) , MarketConstant . MARKET_JYS_COINHOUSE ) ) { startTitle = \"<STR_LIT>\" ; } String symbolNameTmp = symbolName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String mangodbkey = \"<STR_LIT>\" ; if ( Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_XH_TYPE ) ) { mangodbkey = String . format ( startTitle + \"<STR_LIT>\" , symbolNameTmp , period ) . toLowerCase ( ) ; } else if ( Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_BBW_TYPE ) ) { mangodbkey = String . format ( startTitle + \"<STR_LIT>\" , symbolNameTmp , period ) . toLowerCase ( ) ; } else if ( Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_UBW_TYPE ) ) { mangodbkey = String . format ( startTitle + \"<STR_LIT>\" , symbolNameTmp , period ) . toLowerCase ( ) ; } return mangodbkey ; } public static String getDetailMongdbKey ( String type , String symbolName ) { String jys = getNowUseJys ( type , symbolName ) ; String startTitle = \"<STR_LIT>\" ; if ( Func . equals ( jys . toUpperCase ( ) , MarketConstant . MARKET_JYS_HUOBI ) ) { startTitle = \"<STR_LIT>\" ; } else if ( Func . equals ( jys . toUpperCase ( ) , MarketConstant . MARKET_JYS_BINANCE ) ) { startTitle = \"<STR_LIT>\" ; } else if ( Func . equals ( jys . toUpperCase ( ) , MarketConstant . MARKET_JYS_COINHOUSE ) ) { startTitle = \"<STR_LIT>\" ; } symbolName = symbolName . replaceAll ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String mangodbkey = \"<STR_LIT>\" ; if ( Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_XH_TYPE ) ) { mangodbkey = String . format ( startTitle + \"<STR_LIT>\" , symbolName ) . toLowerCase ( ) ; } else if ( Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_BBW_TYPE ) ) { mangodbkey = String . format ( startTitle + \"<STR_LIT>\" , symbolName ) . toLowerCase ( ) ; } else if ( Func . equals ( type . toUpperCase ( ) , MarketConstant . MARKET_UBW_TYPE ) ) { mangodbkey = String . format ( startTitle + \"<STR_LIT>\" , symbolName ) . toLowerCase ( ) ; } return mangodbkey ; } public synchronized static KlineTimeModel getKlineTime ( ) { Date now = DateUtil . now ( ) ; return getKlineTime ( now ) ; } public synchronized static KlineTimeModel getKlineTime ( Date now ) { Long min1 = get1Min ( now ) ; if ( Func . isNotEmpty ( preKlineTimeModel ) ) { Long preMin1 = preKlineTimeModel . getMin1 ( ) ; if ( Func . isNotEmpty ( preMin1 ) ) { if ( preMin1 . longValue ( ) == min1 . longValue ( ) ) { return preKlineTimeModel ; } } } KlineTimeModel model = new KlineTimeModel ( ) ; model . setMin1 ( min1 ) ; model . setMin5 ( get5Min ( now ) ) ; model . setMin15 ( get15Min ( now ) ) ; model . setMin30 ( get30Min ( now ) ) ; model . setMin60 ( get1Hour ( now ) ) ; model . setHour4 ( get4Hour ( now ) ) ; model . setDay1 ( get1Day ( now ) ) ; model . setWeek1 ( get1Week ( now ) ) ; model . setMon1 ( get1Month ( now ) ) ; preKlineTimeModel = model ; return model ; } private static Calendar getCalendar ( Date now ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( now ) ; return calendar ; } private static Long get1Min ( Date now ) { try { Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get5Min ( Date now ) { try { String mmStr = DateUtil . format ( now , \"<STR_LIT>\" ) ; int nowmm = Func . toInt ( mmStr ) ; Integer [ ] mms = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; for ( Integer mm : mms ) { if ( nowmm >= mm ) { nowmm = mm ; break ; } } Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . MINUTE , nowmm ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get15Min ( Date now ) { try { String mmStr = DateUtil . format ( now , \"<STR_LIT>\" ) ; int nowmm = Func . toInt ( mmStr ) ; Integer [ ] mms = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; for ( Integer mm : mms ) { if ( nowmm >= mm ) { nowmm = mm ; break ; } } Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . MINUTE , nowmm ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get30Min ( Date now ) { try { String mmStr = DateUtil . format ( now , \"<STR_LIT>\" ) ; int nowmm = Func . toInt ( mmStr ) ; Integer [ ] mms = { <NUM_LIT> , <NUM_LIT> } ; for ( Integer mm : mms ) { if ( nowmm >= mm ) { nowmm = mm ; break ; } } Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . MINUTE , nowmm ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get1Hour ( Date now ) { try { Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get4Hour ( Date now ) { try { String hhStr = DateUtil . format ( now , \"<STR_LIT>\" ) ; int nowhh = Func . toInt ( hhStr ) ; Integer [ ] hhs = { <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> } ; for ( Integer hh : hhs ) { if ( nowhh >= hh ) { nowhh = hh ; break ; } } Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . HOUR_OF_DAY , nowhh ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get1Day ( Date now ) { try { Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; calendar . set ( Calendar . HOUR_OF_DAY , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get1Week ( Date now ) { try { Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . DAY_OF_WEEK , <NUM_LIT> ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; calendar . set ( Calendar . HOUR_OF_DAY , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } private static Long get1Month ( Date now ) { try { Calendar calendar = getCalendar ( now ) ; calendar . set ( Calendar . DAY_OF_MONTH , <NUM_LIT> ) ; calendar . set ( Calendar . SECOND , <NUM_LIT> ) ; calendar . set ( Calendar . MINUTE , <NUM_LIT> ) ; calendar . set ( Calendar . HOUR_OF_DAY , <NUM_LIT> ) ; Date time = calendar . getTime ( ) ; Long result = time . getTime ( ) / <NUM_LIT> ; return result ; } catch ( Exception e ) { } return <NUM_LIT> ; } }"}, {"input": "package org . springblade . cgform . controller ; import com . alibaba . fastjson . JSON ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . github . xiaoymin . knife4j . annotations . ApiOperationSupport ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import io . swagger . annotations . ApiParam ; import lombok . AllArgsConstructor ; import org . apache . commons . beanutils . PropertyUtils ; import org . springblade . config . util . SqlInjectionUtil ; import org . springblade . cgform . entity . * ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . * ; import org . springblade . core . boot . ctrl . BladeController ; import org . springblade . core . tool . api . R ; import org . springblade . core . tool . utils . Func ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletRequest ; import java . util . List ; import java . util . Properties ; @ RestController @ AllArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( value = \"<STR_LIT>\" , tags = \"<STR_LIT>\" ) public class SystemController extends BladeController { private final IDictService dictService ; private final IMjkjBaseSqlService mjkjBaseSqlService ; @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R loadDictItem ( @ PathVariable String dictCode , @ RequestParam ( name = \"<STR_LIT>\" ) String keys , HttpServletRequest request ) { if ( dictCode . indexOf ( \"<STR_LIT>\" ) == - <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length != <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } List < String > list = dictService . queryTableDictByKeys ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , keys ) ; return R . data ( list ) ; } @ ApiOperationSupport ( order = <NUM_LIT> ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) @ RequestMapping ( value = \"<STR_LIT>\" , method = RequestMethod . GET ) public R < List < DictModel > > getDictItems ( @ PathVariable String dictCode , HttpServletRequest request ) { List < DictModel > resultList = null ; try { if ( dictCode . indexOf ( \"<STR_LIT>\" ) != - <NUM_LIT> ) { String [ ] params = dictCode . split ( \"<STR_LIT>\" ) ; if ( params . length < <NUM_LIT> ) { return R . fail ( \"<STR_LIT>\" ) ; } final String [ ] sqlInjCheck = { params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] } ; SqlInjectionUtil . filterContent ( sqlInjCheck ) ; if ( params . length == <NUM_LIT> ) { SqlInjectionUtil . specialFilterContent ( params [ <NUM_LIT> ] ) ; resultList = dictService . queryTableDictItemsByCodeAndFilter ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else if ( params . length == <NUM_LIT> ) { resultList = dictService . queryTableDictItemsByCode ( params [ <NUM_LIT> ] , params [ <NUM_LIT> ] , params [ <NUM_LIT> ] ) ; } else { return R . fail ( \"<STR_LIT>\" ) ; } } else { resultList = dictService . queryDictItemsByCode ( dictCode ) ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; if ( Func . isEmpty ( property ) || ! Func . equals ( property , \"<STR_LIT>\" ) ) { if ( Func . isNotEmpty ( resultList ) && ! Func . equals ( \"<STR_LIT>\" , dictCode ) ) { for ( DictModel model : resultList ) { String title = model . getTitle ( ) ; String language = mjkjBaseSqlService . getMngLanguage ( title ) ; model . setText ( language ) ; model . setLabel ( language ) ; model . setText ( language ) ; } } }", "output": "} catch ( Exception e ) { return R . fail ( \"<STR_LIT>\" ) ; } return R . data ( resultList ) ; } private String getCheckRuleId ( CheckRule item ) { try { return PropertyUtils . getProperty ( item , \"<STR_LIT>\" ) . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } }"}, {"input": "package org . springblade . common . launch ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . common . constant . LauncherConstant ; import org . springblade . core . auto . service . AutoService ; import org . springblade . core . launch . constant . NacosConstant ; import org . springblade . core . launch . service . LauncherService ; import org . springblade . core . launch . utils . PropsUtil ; import org . springframework . boot . builder . SpringApplicationBuilder ; import java . util . Map ; import java . util . Properties ; @ Slf4j @ AutoService ( LauncherService . class ) public class LauncherServiceImpl implements LauncherService { @ Override public void launcher ( SpringApplicationBuilder builder , String appName , String profile , boolean isLocalDev ) { Properties props = System . getProperties ( ) ; Map < String , String > maps = System . getenv ( ) ; String nacosUrl = \"<STR_LIT>\" ; String elkUrl = \"<STR_LIT>\" ; log . info ( \"<STR_LIT>\" ) ; for ( String key : maps . keySet ( ) ) { String val = maps . get ( key ) ; if ( StringUtils . isNotEmpty ( val ) ) { if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; nacosUrl = val ; } else if ( key . equals ( \"<STR_LIT>\" ) ) { log . error ( \"<STR_LIT>\" + key + \"<STR_LIT>\" + val ) ; elkUrl = val ; } } } if ( StringUtils . isEmpty ( nacosUrl ) ) { nacosUrl = LauncherConstant . nacosAddr ( profile ) ; }", "output": "if ( StringUtils . isEmpty ( elkUrl ) ) { elkUrl = LauncherConstant . elkAddr ( profile ) ; } PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , nacosUrl ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; String GROUP_STR = \"<STR_LIT>\" ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , appName ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , NacosConstant . sharedDataId ( profile ) ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , GROUP_STR ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; PropsUtil . setProperty ( props , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } }"}, {"input": "package com . youlai . system . model . dto ; import com . alibaba . excel . annotation . ExcelProperty ; import com . alibaba . excel . annotation . format . DateTimeFormat ; import com . alibaba . excel . annotation . write . style . ColumnWidth ; import lombok . Data ; import java . time . LocalDateTime ; @ Data @ ColumnWidth ( <NUM_LIT> ) public class UserExportDTO { @ ExcelProperty ( value = \"<STR_LIT>\" ) private String username ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String nickname ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String gender ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String mobile ; @ ExcelProperty ( value = \"<STR_LIT>\" ) private String email ; @ ExcelProperty ( value = \"<STR_LIT>\" ) @ DateTimeFormat ( \"<STR_LIT>\" ) private LocalDateTime createTime ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . config . util . log ; import com . alibaba . nacos . api . common . Constants ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . client . config . utils . ConcurrentDiskUtil ; import com . alibaba . nacos . client . config . utils . JvmUtil ; import com . alibaba . nacos . client . logging . NacosLogging ; import com . alibaba . nacos . client . utils . LogUtils ; import com . alibaba . nacos . common . utils . IoUtils ; import com . alibaba . nacos . common . utils . StringUtils ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . config . util . NacosConfigLoader ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . slf4j . Logger ; import org . springframework . boot . context . logging . LoggingApplicationListener ; import org . springframework . boot . logging . LoggingInitializationContext ; import org . springframework . boot . logging . LoggingSystem ; import org . springframework . boot . logging . LoggingSystemFactory ; import org . springframework . core . env . ConfigurableEnvironment ; import java . io . File ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Properties ; import java . util . function . Function ; public class LogAutoFreshProcess { private static final Logger LOGGER = LogUtils . logger ( LogAutoFreshProcess . class ) ; private final NacosConfigProperties nacosConfigProperties ; private final ConfigurableEnvironment environment ; private final NacosConfigLoader nacosConfigLoader ; private final Function < Properties , ConfigService > builder ; private static final List < String > LOG_DATA_ID = new ArrayList < > ( ) ; private static final String LOG_CACHE_BASE = System . getProperty ( \"<STR_LIT>\" , System . getProperty ( \"<STR_LIT>\" ) ) + File . separator + \"<STR_LIT>\" + File . separator + \"<STR_LIT>\" ; static { LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; LOG_DATA_ID . add ( \"<STR_LIT>\" ) ; } public static LogAutoFreshProcess build ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { return new LogAutoFreshProcess ( environment , nacosConfigProperties , nacosConfigLoader , builder ) ; } private LogAutoFreshProcess ( ConfigurableEnvironment environment , NacosConfigProperties nacosConfigProperties , NacosConfigLoader nacosConfigLoader , Function < Properties , ConfigService > builder ) { this . nacosConfigProperties = nacosConfigProperties ; this . environment = environment ; this . nacosConfigLoader = nacosConfigLoader ; this . builder = builder ; } public void process ( ) { final String groupName = environment . resolvePlaceholders ( nacosConfigProperties . getGroup ( ) ) ; ConfigService configService = builder . apply ( nacosConfigLoader . getGlobalProperties ( ) ) ; for ( String dataId : LOG_DATA_ID ) { String content = NacosUtils . getContent ( configService , dataId , groupName ) ; if ( StringUtils . isNotBlank ( content ) ) { writeLogFile ( content , dataId ) ; System . setProperty ( LoggingApplicationListener . CONFIG_PROPERTY , LOG_CACHE_BASE + File . separator + dataId ) ; registerListener ( configService , dataId , groupName ) ; return ; } } } private void registerListener ( ConfigService configService , String dataId , String groupName ) {", "output": "try { configService . addListener ( dataId , groupName , new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String configInfo ) { if ( StringUtils . isNotBlank ( configInfo ) ) { writeLogFile ( configInfo , dataId ) ; reloadConfig ( LOG_CACHE_BASE + File . separator + dataId ) ; } } } ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId , e ) ; } } private void writeLogFile ( String content , String dataId ) { File file = new File ( LOG_CACHE_BASE , dataId ) ; File parentFile = file . getParentFile ( ) ; if ( ! parentFile . exists ( ) ) { boolean isMdOk = parentFile . mkdirs ( ) ; if ( ! isMdOk ) { LOGGER . error ( \"<STR_LIT>\" ) ; } } try { if ( JvmUtil . isMultiInstance ( ) ) { ConcurrentDiskUtil . writeFileContent ( file , content , Constants . ENCODE ) ; } else { IoUtils . writeStringToFile ( file , content , Constants . ENCODE ) ; } } catch ( IOException e ) { throw new RuntimeException ( \"<STR_LIT>\" ) ; } } private void reloadConfig ( String logPath ) { LoggingSystem loggingSystem = LoggingSystemFactory . fromSpringFactories ( ) . getLoggingSystem ( this . getClass ( ) . getClassLoader ( ) ) ; loggingSystem . cleanUp ( ) ; loggingSystem . initialize ( new LoggingInitializationContext ( environment ) , logPath , null ) ; NacosLogging . getInstance ( ) . loadConfiguration ( ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) @ AllArgsConstructor @ NoArgsConstructor public class BaseStateReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > ids ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer state ;", "output": "}"}, {"input": "package cn . org . alan . exam . util ; import cn . org . alan . exam . util . CryptoUtils . Algorithm . Encryption ; import cn . org . alan . exam . util . CryptoUtils . Algorithm . Signing ; import org . apache . commons . lang3 . StringUtils ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . Getter ; import lombok . NoArgsConstructor ; import org . springframework . stereotype . Component ; import javax . crypto . Cipher ; import javax . crypto . KeyGenerator ; import javax . crypto . NoSuchPaddingException ; import javax . crypto . SecretKey ; import javax . crypto . spec . IvParameterSpec ; import javax . crypto . spec . SecretKeySpec ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . security . Key ; import java . security . KeyFactory ; import java . security . KeyPair ; import java . security . KeyPairGenerator ; import java . security . NoSuchAlgorithmException ; import java . security . PrivateKey ; import java . security . PublicKey ; import java . security . Signature ; import java . security . spec . InvalidKeySpecException ; import java . security . spec . KeySpec ; import java . security . spec . PKCS8EncodedKeySpec ; import java . security . spec . X509EncodedKeySpec ; import java . util . Base64 ; import java . util . Base64 . Decoder ; import java . util . Base64 . Encoder ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component public class CryptoUtils { private static final Charset DEFAULT_CHARSET = StandardCharsets . UTF_8 ; private static final Encoder BASE64_ENCODER = Base64 . getEncoder ( ) ; private static final Decoder BASE64_DECODER = Base64 . getDecoder ( ) ; private static final Map < Algorithm , KeyFactory > KEY_FACTORY_CACHE = new ConcurrentHashMap < > ( ) ; private static final Map < Algorithm , Cipher > CIPHER_CACHE = new HashMap < > ( ) ; public static String generateSymmetricKey ( Algorithm algorithm ) throws NoSuchAlgorithmException { KeyGenerator generator = KeyGenerator . getInstance ( algorithm . getName ( ) ) ; generator . init ( algorithm . getKeySize ( ) ) ; SecretKey secretKey = generator . generateKey ( ) ; return BASE64_ENCODER . encodeToString ( secretKey . getEncoded ( ) ) ; } public static AsymmetricKeyPair generateAsymmetricKeyPair ( Algorithm algorithm ) throws NoSuchAlgorithmException { KeyPairGenerator generator = KeyPairGenerator . getInstance ( algorithm . getName ( ) ) ; generator . initialize ( algorithm . getKeySize ( ) ) ; KeyPair keyPair = generator . generateKeyPair ( ) ; String publicKey = BASE64_ENCODER . encodeToString ( keyPair . getPublic ( ) . getEncoded ( ) ) ; String privateKey = BASE64_ENCODER . encodeToString ( keyPair . getPrivate ( ) . getEncoded ( ) ) ; return new AsymmetricKeyPair ( publicKey , privateKey ) ; } public static String encryptByRSA ( String publicKeyText , String plainText ) throws Exception { return encryptAsymmetrically ( publicKeyText , plainText , Encryption . RSA_ECB_PKCS1 ) ; } public static String decryptByRSA ( String privateKeyText , String ciphertext ) throws Exception { return decryptAsymmetrically ( privateKeyText , ciphertext , Encryption . RSA_ECB_PKCS1 ) ; } public static String signBySHA1WithDSA ( String privateKeyText , String msg ) throws Exception { return doSign ( privateKeyText , msg , Encryption . DSA , Signing . SHA1WithDSA ) ; } public static String signBySHA1WithRSA ( String privateKeyText , String msg ) throws Exception { return doSign ( privateKeyText , msg , Encryption . RSA_ECB_PKCS1 , Signing . SHA1WithRSA ) ; } public static String signBySHA256WithRSA ( String privateKeyText , String msg ) throws Exception { return doSign ( privateKeyText , msg , Encryption . RSA_ECB_PKCS1 , Signing . SHA256WithRSA ) ; } public static boolean verifyBySHA1WithDSA ( String publicKeyText , String msg , String signatureText ) throws Exception { return doVerify ( publicKeyText , msg , signatureText , Encryption . DSA , Signing . SHA1WithDSA ) ; } public static boolean verifyBySHA1WithRSA ( String publicKeyText , String msg , String signatureText ) throws Exception { return doVerify ( publicKeyText , msg , signatureText , Encryption . RSA_ECB_PKCS1 , Signing . SHA1WithRSA ) ; } public static boolean verifyBySHA256WithRSA ( String publicKeyText , String msg , String signatureText ) throws Exception { return doVerify ( publicKeyText , msg , signatureText , Encryption . RSA_ECB_PKCS1 , Signing . SHA256WithRSA ) ; } public static String encryptSymmetrically ( String secretKey , String iv , String plainText , Algorithm algorithm ) throws Exception { SecretKey key = decodeSymmetricKey ( secretKey , algorithm ) ; IvParameterSpec ivParameterSpec = StringUtils . isBlank ( iv ) ? null : decodeIv ( iv ) ; byte [ ] plainTextInBytes = plainText . getBytes ( DEFAULT_CHARSET ) ; byte [ ] ciphertextInBytes = transform ( algorithm , Cipher . ENCRYPT_MODE , key , ivParameterSpec , plainTextInBytes ) ; return BASE64_ENCODER . encodeToString ( ciphertextInBytes ) ; } public static String decryptSymmetrically ( String secretKey , String iv , String ciphertext , Algorithm algorithm ) throws Exception { SecretKey key = decodeSymmetricKey ( secretKey , algorithm ) ; IvParameterSpec ivParameterSpec = StringUtils . isBlank ( iv ) ? null : decodeIv ( iv ) ; byte [ ] ciphertextInBytes = BASE64_DECODER . decode ( ciphertext ) ; byte [ ] plainTextInBytes = transform ( algorithm , Cipher . DECRYPT_MODE , key , ivParameterSpec , ciphertextInBytes ) ; return new String ( plainTextInBytes , DEFAULT_CHARSET ) ; } public static String encryptAsymmetrically ( String publicKeyText , String plainText , Algorithm algorithm ) throws Exception { PublicKey publicKey = regeneratePublicKey ( publicKeyText , algorithm ) ; byte [ ] plainTextInBytes = plainText . getBytes ( DEFAULT_CHARSET ) ; byte [ ] ciphertextInBytes = transform ( algorithm , Cipher . ENCRYPT_MODE , publicKey , plainTextInBytes ) ; return BASE64_ENCODER . encodeToString ( ciphertextInBytes ) ; } public static String decryptAsymmetrically ( String privateKeyText , String ciphertext , Algorithm algorithm ) throws Exception { PrivateKey privateKey = regeneratePrivateKey ( privateKeyText , algorithm ) ; byte [ ] ciphertextInBytes = BASE64_DECODER . decode ( ciphertext ) ; byte [ ] plainTextInBytes = transform ( algorithm , Cipher . DECRYPT_MODE , privateKey , ciphertextInBytes ) ; return new String ( plainTextInBytes , DEFAULT_CHARSET ) ; } public static String doSign ( String privateKeyText , String msg , Algorithm encryptionAlgorithm , Algorithm signatureAlgorithm ) throws Exception { PrivateKey privateKey = regeneratePrivateKey ( privateKeyText , encryptionAlgorithm ) ; Signature signature = Signature . getInstance ( signatureAlgorithm . getName ( ) ) ; signature . initSign ( privateKey ) ; signature . update ( msg . getBytes ( DEFAULT_CHARSET ) ) ; byte [ ] signatureInBytes = signature . sign ( ) ; return BASE64_ENCODER . encodeToString ( signatureInBytes ) ; } public static boolean doVerify ( String publicKeyText , String msg , String signatureText , Algorithm encryptionAlgorithm , Algorithm signatureAlgorithm ) throws Exception { PublicKey publicKey = regeneratePublicKey ( publicKeyText , encryptionAlgorithm ) ; Signature signature = Signature . getInstance ( signatureAlgorithm . getName ( ) ) ; signature . initVerify ( publicKey ) ; signature . update ( msg . getBytes ( DEFAULT_CHARSET ) ) ; return signature . verify ( BASE64_DECODER . decode ( signatureText ) ) ; } private static SecretKey decodeSymmetricKey ( String secretKey , Algorithm algorithm ) { byte [ ] key = BASE64_DECODER . decode ( secretKey ) ; return new SecretKeySpec ( key , algorithm . getName ( ) ) ; } private static IvParameterSpec decodeIv ( String iv ) { byte [ ] ivInBytes = BASE64_DECODER . decode ( iv ) ; return new IvParameterSpec ( ivInBytes ) ; } private static PublicKey regeneratePublicKey ( String publicKeyText , Algorithm algorithm ) throws NoSuchAlgorithmException , InvalidKeySpecException { byte [ ] keyInBytes = BASE64_DECODER . decode ( publicKeyText ) ; KeyFactory keyFactory = getKeyFactory ( algorithm ) ; KeySpec publicKeySpec = new X509EncodedKeySpec ( keyInBytes ) ; PublicKey publicKey = keyFactory . generatePublic ( publicKeySpec ) ; return publicKey ; } private static PrivateKey regeneratePrivateKey ( String key , Algorithm algorithm ) throws Exception { byte [ ] keyInBytes = BASE64_DECODER . decode ( key ) ; KeyFactory keyFactory = getKeyFactory ( algorithm ) ; KeySpec privateKeySpec = new PKCS8EncodedKeySpec ( keyInBytes ) ; PrivateKey privateKey = keyFactory . generatePrivate ( privateKeySpec ) ; return privateKey ; } private static KeyFactory getKeyFactory ( Algorithm algorithm ) throws NoSuchAlgorithmException { KeyFactory keyFactory = KEY_FACTORY_CACHE . get ( algorithm ) ; if ( keyFactory == null ) { keyFactory = KeyFactory . getInstance ( algorithm . getName ( ) ) ; KEY_FACTORY_CACHE . put ( algorithm , keyFactory ) ; } return keyFactory ; } private static byte [ ] transform ( Algorithm algorithm , int mode , Key key , byte [ ] msg ) throws Exception { return transform ( algorithm , mode , key , null , msg ) ; } private static byte [ ] transform ( Algorithm algorithm , int mode , Key key , IvParameterSpec iv , byte [ ] msg ) throws Exception { Cipher cipher = CIPHER_CACHE . get ( algorithm ) ;", "output": "if ( cipher == null ) { synchronized ( CryptoUtils . class ) { if ( ( cipher = CIPHER_CACHE . get ( algorithm ) ) == null ) { cipher = determineWhichCipherToUse ( algorithm ) ; CIPHER_CACHE . put ( algorithm , cipher ) ; } cipher . init ( mode , key , iv ) ; return cipher . doFinal ( msg ) ; } } synchronized ( CryptoUtils . class ) { cipher . init ( mode , key , iv ) ; return cipher . doFinal ( msg ) ; } } private static Cipher determineWhichCipherToUse ( Algorithm algorithm ) throws NoSuchAlgorithmException , NoSuchPaddingException { Cipher cipher ; String transformation = algorithm . getTransformation ( ) ; if ( StringUtils . isNotEmpty ( transformation ) ) { cipher = Cipher . getInstance ( transformation ) ; } else { cipher = Cipher . getInstance ( algorithm . getName ( ) ) ; } return cipher ; } public static class Algorithm { public interface Encryption { Algorithm AES_ECB_PKCS5 = new Algorithm ( \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm AES_CBC_PKCS5 = new Algorithm ( \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm DES_ECB_PKCS5 = new Algorithm ( \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm DES_CBC_PKCS5 = new Algorithm ( \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm RSA_ECB_PKCS1 = new Algorithm ( \"<STR_LIT>\" , \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm DSA = new Algorithm ( \"<STR_LIT>\" , <NUM_LIT> ) ; } public interface Signing { Algorithm SHA1WithDSA = new Algorithm ( \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm SHA1WithRSA = new Algorithm ( \"<STR_LIT>\" , <NUM_LIT> ) ; Algorithm SHA256WithRSA = new Algorithm ( \"<STR_LIT>\" , <NUM_LIT> ) ; } @ Getter private String name ; @ Getter private String transformation ; @ Getter private int keySize ; public Algorithm ( String name , int keySize ) { this ( name , null , keySize ) ; } public Algorithm ( String name , String transformation , int keySize ) { this . name = name ; this . transformation = transformation ; this . keySize = keySize ; } } @ Data @ NoArgsConstructor @ AllArgsConstructor public static class AsymmetricKeyPair { private String publicKey ; private String privateKey ; } }"}, {"input": "package com . yf . system . modules . user . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . system . modules . user . dto . SysUserBindDTO ; import com . yf . system . modules . user . entity . SysUserBind ; import java . util . List ; public interface SysUserBindService extends IService < SysUserBind > { IPage < SysUserBindDTO > paging ( PagingReqDTO < SysUserBindDTO > reqDTO ) ;", "output": "void save ( boolean clear , String userId , String loginType , String openId ) ; void delete ( List < String > ids ) ; String findBind ( String loginType , String openId ) ; boolean hasBind ( String bindType , String openId ) ; }"}, {"input": "package cn . org . alan . exam . model . entity ; import com . baomidou . mybatisplus . annotation . * ; import jakarta . validation . constraints . NotBlank ; import jakarta . validation . constraints . NotNull ; import net . sf . jsqlparser . expression . MySQLGroupConcat ; import java . io . Serializable ; import java . time . LocalDateTime ; @ TableName ( \"<STR_LIT>\" ) public class Repo implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer id ; @ TableField ( fill = FieldFill . INSERT ) private Integer userId ; @ NotBlank ( message = \"<STR_LIT>\" ) private String title ; @ TableField ( fill = FieldFill . INSERT ) private LocalDateTime createTime ; private Integer isDeleted ; public Integer getIsDeleted ( ) { return isDeleted ; } public void setIsDeleted ( Integer isDeleted ) { this . isDeleted = isDeleted ; } public Integer getId ( ) { return id ; } public void setId ( Integer id ) { this . id = id ; } public Integer getUserId ( ) { return userId ; } public void setUserId ( Integer userId ) { this . userId = userId ; } public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; }", "output": "public LocalDateTime getCreateTime ( ) { return createTime ; } public void setCreateTime ( LocalDateTime createTime ) { this . createTime = createTime ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + id + \"<STR_LIT>\" + userId + \"<STR_LIT>\" + title + '<STR_LIT>' + \"<STR_LIT>\" + createTime + \"<STR_LIT>\" + isDeleted + '<STR_LIT>' ; } }"}, {"input": "package com . yf . base . api . api ; import com . yf . base . api . exception . ServiceException ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ NoArgsConstructor @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class ApiRest < T > { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String msg ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer code ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) protected T data ; public boolean isSuccess ( ) { return code . equals ( <NUM_LIT> ) ; } public ApiRest ( ServiceException error ) { this . code = error . getCode ( ) ;", "output": "this . msg = error . getMsg ( ) ; } public ApiRest ( ApiError error ) { this . code = error . getCode ( ) ; this . msg = error . msg ; } }"}, {"input": "package org . springblade . config . util . jsonschema ; import lombok . Data ; @ Data public class BaseColumn { private String title ; private String field ; public BaseColumn ( ) { } public BaseColumn ( String title , String field ) { this . title = title ; this . field = field ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . tools . time ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . commons . lang3 . time . FastDateFormat ; import java . text . ParseException ; import java . util . Date ; public class DateFormatUtil { public static final String PATTERN_ISO = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_SECOND = \"<STR_LIT>\" ; public static final String PATTERN_ISO_ON_DATE = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT = \"<STR_LIT>\" ; public static final String PATTERN_DEFAULT_ON_SECOND = \"<STR_LIT>\" ; public static final FastDateFormat ISO_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO ) ; public static final FastDateFormat ISO_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_SECOND ) ; public static final FastDateFormat ISO_ON_DATE_FORMAT = FastDateFormat . getInstance ( PATTERN_ISO_ON_DATE ) ; public static final FastDateFormat DEFAULT_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT ) ; public static final FastDateFormat DEFAULT_ON_SECOND_FORMAT = FastDateFormat . getInstance ( PATTERN_DEFAULT_ON_SECOND ) ; public static Date parseDate ( @ NotNull String pattern , @ NotNull String dateString ) throws ParseException { return FastDateFormat . getInstance ( pattern ) . parse ( dateString ) ; } public static String formatDate ( @ NotNull String pattern , @ NotNull Date date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDate ( @ NotNull String pattern , long date ) { return FastDateFormat . getInstance ( pattern ) . format ( date ) ; } public static String formatDuration ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDurationHMS ( endDate . getTime ( ) - startDate . getTime ( ) ) ; } public static String formatDuration ( long durationMillis ) { return DurationFormatUtils . formatDurationHMS ( durationMillis ) ; }", "output": "public static String formatDurationOnSecond ( @ NotNull Date startDate , @ NotNull Date endDate ) { return DurationFormatUtils . formatDuration ( endDate . getTime ( ) - startDate . getTime ( ) , \"<STR_LIT>\" ) ; } public static String formatDurationOnSecond ( long durationMillis ) { return DurationFormatUtils . formatDuration ( durationMillis , \"<STR_LIT>\" ) ; } public static String formatFriendlyTimeSpanByNow ( @ NotNull Date date ) { return formatFriendlyTimeSpanByNow ( date . getTime ( ) ) ; } public static String formatFriendlyTimeSpanByNow ( long timeStampMillis ) { long now = ClockUtil . currentTimeMillis ( ) ; long span = now - timeStampMillis ; if ( span < <NUM_LIT> ) { return String . format ( \"<STR_LIT>\" , timeStampMillis ) ; } if ( span < DateUtil . MILLIS_PER_SECOND ) { return \"<STR_LIT>\" ; } else if ( span < DateUtil . MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" , span / DateUtil . MILLIS_PER_SECOND ) ; } else if ( span < DateUtil . MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" , span / DateUtil . MILLIS_PER_MINUTE ) ; } long wee = DateUtil . beginOfDate ( new Date ( now ) ) . getTime ( ) ; if ( timeStampMillis >= wee ) { return String . format ( \"<STR_LIT>\" , timeStampMillis ) ; } else if ( timeStampMillis >= wee - DateUtil . MILLIS_PER_DAY ) { return String . format ( \"<STR_LIT>\" , timeStampMillis ) ; } else { return String . format ( \"<STR_LIT>\" , timeStampMillis ) ; } } }"}, {"input": "package top . kangert . kspider . expression ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; public class ExpressionGlobalVariables { private static Map < String , String > variables = new HashMap < > ( ) ; private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock ( ) ; public static void reset ( Map < String , String > map ) { Lock lock = readWriteLock . writeLock ( ) ; lock . lock ( ) ; try { variables . clear ( ) ; variables . putAll ( map ) ; } finally { lock . unlock ( ) ; } } public static void update ( String key , String value ) { Lock writeLock = readWriteLock . writeLock ( ) ; writeLock . lock ( ) ; try { Lock readLock = readWriteLock . readLock ( ) ; readLock . lock ( ) ; try { if ( variables . containsKey ( key ) ) {", "output": "variables . put ( key , value ) ; } } finally { readLock . unlock ( ) ; } } finally { writeLock . unlock ( ) ; } } public static Map < String , String > getVariables ( ) { Lock lock = readWriteLock . readLock ( ) ; lock . lock ( ) ; try { return variables ; } finally { lock . unlock ( ) ; } } }"}, {"input": "package ginyi . system . domain . model . dto ; import ginyi . common . swagger . AddGroup ; import ginyi . common . swagger . UpdateGroup ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Size ; import java . util . Date ; import java . util . List ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class RoleDto extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = UpdateGroup . class , message = \"<STR_LIT>\" ) private Long roleId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > roleIds ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class }", "output": ", message = \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String roleName ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String roleKey ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotNull ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) @ NotBlank ( groups = { AddGroup . class , UpdateGroup . class } , message = \"<STR_LIT>\" ) @ Size ( max = <NUM_LIT> , message = \"<STR_LIT>\" ) private String status ; @ ApiModelProperty ( \"<STR_LIT>\" ) private List < Long > permissions ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date beginTime ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Date endTime ; }"}, {"input": "package cn . org . alan . exam . model . vo ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class UserVO { private Integer id ; private String userName ; private String realName ; private String roleName ; private String password ; private String avatar ; private String gradeName ; private Integer userId ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private String status ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysDictItem extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dictId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String itemText ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String itemValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sortOrder ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; @ Data public class ChatRoomVO { private String chatRoomName ; private String chatRoomTitle ; private Integer isShowName ; private String selfDisplayName ; private String createBy ; private String headImgUrl ; private Boolean dissolution ; private Boolean enterprise ; @ JsonIgnore private byte [ ] roomData ; private Integer memberCount ;", "output": "}"}, {"input": "package com . yf . system . modules . plugin . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class PluginGroupDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String title ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Boolean single ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . websocket ; import lombok . Data ; @ Data public class SocketMsg { private String msg ; private MsgType msgType ; public SocketMsg ( String msg , MsgType msgType ) { this . msg = msg ;", "output": "this . msgType = msgType ; } }"}, {"input": "package me . zhengjie . modules . quartz . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . modules . quartz . domain . QuartzJob ; import me . zhengjie . modules . quartz . domain . vo . QuartzJobQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface QuartzJobMapper extends BaseMapper < QuartzJob > { IPage < QuartzJob > findAll ( @ Param ( \"<STR_LIT>\" ) QuartzJobQueryCriteria criteria , Page < Object > page ) ; List < QuartzJob > findAll ( @ Param ( \"<STR_LIT>\" ) QuartzJobQueryCriteria criteria ) ; List < QuartzJob > findByIsPauseIsFalse ( ) ;", "output": "}"}, {"input": "package org . springblade . cgform . model . file ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class FileRoleModel implements Serializable { private List < Long > fileIdList ; private List < Long > userList ; private List < Long > roleList ; private List < Long > deptList ;", "output": "}"}, {"input": "package ginyi . framework . security . service ; import eu . bitwalker . useragentutils . UserAgent ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . UserConstants ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . utils . ServletUtils ; import ginyi . common . utils . StringUtils ; import ginyi . common . utils . Constants ; import ginyi . common . utils . ip . AddressUtils ; import ginyi . common . utils . ip . IpUtils ; import ginyi . common . utils . uuid . IdUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . service . ITokenService ; import io . jsonwebtoken . Claims ; import io . jsonwebtoken . Jwts ; import io . jsonwebtoken . SignatureAlgorithm ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import javax . servlet . http . HttpServletRequest ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ Slf4j @ Service public class TokenServiceImpl implements ITokenService { @ Resource private RedisCache redisCache ; @ Resource private HttpServletRequest request ; @ Value ( \"<STR_LIT>\" ) private String header ; @ Value ( \"<STR_LIT>\" ) private String secret ; @ Value ( \"<STR_LIT>\" ) private int expireTime ; protected static final long MILLIS_SECOND = <NUM_LIT> ; protected static final long MILLIS_MINUTE = <NUM_LIT> * MILLIS_SECOND ; private static final Long MILLIS_MINUTE_TEN = <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ; private String createToken ( Map < String , Object > claims ) { String token = Jwts . builder ( ) . setClaims ( claims ) . signWith ( SignatureAlgorithm . HS512 , secret ) . compact ( ) ; return token ; } @ Override public String createToken ( LoginUser loginUser ) { String token = IdUtils . fastUUID ( ) ; loginUser . setToken ( token ) ; setUserAgent ( loginUser ) ; refreshToken ( loginUser ) ; Map < String , Object > claims = new HashMap < > ( ) ; claims . put ( Constants . LOGIN_USER_KEY , token ) ; return createToken ( claims ) ; } @ Override public LoginUser getLoginUser ( HttpServletRequest request ) { String token = getToken ( request ) ; if ( StringUtils . isNotEmpty ( token ) ) { try { Claims claims = parseToken ( token ) ; String uuid = ( String ) claims . get ( Constants . LOGIN_USER_KEY ) ; String userKey = getTokenKey ( uuid ) ; LoginUser user = redisCache . getCacheObject ( userKey , LoginUser . class ) ; request . setAttribute ( UserConstants . CURRENT_USER , user . getUsername ( ) ) ; return user ; } catch ( Exception e ) { } } return null ; } @ Override public void delLoginUser ( String token ) { if ( StringUtils . isNotEmpty ( token ) ) { String userKey = getTokenKey ( token ) ; redisCache . removeCacheObject ( userKey ) ; } } @ Override public void verifyToken ( LoginUser loginUser ) { long expireTime = loginUser . getExpireTime ( ) ; long currentTime = System . currentTimeMillis ( ) ; if ( expireTime - currentTime <= MILLIS_MINUTE_TEN ) { refreshToken ( loginUser ) ; }", "output": "} public void setUserAgent ( LoginUser loginUser ) { UserAgent userAgent = UserAgent . parseUserAgentString ( ServletUtils . getRequest ( ) . getHeader ( \"<STR_LIT>\" ) ) ; String ip = IpUtils . getIpAddr ( ServletUtils . getRequest ( ) ) ; loginUser . setIpaddr ( ip ) ; loginUser . setLoginLocation ( AddressUtils . getRealAddressByIP ( ip ) ) ; loginUser . setBrowser ( userAgent . getBrowser ( ) . getName ( ) ) ; loginUser . setOs ( userAgent . getOperatingSystem ( ) . getName ( ) ) ; } public void refreshToken ( LoginUser loginUser ) { loginUser . setLoginTime ( System . currentTimeMillis ( ) ) ; loginUser . setExpireTime ( loginUser . getLoginTime ( ) + expireTime * MILLIS_MINUTE ) ; String userKey = getTokenKey ( loginUser . getToken ( ) ) ; redisCache . setCacheObject ( userKey , loginUser , expireTime , TimeUnit . MINUTES ) ; } private String getTokenKey ( String uuid ) { return CacheConstants . LOGIN_TOKEN_KEY + uuid ; } private String getToken ( HttpServletRequest request ) { String token = request . getHeader ( header ) ; if ( StringUtils . isNotEmpty ( token ) && token . startsWith ( Constants . TOKEN_PREFIX ) ) { token = token . replace ( Constants . TOKEN_PREFIX , \"<STR_LIT>\" ) ; } return token ; } private Claims parseToken ( String token ) { return Jwts . parser ( ) . setSigningKey ( secret ) . parseClaimsJws ( token ) . getBody ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . metadata ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Properties ; public interface NacosServiceMetaData {", "output": "Properties getProperties ( ) ; }"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . dto . FeedsDTO ; import com . xcs . wx . domain . vo . FeedsVO ; import com . xcs . wx . domain . vo . PageVO ; public interface FeedsService { PageVO < FeedsVO > queryFeeds ( FeedsDTO feedsDTO ) ;", "output": "}"}, {"input": "package com . yf . system . modules . role . service . impl ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . fasterxml . jackson . core . type . TypeReference ; import com . yf . base . api . api . dto . PagingReqDTO ; import com . yf . base . api . exception . ServiceException ; import com . yf . base . utils . BeanMapper ; import com . yf . base . utils . jackson . JsonHelper ; import com . yf . system . modules . role . dto . SysRoleDTO ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . system . modules . role . mapper . SysRoleMapper ; import com . yf . system . modules . role . service . SysRoleService ; import com . yf . system . modules . user . UserUtils ; import org . apache . commons . lang3 . StringUtils ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class SysRoleServiceImpl extends ServiceImpl < SysRoleMapper , SysRole > implements SysRoleService { @ Override public IPage < SysRoleDTO > paging ( PagingReqDTO < SysRoleDTO > reqDTO ) { IPage < SysRole > query = reqDTO . toPage ( ) ; QueryWrapper < SysRole > wrapper = new QueryWrapper < > ( ) ; SysRoleDTO params = reqDTO . getParams ( ) ;", "output": "if ( params != null && StringUtils . isNotBlank ( params . getRoleName ( ) ) ) { wrapper . lambda ( ) . like ( SysRole :: getRoleName , params . getRoleName ( ) ) ; } IPage < SysRole > page = this . page ( query , wrapper ) ; IPage < SysRoleDTO > pageData = JsonHelper . parseObject ( page , new TypeReference < Page < SysRoleDTO > > ( ) { } ) ; return pageData ; } @ Override public int findMaxLevel ( List < String > ids ) { QueryWrapper < SysRole > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysRole :: getId , ids ) ; List < SysRole > list = this . list ( wrapper ) ; int level = <NUM_LIT> ; for ( SysRole role : list ) { if ( level < role . getRoleLevel ( ) ) { level = role . getRoleLevel ( ) ; } } return level ; } @ Override public void save ( SysRoleDTO reqDTO ) { int myLevel = UserUtils . getRoleLevel ( ) ; if ( reqDTO . getRoleLevel ( ) >= myLevel ) { throw new ServiceException ( \"<STR_LIT>\" + myLevel + \"<STR_LIT>\" ) ; } SysRole entity = new SysRole ( ) ; if ( ! StringUtils . isBlank ( reqDTO . getId ( ) ) ) { SysRole ori = this . getById ( reqDTO . getId ( ) ) ; if ( ori != null ) { int level = ori . getRoleLevel ( ) ; if ( myLevel <= level ) { throw new ServiceException ( \"<STR_LIT>\" + myLevel + \"<STR_LIT>\" ) ; } } } BeanMapper . copy ( reqDTO , entity ) ; this . saveOrUpdate ( entity ) ; } @ Override public void delete ( List < String > ids ) { QueryWrapper < SysRole > wrapper = new QueryWrapper < > ( ) ; wrapper . lambda ( ) . in ( SysRole :: getId , ids ) . lt ( SysRole :: getRoleLevel , UserUtils . getRoleLevel ( ) ) ; long count = this . count ( wrapper ) ; if ( count < ids . size ( ) ) { throw new ServiceException ( \"<STR_LIT>\" + UserUtils . getRoleLevel ( ) ) ; } this . removeByIds ( ids ) ; } }"}, {"input": "package org . springblade . cgform . model . database ; import org . springblade . config . constant . MjjyConfig ; import org . springblade . config . db . DbConfig ; import org . springblade . cgform . model . database . util . DbConvertDef ; import org . springblade . cgform . model . generate . pojo . ColumnVo ; import org . springblade . cgform . model . generate . util . StringBoolUtil ; import lombok . extern . slf4j . Slf4j ; import org . apache . commons . lang . StringUtils ; import org . springblade . config . util . TableUtil ; import java . sql . * ; import java . text . MessageFormat ; import java . util . ArrayList ; import java . util . List ; @ Slf4j public class DbReadTableUtil { private static Connection conn ; private static Statement statement ; public static List < String > getTables ( ) throws SQLException { String format = null ; ArrayList < String > list = new ArrayList < String > ( <NUM_LIT> ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { format = MessageFormat . format ( DbConvertDef . MYSQL_TABLES_SQL , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { format = DbConvertDef . ORACLE_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) {", "output": "format = DbConvertDef . POSTGRESQL_TABLES_SQL ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { format = DbConvertDef . SQLSERVER_TABLES_SQL ; } log . debug ( \"<STR_LIT>\" + format ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( format ) ; while ( executeQuery . next ( ) ) { list . add ( executeQuery . getString ( <NUM_LIT> ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } return list ; } public static List < ColumnVo > getColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Connection conn = TableUtil . getConnection ( ) ; String databaseType = TableUtil . getDatabaseType ( conn ) ; DbReadTableUtil . statement = conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( databaseType . equals ( DbConvertDef . MYSQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , \"<STR_LIT>\" + MjjyConfig . getDatabaseSchema ( ) + \"<STR_LIT>\" ) ; } if ( databaseType . equals ( DbConvertDef . ORACLE . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( databaseType . equals ( DbConvertDef . POSTGRESQL . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( databaseType . equals ( DbConvertDef . SQLSERVER . toUpperCase ( ) ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } log . debug ( \"<STR_LIT>\" + s2 ) ; ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldName ( ) ) ; columnVo2 . setFieldType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; log . debug ( \"<STR_LIT>\" + columnVo2 . getFieldType ( ) ) ; columnVo2 . setPrecision ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setScale ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setCharmaxLength ( executeQuery . getString ( <NUM_LIT> ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException e ) { throw e ; } } ArrayList < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static List < ColumnVo > getOriginalColumns ( String tableName ) throws Exception { String s2 = null ; List < ColumnVo > list = new ArrayList < ColumnVo > ( ) ; try { Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { s2 = MessageFormat . format ( DbConvertDef . MYSQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( DbConfig . dbName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { s2 = MessageFormat . format ( DbConvertDef . ORACLE_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName . toUpperCase ( ) ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { s2 = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { s2 = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( s2 ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) <= <NUM_LIT> ) { throw new Exception ( \"<STR_LIT>\" ) ; } ColumnVo columnVo = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setScale ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo . getPrecision ( ) , columnVo . getScale ( ) ) ) ; columnVo . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo ) ; columnVo . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; log . debug ( \"<STR_LIT>\" + columnVo . getFieldName ( ) ) ; list . add ( columnVo ) ; while ( executeQuery . previous ( ) ) { ColumnVo columnVo2 = new ColumnVo ( ) ; if ( DbConfig . dbFiledConvert ) { columnVo2 . setFieldName ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; } else { columnVo2 . setFieldName ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ; } columnVo2 . setFieldDbName ( executeQuery . getString ( <NUM_LIT> ) . toUpperCase ( ) ) ; columnVo2 . setPrecision ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setScale ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setCharmaxLength ( StringBoolUtil . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setNullable ( StringBoolUtil . strBool ( executeQuery . getString ( <NUM_LIT> ) ) ) ; columnVo2 . setFieldType ( jdbc2JavaType ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) , columnVo2 . getPrecision ( ) , columnVo2 . getScale ( ) ) ) ; columnVo2 . setFieldDbType ( humpConver ( executeQuery . getString ( <NUM_LIT> ) . toLowerCase ( ) ) ) ; setAttributes ( columnVo2 ) ; columnVo2 . setFiledComment ( StringUtils . isBlank ( executeQuery . getString ( <NUM_LIT> ) ) ? columnVo2 . getFieldName ( ) : executeQuery . getString ( <NUM_LIT> ) ) ; list . add ( columnVo2 ) ; } log . debug ( \"<STR_LIT>\" ) ; } catch ( ClassNotFoundException | SQLException e ) { throw e ; } finally { try { if ( DbReadTableUtil . statement != null ) { DbReadTableUtil . statement . close ( ) ; DbReadTableUtil . statement = null ; System . gc ( ) ; } if ( DbReadTableUtil . conn != null ) { DbReadTableUtil . conn . close ( ) ; DbReadTableUtil . conn = null ; System . gc ( ) ; } } catch ( SQLException ex3 ) { throw ex3 ; } } List < ColumnVo > list2 = new ArrayList < ColumnVo > ( ) ; for ( int i = list . size ( ) - <NUM_LIT> ; i >= <NUM_LIT> ; -- i ) { list2 . add ( list . get ( i ) ) ; } return list2 ; } public static boolean isTableExist ( String tableName ) { String sql = null ; try { log . debug ( \"<STR_LIT>\" + DbConfig . driver ) ; Class . forName ( DbConfig . driver ) ; DbReadTableUtil . conn = DriverManager . getConnection ( DbConfig . url , DbConfig . username , DbConfig . password ) ; DbReadTableUtil . statement = DbReadTableUtil . conn . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; if ( DbConfig . dbType . equals ( DbConvertDef . MYSQL ) ) { sql = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + DbConfig . dbName + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . ORACLE ) ) { sql = \"<STR_LIT>\" + tableName . toUpperCase ( ) + \"<STR_LIT>\" ; } if ( DbConfig . dbType . equals ( DbConvertDef . POSTGRESQL ) ) { sql = MessageFormat . format ( DbConvertDef . POSTGRESQL_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) , StringBoolUtil . strToStr ( tableName ) ) ; } if ( DbConfig . dbType . equals ( DbConvertDef . SQLSERVER ) ) { sql = MessageFormat . format ( DbConvertDef . SQLSERVER_COLUMNS_SQL , StringBoolUtil . strToStr ( tableName ) ) ; } ResultSet executeQuery = DbReadTableUtil . statement . executeQuery ( sql ) ; executeQuery . last ( ) ; if ( executeQuery . getRow ( ) > <NUM_LIT> ) { return true ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } return false ; } private static String humpConver ( String s ) { return humpConver ( s , false ) ; } public static String humpConver ( String s , boolean upperInitials ) { String [ ] split = s . split ( \"<STR_LIT>\" ) ; s = \"<STR_LIT>\" ; for ( int i = <NUM_LIT> ; i < split . length ; ++ i ) { if ( i > <NUM_LIT> ) { String lowerCase = split [ i ] . toLowerCase ( ) ; s += lowerCase . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + lowerCase . substring ( <NUM_LIT> , lowerCase . length ( ) ) ; } else { s += split [ i ] . toLowerCase ( ) ; } } if ( upperInitials ) { s = s . substring ( <NUM_LIT> , <NUM_LIT> ) . toUpperCase ( ) + s . substring ( <NUM_LIT> ) ; } return s ; } private static void setAttributes ( ColumnVo columnVo ) { String fieldType = columnVo . getFieldType ( ) ; String scale = columnVo . getScale ( ) ; columnVo . setClassType ( \"<STR_LIT>\" ) ; if ( \"<STR_LIT>\" . equals ( columnVo . getNullable ( ) ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } if ( \"<STR_LIT>\" . equals ( fieldType ) || fieldType . contains ( \"<STR_LIT>\" ) ) { columnVo . setClassType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setClassType ( \"<STR_LIT>\" ) ; } else if ( fieldType . contains ( \"<STR_LIT>\" ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { if ( StringUtils . isNotBlank ( scale ) && Integer . parseInt ( scale ) > <NUM_LIT> ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } } else if ( \"<STR_LIT>\" . equals ( fieldType ) || \"<STR_LIT>\" . equals ( fieldType ) || \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } else if ( \"<STR_LIT>\" . equals ( fieldType ) ) { columnVo . setOptionType ( \"<STR_LIT>\" ) ; } } private static String jdbc2JavaType ( String type , String precision , String scale ) { if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { if ( StringUtils . isNotBlank ( scale ) && Integer . parseInt ( scale ) > <NUM_LIT> ) { type = \"<STR_LIT>\" ; } else if ( StringUtils . isNotBlank ( precision ) && Integer . parseInt ( precision ) > <NUM_LIT> ) { type = \"<STR_LIT>\" ; } else { type = \"<STR_LIT>\" ; } } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else if ( type . contains ( \"<STR_LIT>\" ) ) { type = \"<STR_LIT>\" ; } else { type = \"<STR_LIT>\" ; } return type ; } }"}, {"input": "package com . oddfar . campus . common . domain . event ; import lombok . Data ; import javax . servlet . http . HttpServletRequest ; import java . io . Serializable ; @ Data public class LogininforEvent implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; private String username ; private Long userId ; private String status ; private String message ; private HttpServletRequest request ; private Object [ ] args ;", "output": "}"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class ChatRoomInfo { @ TableId ( \"<STR_LIT>\" ) private String chatRoomName ; @ TableField ( \"<STR_LIT>\" ) private String announcement ; @ TableField ( \"<STR_LIT>\" ) private Integer infoVersion ; @ TableField ( \"<STR_LIT>\" ) private String announcementEditor ; @ TableField ( \"<STR_LIT>\" ) private Long announcementPublishTime ; @ TableField ( \"<STR_LIT>\" ) private Integer chatRoomStatus ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved1 ; @ TableField ( \"<STR_LIT>\" ) private String reserved2 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved3 ; @ TableField ( \"<STR_LIT>\" ) private String reserved4 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved5 ; @ TableField ( \"<STR_LIT>\" ) private String reserved6 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved7 ; @ TableField ( \"<STR_LIT>\" ) private String reserved8 ;", "output": "}"}, {"input": "package me . zhengjie . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) public class QiniuConfig implements Serializable { @ TableId ( \"<STR_LIT>\" ) private Long id ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String accessKey ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String secretKey ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String bucket ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String zone ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String host ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . * ; public class LongObjectHashMap < V > implements LongObjectMap < V > { public static final int DEFAULT_CAPACITY = <NUM_LIT> ; public static final float DEFAULT_LOAD_FACTOR = <NUM_LIT> ; private static final Object NULL_VALUE = new Object ( ) ; private int maxSize ; private final float loadFactor ; private long [ ] keys ; private V [ ] values ; private int size ; private int mask ; private final Set < Long > keySet = new KeySet ( ) ; private final Set < Entry < Long , V > > entrySet = new EntrySet ( ) ; private final Iterable < PrimitiveEntry < V > > entries = new Iterable < PrimitiveEntry < V > > ( ) { @ Override public Iterator < PrimitiveEntry < V > > iterator ( ) { return new PrimitiveIterator ( ) ; } } ; public LongObjectHashMap ( ) { this ( DEFAULT_CAPACITY , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity ) { this ( initialCapacity , DEFAULT_LOAD_FACTOR ) ; } public LongObjectHashMap ( int initialCapacity , float loadFactor ) { if ( loadFactor <= <NUM_LIT> || loadFactor > <NUM_LIT> ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } this . loadFactor = loadFactor ; int capacity = safeFindNextPositivePowerOfTwo ( initialCapacity ) ; mask = capacity - <NUM_LIT> ; keys = new long [ capacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ capacity ] ; values = temp ; maxSize = calcMaxSize ( capacity ) ; } private static < T > T toExternal ( T value ) { assert value != null : \"<STR_LIT>\" ; return value == NULL_VALUE ? null : value ; } @ SuppressWarnings ( \"<STR_LIT>\" ) private static < T > T toInternal ( T value ) { return value == null ? ( T ) NULL_VALUE : value ; } @ Override public V get ( long key ) { int index = indexOf ( key ) ; return index == - <NUM_LIT> ? null : toExternal ( values [ index ] ) ; } @ Override public V put ( long key , V value ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = key ; values [ index ] = toInternal ( value ) ; growSize ( ) ; return null ; } if ( keys [ index ] == key ) {", "output": "V previousValue = values [ index ] ; values [ index ] = toInternal ( value ) ; return toExternal ( previousValue ) ; } if ( ( index = probeNext ( index ) ) == startIndex ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } @ Override public void putAll ( Map < ? extends Long , ? extends V > sourceMap ) { if ( sourceMap instanceof LongObjectHashMap ) { @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectHashMap < V > source = ( LongObjectHashMap < V > ) sourceMap ; for ( int i = <NUM_LIT> ; i < source . values . length ; ++ i ) { V sourceValue = source . values [ i ] ; if ( sourceValue != null ) { put ( source . keys [ i ] , sourceValue ) ; } } return ; } for ( Entry < ? extends Long , ? extends V > entry : sourceMap . entrySet ( ) ) { put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } @ Override public V remove ( long key ) { int index = indexOf ( key ) ; if ( index == - <NUM_LIT> ) { return null ; } V prev = values [ index ] ; removeAt ( index ) ; return toExternal ( prev ) ; } @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == <NUM_LIT> ; } @ Override public void clear ( ) { Arrays . fill ( keys , <NUM_LIT> ) ; Arrays . fill ( values , null ) ; size = <NUM_LIT> ; } @ Override public boolean containsKey ( long key ) { return indexOf ( key ) >= <NUM_LIT> ; } @ Override public boolean containsValue ( Object value ) { @ SuppressWarnings ( \"<STR_LIT>\" ) V v1 = toInternal ( ( V ) value ) ; for ( V v2 : values ) { if ( v2 != null && v2 . equals ( v1 ) ) { return true ; } } return false ; } @ Override public Iterable < PrimitiveEntry < V > > entries ( ) { return entries ; } @ Override public Collection < V > values ( ) { return new AbstractCollection < V > ( ) { @ Override public Iterator < V > iterator ( ) { return new Iterator < V > ( ) { final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public V next ( ) { return iter . next ( ) . value ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @ Override public int size ( ) { return size ; } } ; } @ Override public int hashCode ( ) { int hash = size ; for ( long key : keys ) { hash ^= hashCode ( key ) ; } return hash ; } @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LongObjectMap ) ) { return false ; } @ SuppressWarnings ( \"<STR_LIT>\" ) LongObjectMap other = ( LongObjectMap ) obj ; if ( size != other . size ( ) ) { return false ; } for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { long key = keys [ i ] ; Object otherValue = other . get ( key ) ; if ( value == NULL_VALUE ) { if ( otherValue != null ) { return false ; } } else if ( ! value . equals ( otherValue ) ) { return false ; } } } return true ; } @ Override public boolean containsKey ( Object key ) { return containsKey ( objectToKey ( key ) ) ; } @ Override public V get ( Object key ) { return get ( objectToKey ( key ) ) ; } @ Override public V put ( Long key , V value ) { return put ( objectToKey ( key ) , value ) ; } @ Override public V remove ( Object key ) { return remove ( objectToKey ( key ) ) ; } @ Override public Set < Long > keySet ( ) { return keySet ; } @ Override public Set < Entry < Long , V > > entrySet ( ) { return entrySet ; } private long objectToKey ( Object key ) { return ( ( Long ) key ) . longValue ( ) ; } private int indexOf ( long key ) { int startIndex = hashIndex ( key ) ; int index = startIndex ; for ( ; ; ) { if ( values [ index ] == null ) { return - <NUM_LIT> ; } if ( key == keys [ index ] ) { return index ; } if ( ( index = probeNext ( index ) ) == startIndex ) { return - <NUM_LIT> ; } } } private int hashIndex ( long key ) { return hashCode ( key ) & mask ; } private static int hashCode ( long key ) { return ( int ) ( key ^ ( key > > > <NUM_LIT> ) ) ; } private int probeNext ( int index ) { return ( index + <NUM_LIT> ) & mask ; } private void growSize ( ) { size ++ ; if ( size > maxSize ) { if ( keys . length == Integer . MAX_VALUE ) { throw new IllegalStateException ( \"<STR_LIT>\" + size ) ; } rehash ( keys . length << <NUM_LIT> ) ; } } private boolean removeAt ( final int index ) { -- size ; keys [ index ] = <NUM_LIT> ; values [ index ] = null ; int nextFree = index ; int i = probeNext ( index ) ; for ( V value = values [ i ] ; value != null ; value = values [ i = probeNext ( i ) ] ) { long key = keys [ i ] ; int bucket = hashIndex ( key ) ; if ( i < bucket && ( bucket <= nextFree || nextFree <= i ) || bucket <= nextFree && nextFree <= i ) { keys [ nextFree ] = key ; values [ nextFree ] = value ; keys [ i ] = <NUM_LIT> ; values [ i ] = null ; nextFree = i ; } } return nextFree != index ; } private int calcMaxSize ( int capacity ) { int upperBound = capacity - <NUM_LIT> ; return Math . min ( upperBound , ( int ) ( capacity * loadFactor ) ) ; } private void rehash ( int newCapacity ) { long [ ] oldKeys = keys ; V [ ] oldVals = values ; keys = new long [ newCapacity ] ; @ SuppressWarnings ( { \"<STR_LIT>\" , \"<STR_LIT>\" } ) V [ ] temp = ( V [ ] ) new Object [ newCapacity ] ; values = temp ; maxSize = calcMaxSize ( newCapacity ) ; mask = newCapacity - <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < oldVals . length ; ++ i ) { V oldVal = oldVals [ i ] ; if ( oldVal != null ) { long oldKey = oldKeys [ i ] ; int index = hashIndex ( oldKey ) ; for ( ; ; ) { if ( values [ index ] == null ) { keys [ index ] = oldKey ; values [ index ] = oldVal ; break ; } index = probeNext ( index ) ; } } } } @ Override public String toString ( ) { if ( isEmpty ( ) ) { return \"<STR_LIT>\" ; } StringBuilder sb = new StringBuilder ( <NUM_LIT> * size ) ; sb . append ( '<STR_LIT>' ) ; boolean first = true ; for ( int i = <NUM_LIT> ; i < values . length ; ++ i ) { V value = values [ i ] ; if ( value != null ) { if ( ! first ) { sb . append ( \"<STR_LIT>\" ) ; } sb . append ( keyToString ( keys [ i ] ) ) . append ( '<STR_LIT>' ) . append ( value == this ? \"<STR_LIT>\" : toExternal ( value ) ) ; first = false ; } } return sb . append ( '<STR_LIT>' ) . toString ( ) ; } protected String keyToString ( long key ) { return Long . toString ( key ) ; } private final class EntrySet extends AbstractSet < Entry < Long , V > > { @ Override public Iterator < Entry < Long , V > > iterator ( ) { return new MapIterator ( ) ; } @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } } private final class KeySet extends AbstractSet < Long > { @ Override public int size ( ) { return LongObjectHashMap . this . size ( ) ; } @ Override public boolean contains ( Object o ) { return LongObjectHashMap . this . containsKey ( o ) ; } @ Override public boolean remove ( Object o ) { return LongObjectHashMap . this . remove ( o ) != null ; } @ Override public boolean retainAll ( Collection < ? > retainedKeys ) { boolean changed = false ; for ( Iterator < PrimitiveEntry < V > > iter = entries ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { PrimitiveEntry < V > entry = iter . next ( ) ; if ( ! retainedKeys . contains ( entry . key ( ) ) ) { changed = true ; iter . remove ( ) ; } } return changed ; } @ Override public void clear ( ) { LongObjectHashMap . this . clear ( ) ; } @ Override public Iterator < Long > iterator ( ) { return new Iterator < Long > ( ) { private final Iterator < Entry < Long , V > > iter = entrySet . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Long next ( ) { return iter . next ( ) . getKey ( ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } ; } } private final class PrimitiveIterator implements Iterator < PrimitiveEntry < V > > , PrimitiveEntry < V > { private int prevIndex = - <NUM_LIT> ; private int nextIndex = - <NUM_LIT> ; private int entryIndex = - <NUM_LIT> ; private void scanNext ( ) { while ( ++ nextIndex != values . length && values [ nextIndex ] == null ) { } } @ Override public boolean hasNext ( ) { if ( nextIndex == - <NUM_LIT> ) { scanNext ( ) ; } return nextIndex != values . length ; } @ Override public PrimitiveEntry < V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } prevIndex = nextIndex ; scanNext ( ) ; entryIndex = prevIndex ; return this ; } @ Override public void remove ( ) { if ( prevIndex == - <NUM_LIT> ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } if ( removeAt ( prevIndex ) ) { nextIndex = prevIndex ; } prevIndex = - <NUM_LIT> ; } @ Override public long key ( ) { return keys [ entryIndex ] ; } @ Override public V value ( ) { return toExternal ( values [ entryIndex ] ) ; } @ Override public void setValue ( V value ) { values [ entryIndex ] = toInternal ( value ) ; } } private final class MapIterator implements Iterator < Entry < Long , V > > { private final PrimitiveIterator iter = new PrimitiveIterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public Entry < Long , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } iter . next ( ) ; return new MapEntry ( iter . entryIndex ) ; } @ Override public void remove ( ) { iter . remove ( ) ; } } final class MapEntry implements Entry < Long , V > { private final int entryIndex ; MapEntry ( int entryIndex ) { this . entryIndex = entryIndex ; } @ Override public Long getKey ( ) { verifyExists ( ) ; return keys [ entryIndex ] ; } @ Override public V getValue ( ) { verifyExists ( ) ; return toExternal ( values [ entryIndex ] ) ; } @ Override public V setValue ( V value ) { verifyExists ( ) ; V prevValue = toExternal ( values [ entryIndex ] ) ; values [ entryIndex ] = toInternal ( value ) ; return prevValue ; } private void verifyExists ( ) { if ( values [ entryIndex ] == null ) { throw new IllegalStateException ( \"<STR_LIT>\" ) ; } } } public static int safeFindNextPositivePowerOfTwo ( final int value ) { return value <= <NUM_LIT> ? <NUM_LIT> : value >= <NUM_LIT> ? <NUM_LIT> : findNextPositivePowerOfTwo ( value ) ; } public static int findNextPositivePowerOfTwo ( final int value ) { assert value > Integer . MIN_VALUE && value < <NUM_LIT> ; return <NUM_LIT> << ( <NUM_LIT> - Integer . numberOfLeadingZeros ( value - <NUM_LIT> ) ) ; } }"}, {"input": "package com . oddfar . campus . business . controller ; import com . oddfar . campus . common . annotation . Anonymous ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . annotation . Log ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , appCode = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . BUSINESS ) @ Log public class TestController { private static final Logger LOGGER = LoggerFactory . getLogger ( TestController . class ) ; @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R test1 ( ) { return R . ok ( ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R test2 ( ) { return R . ok ( ) ; }", "output": "@ Anonymous @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R test3 ( ) { LOGGER . info ( \"<STR_LIT>\" ) ; return R . ok ( ) ; } }"}, {"input": "package com . youlai . system . config ; import cn . hutool . captcha . generator . CodeGenerator ; import cn . hutool . core . collection . CollectionUtil ; import com . youlai . system . common . constant . SecurityConstants ; import com . youlai . system . config . property . SecurityProperties ; import com . youlai . system . security . exception . MyAccessDeniedHandler ; import com . youlai . system . security . exception . MyAuthenticationEntryPoint ; import com . youlai . system . filter . JwtValidationFilter ; import com . youlai . system . filter . CaptchaValidationFilter ; import lombok . RequiredArgsConstructor ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . security . authentication . AuthenticationManager ; import org . springframework . security . config . annotation . authentication . configuration . AuthenticationConfiguration ; import org . springframework . security . config . annotation . method . configuration . EnableMethodSecurity ; import org . springframework . security . config . annotation . web . builders . HttpSecurity ; import org . springframework . security . config . annotation . web . configuration . EnableWebSecurity ; import org . springframework . security . config . annotation . web . configuration . WebSecurityCustomizer ; import org . springframework . security . config . annotation . web . configurers . AbstractHttpConfigurer ; import org . springframework . security . config . annotation . web . configurers . HeadersConfigurer ; import org . springframework . security . config . http . SessionCreationPolicy ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; import org . springframework . security . crypto . password . PasswordEncoder ; import org . springframework . security . web . SecurityFilterChain ; import org . springframework . security . web . authentication . UsernamePasswordAuthenticationFilter ; @ Configuration @ EnableWebSecurity @ EnableMethodSecurity @ RequiredArgsConstructor public class SecurityConfig { private final MyAuthenticationEntryPoint authenticationEntryPoint ; private final MyAccessDeniedHandler accessDeniedHandler ; private final RedisTemplate < String , Object > redisTemplate ; private final CodeGenerator codeGenerator ; private final SecurityProperties securityProperties ; @ Bean public SecurityFilterChain securityFilterChain ( HttpSecurity http ) throws Exception { http . authorizeHttpRequests ( requestMatcherRegistry -> requestMatcherRegistry . requestMatchers ( SecurityConstants . LOGIN_PATH ) . permitAll ( ) . anyRequest ( ) . authenticated ( ) ) . exceptionHandling ( httpSecurityExceptionHandlingConfigurer -> httpSecurityExceptionHandlingConfigurer . authenticationEntryPoint ( authenticationEntryPoint ) . accessDeniedHandler ( accessDeniedHandler ) ) . sessionManagement ( configurer -> configurer . sessionCreationPolicy ( SessionCreationPolicy . STATELESS ) ) . csrf ( AbstractHttpConfigurer :: disable ) . headers ( headers -> headers . frameOptions ( HeadersConfigurer . FrameOptionsConfig :: disable ) ) ; http . addFilterBefore ( new CaptchaValidationFilter ( redisTemplate , codeGenerator ) , UsernamePasswordAuthenticationFilter . class ) ; http . addFilterBefore ( new JwtValidationFilter ( redisTemplate , securityProperties . getJwt ( ) . getKey ( ) ) , UsernamePasswordAuthenticationFilter . class ) ;", "output": "return http . build ( ) ; } @ Bean public WebSecurityCustomizer webSecurityCustomizer ( ) { return ( web ) -> { if ( CollectionUtil . isNotEmpty ( securityProperties . getIgnoreUrls ( ) ) ) { web . ignoring ( ) . requestMatchers ( securityProperties . getIgnoreUrls ( ) . toArray ( new String [ <NUM_LIT> ] ) ) ; } } ; } @ Bean public PasswordEncoder passwordEncoder ( ) { return new BCryptPasswordEncoder ( ) ; } @ Bean public AuthenticationManager authenticationManager ( AuthenticationConfiguration authenticationConfiguration ) throws Exception { return authenticationConfiguration . getAuthenticationManager ( ) ; } }"}, {"input": "package top . kangert . kspider . exception ; public enum ExceptionCodes { SUCCESS ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , FAILED ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ARGUMENTS_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , FILE_UPLOAD_FAILED ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , OBJECT_IS_NULL ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , FILE_EXPORT_FAILED ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , BIND_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , REBIND_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CACHE_WRONG ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TOKEN_EXPIRE_TIME ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TOKEN_NON_EXISTENT ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , USER_LOGIN_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , KEY_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , DATE_FORMAT_WRONG ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , DB_DATA_WRONG ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , AI_TASK_NON_EXISTENT ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ENTITY_TRANFORM_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , SCRIPT_VALID_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , PARSE_JSON_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , WORD_ERROR ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , FILE_NOT_EXIST ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , CURRENT_TASK_RUN ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ; private int code ; public int getCode ( ) { return this . code ; } private String messageId ; public String getMessageId ( ) { return this . messageId ;", "output": "} private String message ; public String getMessage ( ) { return this . message ; } ExceptionCodes ( int code , String messageId , String message ) { this . code = code ; this . messageId = messageId ; this . message = message ; } }"}, {"input": "package com . xcs . wx . controller ; import org . springframework . stereotype . Controller ; import org . springframework . web . bind . annotation . RequestMapping ; @ Controller public class IndexController { @ RequestMapping ( value = { \"<STR_LIT>\" , \"<STR_LIT>\" }", "output": ") public String index ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package com . youlai . system . model . vo ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class TableColumnVO { @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String columnName ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String dataType ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String columnComment ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer characterMaximumLength ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer isPrimaryKey ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String isNullable ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String characterSetName ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String collationName ;", "output": "}"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeRefreshParam { private String symbolName ;", "output": "}"}, {"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelImportEnum { GET_VALUE_ERROR ( \"<STR_LIT>\" ) , VERIFY_ERROR ( \"<STR_LIT>\" ) ; private String msg ; ExcelImportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) {", "output": "return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } }"}, {"input": "package top . kangert . kspider . job ; import top . kangert . kspider . KspiderRuntime ; import top . kangert . kspider . config . SpiderConfig ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . context . SpiderContextHolder ; import top . kangert . kspider . context . SpiderJobContext ; import top . kangert . kspider . dao . SpiderTaskRepository ; import top . kangert . kspider . domain . SpiderFlow ; import top . kangert . kspider . domain . SpiderTask ; import top . kangert . kspider . enums . TaskStateEnum ; import top . kangert . kspider . service . SpiderFlowService ; import top . kangert . kspider . service . SpiderTaskService ; import lombok . extern . slf4j . Slf4j ; import org . quartz . JobDataMap ; import org . quartz . JobExecutionContext ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . scheduling . quartz . QuartzJobBean ; import org . springframework . stereotype . Component ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . lang . TypeReference ; import cn . hutool . json . JSONUtil ; import javax . annotation . Resource ; import java . io . FileNotFoundException ; import java . util . Date ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; @ Component @ Slf4j public class SpiderJob extends QuartzJobBean { private KspiderRuntime spider ; @ Resource private SpiderConfig spiderConfig ; @ Resource private SpiderTaskService spiderTaskService ; @ Resource private SpiderFlowService spiderFlowService ; @ Resource private SpiderTaskRepository spiderTaskRepository ; @ Autowired public void setSpider ( KspiderRuntime spider ) { this . spider = spider ; } private static Map < Long , SpiderContext > contextMap = new ConcurrentHashMap < > ( ) ; @ Override protected void executeInternal ( JobExecutionContext context ) { if ( spiderConfig . getJobEnabled ( ) ) { JobDataMap jobDataMap = context . getMergedJobDataMap ( ) ; SpiderTask spiderTask = ( SpiderTask ) jobDataMap . get ( Constants . QUARTZ_KSPIDER_FLOW_PARAM_NAME ) ; run ( spiderTask , context . getNextFireTime ( ) ) ; } } public void run ( Long taskId ) { run ( spiderTaskService . queryItem ( taskId ) , null ) ; } private void run ( SpiderTask task , Date nextTime ) { Date now = new Date ( ) ; SpiderFlow flow = spiderFlowService . queryItem ( task . getFlowId ( ) ) ; task . setRunState ( TaskStateEnum . TASK_RUNNING . getTypeCode ( ) ) ; spiderTaskRepository . save ( task ) ; SpiderJobContext context = null ; try { context = SpiderJobContext . create ( spiderConfig . getWorkspace ( ) , flow . getFlowId ( ) , task . getTaskId ( ) , false ) ; SpiderContextHolder . set ( context ) ; log . info ( \"<STR_LIT>\" , flow . getName ( ) , task . getTaskId ( ) ) ; contextMap . put ( task . getTaskId ( ) , context ) ; Map < String , Object > variables = JSONUtil . toBean ( task . getMatedata ( ) , new TypeReference < Map < String , Object > > ( ) { } , false ) ; variables . put ( \"<STR_LIT>\" , task . getTaskId ( ) ) ; spider . run ( flow , context , variables ) ; log . info ( \"<STR_LIT>\" , flow . getName ( ) , task . getTaskId ( ) , DateUtil . format ( nextTime , \"<STR_LIT>\" ) ) ; } catch ( FileNotFoundException e ) { log . error ( \"<STR_LIT>\" , e ) ; } catch ( Throwable t ) { log . error ( \"<STR_LIT>\" , flow . getName ( ) , task . getTaskId ( ) ) ; } finally { if ( context != null ) {", "output": "context . close ( ) ; } contextMap . remove ( task . getTaskId ( ) ) ; SpiderContextHolder . remove ( ) ; SpiderTask currentTask = spiderTaskRepository . findById ( task . getTaskId ( ) ) . get ( ) ; System . out . println ( task . getRunState ( ) ) ; if ( currentTask . getRunState ( ) == TaskStateEnum . TASK_RUNNING . getTypeCode ( ) ) { currentTask . setRunState ( TaskStateEnum . TASK_FINISHED . getTypeCode ( ) ) ; spiderTaskRepository . save ( currentTask ) ; } } spiderTaskService . executeCountIncrement ( task . getTaskId ( ) , now , nextTime ) ; } public static SpiderContext getSpiderContext ( Long taskId ) { return contextMap . get ( taskId ) ; } }"}, {"input": "package com . youlai . system . model . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . youlai . system . common . base . BaseEntity ; import lombok . Getter ; import lombok . Setter ; @ Getter @ Setter public class SysRole extends BaseEntity { @ TableId ( type = IdType . AUTO ) private Long id ; private String name ; private String code ; private Integer sort ; private Integer status ; private Integer dataScope ; private Long createBy ; private Long updateBy ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . openfeign . config ; import io . github . chensheng . dddboot . openfeign . annotation . EnableFeignClients ; import io . github . chensheng . dddboot . openfeign . httpclient . ApacheHcFeignClient ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration @ ConditionalOnProperty ( \"<STR_LIT>\" ) @ EnableConfigurationProperties ( OpenFeignProperties . class ) @ EnableFeignClients public class OpenFeignAutoConfiguration { public static final String DEFAULT_FEIGN_CLIENT_BEAN_NAME = \"<STR_LIT>\" ; @ Configuration @ ConditionalOnMissingBean ( name = { DEFAULT_FEIGN_CLIENT_BEAN_NAME } ) public static class ApacheHttpClientConfig { @ Bean ( DEFAULT_FEIGN_CLIENT_BEAN_NAME ) public ApacheHcFeignClient apacheHcFeignClient ( OpenFeignProperties properties ) {", "output": "return new ApacheHcFeignClient ( properties ) ; } } }"}, {"input": "package me . zhengjie . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class QiniuQueryCriteria { private String key ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class CardLinkVO { private String title ; private String sourceDisplayName ; private String des ; private String url ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . util ; import ch . ethz . ssh2 . Connection ; import ch . ethz . ssh2 . SCPClient ; import com . google . common . collect . Maps ; import java . io . IOException ; import java . util . Map ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ScpClientUtil { static private Map < String , ScpClientUtil > instance = Maps . newHashMap ( ) ; static synchronized public ScpClientUtil getInstance ( String ip , int port , String username , String password ) { if ( instance . get ( ip ) == null ) { instance . put ( ip , new ScpClientUtil ( ip , port , username , password ) ) ; } return instance . get ( ip ) ; } public ScpClientUtil ( String ip , int port , String username , String password ) { this . ip = ip ; this . port = port ; this . username = username ; this . password = password ; } public void getFile ( String remoteFile , String localTargetDirectory ) { Connection conn = new Connection ( ip , port ) ; try { conn . connect ( ) ; boolean isAuthenticated = conn . authenticateWithPassword ( username , password ) ; if ( ! isAuthenticated ) { System . err . println ( \"<STR_LIT>\" ) ; } SCPClient client = new SCPClient ( conn ) ; client . get ( remoteFile , localTargetDirectory ) ; } catch ( IOException ex ) { Logger . getLogger ( SCPClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { conn . close ( ) ; } } public void putFile ( String localFile , String remoteTargetDirectory ) { putFile ( localFile , null , remoteTargetDirectory ) ; }", "output": "public void putFile ( String localFile , String remoteFileName , String remoteTargetDirectory ) { putFile ( localFile , remoteFileName , remoteTargetDirectory , null ) ; } public void putFile ( String localFile , String remoteFileName , String remoteTargetDirectory , String mode ) { Connection conn = new Connection ( ip , port ) ; try { conn . connect ( ) ; boolean isAuthenticated = conn . authenticateWithPassword ( username , password ) ; if ( ! isAuthenticated ) { System . err . println ( \"<STR_LIT>\" ) ; } SCPClient client = new SCPClient ( conn ) ; if ( ( mode == null ) || ( mode . length ( ) == <NUM_LIT> ) ) { mode = \"<STR_LIT>\" ; } if ( remoteFileName == null ) { client . put ( localFile , remoteTargetDirectory ) ; } else { client . put ( localFile , remoteFileName , remoteTargetDirectory , mode ) ; } } catch ( IOException ex ) { Logger . getLogger ( ScpClientUtil . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { conn . close ( ) ; } } private String ip ; private int port ; private String username ; private String password ; }"}, {"input": "package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class DictDetail extends BaseEntity implements Serializable { @ NotNull ( groups = Update . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Long id ; @ TableField ( value = \"<STR_LIT>\" ) @ ApiModelProperty ( hidden = true ) private Long dictId ; @ TableField ( exist = false ) private Dict dict ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String label ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String value ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer dictSort = <NUM_LIT> ;", "output": "}"}, {"input": "package com . youlai . system . controller ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . common . result . PageResult ; import com . youlai . system . common . result . Result ; import com . youlai . system . model . query . LogPageQuery ; import com . youlai . system . model . vo . LogPageVO ; import com . youlai . system . model . vo . VisitStatsVO ; import com . youlai . system . model . vo . VisitTrendVO ; import com . youlai . system . service . SysLogService ; import io . swagger . v3 . oas . annotations . Operation ; import io . swagger . v3 . oas . annotations . Parameter ; import io . swagger . v3 . oas . annotations . tags . Tag ; import lombok . RequiredArgsConstructor ; import org . springframework . web . bind . annotation . * ; import java . time . LocalDate ; import java . util . List ; @ Tag ( name = \"<STR_LIT>\" ) @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ RequiredArgsConstructor public class SysLogController { private final SysLogService logService ; @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public PageResult < LogPageVO > listPagedLogs ( LogPageQuery queryParams ) { Page < LogPageVO > result = logService . listPagedLogs ( queryParams ) ; return PageResult . success ( result ) ; }", "output": "@ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < VisitTrendVO > getVisitTrend ( @ Parameter ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ RequestParam String startDate , @ Parameter ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) @ RequestParam String endDate ) { LocalDate start = LocalDate . parse ( startDate ) ; LocalDate end = LocalDate . parse ( endDate ) ; VisitTrendVO data = logService . getVisitTrend ( start , end ) ; return Result . success ( data ) ; } @ Operation ( summary = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public Result < List < VisitStatsVO > > getVisitStats ( ) { List < VisitStatsVO > list = logService . getVisitStats ( ) ; return Result . success ( list ) ; } }"}, {"input": "package cn . org . alan . exam . model . vo ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . time . LocalDateTime ; @ Data public class NoticeVO { private Integer id ; private String title ; private String image ; private String content ; private Integer userId ; @ JsonFormat ( shape = JsonFormat . Shape . STRING , pattern = \"<STR_LIT>\" ) private LocalDateTime createTime ; private String realName ;", "output": "}"}, {"input": "package top . kangert . kspider . io ; import cn . hutool . json . JSONUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import java . io . InputStream ; import java . util . Map ; public interface SpiderResponse { @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) int getStatusCode ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) String getTitle ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) String getHtml ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) default Object getJson ( ) { return JSONUtil . parse ( getHtml ( ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) Map < String , String > getCookies ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) Map < String , String > getHeaders ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) byte [ ] getBytes ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) String getContentType ( ) ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) String getUrl ( ) ;", "output": "@ Example ( \"<STR_LIT>\" ) default void setCharset ( String charset ) { } @ Example ( \"<STR_LIT>\" ) default InputStream getStream ( ) { return null ; } }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . HardLinkVideoAttribute ; import com . xcs . wx . mapper . HardLinkVideoAttributeMapper ; import com . xcs . wx . repository . HardLinkVideoAttributeRepository ; import org . springframework . stereotype . Repository ; @ Repository @ DS ( value = DataSourceType . HARD_LINK_VIDEO_DB ) public class HardLinkVideoAttributeRepositoryImpl extends ServiceImpl < HardLinkVideoAttributeMapper , HardLinkVideoAttribute > implements HardLinkVideoAttributeRepository { @ Override public String queryHardLinkVideo ( byte [ ] md5 ) {", "output": "return super . getBaseMapper ( ) . queryHardLinkVideo ( md5 ) ; } }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . Msg ; import com . xcs . wx . domain . vo . CountRecentMsgsVO ; import com . xcs . wx . domain . vo . MsgTypeDistributionVO ; import com . xcs . wx . domain . vo . TopContactsVO ; import java . util . List ; public interface MsgMapper extends BaseMapper < Msg > { List < MsgTypeDistributionVO > msgTypeDistribution ( ) ; List < CountRecentMsgsVO > countRecentMsgs ( ) ; List < TopContactsVO > topContacts ( ) ;", "output": "int countSent ( ) ; int countReceived ( ) ; }"}, {"input": "package top . kangert . kspider . controller ; import java . util . Map ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; import top . kangert . kspider . entity . Application ; import top . kangert . kspider . service . ApplicationService ; import top . kangert . kspider . util . BaseResponse ; import top . kangert . kspider . util . PageInfo ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class ApplicationController extends BaseController { @ Autowired private ApplicationService applicationService ; @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse addApp ( @ RequestBody Map < String , Object > params ) { applicationService . addItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse queryApp ( @ RequestBody Map < String , Object > params ) { PageInfo < Application > queryItem = applicationService . queryItem ( params ) ; return successResponse ( queryItem ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse editApp ( @ RequestBody Map < String , Object > params ) { applicationService . editItem ( params ) ; return successResponse ( ) ; } @ PostMapping ( \"<STR_LIT>\" ) public BaseResponse deleteApp ( @ RequestBody Map < String , Object > param ) { applicationService . delete ( param ) ;", "output": "return successResponse ( ) ; } }"}, {"input": "package com . yf . base . api . api . dto ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BaseBatchReqDTO extends BaseDTO { @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private List < String > ids ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String toId ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class MenuQueryCriteria { private String blurry ; private List < Timestamp > createTime ; private Boolean pidIsNull ; private Long pid ;", "output": "}"}, {"input": "package com . yf . system . modules . user . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class SysUserUpdateReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String avatar ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String realName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String password ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idCard ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String email ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . form . Auth ; import jakarta . validation . constraints . NotBlank ; import lombok . Data ; @ Data public class LoginForm { @ NotBlank ( message = \"<STR_LIT>\" ) private String username ; @ NotBlank ( message = \"<STR_LIT>\" ) private String password ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . converter . CellContentConverterFactory ; import io . github . chensheng . dddboot . excel . core . DataCellConfig ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . reflect . ReflectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; public class RowDataAssembler { private static final Logger logger = LoggerFactory . getLogger ( RowDataAssembler . class ) ; public static Object assemble ( Class < ? > rowType , List < DataCellConfig > dataRowConfig , String [ ] rowContent , boolean use1904DateWindowing ) { if ( rowType == null ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } Object rowObject = null ; try { rowObject = rowType . newInstance ( ) ; } catch ( InstantiationException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } catch ( IllegalAccessException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; return null ; } if ( CollectionUtil . isEmpty ( dataRowConfig ) || rowContent == null || rowContent . length == <NUM_LIT> ) { return rowObject ; } for ( DataCellConfig cellConfig : dataRowConfig ) { if ( cellConfig . getField ( ) == null ) { continue ; } int cellIndex = cellConfig . getIndex ( ) ; if ( cellIndex < <NUM_LIT> || cellIndex >= rowContent . length ) { continue ;", "output": "} String cellContent = rowContent [ cellIndex ] ; Object cellValue = CellContentConverterFactory . fromCellContent ( cellContent , cellConfig . getField ( ) , cellConfig . getType ( ) , cellConfig . getFormat ( ) , use1904DateWindowing ) ; if ( cellValue == null ) { continue ; } try { ReflectionUtil . makeAccessible ( cellConfig . getField ( ) ) ; ReflectionUtil . setField ( rowObject , cellConfig . getField ( ) , cellValue ) ; } catch ( Exception e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } } return rowObject ; } }"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import lombok . EqualsAndHashCode ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformEnhanceJava extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String buttonCode ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJavaType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String cgJavaValue ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long cgformHeadId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String activeStatus ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String event ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceName ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . config . BeanDefinition ; import org . springframework . beans . factory . support . BeanDefinitionBuilder ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . context . support . PropertySourcesPlaceholderConfigurer ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; public class NacosBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata importingClassMetadata , BeanDefinitionRegistry registry ) { BeanDefinition annotationProcessor = BeanDefinitionBuilder . genericBeanDefinition ( PropertySourcesPlaceholderConfigurer . class ) . getBeanDefinition ( ) ; registry . registerBeanDefinition ( PropertySourcesPlaceholderConfigurer . class . getName ( ) , annotationProcessor ) ; AnnotationAttributes attributes = AnnotationAttributes . fromMap ( importingClassMetadata . getAnnotationAttributes ( EnableNacos . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosAnnotationBeans ( registry ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } public void registerNacosAnnotationBeans ( BeanDefinitionRegistry registry ) { registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ; registerNacosDiscoveryBeans ( registry ) ; } @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; }", "output": "}"}, {"input": "package com . oddfar . campus . common . exception ; public final class ServiceException extends RuntimeException { private static final long serialVersionUID = <NUM_LIT> ; private Integer code ; private String message ; private String detailMessage ; public ServiceException ( ) { } public ServiceException ( String message ) { this . message = message ;", "output": "} public ServiceException ( String message , Integer code ) { this . message = message ; this . code = code ; } public String getDetailMessage ( ) { return detailMessage ; } @ Override public String getMessage ( ) { return message ; } public Integer getCode ( ) { return code ; } public ServiceException setMessage ( String message ) { this . message = message ; return this ; } public ServiceException setDetailMessage ( String detailMessage ) { this . detailMessage = detailMessage ; return this ; } }"}, {"input": "package org . springblade . config . util ; import org . springblade . config . constant . MjkjConstant ; import org . springblade . config . exception . DBException ; import org . springblade . config . service . DbTableHandleI ; import org . springblade . config . service . impl . MysqlTableHandle ; import org . springblade . config . service . impl . OracleTableHandle ; import org . springblade . config . service . impl . PgTableHandle ; import org . springblade . config . service . impl . SqlServerTableHandle ; import org . springblade . config . constant . MjjyConfig ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . utils . Func ; import javax . sql . DataSource ; import java . sql . Connection ; import java . sql . DatabaseMetaData ; import java . sql . ResultSet ; import java . sql . SQLException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j public class TableUtil { public static String DATABASE_TYPE = \"<STR_LIT>\" ; public TableUtil ( ) { } public static DbTableHandleI getTableHandle ( ) throws SQLException , DBException { DbTableHandleI dbTableHandle = null ; String databaseType = getDatabaseType ( ) ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : dbTableHandle = new OracleTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : dbTableHandle = new PgTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_MYSQL : dbTableHandle = new MysqlTableHandle ( ) ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : dbTableHandle = new SqlServerTableHandle ( ) ; } return dbTableHandle ; } public static Connection getConnection ( ) throws SQLException { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return ds . getConnection ( ) ; } public static String getDatabaseType ( ) throws SQLException , DBException { if ( ConvertUtils . isNotEmpty ( DATABASE_TYPE ) ) { return DATABASE_TYPE ; } else { DataSource ds = SpringContextUtils . getApplicationContext ( ) . getBean ( DataSource . class ) ; return getDatabaseType ( ds ) ; } } public static boolean isOracle ( ) { try { return MjkjConstant . DB_TYPE_ORACLE . equals ( getDatabaseType ( ) ) ; } catch ( SQLException | DBException e ) { e . printStackTrace ( ) ; } return false ; } public static String getDatabaseType ( DataSource ds ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { Connection conn = ds . getConnection ( ) ; try { DatabaseMetaData dbMetaData = conn . getMetaData ( ) ; String dbProductName = dbMetaData . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( dbProductName . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + dbProductName + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } finally { conn . close ( ) ; } } return DATABASE_TYPE ; } public static String getDatabaseType ( Connection conn ) throws SQLException , DBException { if ( \"<STR_LIT>\" . equals ( DATABASE_TYPE ) ) { DatabaseMetaData var1 = conn . getMetaData ( ) ; String type = var1 . getDatabaseProductName ( ) . toLowerCase ( ) ; if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_MYSQL ; } else if ( type . indexOf ( \"<STR_LIT>\" ) >= <NUM_LIT> ) { DATABASE_TYPE = MjkjConstant . DB_TYPE_ORACLE ; } else if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> && type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { if ( type . indexOf ( \"<STR_LIT>\" ) < <NUM_LIT> ) { throw new DBException ( \"<STR_LIT>\" + type + \"<STR_LIT>\" ) ; } DATABASE_TYPE = MjkjConstant . DB_TYPE_POSTGRESQL ; } else { DATABASE_TYPE = MjkjConstant . DB_TYPE_SQLSERVER ; } } return DATABASE_TYPE ; } public static String fixTableName ( String tableName , String databaseType ) { switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : return tableName . toUpperCase ( ) ; case MjkjConstant . DB_TYPE_POSTGRESQL : return tableName . toLowerCase ( ) ; default : return tableName ; } } public static Boolean tableNameIsuUable ( String tableName ) { String excludeTableStr = MjjyConfig . getExcludeTable ( ) ; if ( Func . isEmpty ( excludeTableStr ) ) { return true ; } String [ ] excludeTables = Func . toStrArray ( excludeTableStr ) ; if ( Func . isEmpty ( excludeTables ) ) { return true ; } for ( String excludeTable : excludeTables ) { if ( tableName . startsWith ( excludeTable ) ) { return false ; } } return true ; } public static Boolean isTableExist ( String tableName ) { Connection conn = null ; ResultSet rs = null ; Boolean isTableExist ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; String databaseProductName = databaseMetaData . getDatabaseProductName ( ) . toUpperCase ( ) ; String dbTableName = fixTableName ( tableName , databaseProductName ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , MjjyConfig . getDatabaseSchema ( ) , dbTableName , tables ) ; if ( rs . next ( ) ) { log . info ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" ) ; isTableExist = true ; return isTableExist ; } isTableExist = false ; } catch ( SQLException e ) { throw new RuntimeException ( ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( conn != null ) { conn . close ( ) ; } } catch ( SQLException e ) { log . error ( e . getMessage ( ) , e ) ; } } return isTableExist ; } public static List < Map < String , String > > getDatabaseAlTable ( ) { Connection conn = null ; ResultSet rs = null ; List < Map < String , String > > resultList = new ArrayList < > ( ) ; try { String [ ] tables = new String [ ] { \"<STR_LIT>\" } ; conn = getConnection ( ) ; DatabaseMetaData databaseMetaData = conn . getMetaData ( ) ; rs = databaseMetaData . getTables ( conn . getCatalog ( ) , null , null , tables ) ; while ( rs . next ( ) ) { Map < String , String > dataMap = new HashMap < > ( ) ; dataMap . put ( \"<STR_LIT>\" , rs . getString ( \"<STR_LIT>\" ) ) ; dataMap . put ( \"<STR_LIT>\" , rs . getString ( \"<STR_LIT>\" ) ) ; resultList . add ( dataMap ) ; } return resultList ; } catch ( SQLException e ) { throw new RuntimeException ( ) ; } finally { try { if ( rs != null ) { rs . close ( ) ; } if ( conn != null ) { conn . close ( ) ; }", "output": "} catch ( SQLException e ) { log . error ( e . getMessage ( ) , e ) ; } } } public static String getDialect ( ) throws SQLException , DBException { String databaseType = getDatabaseType ( ) ; return getJdbcDriver ( databaseType ) ; } public static String getJdbcDriver ( String databaseType ) throws SQLException , DBException { String driver = \"<STR_LIT>\" ; switch ( databaseType ) { case MjkjConstant . DB_TYPE_ORACLE : driver = \"<STR_LIT>\" ; break ; case MjkjConstant . DB_TYPE_POSTGRESQL : driver = \"<STR_LIT>\" ; break ; case MjkjConstant . DB_TYPE_SQLSERVER : driver = \"<STR_LIT>\" ; } return driver ; } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; import org . apache . ibatis . type . ByteArrayTypeHandler ; @ Data @ TableName ( value = \"<STR_LIT>\" , autoResultMap = true ) public class Msg { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) private Integer localId ; @ TableField ( \"<STR_LIT>\" ) private Integer talkerId ; @ TableField ( \"<STR_LIT>\" ) private String msgSvrId ; @ TableField ( \"<STR_LIT>\" ) private Integer type ; @ TableField ( \"<STR_LIT>\" ) private Integer subType ; @ TableField ( \"<STR_LIT>\" ) private Integer isSender ; @ TableField ( \"<STR_LIT>\" ) private Integer createTime ; @ TableField ( \"<STR_LIT>\" ) private Long sequence ; @ TableField ( \"<STR_LIT>\" ) private Integer statusEx ; @ TableField ( \"<STR_LIT>\" ) private Integer flagEx ; @ TableField ( \"<STR_LIT>\" ) private Integer status ; @ TableField ( \"<STR_LIT>\" ) private Integer msgServerSeq ; @ TableField ( \"<STR_LIT>\" ) private Integer msgSequence ; @ TableField ( \"<STR_LIT>\" ) private String strTalker ; @ TableField ( \"<STR_LIT>\" ) private String strContent ; @ TableField ( \"<STR_LIT>\" ) private String displayContent ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved0 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved1 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved2 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved3 ; @ TableField ( \"<STR_LIT>\" ) private String reserved4 ; @ TableField ( \"<STR_LIT>\" ) private String reserved5 ; @ TableField ( \"<STR_LIT>\" ) private String reserved6 ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] compressContent ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] bytesExtra ; @ TableField ( value = \"<STR_LIT>\" , typeHandler = ByteArrayTypeHandler . class ) private byte [ ] bytesTrans ;", "output": "}"}, {"input": "package org . springblade . cgform . model ; import org . springblade . cgform . entity . CgformButton ; import org . springblade . cgform . entity . BludeUser ; import lombok . Data ; import org . springblade . entity . BladeDept ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Data public class OnlineConfigModel { private Long headId ; private String formTemplate ; private String description ; private String currentTableName ; private Integer tableType ; private String paginationFlag ; private String checkboxFlag ; private Integer scrollFlag ; private List < OnlColumn > columns ; private List < String > hideColumns ; private Map < String , List < DictModel > > dictOptions = new HashMap < > ( ) ; private Map < String , List < BladeDept > > deptOptions = new HashMap < > ( ) ; private Map < String , List < BludeUser > > userOptions = new HashMap < > ( ) ; private List < CgformButton > cgButtonList ; private List < HrefSlots > fieldHrefSlots ; private String enhanceJs ; private String enhanceJsApp ; private List < OnlForeignKey > foreignKeys ; private String pidField ; private String hasChildrenField ; private String textField ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . web . core ; public enum ResponseType { BIZ_SUCCESS ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , BIZ_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , SYS_ERROR ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; private String code ; private String msg ; ResponseType ( String code , String msg ) {", "output": "this . code = code ; this . msg = msg ; } public String getCode ( ) { return code ; } public String getMsg ( ) { return msg ; } }"}, {"input": "package org . example . domain . example . repository ; import org . example . domain . example . valueobject . ExampleAddress ; public interface ExampleLocationRepository {", "output": "ExampleAddress find ( Double longitude , Double latitude ) ; }"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; public class ListQuery extends SortableQuery { private Long limit ; protected Long getMaxLimit ( ) { return null ; } public Long getLimit ( ) { Long maxLimit = getMaxLimit ( ) ; if ( maxLimit == null || limit == null ) { return limit ; } if ( limit <= maxLimit ) { return limit ; } return maxLimit ; } public void setLimit ( Long limit ) { this . limit = limit ;", "output": "} }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . Data ; @ Data public class ResponseVO < T > { private Boolean success ; private Integer errorCode ; private String errorMessage ; private Long page ; private Long total ; private Integer showType ; private T data ; public static < T > ResponseVO < T > ok ( T data ) { ResponseVO < T > wrapper = new ResponseVO < > ( ) ; wrapper . setSuccess ( true ) ; wrapper . setData ( data ) ; return wrapper ; } public static < T > ResponseVO < T > ok ( T data , Long page , Long total ) { ResponseVO < T > wrapper = new ResponseVO < > ( ) ; wrapper . setSuccess ( true ) ; wrapper . setData ( data ) ; wrapper . setPage ( page ) ; wrapper . setTotal ( total ) ; return wrapper ; } public static < T > ResponseVO < T > error ( Integer errorCode , String errorMessage ) { ResponseVO < T > wrapper = new ResponseVO < > ( ) ; wrapper . setSuccess ( false ) ; wrapper . setErrorCode ( errorCode ) ; wrapper . setShowType ( <NUM_LIT> ) ; wrapper . setErrorMessage ( errorMessage ) ; return wrapper ;", "output": "} }"}, {"input": "package com . yf . system . modules . user . enums ; public interface LoginType {", "output": "String WECHAT = \"<STR_LIT>\" ; String CROP_WECHAT = \"<STR_LIT>\" ; String DING_TALK = \"<STR_LIT>\" ; String MOBILE = \"<STR_LIT>\" ; }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import org . springblade . core . mp . support . Query ; @ Data public class ContractOrdersParam extends Query { private String contractId ; private String UID ; private String pUID ; private String symbol ; private String feeSymbol ; private String startDate ; private String endDate ;", "output": "}"}, {"input": "package me . zhengjie . utils ; public enum AliPayStatusEnum { FINISHED ( \"<STR_LIT>\" ) , SUCCESS ( \"<STR_LIT>\" ) , BUYER_PAY ( \"<STR_LIT>\" ) , CLOSED ( \"<STR_LIT>\" ) ; private final String value ; AliPayStatusEnum ( String value ) { this . value = value ; } public String getValue ( ) { return value ; }", "output": "}"}, {"input": "package org . example . ddduser . api . web ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngCommandService ; import org . example . ddduser . application . service . UserMngQueryService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class UserMngController { @ Autowired private UserMngQueryService userMngQueryService ; @ Autowired private UserMngCommandService userMngCommandService ; @ GetMapping ( \"<STR_LIT>\" ) public Page < UserProfile > page ( UserProfilePageQuery query ) { return userMngQueryService . profilePage ( query ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void enable ( @ PathVariable Long id ) {", "output": "userMngCommandService . enable ( id ) ; } @ PutMapping ( \"<STR_LIT>\" ) public void disable ( @ PathVariable Long id ) { userMngCommandService . disable ( id ) ; } }"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysLogLogin ; import ginyi . system . domain . SysLogOperation ; import ginyi . system . domain . model . vo . BaseVo ; import org . springframework . web . bind . annotation . RequestParam ; import java . util . List ; public interface ISysLogService { public BaseVo < SysLogLogin > getLoginLogList ( Long page , Long pageSize ) ; public BaseVo < SysLogOperation > getOperationLogList ( Long page , Long pageSize ) ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class DatabaseQueryCriteria { private String name ; private String jdbcUrl ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package com . yf . base . api . api . dto ; import com . fasterxml . jackson . annotation . JsonIgnore ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . AllArgsConstructor ; import lombok . Data ; import lombok . NoArgsConstructor ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) @ AllArgsConstructor @ NoArgsConstructor public class BaseUserReqDTO extends BaseDTO { @ JsonIgnore @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String userId ;", "output": "}"}, {"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import lombok . Data ; import java . util . List ; import java . util . Map ; @ Data public class TableFieldCommentConverter implements FieldCommentConverter { protected IDictService dictService ; protected String field ; protected String table ; protected String code ; protected String text ; public TableFieldCommentConverter ( ) { this . dictService = SpringContextUtils . getBean ( IDictService . class ) ; } public TableFieldCommentConverter ( String table , String code , String text ) {", "output": "this ( ) ; this . table = table ; this . code = code ; this . text = text ; } @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { String s = this . text + \"<STR_LIT>\" + txt + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > filterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( filterTableDictInfo != null && filterTableDictInfo . size ( ) > <NUM_LIT> ) { return filterTableDictInfo . get ( <NUM_LIT> ) . getValue ( ) ; } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { String s = this . code + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; String s1 ; int where = this . table . indexOf ( \"<STR_LIT>\" ) ; if ( where > <NUM_LIT> ) { s1 = this . table . substring ( <NUM_LIT> , where ) . trim ( ) ; s = s + \"<STR_LIT>\" + this . table . substring ( where + <NUM_LIT> ) ; } else { s1 = this . table ; } List < DictModel > queryFilterTableDictInfo = this . dictService . queryFilterTableDictInfo ( s1 , this . text , this . code , s ) ; if ( queryFilterTableDictInfo != null && queryFilterTableDictInfo . size ( ) > <NUM_LIT> ) { return queryFilterTableDictInfo . get ( <NUM_LIT> ) . getText ( ) ; } } return null ; } @ Override public Map < String , String > getConfig ( ) { return null ; } }"}, {"input": "package ginyi . system . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . apache . ibatis . annotations . Select ; @ EqualsAndHashCode ( callSuper = true ) @ Data public class SysPost extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ TableId private Long postId ; private String postCode ; private String postName ; private Integer sort ; private String status ; @ TableField ( select = false , exist = false ) private boolean flag = false ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . node ; import top . kangert . kspider . KspiderRuntime ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . dao . SpiderFlowRepository ; import top . kangert . kspider . domain . SpiderFlow ; import top . kangert . kspider . executor . NodeExecutor ; import top . kangert . kspider . model . ConfigItem ; import top . kangert . kspider . model . Shape ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . service . SpiderFlowService ; import top . kangert . kspider . util . SpiderFlowUtils ; import top . kangert . kspider . websocket . WebSocketEvent ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; @ Component @ Slf4j public class ProcessExecutor implements NodeExecutor { @ Autowired private KspiderRuntime spider ; @ Autowired private SpiderFlowService spiderFlowService ; @ Autowired private SpiderFlowRepository spiderFlowRepository ; @ Override public void execute ( SpiderNode node , SpiderContext context , Map < String , Object > variables ) { Long flowId = Long . parseLong ( node . getJsonProperty ( Constants . FLOW_ID ) ) ; SpiderFlow spiderFlow = spiderFlowService . getById ( flowId ) ; if ( spiderFlow != null ) { log . info ( \"<STR_LIT>\" , spiderFlow . getName ( ) ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , \"<STR_LIT>\" , spiderFlow . getName ( ) ) ; SpiderNode root = SpiderFlowUtils . parseJsonToSpiderNode ( spiderFlow . getJson ( ) ) ; spider . executeNode ( null , root , context , variables ) ; } else { log . info ( \"<STR_LIT>\" , flowId ) ; context . pause ( node . getNodeId ( ) , WebSocketEvent . COMMON_EVENT , \"<STR_LIT>\" , flowId ) ; } } @ Override public String supportType ( ) { return \"<STR_LIT>\" ; } @ Override public Shape shape ( ) { return new Shape ( supportType ( ) , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } @ Override public List < ConfigItem > configItems ( ) { List < ConfigItem > configItemList = new ArrayList < > ( ) ; List < ConfigItem . SelectItem > spiderList = new ArrayList < > ( ) ; List < SpiderFlow > spiderFlows = spiderFlowRepository . findAll ( ) ; for ( SpiderFlow spiderFlow : spiderFlows ) { ConfigItem . SelectItem item = new ConfigItem . SelectItem ( spiderFlow . getName ( ) , spiderFlow . getFlowId ( ) , ConfigItem . DataType . INT ) ; spiderList . add ( item ) ;", "output": "} ConfigItem otherKspider = new ConfigItem ( \"<STR_LIT>\" , ConfigItem . ComponentType . EL_SELECT , ConfigItem . DataType . INT , Constants . FLOW_ID , \"<STR_LIT>\" , \"<STR_LIT>\" , null , spiderList ) ; configItemList . add ( otherKspider ) ; return configItemList ; } }"}, {"input": "package me . zhengjie . exception ; import org . springframework . util . StringUtils ; public class EntityExistException extends RuntimeException { public EntityExistException ( Class clazz , String field , String val ) { super ( EntityExistException . generateMessage ( clazz . getSimpleName ( ) , field , val ) ) ;", "output": "} private static String generateMessage ( String entity , String field , String val ) { return StringUtils . capitalize ( entity ) + \"<STR_LIT>\" + field + \"<STR_LIT>\" + val + \"<STR_LIT>\" ; } }"}, {"input": "package io . github . chensheng . dddboot . test ; import com . tngtech . archunit . core . domain . JavaClass ; import com . tngtech . archunit . core . domain . JavaClasses ; import com . tngtech . archunit . core . domain . JavaField ; import com . tngtech . archunit . core . domain . JavaMethod ; import com . tngtech . archunit . core . importer . ClassFileImporter ; import com . tngtech . archunit . lang . ArchCondition ; import com . tngtech . archunit . lang . ConditionEvents ; import com . tngtech . archunit . lang . SimpleConditionEvent ; import java . util . Optional ; import java . util . Set ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . classes ; import static com . tngtech . archunit . lang . syntax . ArchRuleDefinition . noClasses ; public class ArchitectureTest { public static void validateDDD ( String packageName ) { JavaClasses projectClasses = new ClassFileImporter ( ) . importPackages ( packageName ) ; doValidateApiLayer ( projectClasses , packageName ) ; doValidateApplicationLayer ( projectClasses , packageName ) ; doValidateDomainLayer ( projectClasses , packageName ) ; doValidateInfrastructureLayer ( ) ; } private static void doValidateApiLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateDomainLayer ( JavaClasses projectClasses , String packageName ) { noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . haveNameMatching ( \"<STR_LIT>\" ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( entityCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areNotEnums ( ) . and ( ) . areNotMemberClasses ( ) . and ( ) . areNotInnerClasses ( ) . should ( valueObjectCondition ( ) ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . andShould ( ) . beInterfaces ( ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateApplicationLayer ( JavaClasses projectClasses , String packageName ) { classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; classes ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . should ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . orShould ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; noClasses ( ) . that ( ) . resideInAPackage ( packageName + \"<STR_LIT>\" ) . and ( ) . areLocalClasses ( ) . and ( ) . haveSimpleNameEndingWith ( \"<STR_LIT>\" ) . should ( ) . dependOnClassesThat ( ) . resideInAnyPackage ( packageName + \"<STR_LIT>\" , packageName + \"<STR_LIT>\" ) . because ( \"<STR_LIT>\" ) . allowEmptyShould ( true ) . check ( projectClasses ) ; } private static void doValidateInfrastructureLayer ( ) { } private static ArchCondition < JavaClass > entityCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } }", "output": "} ; } private static ArchCondition < JavaClass > valueObjectCondition ( ) { return new ArchCondition < JavaClass > ( \"<STR_LIT>\" ) { @ Override public void check ( JavaClass item , ConditionEvents events ) { try { item . getMethod ( \"<STR_LIT>\" ) ; } catch ( IllegalArgumentException e ) { events . add ( SimpleConditionEvent . violated ( item , \"<STR_LIT>\" + item . getFullName ( ) + \"<STR_LIT>\" ) ) ; } Set < JavaField > fields = item . getAllFields ( ) ; if ( fields != null && fields . size ( ) > <NUM_LIT> ) { for ( JavaField field : fields ) { String fieldName = field . getName ( ) ; String setterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > setter = item . tryGetMethod ( setterName , field . getRawType ( ) . getFullName ( ) ) ; if ( setter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } String getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; Optional < JavaMethod > getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { getterName = \"<STR_LIT>\" + firstLetterToUpperCase ( fieldName ) ; getter = item . tryGetMethod ( getterName ) ; if ( ! getter . isPresent ( ) ) { String message = String . format ( \"<STR_LIT>\" , item . getFullName ( ) , field . getName ( ) ) ; events . add ( SimpleConditionEvent . violated ( field , message ) ) ; } } } } } } ; } private static String firstLetterToUpperCase ( String word ) { if ( word == null || word . length ( ) == <NUM_LIT> ) { return word ; } StringBuilder result = new StringBuilder ( ) ; for ( int i = <NUM_LIT> ; i < word . length ( ) ; i ++ ) { if ( i == <NUM_LIT> ) { result . append ( String . valueOf ( word . charAt ( i ) ) . toUpperCase ( ) ) ; } else { result . append ( String . valueOf ( word . charAt ( i ) ) ) ; } } return result . toString ( ) ; } }"}, {"input": "package top . kangert . kspider . entity ; import java . io . Serializable ; import java . util . Date ; import javax . persistence . Column ; import javax . persistence . EntityListeners ; import javax . persistence . MappedSuperclass ; import org . hibernate . annotations . ColumnDefault ; import org . springframework . data . annotation . CreatedBy ; import org . springframework . data . annotation . CreatedDate ; import org . springframework . data . annotation . LastModifiedBy ; import org . springframework . data . annotation . LastModifiedDate ; import org . springframework . data . jpa . domain . support . AuditingEntityListener ; @ MappedSuperclass @ EntityListeners ( AuditingEntityListener . class ) public abstract class BaseEntity implements Serializable { @ CreatedBy @ LastModifiedBy @ Column ( name = \"<STR_LIT>\" , columnDefinition = \"<STR_LIT>\" ) public String operationName ; @ CreatedDate @ Column ( name = \"<STR_LIT>\" , updatable = false , columnDefinition = \"<STR_LIT>\" ) @ ColumnDefault ( \"<STR_LIT>\" ) public Date createTime = new Date ( ) ; @ LastModifiedDate @ Column ( name = \"<STR_LIT>\" , updatable = true , columnDefinition = \"<STR_LIT>\" ) @ ColumnDefault ( \"<STR_LIT>\" ) public Date updateTime = null ; @ Column ( name = \"<STR_LIT>\" , columnDefinition = \"<STR_LIT>\" ) private String remark ; public String getOperationName ( ) { return operationName ; }", "output": "public void setOperationName ( String operationName ) { this . operationName = operationName ; } public Date getCreateTime ( ) { return createTime ; } public void setCreateTime ( Date createTime ) { this . createTime = createTime ; } public Date getUpdateTime ( ) { return updateTime ; } public void setUpdateTime ( Date updateTime ) { this . updateTime = updateTime ; } public String getRemark ( ) { return remark ; } public void setRemark ( String remark ) { this . remark = remark ; } }"}, {"input": "package com . yf . config ; import io . swagger . annotations . ApiOperation ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import springfox . documentation . builders . ApiInfoBuilder ; import springfox . documentation . builders . PathSelectors ; import springfox . documentation . builders . RequestHandlerSelectors ; import springfox . documentation . service . ApiInfo ; import springfox . documentation . service . ApiKey ; import springfox . documentation . service . Contact ; import springfox . documentation . service . SecurityScheme ; import springfox . documentation . spi . DocumentationType ; import springfox . documentation . spring . web . plugins . Docket ; import springfox . documentation . swagger2 . annotations . EnableSwagger2 ; import java . util . Collections ; @ Configuration @ EnableSwagger2 @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class SwaggerConfig { @ Bean public Docket commonApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . apiInfo ( apiInfo ( ) ) . groupName ( \"<STR_LIT>\" ) . select ( ) . apis ( RequestHandlerSelectors . withMethodAnnotation ( ApiOperation . class ) ) . paths ( PathSelectors . ant ( \"<STR_LIT>\" ) ) . build ( ) . securitySchemes ( Collections . singletonList ( securityScheme ( ) ) ) ; } @ Bean public Docket sysApi ( ) { return new Docket ( DocumentationType . SWAGGER_2 ) . apiInfo ( apiInfo ( ) ) . groupName ( \"<STR_LIT>\" ) . select ( ) . apis ( RequestHandlerSelectors . withMethodAnnotation ( ApiOperation . class ) ) . paths ( PathSelectors . ant ( \"<STR_LIT>\" ) ) . build ( ) . securitySchemes ( Collections . singletonList ( securityScheme ( ) ) ) ; } private ApiInfo apiInfo ( ) { return new ApiInfoBuilder ( ) . title ( \"<STR_LIT>\" ) . description ( \"<STR_LIT>\" ) . contact ( new Contact ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ) . version ( \"<STR_LIT>\" ) . build ( ) ; } @ Bean SecurityScheme securityScheme ( ) { return new ApiKey ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; }", "output": "}"}, {"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . Wrapper ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import lombok . extern . slf4j . Slf4j ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformFieldMapper ; import org . springblade . cgform . mapper . CgformHeadMapper ; import org . springblade . cgform . mapper . SqlMapper ; import org . springblade . cgform . model . CommonEntity ; import org . springblade . cgform . model . TreeModel ; import org . springblade . cgform . service . ICgformFieldService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SqlSymbolUtil ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . redis . cache . BladeRedis ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . * ; @ Slf4j @ Service public class CgformFieldServiceImpl extends BaseServiceImpl < CgformFieldMapper , CgformField > implements ICgformFieldService { @ Autowired private CgformHeadMapper headMapper ; @ Autowired private SqlMapper sqlMapper ; @ Autowired private BladeRedis bladeRedis ; public void executeInsertSQL ( Map < String , Object > map ) { sqlMapper . executeInsertSQL ( map ) ; } @ Override public Map < String , Object > queryAutolistPage ( String tableName , Long headId , Map < String , Object > params , List < String > needList ) { HashMap < String , Object > resultMap = new HashMap < > ( ) ; String redisKey = \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + headId + \"<STR_LIT>\" + Func . md5Hex ( JsonUtil . toJson ( params ) ) ; LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , headId ) ; wrapper . orderByAsc ( CgformField :: getOrderNum ) ; List < CgformField > fieldList = this . list ( wrapper ) ; String sqlStr = \"<STR_LIT>\" ; StringBuffer sbf = new StringBuffer ( ) ; SqlSymbolUtil . getSelect ( tableName , fieldList , sbf ) ; String sql = SqlSymbolUtil . getByDataType ( fieldList , params , needList ) ; String sql1 = SqlSymbolUtil . getByParams ( params ) ; sbf . append ( \"<STR_LIT>\" + sql + sql1 ) ; Object column = params . get ( \"<STR_LIT>\" ) ; if ( column != null ) { String columnStr = column . toString ( ) ; String orderStr = params . get ( \"<STR_LIT>\" ) . toString ( ) ; if ( this . orderBy ( columnStr , fieldList ) ) { String orderBy = ConvertUtils . camelToUnderline ( columnStr ) ;", "output": "if ( Func . equals ( orderBy , \"<STR_LIT>\" ) ) { orderBy = \"<STR_LIT>\" + orderBy + \"<STR_LIT>\" ; } sbf . append ( \"<STR_LIT>\" + orderBy ) ; if ( \"<STR_LIT>\" . equals ( orderStr ) ) { sbf . append ( \"<STR_LIT>\" ) ; } else { sbf . append ( \"<STR_LIT>\" ) ; } } } if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { sbf = new StringBuffer ( ) ; sbf . append ( \"<STR_LIT>\" + tableName + \"<STR_LIT>\" + sql + sql1 ) ; } sqlStr = sbf . toString ( ) ; bladeRedis . setEx ( redisKey , sqlStr , <NUM_LIT> ) ; if ( params . containsKey ( \"<STR_LIT>\" ) && MjkjUtils . getMap2Integer ( params , \"<STR_LIT>\" ) == <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , new ArrayList < > ( ) ) ; resultMap . put ( \"<STR_LIT>\" , dataList ) ; return resultMap ; } Integer pageSzie = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; if ( pageSzie == - <NUM_LIT> ) { List < Map < String , Object > > dataList = sqlMapper . queryListBySqlList ( sqlStr ) ; if ( dataList != null && dataList . size ( ) != <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , dataList . size ( ) ) ; resultMap . put ( \"<STR_LIT>\" , fieldList ) ; Integer cou = baseMapper . getBlobCou ( headId ) ; if ( Func . isNotEmpty ( cou ) && cou > <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , SqlSymbolUtil . handleClob ( dataList ) ) ; } else { resultMap . put ( \"<STR_LIT>\" , dataList ) ; } } else { resultMap . put ( \"<STR_LIT>\" , <NUM_LIT> ) ; resultMap . put ( \"<STR_LIT>\" , fieldList ) ; List < Map < String , Object > > list = new ArrayList < > ( ) ; resultMap . put ( \"<STR_LIT>\" , list ) ; } } else { Integer pageNo = params . get ( \"<STR_LIT>\" ) == null ? <NUM_LIT> : Integer . parseInt ( params . get ( \"<STR_LIT>\" ) . toString ( ) ) ; Page < Map < String , Object > > page = new Page < > ( pageNo , pageSzie ) ; IPage < Map < String , Object > > ipage = sqlMapper . selectPageBySqlList ( page , sqlStr ) ; resultMap . put ( \"<STR_LIT>\" , ipage . getTotal ( ) ) ; Integer cou = baseMapper . getBlobCou ( headId ) ; if ( Func . isNotEmpty ( cou ) && cou > <NUM_LIT> ) { resultMap . put ( \"<STR_LIT>\" , SqlSymbolUtil . handleClob ( ipage . getRecords ( ) ) ) ; } else { resultMap . put ( \"<STR_LIT>\" , ipage . getRecords ( ) ) ; } } return resultMap ; } public boolean orderBy ( String str , List < CgformField > list ) { boolean flag = false ; Iterator iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { CgformField field = ( CgformField ) iterator . next ( ) ; if ( ConvertUtils . camelToUnderline ( str ) . equals ( field . getDbFieldName ( ) ) ) { flag = true ; break ; } } return flag ; } public List < CgformField > queryFormFieldsByTableName ( String tableName ) { CgformHead head = headMapper . selectOne ( ( Wrapper ) ( new LambdaQueryWrapper < CgformHead > ( ) ) . eq ( CgformHead :: getTableName , tableName ) ) ; if ( Func . isEmpty ( head ) ) { return null ; } LambdaQueryWrapper < CgformField > wrapper = new LambdaQueryWrapper ( ) ; wrapper . eq ( CgformField :: getCgformHeadId , head . getId ( ) ) ; return this . list ( wrapper ) ; } }"}, {"input": "package top . kangert . kspider . model ; import org . openqa . selenium . By ; import org . openqa . selenium . NoSuchElementException ; import org . openqa . selenium . WebElement ; import top . kangert . kspider . executor . function . extension . WebElementWrapper ; import top . kangert . kspider . io . SeleniumResponse ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . stream . Collectors ; public class WebElements extends ArrayList < WebElement > { private SeleniumResponse response ; public WebElements ( ) { } public WebElements ( SeleniumResponse response , List < WebElement > elements ) { super ( elements == null ? Collections . emptyList ( ) : elements . stream ( ) . map ( e -> new WebElementWrapper ( response , e ) ) . collect ( Collectors . toList ( ) ) ) ; this . response = response ; } public List < String > html ( ) { return attr ( \"<STR_LIT>\" ) ; } public List < String > attr ( String attr ) { return this . stream ( ) . map ( element -> element . getAttribute ( attr ) ) . collect ( Collectors . toList ( ) ) ; } public List < String > text ( ) { return this . stream ( ) . map ( WebElement :: getText ) . collect ( Collectors . toList ( ) ) ; } public WebElements selectors ( String css ) { WebElements elements = new WebElements ( ) ; this . stream ( ) . map ( element -> findElements ( element , By . cssSelector ( css ) ) ) . forEach ( elements :: addAll ) ; return elements ; } public WebElement selector ( String css ) { for ( WebElement element : this ) { WebElement ele = findElement ( element , By . cssSelector ( css ) ) ; if ( ele != null ) { return ele ; } } return null ; } public WebElements xpaths ( String xpath ) { WebElements elements = new WebElements ( ) ; this . stream ( ) . map ( element -> findElements ( element , By . xpath ( xpath ) ) ) . forEach ( elements :: addAll ) ; return elements ; } public WebElement xpath ( String xpath ) { for ( WebElement element : this ) { WebElement ele = findElement ( element , By . xpath ( xpath ) ) ; if ( ele != null ) { return ele ; } } return null ; } private WebElement findElement ( WebElement element , By by ) { try { return new WebElementWrapper ( this . response , element . findElement ( by ) ) ; } catch ( NoSuchElementException e ) {", "output": "return null ; } } private List < WebElement > findElements ( WebElement element , By by ) { try { List < WebElement > elements = element . findElements ( by ) ; if ( elements != null ) { return elements . stream ( ) . map ( ele -> new WebElementWrapper ( this . response , ele ) ) . collect ( Collectors . toList ( ) ) ; } } catch ( NoSuchElementException ignored ) { } return Collections . emptyList ( ) ; } }"}, {"input": "package org . example . infrastructure . repository . example . database . dataobject ; import io . github . chensheng . dddboot . microservice . core . DataObject ; import lombok . Data ; @ Data public class ExampleDetail extends DataObject { private Long userId ; private String country ; private String province ; private String city ; private String county ; private String detailAddress ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . reader . xls . XlsReader ; import io . github . chensheng . dddboot . excel . reader . xlsx . XlsxReader ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import org . apache . poi . poifs . filesystem . FileMagic ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . List ; public class ExcelReaderFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelReaderFactory . class ) ; public static < T > List < T > read ( InputStream inputStream , Class < T > rowType ) { List < T > rowDataList = new ArrayList < T > ( ) ; read ( inputStream , ( sheetConfig , rowData , rowIndex ) -> { if ( rowData != null ) { rowDataList . add ( ( T ) rowData ) ; } } , rowType ) ; return rowDataList ; } public static boolean read ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) { ExcelType excelType = resolveExcelType ( inputStream ) ; try { if ( excelType == null ) { readUnknownType ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLS ) { new XlsReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } else if ( excelType == ExcelType . XLSX ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } return true ; } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; return false ; } } private static void readUnknownType ( InputStream inputStream , RowReadingListener rowReadingListener , Class < ? > ... rowTypes ) throws Exception { try { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } catch ( Exception e ) { new XlsxReader ( ) . read ( inputStream , rowReadingListener , rowTypes ) ; } } private static ExcelType resolveExcelType ( InputStream inputStream ) { if ( inputStream == null || ! inputStream . markSupported ( ) ) { return null ; } try { FileMagic fileMagic = FileMagic . valueOf ( inputStream ) ; if ( FileMagic . OLE2 . equals ( fileMagic ) ) { return ExcelType . XLS ; } if ( FileMagic . OOXML . equals ( fileMagic ) ) { return ExcelType . XLSX ; } } catch ( IOException e ) { logger . warn ( ExceptionUtil . stackTraceText ( e ) ) ; } return null ;", "output": "} }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . date . DateUtil ; import cn . hutool . core . io . FileUtil ; import cn . hutool . extra . spring . SpringUtil ; import com . alibaba . excel . EasyExcel ; import com . google . protobuf . InvalidProtocolBufferException ; import com . xcs . wx . constant . ChatRoomConstant ; import com . xcs . wx . domain . Msg ; import com . xcs . wx . domain . vo . ExportMsgVO ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . mapping . MsgMapping ; import com . xcs . wx . msg . MsgStrategy ; import com . xcs . wx . msg . MsgStrategyFactory ; import com . xcs . wx . protobuf . MsgProto ; import com . xcs . wx . repository . ContactHeadImgUrlRepository ; import com . xcs . wx . repository . ContactRepository ; import com . xcs . wx . repository . MsgRepository ; import com . xcs . wx . service . MsgService ; import com . xcs . wx . service . UserService ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springframework . stereotype . Service ; import java . nio . file . FileSystems ; import java . util . Comparator ; import java . util . Date ; import java . util . List ; import java . util . stream . Collectors ; @ Slf4j @ Service @ RequiredArgsConstructor public class MsgServiceImpl implements MsgService { private final MsgRepository msgRepository ; private final MsgMapping msgMapping ; private final ContactHeadImgUrlRepository contactHeadImgUrlRepository ; private final ContactRepository contactRepository ; @ Override public List < MsgVO > queryMsg ( String talker , Long nextSequence ) { List < Msg > allData = msgRepository . queryMsgByTalker ( talker , nextSequence ) ; return msgMapping . convert ( allData ) . stream ( ) . sorted ( Comparator . comparing ( MsgVO :: getCreateTime ) ) . peek ( msgVO -> { msgVO . setWxId ( getChatWxId ( talker , msgVO ) ) ; msgVO . setStrCreateTime ( DateUtil . formatDateTime ( new Date ( msgVO . getCreateTime ( ) * <NUM_LIT> ) ) ) ; msgVO . setAvatar ( getChatAvatar ( msgVO . getWxId ( ) ) ) ; MsgStrategy strategy = MsgStrategyFactory . getStrategy ( msgVO . getType ( ) , msgVO . getSubType ( ) ) ; if ( strategy != null ) { strategy . process ( msgVO ) ; } } ) . collect ( Collectors . toList ( ) ) ; } @ Override public String exportMsg ( String talker ) { List < Msg > msgList = msgRepository . exportMsg ( talker ) ; List < MsgVO > msgVOList = msgMapping . convert ( msgList ) . stream ( ) . sorted ( Comparator . comparing ( MsgVO :: getCreateTime ) ) . peek ( msgVO -> { msgVO . setWxId ( getChatWxId ( talker , msgVO ) ) ; msgVO . setStrCreateTime ( DateUtil . formatDateTime ( new Date ( msgVO . getCreateTime ( ) * <NUM_LIT> ) ) ) ; MsgStrategy strategy = MsgStrategyFactory . getStrategy ( msgVO . getType ( ) , msgVO . getSubType ( ) ) ; if ( strategy != null ) { strategy . process ( msgVO ) ; } } ) . collect ( Collectors . toList ( ) ) ; String nickname = contactRepository . getContactNickname ( talker ) ; String separator = FileSystems . getDefault ( ) . getSeparator ( ) ; String filePath = System . getProperty ( \"<STR_LIT>\" ) + separator + \"<STR_LIT>\" + separator + \"<STR_LIT>\" ; FileUtil . mkdir ( filePath ) ; String pathName = filePath + separator + nickname + \"<STR_LIT>\" ;", "output": "EasyExcel . write ( pathName , ExportMsgVO . class ) . sheet ( \"<STR_LIT>\" ) . doWrite ( ( ) -> msgMapping . convertToExportMsgVO ( msgVOList ) ) ; return pathName ; } private String getChatWxId ( String talker , MsgVO msgVO ) { if ( msgVO . getIsSender ( ) == <NUM_LIT> ) { return SpringUtil . getBean ( UserService . class ) . currentUser ( ) ; } try { if ( talker . endsWith ( ChatRoomConstant . CHATROOM_SUFFIX ) ) { MsgProto . MessageBytesExtra messageBytesExtra = MsgProto . MessageBytesExtra . parseFrom ( msgVO . getBytesExtra ( ) ) ; List < MsgProto . SubMessage2 > message2List = messageBytesExtra . getMessage2List ( ) ; for ( MsgProto . SubMessage2 subMessage2 : message2List ) { if ( subMessage2 . getField1 ( ) == <NUM_LIT> ) { return subMessage2 . getField2 ( ) ; } } } } catch ( InvalidProtocolBufferException e ) { log . error ( \"<STR_LIT>\" , e ) ; } return talker ; } private String getChatAvatar ( String wxId ) { return contactHeadImgUrlRepository . queryHeadImgUrlByUserName ( wxId ) ; } }"}, {"input": "package com . youlai . system . service ; import com . youlai . system . model . dto . FileInfo ; import org . springframework . web . multipart . MultipartFile ; public interface OssService {", "output": "FileInfo uploadFile ( MultipartFile file ) ; boolean deleteFile ( String filePath ) ; }"}, {"input": "package com . xcs . wx . domain . vo ; import lombok . AllArgsConstructor ; import lombok . Data ; import java . util . List ; @ Data @ AllArgsConstructor public class PageVO < T > { private Long current ; private Long pageSize ; private Long total ; private List < T > records ;", "output": "}"}, {"input": "package com . oddfar . campus . common . utils ; import com . oddfar . campus . common . constant . HttpStatus ; import com . oddfar . campus . common . constant . UserConstants ; import com . oddfar . campus . common . domain . model . LoginUser ; import com . oddfar . campus . common . exception . ServiceException ; import org . springframework . security . authentication . AnonymousAuthenticationToken ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; public class SecurityUtils { public static Long getUserId ( ) { try { return getLoginUser ( ) . getUserId ( ) ; } catch ( Exception e ) { throw new ServiceException ( \"<STR_LIT>\" , HttpStatus . UNAUTHORIZED ) ; } } public static String getUsername ( ) { try { return getLoginUser ( ) . getUsername ( ) ; } catch ( Exception e ) { throw new ServiceException ( \"<STR_LIT>\" , HttpStatus . UNAUTHORIZED ) ; } } public static LoginUser getLoginUser ( ) { try { LoginUser loginUser = ( LoginUser ) getAuthentication ( ) . getPrincipal ( ) ; if ( ! loginUser . getUser ( ) . getStatus ( ) . equals ( UserConstants . NORMAL ) ) { throw new ServiceException ( \"<STR_LIT>\" , HttpStatus . FORBIDDEN ) ; } return loginUser ; } catch ( Exception e ) { throw new ServiceException ( \"<STR_LIT>\" , HttpStatus . UNAUTHORIZED ) ; } } public static boolean isLogin ( ) { Authentication auth = getAuthentication ( ) ; if ( auth instanceof AnonymousAuthenticationToken ) { return false ; } else { return true ; } } public static Authentication getAuthentication ( ) { return SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; } public static String encryptPassword ( String password ) { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder ( ) ; return passwordEncoder . encode ( password ) ; }", "output": "public static boolean matchesPassword ( String rawPassword , String encodedPassword ) { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder ( ) ; return passwordEncoder . matches ( rawPassword , encodedPassword ) ; } public static boolean isAdmin ( Long userId ) { return userId != null && <NUM_LIT> == userId ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . ExerciseRecord ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface ExerciseRecordMapper extends BaseMapper < ExerciseRecord > {", "output": "Integer deleteByUserIds ( List < Integer > userIds ) ; }"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import cn . hutool . crypto . digest . DigestUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; import java . io . IOException ; import java . io . InputStream ; @ Component @ Comment ( \"<STR_LIT>\" ) public class MD5FunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String string ( String str ) { return DigestUtil . md5Hex ( str ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String string ( byte [ ] bytes ) { return DigestUtil . md5Hex ( bytes ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String string ( InputStream stream ) throws IOException { return DigestUtil . md5Hex ( stream ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] bytes ( String str ) { return DigestUtil . md5 ( str ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] bytes ( byte [ ] bytes ) { return DigestUtil . md5 ( bytes ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static byte [ ] bytes ( InputStream stream ) throws IOException {", "output": "return DigestUtil . md5 ( stream ) ; } }"}, {"input": "package com . youlai . system . common . base ; import lombok . Data ; import lombok . ToString ; import java . io . Serial ; import java . io . Serializable ; @ Data @ ToString public class BaseVO implements Serializable { @ Serial private static final long serialVersionUID = <NUM_LIT> ;", "output": "}"}, {"input": "package com . yf . base . utils ; import lombok . extern . slf4j . Slf4j ; import java . math . BigDecimal ; import java . math . RoundingMode ; @ Slf4j public class DecimalUtils { private static final BigDecimal ZERO = new BigDecimal ( <NUM_LIT> ) ; public static BigDecimal zero ( ) { return ZERO ; } public static boolean gt ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null || arg1 == null ) { warnValue ( \"<STR_LIT>\" , arg0 , arg1 ) ; return false ; } return arg0 . compareTo ( arg1 ) > <NUM_LIT> ; } public static boolean gt ( BigDecimal arg0 , Double arg1 ) { return gt ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 . toString ( ) ) ) ; } public static boolean gt ( BigDecimal arg0 , Integer arg1 ) { return gt ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 ) ) ; } public static boolean ge ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null || arg1 == null ) { warnValue ( \"<STR_LIT>\" , arg0 , arg1 ) ; return false ; } return arg0 . compareTo ( arg1 ) >= <NUM_LIT> ; } public static boolean ge ( BigDecimal arg0 , Double arg1 ) { return gt ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 . toString ( ) ) ) ; } public static boolean lt ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null || arg1 == null ) { warnValue ( \"<STR_LIT>\" , arg0 , arg1 ) ; return false ; } return arg0 . compareTo ( arg1 ) < <NUM_LIT> ; } public static boolean lt ( BigDecimal arg0 , Double arg1 ) { return lt ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 . toString ( ) ) ) ; } public static boolean le ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null || arg1 == null ) { warnValue ( \"<STR_LIT>\" , arg0 , arg1 ) ; return false ; } return arg0 . compareTo ( arg1 ) <= <NUM_LIT> ; } public static boolean le ( BigDecimal arg0 , Double arg1 ) { return lt ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 . toString ( ) ) ) ; } public static boolean eq ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null || arg1 == null ) { warnValue ( \"<STR_LIT>\" , arg0 , arg1 ) ; return false ; } return arg0 . compareTo ( arg1 ) == <NUM_LIT> ; } public static boolean isZero ( BigDecimal value ) { return eq ( value , ZERO ) ; } public static boolean ltZero ( BigDecimal value ) { return lt ( value , ZERO ) ; } public static boolean gtZero ( BigDecimal value ) { return gt ( value , ZERO ) ; } public static boolean nullOrZero ( BigDecimal value ) { return value == null || isZero ( value ) ; } public static BigDecimal add ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null && arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ZERO ; } if ( arg0 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return arg1 ; } if ( arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return arg0 ; } return arg0 . add ( arg1 ) ; } public static BigDecimal divide ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null && arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ZERO ; } if ( arg0 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ZERO ; } if ( arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return arg0 ; } return arg0 . divide ( arg1 , <NUM_LIT> , RoundingMode . DOWN ) ; } public static BigDecimal divide ( BigDecimal arg0 , Integer arg1 ) { return divide ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 ) ) ; } public static BigDecimal divide ( BigDecimal arg0 , Double arg1 ) { return divide ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 . toString ( ) ) ) ; } public static BigDecimal multiply ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null && arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ZERO ; } if ( arg0 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return arg1 ; } if ( arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return arg0 ; } return arg0 . multiply ( arg1 ) ; }", "output": "public static BigDecimal multiply ( BigDecimal arg0 , Integer arg1 ) { return multiply ( arg0 , arg1 == null ? null : new BigDecimal ( arg1 ) ) ; } public static BigDecimal subtract ( BigDecimal arg0 , BigDecimal arg1 ) { if ( arg0 == null && arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return ZERO ; } if ( arg1 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; return arg0 ; } if ( arg0 == null ) { warnNull ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; arg0 = ZERO ; } return arg0 . subtract ( arg1 ) ; } private static void warnNull ( String methodName , String parmName ) { log . warn ( \"<STR_LIT>\" , methodName , parmName ) ; } private static void warnValue ( String methodName , BigDecimal ... value ) { log . warn ( \"<STR_LIT>\" , methodName , value ) ; } public static BigDecimal legal ( BigDecimal value ) { return value == null ? ZERO : value ; } }"}, {"input": "package com . oddfar . campus . framework . service . impl ; import cn . hutool . core . util . ObjectUtil ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . oddfar . campus . common . constant . UserConstants ; import com . oddfar . campus . common . core . page . PageQuery ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import com . oddfar . campus . common . domain . entity . SysUserEntity ; import com . oddfar . campus . common . domain . entity . SysUserRoleEntity ; import com . oddfar . campus . common . exception . ServiceException ; import com . oddfar . campus . common . utils . SecurityUtils ; import com . oddfar . campus . common . utils . StringUtils ; import com . oddfar . campus . framework . api . sysconfig . ConfigExpander ; import com . oddfar . campus . framework . mapper . SysRoleMapper ; import com . oddfar . campus . framework . mapper . SysUserMapper ; import com . oddfar . campus . framework . mapper . SysUserRoleMapper ; import com . oddfar . campus . framework . service . SysRoleService ; import com . oddfar . campus . framework . service . SysUserService ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . util . CollectionUtils ; import javax . annotation . Resource ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Service public class SysUserServiceImpl implements SysUserService { @ Resource private SysUserMapper userMapper ; @ Resource private SysUserRoleMapper userRoleMapper ; @ Resource private SysRoleMapper roleMapper ; @ Resource private SysRoleService roleService ; @ Override public PageResult < SysUserEntity > page ( SysUserEntity sysUserEntity ) { return userMapper . selectPage ( sysUserEntity ) ; } @ Override public SysUserEntity selectUserByUserName ( String userName ) { SysUserEntity userEntity = userMapper . selectUserByUserName ( userName ) ; if ( userEntity != null && StringUtils . isEmpty ( userEntity . getAvatar ( ) ) ) { userEntity . setAvatar ( ConfigExpander . getUserDefaultAvatar ( ) ) ; } return userEntity ; } @ Override public SysUserEntity selectUserById ( Long userId ) { SysUserEntity userEntity = userMapper . selectUserById ( userId ) ; if ( userEntity != null && StringUtils . isEmpty ( userEntity . getAvatar ( ) ) ) { userEntity . setAvatar ( ConfigExpander . getUserDefaultAvatar ( ) ) ; } return userEntity ; } @ Override public Page < SysUserEntity > selectAllocatedList ( SysUserEntity user ) { Page < SysUserEntity > page = new PageQuery ( ) . buildPage ( ) ; QueryWrapper < SysUserEntity > wrapper = Wrappers . query ( ) ; wrapper . eq ( \"<STR_LIT>\" , UserConstants . NORMAL ) . eq ( \"<STR_LIT>\" , user . getRoleId ( ) ) . eq ( ObjectUtil . isNotNull ( user . getPhonenumber ( ) ) , \"<STR_LIT>\" , user . getPhonenumber ( ) ) . like ( ObjectUtil . isNotNull ( user . getUserName ( ) ) , \"<STR_LIT>\" , user . getUserName ( ) ) ; Page < SysUserEntity > sysUserPage = userMapper . selectAllocatedList ( page , wrapper ) ; return sysUserPage ; } @ Override public Page < SysUserEntity > selectUnallocatedList ( SysUserEntity user ) { Page < SysUserEntity > page = new PageQuery ( ) . buildPage ( ) ; return userMapper . selectUnallocatedList ( page , user ) ; } @ Override public String selectUserRoleGroup ( String userName ) { List < SysRoleEntity > list = roleMapper . selectRolesByUserName ( userName ) ; if ( CollectionUtils . isEmpty ( list ) ) { return StringUtils . EMPTY ; } return list . stream ( ) . map ( SysRoleEntity :: getRoleName ) . collect ( Collectors . joining ( \"<STR_LIT>\" ) ) ; } @ Override public boolean registerUser ( SysUserEntity user ) { return userMapper . insert ( user ) > <NUM_LIT> ; } @ Override @ Transactional public int insertUser ( SysUserEntity user ) { if ( StringUtils . isNotEmpty ( user . getUserName ( ) ) && ! checkUserNameUnique ( user ) ) { throw new ServiceException ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } if ( StringUtils . isNotEmpty ( user . getPhonenumber ( ) ) && ! ( checkPhoneUnique ( user ) ) ) { throw new ServiceException ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } if ( StringUtils . isNotEmpty ( user . getEmail ( ) ) && ! ( checkEmailUnique ( user ) ) ) { throw new ServiceException ( \"<STR_LIT>\" + user . getUserName ( ) + \"<STR_LIT>\" ) ; } user . setPassword ( SecurityUtils . encryptPassword ( user . getPassword ( ) ) ) ; int rows = userMapper . insert ( user ) ; insertUserRole ( user ) ; return rows ; } @ Override @ Transactional public int updateUser ( SysUserEntity user ) { Long userId = user . getUserId ( ) ; userRoleMapper . deleteUserRoleByUserId ( userId ) ; insertUserRole ( user ) ; return userMapper . updateById ( user ) ; } @ Override @ Transactional public int deleteUserByIds ( Long [ ] userIds ) { for ( Long userId : userIds ) { checkUserAllowed ( new SysUserEntity ( userId ) ) ; } userRoleMapper . deleteUserRole ( userIds ) ; return userMapper . deleteBatchIds ( Arrays . asList ( userIds ) ) ; } @ Override public int updateUserProfile ( SysUserEntity user ) { return userMapper . updateById ( user ) ; } @ Override public int updateUserStatus ( SysUserEntity user ) { return userMapper . updateById ( user ) ; } @ Override public boolean updateUserAvatar ( String userName , String avatar ) { return userMapper . updateUserAvatar ( userName , avatar ) > <NUM_LIT> ; } @ Override public int resetPwd ( SysUserEntity user ) { return userMapper . updateById ( user ) ; } @ Override public void checkUserAllowed ( SysUserEntity user ) { if ( StringUtils . isNotNull ( user . getUserId ( ) ) && user . isAdmin ( ) ) { throw new ServiceException ( \"<STR_LIT>\" ) ; }", "output": "} @ Override @ Transactional public void insertUserAuth ( Long userId , Long [ ] roleIds ) { userRoleMapper . deleteUserRoleByUserId ( userId ) ; insertUserRole ( userId , roleIds ) ; } @ Override public void insertUserAuth ( Long userId , Set < String > roleKey ) { Set < String > roleSet = roleService . selectRolePermissionByUserId ( userId ) ; roleKey . addAll ( roleSet ) ; List < SysRoleEntity > sysRoleList = roleMapper . selectRoleListByKey ( roleKey ) ; List < Long > roleIds = sysRoleList . stream ( ) . map ( SysRoleEntity :: getRoleId ) . collect ( Collectors . toList ( ) ) ; userRoleMapper . deleteUserRoleByUserId ( userId ) ; insertUserRole ( userId , roleIds . toArray ( new Long [ <NUM_LIT> ] ) ) ; } @ Override public int resetUserPwd ( String userName , String password ) { return userMapper . resetUserPwd ( userName , password ) ; } @ Override public boolean checkUserNameUnique ( SysUserEntity user ) { Long userId = StringUtils . isNull ( user . getUserId ( ) ) ? - <NUM_LIT> : user . getUserId ( ) ; SysUserEntity info = userMapper . checkUserNameUnique ( user . getUserName ( ) ) ; if ( StringUtils . isNotNull ( info ) && info . getUserId ( ) . longValue ( ) != userId . longValue ( ) ) { return false ; } return true ; } @ Override public boolean checkPhoneUnique ( SysUserEntity user ) { Long userId = StringUtils . isNull ( user . getUserId ( ) ) ? - <NUM_LIT> : user . getUserId ( ) ; SysUserEntity info = userMapper . checkPhoneUnique ( user . getPhonenumber ( ) ) ; if ( StringUtils . isNotNull ( info ) && info . getUserId ( ) . longValue ( ) != userId . longValue ( ) ) { return false ; } return true ; } @ Override public boolean checkEmailUnique ( SysUserEntity user ) { Long userId = StringUtils . isNull ( user . getUserId ( ) ) ? - <NUM_LIT> : user . getUserId ( ) ; SysUserEntity info = userMapper . checkEmailUnique ( user . getEmail ( ) ) ; if ( StringUtils . isNotNull ( info ) && info . getUserId ( ) . longValue ( ) != userId . longValue ( ) ) { return false ; } return true ; } public void insertUserRole ( SysUserEntity user ) { this . insertUserRole ( user . getUserId ( ) , user . getRoleIds ( ) ) ; } public void insertUserRole ( Long userId , Long [ ] roleIds ) { if ( StringUtils . isNotEmpty ( roleIds ) ) { List < SysUserRoleEntity > list = new ArrayList < SysUserRoleEntity > ( roleIds . length ) ; for ( Long roleId : roleIds ) { SysUserRoleEntity ur = new SysUserRoleEntity ( ) ; ur . setUserId ( userId ) ; ur . setRoleId ( roleId ) ; list . add ( ur ) ; } userRoleMapper . insertBatch ( list ) ; } } }"}, {"input": "package org . springblade . config . util . converter ; import java . util . Map ; public interface FieldCommentConverter { String converterToVal ( String s ) ; String converterToTxt ( String s ) ; Map < String , String > getConfig ( ) ;", "output": "}"}, {"input": "package com . youlai . system . common . util ; import cn . hutool . core . util . StrUtil ; import jakarta . annotation . PostConstruct ; import jakarta . servlet . http . HttpServletRequest ; import lombok . extern . slf4j . Slf4j ; import org . lionsoul . ip2region . xdb . Searcher ; import org . springframework . stereotype . Component ; import java . io . FileNotFoundException ; import java . io . InputStream ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardCopyOption ; @ Slf4j @ Component public class IPUtils { private static final String DB_PATH = \"<STR_LIT>\" ; private static Searcher searcher ; @ PostConstruct public void init ( ) { try { InputStream inputStream = getClass ( ) . getResourceAsStream ( DB_PATH ) ; if ( inputStream == null ) { throw new FileNotFoundException ( \"<STR_LIT>\" + DB_PATH ) ; } Path tempDbPath = Files . createTempFile ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Files . copy ( inputStream , tempDbPath , StandardCopyOption . REPLACE_EXISTING ) ; searcher = Searcher . newWithFileOnly ( tempDbPath . toString ( ) ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } } public static String getIpAddr ( HttpServletRequest request ) { String ip = null ; try { if ( request == null ) { return \"<STR_LIT>\" ; } ip = request . getHeader ( \"<STR_LIT>\" ) ; if ( checkIp ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ;", "output": "} if ( checkIp ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( checkIp ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( checkIp ( ip ) ) { ip = request . getHeader ( \"<STR_LIT>\" ) ; } if ( checkIp ( ip ) ) { ip = request . getRemoteAddr ( ) ; if ( \"<STR_LIT>\" . equals ( ip ) || \"<STR_LIT>\" . equals ( ip ) ) { ip = getLocalAddr ( ) ; } } } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } if ( StrUtil . isNotBlank ( ip ) && ip . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) { ip = ip . substring ( <NUM_LIT> , ip . indexOf ( \"<STR_LIT>\" ) ) ; } return ip ; } private static boolean checkIp ( String ip ) { String unknown = \"<STR_LIT>\" ; return StrUtil . isEmpty ( ip ) || unknown . equalsIgnoreCase ( ip ) ; } private static String getLocalAddr ( ) { try { return InetAddress . getLocalHost ( ) . getHostAddress ( ) ; } catch ( UnknownHostException e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; } return null ; } public static String getRegion ( String ip ) { if ( searcher == null ) { log . error ( \"<STR_LIT>\" ) ; return null ; } try { return searcher . search ( ip ) ; } catch ( Exception e ) { log . error ( \"<STR_LIT>\" , e . getMessage ( ) ) ; return null ; } } }"}, {"input": "package me . zhengjie . modules . quartz . domain . vo ; import lombok . Data ; import java . sql . Timestamp ; import java . util . List ; @ Data public class QuartzJobQueryCriteria { private String jobName ; private Boolean isSuccess ; private List < Timestamp > createTime ;", "output": "}"}, {"input": "package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . GET ) public @ interface AnonymousGetMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default \"<STR_LIT>\" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default {", "output": "} ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; }"}, {"input": "package ginyi . common . mysql . config ; import com . baomidou . mybatisplus . annotation . DbType ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; @ Configuration public class MyBatisPlusInterceptorConfig { @ Bean public MybatisPlusInterceptor myBatisPlusInterceptor ( ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ;", "output": "interceptor . addInnerInterceptor ( new PaginationInnerInterceptor ( DbType . MYSQL ) ) ; return interceptor ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . context . event . DeferredApplicationEventPublisher ; import io . github . chensheng . dddboot . nacos . spring . metadata . NacosServiceMetaData ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import java . util . Properties ; import java . util . concurrent . Executor ; public class EventPublishingConfigService implements ConfigService , NacosServiceMetaData , DisposableBean { private final ConfigService configService ; private final ApplicationEventPublisher applicationEventPublisher ; private final Executor executor ; private final Properties properties ; public EventPublishingConfigService ( ConfigService configService , Properties properties , ConfigurableApplicationContext context , Executor executor ) { this . configService = configService ; this . properties = properties ; this . applicationEventPublisher = new DeferredApplicationEventPublisher ( context ) ; this . executor = executor ; } @ Override public String getConfig ( String dataId , String group , long timeoutMs ) throws NacosException { try { return configService . getConfig ( dataId , group , timeoutMs ) ; } catch ( NacosException e ) { if ( NacosException . SERVER_ERROR == e . getErrCode ( ) ) { publishEvent ( new NacosConfigTimeoutEvent ( configService , dataId , group , timeoutMs , e . getErrMsg ( ) ) ) ; } throw e ; } } @ Override public String getConfigAndSignListener ( String dataId , String group , long timeoutMs , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , applicationEventPublisher , executor , listener ) ; return configService . getConfigAndSignListener ( dataId , group , timeoutMs , listenerAdapter ) ; } public void addListener ( String dataId , String group , String type , Listener listener ) throws NacosException { Listener listenerAdapter = new DelegatingEventPublishingListener ( configService , dataId , group , type , applicationEventPublisher , executor , listener ) ; addListener ( dataId , group , listenerAdapter ) ; } @ Override public void addListener ( String dataId , String group , Listener listener ) throws NacosException { configService . addListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , true ) ) ; } @ Override public boolean publishConfig ( String dataId , String group , String content ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean publishConfig ( String dataId , String group , String content , String type ) throws NacosException { boolean published = configService . publishConfig ( dataId , group , content , type ) ; publishEvent ( new NacosConfigPublishedEvent ( configService , dataId , group , content , published ) ) ; return published ; } @ Override public boolean removeConfig ( String dataId , String group ) throws NacosException {", "output": "boolean removed = configService . removeConfig ( dataId , group ) ; publishEvent ( new NacosConfigRemovedEvent ( configService , dataId , group , removed ) ) ; return removed ; } @ Override public void removeListener ( String dataId , String group , Listener listener ) { configService . removeListener ( dataId , group , listener ) ; publishEvent ( new NacosConfigListenerRegisteredEvent ( configService , dataId , group , listener , false ) ) ; } @ Override public String getServerStatus ( ) { return configService . getServerStatus ( ) ; } @ Override public void shutDown ( ) throws NacosException { configService . shutDown ( ) ; } private void publishEvent ( NacosConfigEvent nacosConfigEvent ) { applicationEventPublisher . publishEvent ( nacosConfigEvent ) ; } @ Override public Properties getProperties ( ) { return properties ; } @ Override public void destroy ( ) throws Exception { shutDown ( ) ; } }"}, {"input": "package cn . org . alan . exam . config ; import org . springframework . boot . web . servlet . FilterRegistrationBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import java . util . Collections ; @ Configuration public class CorsConfig { @ Bean public FilterRegistrationBean filterRegistrationBean ( ) { CorsConfiguration corsConfiguration = new CorsConfiguration ( ) ;", "output": "corsConfiguration . setAllowedOriginPatterns ( Collections . singletonList ( \"<STR_LIT>\" ) ) ; corsConfiguration . addAllowedHeader ( CorsConfiguration . ALL ) ; corsConfiguration . addAllowedMethod ( CorsConfiguration . ALL ) ; corsConfiguration . setAllowCredentials ( true ) ; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , corsConfiguration ) ; CorsFilter corsFilter = new CorsFilter ( source ) ; FilterRegistrationBean < CorsFilter > filterRegistrationBean = new FilterRegistrationBean < > ( corsFilter ) ; filterRegistrationBean . setOrder ( - <NUM_LIT> ) ; return filterRegistrationBean ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event . config ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . listener . Listener ; import org . springframework . context . ApplicationEventPublisher ; import java . util . concurrent . Executor ; public final class DelegatingEventPublishingListener implements Listener { private final ConfigService configService ; private final String dataId ; private final String groupId ; private final ApplicationEventPublisher applicationEventPublisher ; private final String configType ; private final Executor executor ; private final Listener delegate ; DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this ( configService , dataId , groupId , ConfigType . PROPERTIES . getType ( ) , applicationEventPublisher , executor , delegate ) ; } DelegatingEventPublishingListener ( ConfigService configService , String dataId , String groupId , String configType , ApplicationEventPublisher applicationEventPublisher , Executor executor , Listener delegate ) { this . configService = configService ; this . dataId = dataId ; this . groupId = groupId ; this . configType = configType ; this . applicationEventPublisher = applicationEventPublisher ; this . executor = executor ; this . delegate = delegate ; } @ Override public Executor getExecutor ( ) { Executor executor = delegate . getExecutor ( ) ; if ( executor == null ) {", "output": "executor = this . executor ; } return executor ; } @ Override public void receiveConfigInfo ( String content ) { onReceived ( content ) ; publishEvent ( content ) ; } private void publishEvent ( String content ) { NacosConfigReceivedEvent event = new NacosConfigReceivedEvent ( configService , dataId , groupId , content , configType ) ; applicationEventPublisher . publishEvent ( event ) ; } private void onReceived ( String content ) { delegate . receiveConfigInfo ( content ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . context . ApplicationListener ; import java . util . Map ; public class LoggingNacosConfigMetadataEventListener implements ApplicationListener < NacosConfigMetadataEvent > { public static final String BEAN_NAME = \"<STR_LIT>\" ; private final static String LOGGING_MESSAGE = \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ; private final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; @ Override public void onApplicationEvent ( NacosConfigMetadataEvent event ) { if ( ! logger . isInfoEnabled ( ) ) { return ;", "output": "} logger . info ( LOGGING_MESSAGE , event . getDataId ( ) , event . getGroupId ( ) , event . getBeanName ( ) , event . getBean ( ) , event . getBeanType ( ) , event . getAnnotatedElement ( ) , event . getXmlResource ( ) , obscuresNacosProperties ( event . getNacosProperties ( ) ) , event . getNacosPropertiesAttributes ( ) , event . getSource ( ) , event . getTimestamp ( ) ) ; } private String obscuresNacosProperties ( Map < Object , Object > nacosProperties ) { String nacosPropertyStr ; if ( nacosProperties != null && nacosProperties . size ( ) > <NUM_LIT> ) { StringBuilder sb = new StringBuilder ( \"<STR_LIT>\" ) ; int size = nacosProperties . size ( ) ; int idx = <NUM_LIT> ; for ( Map . Entry < Object , Object > e : nacosProperties . entrySet ( ) ) { Object key = e . getKey ( ) ; Object value = e . getValue ( ) ; sb . append ( key ) ; sb . append ( '<STR_LIT>' ) ; if ( key != null && NacosProperties . PASSWORD . equals ( key . toString ( ) ) ) { sb . append ( \"<STR_LIT>\" ) ; } else { sb . append ( value ) ; } if ( idx < size - <NUM_LIT> ) { sb . append ( \"<STR_LIT>\" ) ; } idx ++ ; } sb . append ( \"<STR_LIT>\" ) ; nacosPropertyStr = sb . toString ( ) ; } else { nacosPropertyStr = \"<STR_LIT>\" ; } return nacosPropertyStr ; } }"}, {"input": "package org . example . ddduser . infrastructure . repository . microservice . request ; import lombok . Data ; @ Data public class WorkspaceCreateRequest { private Long owner ;", "output": "}"}, {"input": "package org . example . ddduser . application . dto . command ; import lombok . Data ; import javax . validation . constraints . NotEmpty ; @ Data public class ModifyPasswordCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String oldPassword ; @ NotEmpty ( message = \"<STR_LIT>\" ) private String newPassword ;", "output": "}"}, {"input": "package org . springblade . config . util . jsonschema . validate ; import com . alibaba . fastjson . JSONArray ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . util . jsonschema . CommonProperty ; import java . util . HashMap ; import java . util . Map ; public class SwitchProperty extends CommonProperty { private static final long serialVersionUID = <NUM_LIT> ; private String extendStr ; public SwitchProperty ( ) {", "output": "} public SwitchProperty ( String key , String title , String extendStr ) { this . type = \"<STR_LIT>\" ; this . view = \"<STR_LIT>\" ; this . key = key ; this . title = title ; this . extendStr = extendStr ; } @ Override public Map < String , Object > getPropertyJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( \"<STR_LIT>\" , getKey ( ) ) ; JSONObject prop = getCommonJson ( ) ; JSONArray array = new JSONArray ( ) ; if ( extendStr != null ) { array = JSONArray . parseArray ( extendStr ) ; prop . put ( \"<STR_LIT>\" , array ) ; } map . put ( \"<STR_LIT>\" , prop ) ; return map ; } }"}, {"input": "package com . oddfar . campus . common . domain ; import com . alibaba . fastjson2 . JSON ; import com . alibaba . fastjson2 . TypeReference ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . oddfar . campus . common . enums . BizCodeEnum ; import java . util . HashMap ; import java . util . Map ; public class R extends HashMap < String , Object > { private static final long serialVersionUID = <NUM_LIT> ; public R setData ( Object data ) { put ( \"<STR_LIT>\" , data ) ; return this ; } public < T > T getData ( String key , TypeReference < T > typeReference ) { Object data = get ( key ) ; String s = JSON . toJSONString ( data ) ; T t = JSON . parseObject ( s , typeReference ) ; return t ; } public < T > T getData ( TypeReference < T > typeReference ) { Object data = get ( \"<STR_LIT>\" ) ; String s = JSON . toJSONString ( data ) ; T t = JSON . parseObject ( s , typeReference ) ; return t ; } public R ( ) { put ( \"<STR_LIT>\" , <NUM_LIT> ) ; put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; } public static R error ( ) { return error ( <NUM_LIT> , \"<STR_LIT>\" ) ; } public static R error ( String msg ) { return error ( <NUM_LIT> , msg ) ; } public static R error ( int code , String msg ) { R r = new R ( ) ; r . put ( \"<STR_LIT>\" , code ) ; r . put ( \"<STR_LIT>\" , msg ) ;", "output": "return r ; } public static R error ( BizCodeEnum bizCodeEnum ) { R r = new R ( ) ; r . put ( \"<STR_LIT>\" , bizCodeEnum . getCode ( ) ) ; r . put ( \"<STR_LIT>\" , bizCodeEnum . getMsg ( ) ) ; return r ; } public static R ok ( String msg ) { R r = new R ( ) ; r . put ( \"<STR_LIT>\" , msg ) ; return r ; } public static R ok ( String msg , Object data ) { R r = new R ( ) ; r . put ( \"<STR_LIT>\" , msg ) ; r . put ( \"<STR_LIT>\" , data ) ; return r ; } public static R ok ( Object data ) { R r = new R ( ) ; r . put ( \"<STR_LIT>\" , data ) ; return r ; } public static R ok ( Map < String , Object > map ) { R r = new R ( ) ; r . putAll ( map ) ; return r ; } public static R ok ( ) { return new R ( ) ; } public R put ( String key , Object value ) { super . put ( key , value ) ; return this ; } public R put ( Object value ) { super . put ( \"<STR_LIT>\" , value ) ; return this ; } public R put ( PageResult pageResult ) { super . put ( \"<STR_LIT>\" , pageResult . getRows ( ) ) ; super . put ( \"<STR_LIT>\" , pageResult . getTotal ( ) ) ; return this ; } public R put ( IPage page ) { super . put ( \"<STR_LIT>\" , page . getRecords ( ) ) ; super . put ( \"<STR_LIT>\" , page . getTotal ( ) ) ; return this ; } public Integer getCode ( ) { return ( Integer ) this . get ( \"<STR_LIT>\" ) ; } }"}, {"input": "package org . springblade . cgform . model . generate . pojo ; public class CgFormColumnExtendVo { protected Integer fieldLength ; protected String fieldHref ; protected String fieldValidType ; protected String fieldDefault ; protected String fieldShowType ; protected Integer fieldOrderNum ; protected String isKey ; protected String isShow ; protected String isShowList ; protected String isQuery ; protected String queryMode ; protected String dictField ; protected String dictTable ; protected String dictText ; public String getIsKey ( ) { return this . isKey ; } public void setIsKey ( String isKey ) { this . isKey = isKey ; } public String getFieldDefault ( ) { return this . fieldDefault ; } public void setFieldDefault ( String fieldDefault ) { this . fieldDefault = fieldDefault ; } public String getIsShow ( ) { return this . isShow ; } public void setIsShow ( String isShow ) { this . isShow = isShow ; } public String getIsShowList ( ) { return this . isShowList ; } public void setIsShowList ( String isShowList ) { this . isShowList = isShowList ; } public String getIsQuery ( ) { return this . isQuery ; } public void setIsQuery ( String isQuery ) { this . isQuery = isQuery ; } public Integer getFieldLength ( ) { return this . fieldLength ; } public void setFieldLength ( Integer fieldLength ) { this . fieldLength = fieldLength ; } public String getFieldHref ( ) { return this . fieldHref ; } public void setFieldHref ( String fieldHref ) { this . fieldHref = fieldHref ; } public String getFieldValidType ( ) { return this . fieldValidType ; } public void setFieldValidType ( String fieldValidType ) { this . fieldValidType = fieldValidType ; } public String getQueryMode ( ) { return this . queryMode ;", "output": "} public void setQueryMode ( String queryMode ) { this . queryMode = queryMode ; } public String getDictField ( ) { return this . dictField ; } public void setDictField ( String dictField ) { this . dictField = dictField ; } public String getDictTable ( ) { return this . dictTable ; } public void setDictTable ( String dictTable ) { this . dictTable = dictTable ; } public String getDictText ( ) { return this . dictText ; } public void setDictText ( String dictText ) { this . dictText = dictText ; } public String getFieldShowType ( ) { return this . fieldShowType ; } public void setFieldShowType ( String fieldShowType ) { this . fieldShowType = fieldShowType ; } public Integer getFieldOrderNum ( ) { return this . fieldOrderNum ; } public void setFieldOrderNum ( Integer fieldOrderNum ) { this . fieldOrderNum = fieldOrderNum ; } @ Override public String toString ( ) { return \"<STR_LIT>\" ; } }"}, {"input": "package top . kangert . kspider . expression ; import top . kangert . kspider . executor . FunctionExecutor ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . expression . interpreter . AbstractReflection ; import top . kangert . kspider . io . SpiderResponse ; import top . kangert . kspider . support . ExpressionEngine ; import org . jsoup . nodes . Element ; import org . jsoup . select . Elements ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . jdbc . support . rowset . SqlRowSet ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import javax . annotation . PostConstruct ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Date ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Component public class DefaultExpressionEngine implements ExpressionEngine { @ Autowired @ SuppressWarnings ( \"<STR_LIT>\" ) private List < FunctionExecutor > functionExecutors ; @ Autowired @ SuppressWarnings ( \"<STR_LIT>\" ) private List < FunctionExtension > functionExtensions ; private List < Class < ? > > extensionClasses = Arrays . asList ( SpiderResponse . class , Element . class , Elements . class , String . class , Object . class , Date . class , Integer . class , List . class , Object [ ] . class , Map . class , SqlRowSet . class ) ; @ PostConstruct private void init ( ) { for ( FunctionExtension extension : functionExtensions ) { AbstractReflection . getInstance ( ) . registerExtensionClass ( extension . support ( ) , extension . getClass ( ) ) ; } } public Map < String , ExpressionObject > getExpressionObjectMap ( ) { Map < String , ExpressionObject > objectMap = new HashMap < > ( ) ; functionExecutors . forEach ( functionExecutor -> { ExpressionObject object = new ExpressionObject ( ) ;", "output": "object . setClassName ( functionExecutor . getFunctionPrefix ( ) ) ; object . setMethods ( getMethod ( functionExecutor . getClass ( ) , true ) ) ; objectMap . put ( object . getClassName ( ) , object ) ; } ) ; extensionClasses . forEach ( clazz -> { ExpressionObject object = new ExpressionObject ( ) ; object . setClassName ( clazz . getSimpleName ( ) ) ; getMethod ( clazz , false ) . forEach ( method -> { if ( method . getName ( ) . startsWith ( \"<STR_LIT>\" ) && method . getParameters ( ) . size ( ) == <NUM_LIT> && method . getName ( ) . length ( ) > <NUM_LIT> ) { String attributeName = method . getName ( ) . substring ( <NUM_LIT> ) ; attributeName = attributeName . substring ( <NUM_LIT> , <NUM_LIT> ) . toLowerCase ( ) + attributeName . substring ( <NUM_LIT> ) ; object . addAttribute ( new ExpressionObject . ExpressionAttribute ( method . getReturnType ( ) , attributeName ) ) ; } else { object . addMethod ( method ) ; } } ) ; objectMap . put ( object . getClassName ( ) , object ) ; } ) ; functionExtensions . forEach ( extensions -> { ExpressionObject object = objectMap . get ( extensions . support ( ) . getSimpleName ( ) ) ; if ( object != null ) { getMethod ( extensions . getClass ( ) , true ) . forEach ( method -> { if ( method . getParameters ( ) . size ( ) > <NUM_LIT> ) { method . getParameters ( ) . remove ( <NUM_LIT> ) ; object . addMethod ( method ) ; } } ) ; } } ) ; return objectMap ; } private List < ExpressionObject . ExpressionMethod > getMethod ( Class < ? > clazz , boolean publicAndStatic ) { List < ExpressionObject . ExpressionMethod > methods = new ArrayList < > ( ) ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; for ( int i = <NUM_LIT> ; i < declaredMethods . length ; i ++ ) { Method declaredMethod = declaredMethods [ i ] ; if ( Modifier . isPublic ( declaredMethod . getModifiers ( ) ) ) { boolean isStatic = Modifier . isStatic ( declaredMethod . getModifiers ( ) ) ; if ( ( ! publicAndStatic ) || isStatic ) { methods . add ( new ExpressionObject . ExpressionMethod ( declaredMethod ) ) ; } } } return methods ; } @ Override public Object execute ( String expression , Map < String , Object > variables ) { if ( StrUtil . isBlank ( expression ) ) { return expression ; } ExpressionTemplateContext context = new ExpressionTemplateContext ( variables ) ; for ( FunctionExecutor executor : functionExecutors ) { context . set ( executor . getFunctionPrefix ( ) , executor ) ; } ExpressionGlobalVariables . getVariables ( ) . entrySet ( ) . forEach ( entry -> { context . set ( entry . getKey ( ) , ExpressionTemplate . create ( entry . getValue ( ) ) . render ( context ) ) ; } ) ; try { ExpressionTemplateContext . set ( context ) ; return ExpressionTemplate . create ( expression ) . render ( context ) ; } finally { ExpressionTemplateContext . remove ( ) ; } } }"}, {"input": "package me . zhengjie . modules . mnt . service . impl ; import cn . hutool . core . date . DatePattern ; import cn . hutool . core . date . DateUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . mnt . domain . App ; import me . zhengjie . modules . mnt . domain . Deploy ; import me . zhengjie . modules . mnt . domain . DeployHistory ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . mapper . DeployMapper ; import me . zhengjie . modules . mnt . mapper . DeployServerMapper ; import me . zhengjie . modules . mnt . service . DeployHistoryService ; import me . zhengjie . modules . mnt . service . DeployService ; import me . zhengjie . modules . mnt . service . ServerService ; import me . zhengjie . modules . mnt . domain . vo . DeployQueryCriteria ; import me . zhengjie . modules . mnt . util . ExecuteShellUtil ; import me . zhengjie . modules . mnt . util . ScpClientUtil ; import me . zhengjie . modules . mnt . websocket . MsgType ; import me . zhengjie . modules . mnt . websocket . SocketMsg ; import me . zhengjie . modules . mnt . websocket . WebSocketServer ; import me . zhengjie . utils . * ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Slf4j @ Service @ RequiredArgsConstructor public class DeployServiceImpl extends ServiceImpl < DeployMapper , Deploy > implements DeployService { private final String FILE_SEPARATOR = \"<STR_LIT>\" ; private final DeployMapper deployMapper ; private final DeployServerMapper deployServerMapper ; private final ServerService serverService ; private final DeployHistoryService deployHistoryService ; private final Integer count = <NUM_LIT> ; @ Override public PageResult < Deploy > queryAll ( DeployQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < Deploy > deploys = deployMapper . findAll ( criteria ) ; Long total = deployMapper . countAll ( criteria ) ; return PageUtil . toPage ( deploys , total ) ; } @ Override public List < Deploy > queryAll ( DeployQueryCriteria criteria ) { return deployMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Deploy resources ) { resources . setAppId ( resources . getApp ( ) . getId ( ) ) ; save ( resources ) ; deployServerMapper . insertData ( resources . getId ( ) , resources . getDeploys ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Deploy resources ) { Deploy deploy = getById ( resources . getId ( ) ) ; deploy . copy ( resources ) ; saveOrUpdate ( deploy ) ; deployServerMapper . deleteByDeployId ( resources . getId ( ) ) ; deployServerMapper . insertData ( resources . getId ( ) , resources . getDeploys ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; deployServerMapper . deleteByDeployIds ( ids ) ; } @ Override public void deploy ( String fileSavePath , Long id ) { deployApp ( fileSavePath , id ) ; } private void deployApp ( String fileSavePath , Long id ) { Deploy deploy = deployMapper . getDeployById ( id ) ; if ( deploy == null ) { sendMsg ( \"<STR_LIT>\" , MsgType . ERROR ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } App app = deploy . getApp ( ) ; if ( app == null ) { sendMsg ( \"<STR_LIT>\" , MsgType . ERROR ) ; throw new BadRequestException ( \"<STR_LIT>\" ) ; } int port = app . getPort ( ) ; String uploadPath = app . getUploadPath ( ) ; StringBuilder sb = new StringBuilder ( ) ; String msg ; Set < Server > deploys = deploy . getDeploys ( ) ; for ( Server server : deploys ) { String ip = server . getIp ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( ip ) ; boolean flag = checkFile ( executeShellUtil , app ) ; executeShellUtil . execute ( \"<STR_LIT>\" + app . getUploadPath ( ) ) ; executeShellUtil . execute ( \"<STR_LIT>\" + app . getBackupPath ( ) ) ; executeShellUtil . execute ( \"<STR_LIT>\" + app . getDeployPath ( ) ) ; msg = String . format ( \"<STR_LIT>\" , ip ) ;", "output": "ScpClientUtil scpClientUtil = getScpClientUtil ( ip ) ; log . info ( msg ) ; sendMsg ( msg , MsgType . INFO ) ; msg = String . format ( \"<STR_LIT>\" , ip , uploadPath ) ; sendMsg ( msg , MsgType . INFO ) ; scpClientUtil . putFile ( fileSavePath , uploadPath ) ; if ( flag ) { sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; stopApp ( port , executeShellUtil ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; backupApp ( executeShellUtil , ip , app . getDeployPath ( ) + FILE_SEPARATOR , app . getName ( ) , app . getBackupPath ( ) + FILE_SEPARATOR , id ) ; } sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; String deployScript = app . getDeployScript ( ) ; executeShellUtil . execute ( deployScript ) ; sleep ( <NUM_LIT> ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; int i = <NUM_LIT> ; boolean result = false ; while ( i ++ < count ) { result = checkIsRunningStatus ( port , executeShellUtil ) ; if ( result ) { break ; } sleep ( <NUM_LIT> ) ; } sb . append ( \"<STR_LIT>\" ) . append ( server . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( app . getName ( ) ) ; sendResultMsg ( result , sb ) ; executeShellUtil . close ( ) ; } } private void sleep ( int second ) { try { Thread . sleep ( second * <NUM_LIT> ) ; } catch ( InterruptedException e ) { log . error ( e . getMessage ( ) , e ) ; } } private void backupApp ( ExecuteShellUtil executeShellUtil , String ip , String fileSavePath , String appName , String backupPath , Long id ) { String deployDate = DateUtil . format ( new Date ( ) , DatePattern . PURE_DATETIME_PATTERN ) ; StringBuilder sb = new StringBuilder ( ) ; backupPath += appName + FILE_SEPARATOR + deployDate + \"<STR_LIT>\" ; sb . append ( \"<STR_LIT>\" ) . append ( backupPath ) ; sb . append ( \"<STR_LIT>\" ) . append ( fileSavePath ) ; sb . append ( appName ) . append ( \"<STR_LIT>\" ) . append ( backupPath ) ; log . info ( \"<STR_LIT>\" + sb . toString ( ) ) ; executeShellUtil . execute ( sb . toString ( ) ) ; DeployHistory deployHistory = new DeployHistory ( ) ; deployHistory . setAppName ( appName ) ; deployHistory . setDeployUser ( SecurityUtils . getCurrentUsername ( ) ) ; deployHistory . setIp ( ip ) ; deployHistory . setDeployId ( id ) ; deployHistoryService . create ( deployHistory ) ; } private void stopApp ( int port , ExecuteShellUtil executeShellUtil ) { executeShellUtil . execute ( String . format ( \"<STR_LIT>\" , port ) ) ; } private boolean checkIsRunningStatus ( int port , ExecuteShellUtil executeShellUtil ) { String result = executeShellUtil . executeForResult ( String . format ( \"<STR_LIT>\" , port ) ) ; return result . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ; } private void sendMsg ( String msg , MsgType msgType ) { try { WebSocketServer . sendInfo ( new SocketMsg ( msg , msgType ) , \"<STR_LIT>\" ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ; } } @ Override public String serverStatus ( Deploy resources ) { Set < Server > servers = resources . getDeploys ( ) ; App app = resources . getApp ( ) ; for ( Server server : servers ) { StringBuilder sb = new StringBuilder ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( server . getIp ( ) ) ; sb . append ( \"<STR_LIT>\" ) . append ( server . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( app . getName ( ) ) ; boolean result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { sb . append ( \"<STR_LIT>\" ) ; sendMsg ( sb . toString ( ) , MsgType . INFO ) ; } else { sb . append ( \"<STR_LIT>\" ) ; sendMsg ( sb . toString ( ) , MsgType . ERROR ) ; } log . info ( sb . toString ( ) ) ; executeShellUtil . close ( ) ; } return \"<STR_LIT>\" ; } private boolean checkFile ( ExecuteShellUtil executeShellUtil , App app ) { String result = executeShellUtil . executeForResult ( \"<STR_LIT>\" + app . getDeployPath ( ) + \"<STR_LIT>\" + app . getName ( ) ) ; return result . indexOf ( app . getName ( ) ) > <NUM_LIT> ; } @ Override public String startServer ( Deploy resources ) { Set < Server > deploys = resources . getDeploys ( ) ; App app = resources . getApp ( ) ; for ( Server deploy : deploys ) { StringBuilder sb = new StringBuilder ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( deploy . getIp ( ) ) ; stopApp ( app . getPort ( ) , executeShellUtil ) ; sb . append ( \"<STR_LIT>\" ) . append ( deploy . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( app . getName ( ) ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; executeShellUtil . execute ( app . getStartScript ( ) ) ; sleep ( <NUM_LIT> ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; int i = <NUM_LIT> ; boolean result = false ; while ( i ++ < count ) { result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { break ; } sleep ( <NUM_LIT> ) ; } sendResultMsg ( result , sb ) ; log . info ( sb . toString ( ) ) ; executeShellUtil . close ( ) ; } return \"<STR_LIT>\" ; } @ Override public String stopServer ( Deploy resources ) { Set < Server > deploys = resources . getDeploys ( ) ; App app = resources . getApp ( ) ; for ( Server deploy : deploys ) { StringBuilder sb = new StringBuilder ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( deploy . getIp ( ) ) ; sb . append ( \"<STR_LIT>\" ) . append ( deploy . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( app . getName ( ) ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; stopApp ( app . getPort ( ) , executeShellUtil ) ; sleep ( <NUM_LIT> ) ; boolean result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { sb . append ( \"<STR_LIT>\" ) ; sendMsg ( sb . toString ( ) , MsgType . ERROR ) ; } else { sb . append ( \"<STR_LIT>\" ) ; sendMsg ( sb . toString ( ) , MsgType . INFO ) ; } log . info ( sb . toString ( ) ) ; executeShellUtil . close ( ) ; } return \"<STR_LIT>\" ; } @ Override public String serverReduction ( DeployHistory resources ) { Long deployId = resources . getDeployId ( ) ; Deploy deployInfo = getById ( deployId ) ; String deployDate = DateUtil . format ( resources . getDeployDate ( ) , DatePattern . PURE_DATETIME_PATTERN ) ; App app = deployInfo . getApp ( ) ; if ( app == null ) { sendMsg ( \"<STR_LIT>\" + resources . getAppName ( ) , MsgType . ERROR ) ; throw new BadRequestException ( \"<STR_LIT>\" + resources . getAppName ( ) ) ; } String backupPath = app . getBackupPath ( ) + FILE_SEPARATOR ; backupPath += resources . getAppName ( ) + FILE_SEPARATOR + deployDate ; String deployPath = app . getDeployPath ( ) ; String ip = resources . getIp ( ) ; ExecuteShellUtil executeShellUtil = getExecuteShellUtil ( ip ) ; String msg ; msg = String . format ( \"<STR_LIT>\" , ip ) ; log . info ( msg ) ; sendMsg ( msg , MsgType . INFO ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; stopApp ( app . getPort ( ) , executeShellUtil ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; executeShellUtil . execute ( \"<STR_LIT>\" + deployPath + FILE_SEPARATOR + resources . getAppName ( ) ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; executeShellUtil . execute ( \"<STR_LIT>\" + backupPath + \"<STR_LIT>\" + deployPath ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; executeShellUtil . execute ( app . getStartScript ( ) ) ; sendMsg ( \"<STR_LIT>\" , MsgType . INFO ) ; int i = <NUM_LIT> ; boolean result = false ; while ( i ++ < count ) { result = checkIsRunningStatus ( app . getPort ( ) , executeShellUtil ) ; if ( result ) { break ; } sleep ( <NUM_LIT> ) ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"<STR_LIT>\" ) . append ( ip ) . append ( \"<STR_LIT>\" ) . append ( resources . getAppName ( ) ) ; sendResultMsg ( result , sb ) ; executeShellUtil . close ( ) ; return \"<STR_LIT>\" ; } private ExecuteShellUtil getExecuteShellUtil ( String ip ) { Server server = serverService . findByIp ( ip ) ; if ( server == null ) { sendMsg ( \"<STR_LIT>\" + ip , MsgType . ERROR ) ; throw new BadRequestException ( \"<STR_LIT>\" + ip ) ; } return new ExecuteShellUtil ( ip , server . getAccount ( ) , server . getPassword ( ) , server . getPort ( ) ) ; } private ScpClientUtil getScpClientUtil ( String ip ) { Server server = serverService . findByIp ( ip ) ; if ( server == null ) { sendMsg ( \"<STR_LIT>\" + ip , MsgType . ERROR ) ; throw new BadRequestException ( \"<STR_LIT>\" + ip ) ; } return ScpClientUtil . getInstance ( ip , server . getPort ( ) , server . getAccount ( ) , server . getPassword ( ) ) ; } private void sendResultMsg ( boolean result , StringBuilder sb ) { if ( result ) { sb . append ( \"<STR_LIT>\" ) ; sendMsg ( sb . toString ( ) , MsgType . INFO ) ; } else { sb . append ( \"<STR_LIT>\" ) ; sendMsg ( sb . toString ( ) , MsgType . ERROR ) ; } } @ Override public void download ( List < Deploy > deploys , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Deploy deploy : deploys ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , deploy . getApp ( ) . getName ( ) ) ; map . put ( \"<STR_LIT>\" , deploy . getServers ( ) ) ; map . put ( \"<STR_LIT>\" , deploy . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } }"}, {"input": "package ginyi . framework . security . service ; import ginyi . system . domain . SysLogLogin ; import ginyi . system . service . ISysLogininforService ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class SysLoginLogServiceImpl implements ISysLogininforService { @ Override public void insertLogininfor ( SysLogLogin logininfor ) { }", "output": "@ Override public List < SysLogLogin > selectLogininforList ( SysLogLogin logininfor ) { return null ; } @ Override public int deleteLogininforByIds ( Long [ ] infoIds ) { return <NUM_LIT> ; } @ Override public void cleanLogininfor ( ) { } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . properties . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigurationProperties ; import com . alibaba . nacos . api . config . listener . AbstractListener ; import com . alibaba . nacos . api . config . listener . Listener ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . EventPublishingConfigService ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigurationPropertiesBeanBoundEvent ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . ObjectUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . beans . PropertyValues ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ConfigurableApplicationContext ; import org . springframework . core . env . Environment ; import org . springframework . util . Assert ; import org . springframework . validation . DataBinder ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . getContent ; import static org . springframework . core . annotation . AnnotationUtils . findAnnotation ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; import static org . springframework . util . StringUtils . hasText ; public class NacosConfigurationPropertiesBinder { public static final String BEAN_NAME = \"<STR_LIT>\" ; private static final Logger logger = LoggerFactory . getLogger ( NacosConfigurationPropertiesBinder . class ) ; private final ConfigurableApplicationContext applicationContext ; private final Environment environment ; private final ApplicationEventPublisher applicationEventPublisher ; private final ConfigServiceBeanBuilder configServiceBeanBuilder ; protected NacosConfigurationPropertiesBinder ( ConfigurableApplicationContext applicationContext ) { Assert . notNull ( applicationContext , \"<STR_LIT>\" ) ; this . applicationContext = applicationContext ; this . environment = applicationContext . getEnvironment ( ) ; this . applicationEventPublisher = applicationContext ; this . configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } protected void bind ( Object bean , String beanName ) { NacosConfigurationProperties properties = findAnnotation ( bean . getClass ( ) , NacosConfigurationProperties . class ) ; bind ( bean , beanName , properties ) ; } protected void bind ( final Object bean , final String beanName , final NacosConfigurationProperties properties ) { Assert . notNull ( bean , \"<STR_LIT>\" ) ; Assert . notNull ( properties , \"<STR_LIT>\" ) ; final String dataId = NacosUtils . readFromEnvironment ( properties . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( properties . groupId ( ) , environment ) ; final String type ; ConfigType typeEunm = properties . yaml ( ) ? ConfigType . YAML : properties . type ( ) ; if ( ConfigType . UNSET . equals ( typeEunm ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEunm . getType ( ) ; } final ConfigService configService = configServiceBeanBuilder . build ( properties . properties ( ) ) ; if ( properties . autoRefreshed ( ) ) { String content = getContent ( configService , dataId , groupId ) ; if ( hasText ( content ) ) { doBind ( bean , beanName , dataId , groupId , type , properties , content , configService ) ;", "output": "} Listener listener = new AbstractListener ( ) { @ Override public void receiveConfigInfo ( String config ) { doBind ( bean , beanName , dataId , groupId , type , properties , config , configService ) ; } } ; try { if ( configService instanceof EventPublishingConfigService ) { ( ( EventPublishingConfigService ) configService ) . addListener ( dataId , groupId , type , listener ) ; } else { configService . addListener ( dataId , groupId , listener ) ; } } catch ( NacosException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( e . getMessage ( ) , e ) ; } } } } protected void doBind ( Object bean , String beanName , String dataId , String groupId , String type , NacosConfigurationProperties properties , String content , ConfigService configService ) { final String prefix = properties . prefix ( ) ; PropertyValues propertyValues = NacosUtils . resolvePropertyValues ( bean , prefix , dataId , groupId , content , type ) ; doBind ( bean , properties , propertyValues ) ; publishBoundEvent ( bean , beanName , dataId , groupId , properties , content , configService ) ; publishMetadataEvent ( bean , beanName , dataId , groupId , properties ) ; } protected void publishMetadataEvent ( Object bean , String beanName , String dataId , String groupId , NacosConfigurationProperties properties ) { NacosProperties nacosProperties = properties . properties ( ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( properties ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ; metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; metadataEvent . setNacosProperties ( resolvedNacosProperties ) ; Class < ? > beanClass = bean . getClass ( ) ; metadataEvent . setBeanName ( beanName ) ; metadataEvent . setBean ( bean ) ; metadataEvent . setBeanType ( beanClass ) ; metadataEvent . setAnnotatedElement ( beanClass ) ; applicationEventPublisher . publishEvent ( metadataEvent ) ; } protected void publishBoundEvent ( Object bean , String beanName , String dataId , String groupId , NacosConfigurationProperties properties , String content , ConfigService configService ) { NacosConfigEvent event = new NacosConfigurationPropertiesBeanBoundEvent ( configService , dataId , groupId , bean , beanName , properties , content ) ; applicationEventPublisher . publishEvent ( event ) ; } private void doBind ( Object bean , NacosConfigurationProperties properties , PropertyValues propertyValues ) { ObjectUtils . cleanMapOrCollectionField ( bean ) ; DataBinder dataBinder = new DataBinder ( bean ) ; dataBinder . setAutoGrowNestedPaths ( properties . ignoreNestedProperties ( ) ) ; dataBinder . setIgnoreInvalidFields ( properties . ignoreInvalidFields ( ) ) ; dataBinder . setIgnoreUnknownFields ( properties . ignoreUnknownFields ( ) ) ; dataBinder . bind ( propertyValues ) ; } }"}, {"input": "package me . zhengjie . modules . mnt . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . mnt . domain . Server ; import me . zhengjie . modules . mnt . mapper . DeployServerMapper ; import me . zhengjie . modules . mnt . mapper . ServerMapper ; import me . zhengjie . modules . mnt . service . ServerService ; import me . zhengjie . modules . mnt . domain . vo . ServerQueryCriteria ; import me . zhengjie . modules . mnt . util . ExecuteShellUtil ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor public class ServerServiceImpl extends ServiceImpl < ServerMapper , Server > implements ServerService { private final ServerMapper serverMapper ; private final DeployServerMapper deployServerMapper ; @ Override public PageResult < Server > queryAll ( ServerQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( serverMapper . findAll ( criteria , page ) ) ; } @ Override public List < Server > queryAll ( ServerQueryCriteria criteria ) { return serverMapper . findAll ( criteria ) ; } @ Override public Server findByIp ( String ip ) { return serverMapper . findByIp ( ip ) ; } @ Override public Boolean testConnect ( Server resources ) { ExecuteShellUtil executeShellUtil = null ; try { executeShellUtil = new ExecuteShellUtil ( resources . getIp ( ) , resources . getAccount ( ) , resources . getPassword ( ) , resources . getPort ( ) ) ; return executeShellUtil . execute ( \"<STR_LIT>\" ) == <NUM_LIT> ; } catch ( Exception e ) { return false ; } finally { if ( executeShellUtil != null ) { executeShellUtil . close ( ) ; } } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( Server resources ) { save ( resources ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( Server resources ) { Server server = getById ( resources . getId ( ) ) ; server . copy ( resources ) ; saveOrUpdate ( server ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { removeBatchByIds ( ids ) ; deployServerMapper . deleteByServerIds ( ids ) ; }", "output": "@ Override public void download ( List < Server > servers , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( Server deploy : servers ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , deploy . getName ( ) ) ; map . put ( \"<STR_LIT>\" , deploy . getIp ( ) ) ; map . put ( \"<STR_LIT>\" , deploy . getPort ( ) ) ; map . put ( \"<STR_LIT>\" , deploy . getAccount ( ) ) ; map . put ( \"<STR_LIT>\" , deploy . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } }"}, {"input": "package com . oddfar . campus . framework . api . mail ; import cn . hutool . extra . spring . SpringUtil ; public class MailSendContext { public static MailSendApi me ( ) { return SpringUtil . getBean ( MailSendApi . class ) ; }", "output": "}"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; import org . springblade . core . tool . node . INode ; import java . util . ArrayList ; import java . util . List ; @ Data public class TreeDataModel implements INode < TreeDataModel > { private Long id ; private Long pId ; private Long parentId ; private String title ; private Object data ; private List < TreeDataModel > children ; @ Override public List < TreeDataModel > getChildren ( ) { if ( this . children == null ) { this . children = new ArrayList < > ( ) ; }", "output": "return this . children ; } }"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import javax . validation . constraints . NotBlank ; import java . io . Serializable ; @ Data public class VerifiedParam implements Serializable { @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String country ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardType ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String surname ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String name ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardCode ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardFront ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardBack ; @ NotBlank @ ApiModelProperty ( \"<STR_LIT>\" ) private String cardHand ;", "output": "}"}, {"input": "package com . youlai . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . query . TablePageQuery ; import com . youlai . system . model . vo . TableColumnVO ; import com . youlai . system . model . vo . TableGeneratePreviewVO ; import com . youlai . system . model . vo . TablePageVO ; import java . util . List ; public interface GeneratorService { Page < TablePageVO > getTablePage ( TablePageQuery queryParams ) ; List < TableColumnVO > getTableColumns ( String tableName ) ; List < TableGeneratePreviewVO > getTablePreviewData ( String tableName ) ;", "output": "}"}, {"input": "package com . yf . config ; import com . alibaba . druid . pool . DruidDataSource ; import com . alibaba . druid . support . http . StatViewServlet ; import com . alibaba . druid . support . http . WebStatFilter ; import org . springframework . boot . context . properties . ConfigurationProperties ; import org . springframework . boot . web . servlet . FilterRegistrationBean ; import org . springframework . boot . web . servlet . ServletRegistrationBean ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import javax . sql . DataSource ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; @ Configuration public class DruidConfig { @ Bean @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public DataSource druid ( ) { return new DruidDataSource ( ) ; }", "output": "@ Bean public ServletRegistrationBean statViewServlet ( ) { ServletRegistrationBean bean = new ServletRegistrationBean ( new StatViewServlet ( ) , \"<STR_LIT>\" ) ; Map < String , String > initParams = new HashMap < > ( ) ; initParams . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; initParams . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; initParams . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bean . setInitParameters ( initParams ) ; return bean ; } @ Bean public FilterRegistrationBean webStatFilter ( ) { FilterRegistrationBean bean = new FilterRegistrationBean ( ) ; bean . setFilter ( new WebStatFilter ( ) ) ; Map < String , String > initParams = new HashMap < > ( ) ; initParams . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; bean . setInitParameters ( initParams ) ; bean . setUrlPatterns ( Arrays . asList ( \"<STR_LIT>\" ) ) ; return bean ; } }"}, {"input": "package ginyi . framework . security . service ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import ginyi . common . constant . CacheConstants ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . mysql . MyPage ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . StringUtils ; import ginyi . system . domain . SysDept ; import ginyi . system . domain . SysUser ; import ginyi . system . domain . model . dto . DeptDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . DeptVo ; import ginyi . system . mapper . SysDeptMapper ; import ginyi . system . service . ISysDeptService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeanUtils ; import org . springframework . stereotype . Service ; import javax . annotation . Resource ; import java . util . List ; import java . util . Set ; import java . util . stream . Collectors ; @ Service @ Slf4j public class SysDeptServiceImpl implements ISysDeptService { @ Resource private SysDeptMapper deptMapper ; @ Resource private RedisCache redisCache ; @ Override public BaseVo < SysDept > list ( DeptDto deptDto , Long page , Long pageSize ) { IPage < SysDept > list = deptMapper . list ( deptDto , new MyPage ( page , pageSize ) . getPage ( ) ) ; List < SysDept > deptList = list . getRecords ( ) . stream ( ) . filter ( dept -> dept . getParentId ( ) . equals ( <NUM_LIT> ) ) . map ( dept -> convertToDeptTree ( dept , list . getRecords ( ) ) ) . collect ( Collectors . toList ( ) ) ; BaseVo < SysDept > baseVo = new BaseVo < > ( ) ; baseVo . setList ( deptList ) ; baseVo . setCount ( deptList . size ( ) ) ; return baseVo ; } @ Override public DeptVo getDeptByDeptId ( Long deptId ) { if ( redisCache . hasKey ( CacheConstants . DEPT_NOT_EXIST_KEY + deptId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptId + CommonMessageConstants . DEPT_NOT_EXIST ) ; } DeptVo deptVo = new DeptVo ( ) ; SysDept dept = redisCache . getCacheObject ( CacheConstants . DEPT_DETAILS_BY_DEPTID_KEY + deptId , SysDept . class ) ; if ( StringUtils . isNotNull ( dept ) ) { BeanUtils . copyProperties ( dept , deptVo ) ; return deptVo ; } LambdaQueryWrapper < SysDept > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysDept :: getDeptId , deptId ) ; dept = deptMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( dept ) ) { redisCache . setCacheObject ( CacheConstants . DEPT_NOT_EXIST_KEY + deptId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptId + CommonMessageConstants . DEPT_NOT_EXIST ) ; } redisCache . setCacheObject ( CacheConstants . DEPT_DETAILS_BY_DEPTID_KEY + deptId , dept ) ; BeanUtils . copyProperties ( dept , deptVo ) ; return deptVo ; } @ Override public void addDept ( DeptDto deptDto ) { Long parentId = StringUtils . isNull ( deptDto . getParentId ( ) ) ? <NUM_LIT> : deptDto . getParentId ( ) ; if ( redisCache . hasKey ( CacheConstants . DEPT_NAME_USED_KEY + parentId + deptDto . getDeptName ( ) ) ) { throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . DEPT_NAME_USED ) ; } LambdaQueryWrapper < SysDept > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysDept :: getParentId , parentId ) . eq ( SysDept :: getDeptName , deptDto . getDeptName ( ) ) ; SysDept dept = deptMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( dept ) ) { redisCache . setCacheObject ( CacheConstants . DEPT_NAME_USED_KEY + parentId + deptDto . getDeptName ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . DEPT_NAME_USED ) ; } deptMapper . insertDept ( deptDto ) ; redisCache . removeCacheObject ( CacheConstants . DEPT_KEY_PREFIX ) ; } @ Override public void updateDept ( DeptDto deptDto ) { if ( redisCache . hasKey ( CacheConstants . DEPT_NOT_EXIST_KEY + deptDto . getDeptId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptDto . getDeptId ( ) + CommonMessageConstants . DEPT_NOT_EXIST ) ; } LambdaQueryWrapper < SysDept > queryWrapper = new LambdaQueryWrapper < > ( ) ; Long parentId = StringUtils . isNull ( deptDto . getParentId ( ) ) ? <NUM_LIT> : deptDto . getParentId ( ) ; queryWrapper . eq ( parentId != <NUM_LIT> , SysDept :: getDeptId , parentId ) ; List < SysDept > deptList = deptMapper . selectList ( queryWrapper ) ; if ( deptList . size ( ) == <NUM_LIT> ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . DEPT_PARENT_NOT_EXIST ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysDept :: getParentId , parentId ) . eq ( SysDept :: getDeptName , deptDto . getDeptName ( ) ) ; SysDept dept = deptMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNotNull ( dept ) ) { redisCache . setCacheObject ( CacheConstants . DEPT_NAME_USED_KEY + parentId + deptDto . getDeptName ( ) , null ) ; throw new CommonException ( StateCode . ERROR_EXIST , CommonMessageConstants . DEPT_NAME_USED ) ; } queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysDept :: getDeptId , deptDto . getDeptId ( ) ) ; dept = deptMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( dept ) ) { redisCache . setCacheObject ( CacheConstants . DEPT_NOT_EXIST_KEY + deptDto . getDeptId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptDto . getDeptId ( ) + CommonMessageConstants . DEPT_NOT_EXIST ) ; } deptMapper . updateDept ( deptDto ) ; redisCache . removeCacheObject ( CacheConstants . DEPT_KEY_PREFIX ) ; } @ Override public void removeDeptById ( Long deptId ) { if ( redisCache . hasKey ( CacheConstants . DEPT_NOT_EXIST_KEY + deptId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptId + CommonMessageConstants . DEPT_NOT_EXIST ) ; } LambdaQueryWrapper < SysDept > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysDept :: getDeptId , deptId ) ; SysDept dept = deptMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( dept ) ) { redisCache . setCacheObject ( CacheConstants . DEPT_NOT_EXIST_KEY + deptId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptId + CommonMessageConstants . DEPT_NOT_EXIST ) ; } deptMapper . deleteById ( deptId ) ; redisCache . removeCacheObject ( CacheConstants . DEPT_KEY_PREFIX ) ; } @ Override public void removeDeptByIds ( Set < Long > ids ) { if ( ids . size ( ) > <NUM_LIT> ) { List < SysDept > deptList ; deptList = redisCache . getCacheList ( CacheConstants . DEPT_LIST_KEY , SysDept . class ) ; if ( StringUtils . isNull ( deptList ) || deptList . size ( ) == <NUM_LIT> ) { LambdaQueryWrapper < SysDept > queryWrapper = new LambdaQueryWrapper < > ( ) ; deptList = deptMapper . selectList ( queryWrapper ) ; redisCache . setCacheList ( CacheConstants . DEPT_LIST_KEY , deptList ) ;", "output": "} for ( Long deptId : ids ) { if ( redisCache . hasKey ( CacheConstants . DEPT_NOT_EXIST_KEY + deptId ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptId + CommonMessageConstants . DEPT_NOT_EXIST ) ; } boolean exist = deptList . stream ( ) . anyMatch ( dept -> deptId . equals ( dept . getDeptId ( ) ) ) ; if ( ! exist ) { redisCache . setCacheObject ( CacheConstants . DEPT_NOT_EXIST_KEY + deptId , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptId + CommonMessageConstants . DEPT_NOT_EXIST ) ; } } deptMapper . deleteBatchIds ( ids ) ; redisCache . removeCacheObject ( CacheConstants . DEPT_KEY_PREFIX ) ; } else { throw new CommonException ( StateCode . ERROR_REQUEST_PARAMS , CommonMessageConstants . SYS_REQUEST_ILLEGAL ) ; } } @ Override public void updateStatus ( DeptDto deptDto ) { if ( StringUtils . isNull ( deptDto . getDeptId ( ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . DEPT_ID_NOT_FOUND ) ; } if ( ! ( \"<STR_LIT>\" . equals ( deptDto . getStatus ( ) ) || \"<STR_LIT>\" . equals ( deptDto . getStatus ( ) ) ) ) { throw new CommonException ( StateCode . ERROR_PARAMS , CommonMessageConstants . DEPT_STATUS_ILLEGAL ) ; } if ( redisCache . hasKey ( CacheConstants . DEPT_NOT_EXIST_KEY + deptDto . getDeptId ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptDto . getDeptId ( ) + CommonMessageConstants . DEPT_NOT_EXIST ) ; } LambdaQueryWrapper < SysDept > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( SysDept :: getDeptId , deptDto . getDeptId ( ) ) ; SysDept dept = deptMapper . selectOne ( queryWrapper ) ; if ( StringUtils . isNull ( dept ) ) { redisCache . setCacheObject ( CacheConstants . DEPT_NOT_EXIST_KEY + deptDto . getDeptId ( ) , null ) ; throw new CommonException ( StateCode . ERROR_NOT_EXIST , deptDto . getDeptId ( ) + CommonMessageConstants . DEPT_NOT_EXIST ) ; } deptMapper . updateDeptStatus ( deptDto ) ; } public SysDept convertToDeptTree ( SysDept dept , List < SysDept > list ) { SysDept sysDept = new SysDept ( ) ; BeanUtils . copyProperties ( dept , sysDept ) ; List < SysDept > children = list . stream ( ) . filter ( subDept -> dept . getDeptId ( ) . equals ( subDept . getParentId ( ) ) ) . map ( subDept -> convertToDeptTree ( subDept , list ) ) . collect ( Collectors . toList ( ) ) ; sysDept . setChildren ( children ) ; return sysDept ; } }"}, {"input": "package com . yf . system . modules . menu . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import com . baomidou . mybatisplus . extension . activerecord . Model ; import lombok . Data ; import java . util . Date ; @ Data @ TableName ( \"<STR_LIT>\" ) public class SysMenu extends Model < SysMenu > { private static final long serialVersionUID = <NUM_LIT> ; @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private String id ; @ TableField ( \"<STR_LIT>\" ) private String parentId ; @ TableField ( \"<STR_LIT>\" ) private Integer menuType ; @ TableField ( \"<STR_LIT>\" ) private String permissionTag ; private String path ; private String component ; private String redirect ; private String name ; @ TableField ( \"<STR_LIT>\" ) private String metaTitle ; @ TableField ( \"<STR_LIT>\" ) private String metaIcon ; @ TableField ( \"<STR_LIT>\" ) private String metaActiveMenu ; @ TableField ( \"<STR_LIT>\" ) private Boolean metaNoCache ; private Boolean hidden ; private Integer sort ; @ TableField ( \"<STR_LIT>\" ) private Date createTime ; @ TableField ( \"<STR_LIT>\" ) private Date updateTime ; @ TableField ( \"<STR_LIT>\" ) private String createBy ; @ TableField ( \"<STR_LIT>\" ) private String updateBy ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysRoleEntity ; import org . apache . ibatis . annotations . Param ; import java . util . List ; import java . util . Set ; public interface SysRoleMapper extends BaseMapperX < SysRoleEntity > {", "output": "default PageResult < SysRoleEntity > selectPage ( SysRoleEntity role ) { return selectPage ( new LambdaQueryWrapperX < SysRoleEntity > ( ) . likeIfPresent ( SysRoleEntity :: getRoleName , role . getRoleName ( ) ) . likeIfPresent ( SysRoleEntity :: getRoleKey , role . getRoleKey ( ) ) . eqIfPresent ( SysRoleEntity :: getStatus , role . getStatus ( ) ) ) ; } List < SysRoleEntity > selectRolePermissionByUserId ( Long userId ) ; SysRoleEntity selectRoleById ( Long roleId ) ; List < SysRoleEntity > selectRoleList ( SysRoleEntity role ) ; List < SysRoleEntity > selectRoleListByKey ( @ Param ( \"<STR_LIT>\" ) Set < String > RoleKeys ) ; SysRoleEntity checkRoleNameUnique ( String roleName ) ; SysRoleEntity checkRoleKeyUnique ( String roleKey ) ; public List < SysRoleEntity > selectRolesByUserName ( String userName ) ; }"}, {"input": "package io . github . chensheng . dddboot . excel . writer ; import io . github . chensheng . dddboot . excel . core . ExcelType ; import io . github . chensheng . dddboot . excel . writer . xlsx . XlsxWriter ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . List ; public class ExcelWriterFactory { private static final Logger logger = LoggerFactory . getLogger ( ExcelWriterFactory . class ) ; public static void write ( OutputStream outputStream , List < ? > sheetData ) { write ( outputStream , null , sheetData ) ; } public static void write ( OutputStream outputStream , InputStream templateIs , List < ? > sheetData ) { if ( CollectionUtil . isEmpty ( sheetData ) ) { return ; } write ( outputStream , templateIs , ( sheetConfig ) -> sheetData , ExcelType . XLSX , sheetData . get ( <NUM_LIT> ) . getClass ( ) ) ; } public static boolean write ( OutputStream outputStream , InputStream templateIs , RowWritingListener rowWritingListener , ExcelType excelType , Class < ? > ... rowTypes ) { try { if ( ExcelType . XLSX . equals ( excelType ) ) { new XlsxWriter ( ) . write ( outputStream , templateIs , rowWritingListener , rowTypes ) ; return true ; } } catch ( Exception e ) { logger . error ( ExceptionUtil . stackTraceText ( e ) ) ; } return false ; }", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . apache . commons . logging . Log ; import org . apache . commons . logging . LogFactory ; import org . springframework . aop . support . AopUtils ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationListener ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . core . annotation . AnnotationUtils ; import org . springframework . util . ReflectionUtils ; import java . lang . annotation . Annotation ; import java . lang . reflect . Method ; import java . util . Map ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosUtils . resolveGenericType ; import static java . lang . reflect . Modifier . * ; public abstract class AnnotationListenerMethodProcessor < A extends Annotation > implements ApplicationListener < ContextRefreshedEvent > { protected final Log logger = LogFactory . getLog ( getClass ( ) ) ; private final Class < A > annotationType ; public AnnotationListenerMethodProcessor ( ) { this . annotationType = resolveGenericType ( getClass ( ) ) ; } static boolean isListenerMethod ( Method method ) { int modifiers = method . getModifiers ( ) ; Class < ? > returnType = method . getReturnType ( ) ; return isPublic ( modifiers ) && ! isStatic ( modifiers ) && ! isNative ( modifiers ) && ! isAbstract ( modifiers ) && void . class . equals ( returnType ) ; } @ Override public final void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext applicationContext = event . getApplicationContext ( ) ; processBeans ( applicationContext ) ; } private void processBeans ( ApplicationContext applicationContext ) { Map < String , Object > beansMap = applicationContext . getBeansOfType ( Object . class , false , false ) ; processBeans ( beansMap , applicationContext ) ; } private void processBeans ( Map < String , Object > beansMap , ApplicationContext applicationContext ) { for ( Map . Entry < String , Object > entry : beansMap . entrySet ( ) ) { String beanName = entry . getKey ( ) ; Object bean = entry . getValue ( ) ; if ( bean != null ) { Class < ? > beanClass = AopUtils . getTargetClass ( bean ) ; processBean ( beanName , bean , beanClass , applicationContext ) ; } } } private void processBean ( final String beanName , final Object bean , final Class < ? > beanClass , final ApplicationContext applicationContext ) { ReflectionUtils . doWithMethods ( beanClass , new ReflectionUtils . MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException , IllegalAccessException { A annotation = AnnotationUtils . getAnnotation ( method , annotationType ) ; if ( annotation != null && isCandidateMethod ( bean , beanClass , annotation , method , applicationContext ) ) { processListenerMethod ( beanName , bean , beanClass , annotation , method , applicationContext ) ; } } } , new ReflectionUtils . MethodFilter ( ) { @ Override public boolean matches ( Method method ) { return isListenerMethod ( method ) ; } }", "output": ") ; } protected abstract void processListenerMethod ( String beanName , Object bean , Class < ? > beanClass , A annotation , Method method , ApplicationContext applicationContext ) ; protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , A annotation , Method method , ApplicationContext applicationContext ) { return true ; } }"}, {"input": "package org . springblade . entity ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . List ; @ Data public class CancelExchangeParamDTO implements Serializable { private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < String > idList ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Target ( ElementType . FIELD ) @ Retention ( RetentionPolicy . RUNTIME ) public @ interface QueryCondition { String column ( ) default \"<STR_LIT>\" ; ConditionOperator operator ( ) default ConditionOperator . eq ; boolean ignore ( ) default false ; boolean allowEmpty ( ) default false ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import org . apache . commons . lang3 . Validate ; import java . util . concurrent . * ; import java . util . concurrent . ThreadPoolExecutor . AbortPolicy ; public class ThreadPoolBuilder { private static RejectedExecutionHandler defaultRejectHandler = new AbortPolicy ( ) ; public static FixedThreadPoolBuilder fixedPool ( ) { return new FixedThreadPoolBuilder ( ) ; } public static CachedThreadPoolBuilder cachedPool ( ) { return new CachedThreadPoolBuilder ( ) ; } public static ScheduledThreadPoolBuilder scheduledPool ( ) { return new ScheduledThreadPoolBuilder ( ) ; } public static QueuableCachedThreadPoolBuilder queuableCachedPool ( ) { return new QueuableCachedThreadPoolBuilder ( ) ; } public static class FixedThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private int queueSize = - <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public FixedThreadPoolBuilder setPoolSize ( int poolSize ) { Validate . isTrue ( poolSize >= <NUM_LIT> ) ; this . poolSize = poolSize ; return this ; } public FixedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public FixedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public FixedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public FixedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public FixedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { BlockingQueue < Runnable > queue = null ; if ( queueSize < <NUM_LIT> ) { queue = new LinkedBlockingQueue < Runnable > ( ) ; } else { queue = new ArrayBlockingQueue < Runnable > ( queueSize ) ; } threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( poolSize , poolSize , <NUM_LIT> , TimeUnit . MILLISECONDS , queue , threadFactory , rejectHandler ) ; } } public static class CachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public CachedThreadPoolBuilder setMinSize ( int minSize ) {", "output": "this . minSize = minSize ; return this ; } public CachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public CachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public CachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public CachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public CachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public CachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public ThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new ThreadPoolExecutor ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , threadFactory , rejectHandler ) ; } } public static class ScheduledThreadPoolBuilder { private int poolSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; public ScheduledThreadPoolBuilder setPoolSize ( int poolSize ) { this . poolSize = poolSize ; return this ; } public ScheduledThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public ScheduledThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public ScheduledThreadPoolExecutor build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , Boolean . TRUE ) ; return new ScheduledThreadPoolExecutor ( poolSize , threadFactory ) ; } } public static class QueuableCachedThreadPoolBuilder { private int minSize = <NUM_LIT> ; private int maxSize = Integer . MAX_VALUE ; private int keepAliveSecs = <NUM_LIT> ; private int queueSize = <NUM_LIT> ; private ThreadFactory threadFactory ; private String threadNamePrefix ; private Boolean daemon ; private RejectedExecutionHandler rejectHandler ; public QueuableCachedThreadPoolBuilder setMinSize ( int minSize ) { this . minSize = minSize ; return this ; } public QueuableCachedThreadPoolBuilder setMaxSize ( int maxSize ) { this . maxSize = maxSize ; return this ; } public QueuableCachedThreadPoolBuilder setQueueSize ( int queueSize ) { this . queueSize = queueSize ; return this ; } public QueuableCachedThreadPoolBuilder setKeepAliveSecs ( int keepAliveSecs ) { this . keepAliveSecs = keepAliveSecs ; return this ; } public QueuableCachedThreadPoolBuilder setThreadFactory ( ThreadFactory threadFactory ) { this . threadFactory = threadFactory ; return this ; } public QueuableCachedThreadPoolBuilder setThreadNamePrefix ( String threadNamePrefix ) { this . threadNamePrefix = threadNamePrefix ; return this ; } public QueuableCachedThreadPoolBuilder setDaemon ( Boolean daemon ) { this . daemon = daemon ; return this ; } public QueuableCachedThreadPoolBuilder setRejectHanlder ( RejectedExecutionHandler rejectHandler ) { this . rejectHandler = rejectHandler ; return this ; } public QueuableCachedThreadPool build ( ) { threadFactory = createThreadFactory ( threadFactory , threadNamePrefix , daemon ) ; if ( rejectHandler == null ) { rejectHandler = defaultRejectHandler ; } return new QueuableCachedThreadPool ( minSize , maxSize , keepAliveSecs , TimeUnit . SECONDS , new QueuableCachedThreadPool . ControllableQueue ( queueSize ) , threadFactory , rejectHandler ) ; } } private static ThreadFactory createThreadFactory ( ThreadFactory threadFactory , String threadNamePrefix , Boolean daemon ) { if ( threadFactory != null ) { return threadFactory ; } if ( threadNamePrefix != null ) { if ( daemon != null ) { return ThreadPoolUtil . buildThreadFactory ( threadNamePrefix , daemon ) ; } else { return ThreadPoolUtil . buildThreadFactory ( threadNamePrefix ) ; } } return Executors . defaultThreadFactory ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import org . apache . commons . lang3 . StringUtils ; public class ValueValidator { public static < T > T checkAndGet ( T value , T defaultValue , Validator < T > v ) { if ( v . validate ( value ) ) { return value ; } return defaultValue ; } public interface Validator < T > { boolean validate ( T value ) ; Validator < Integer > INTEGER_GT_ZERO_VALIDATOR = new Validator < Integer > ( ) { @ Override public boolean validate ( Integer value ) { return ( value != null && value > <NUM_LIT> ) ;", "output": "} } ; Validator < String > STRING_EMPTY_VALUE_VALIDATOR = new Validator < String > ( ) { @ Override public boolean validate ( String value ) { return StringUtils . isNotEmpty ( value ) ; } } ; Validator < String > STRICT_BOOL_VALUE_VALIDATOR = new Validator < String > ( ) { @ Override public boolean validate ( String value ) { return \"<STR_LIT>\" . equalsIgnoreCase ( value ) || \"<STR_LIT>\" . equalsIgnoreCase ( value ) ; } } ; } }"}, {"input": "package me . zhengjie . modules . system . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . vo . EmailVo ; import me . zhengjie . service . EmailService ; import me . zhengjie . modules . system . service . VerifyService ; import me . zhengjie . utils . enums . CodeBiEnum ; import me . zhengjie . utils . enums . CodeEnum ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . web . bind . annotation . * ; import java . util . Objects ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class VerifyController { private final VerifyService verificationCodeService ; private final EmailService emailService ; @ PostMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > resetEmail ( @ RequestParam String email ) { EmailVo emailVo = verificationCodeService . sendEmail ( email , CodeEnum . EMAIL_RESET_EMAIL_CODE . getKey ( ) ) ; emailService . send ( emailVo , emailService . find ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ PostMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > resetPass ( @ RequestParam String email ) { EmailVo emailVo = verificationCodeService . sendEmail ( email , CodeEnum . EMAIL_RESET_PWD_CODE . getKey ( ) ) ; emailService . send ( emailVo , emailService . find ( ) ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } @ GetMapping ( value = \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) public ResponseEntity < Object > validated ( @ RequestParam String email , @ RequestParam String code , @ RequestParam Integer codeBi ) { CodeBiEnum biEnum = CodeBiEnum . find ( codeBi ) ; switch ( Objects . requireNonNull ( biEnum ) ) { case ONE : verificationCodeService . validated ( CodeEnum . EMAIL_RESET_EMAIL_CODE . getKey ( ) + email , code ) ; break ; case TWO : verificationCodeService . validated ( CodeEnum . EMAIL_RESET_PWD_CODE . getKey ( ) + email , code ) ; break ; default : break ; } return new ResponseEntity < > ( HttpStatus . OK ) ;", "output": "} }"}, {"input": "package org . springblade . gateway . dynamic ; import org . springframework . cloud . gateway . event . RefreshRoutesEvent ; import org . springframework . cloud . gateway . route . RouteDefinition ; import org . springframework . cloud . gateway . route . RouteDefinitionWriter ; import org . springframework . context . ApplicationEventPublisher ; import org . springframework . context . ApplicationEventPublisherAware ; import org . springframework . stereotype . Service ; import reactor . core . publisher . Mono ; import java . util . List ; @ Service public class DynamicRouteService implements ApplicationEventPublisherAware { private final RouteDefinitionWriter routeDefinitionWriter ; private ApplicationEventPublisher publisher ; public DynamicRouteService ( RouteDefinitionWriter routeDefinitionWriter ) { this . routeDefinitionWriter = routeDefinitionWriter ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . publisher = applicationEventPublisher ; } public String save ( RouteDefinition definition ) { try { routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; }", "output": "} public String update ( RouteDefinition definition ) { try { this . routeDefinitionWriter . delete ( Mono . just ( definition . getId ( ) ) ) ; this . routeDefinitionWriter . save ( Mono . just ( definition ) ) . subscribe ( ) ; this . publisher . publishEvent ( new RefreshRoutesEvent ( this ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } public String updateList ( List < RouteDefinition > routeDefinitions ) { routeDefinitions . forEach ( this :: update ) ; return \"<STR_LIT>\" ; } public String delete ( String id ) { try { this . routeDefinitionWriter . delete ( Mono . just ( id ) ) ; return \"<STR_LIT>\" ; } catch ( Exception e ) { e . printStackTrace ( ) ; return \"<STR_LIT>\" ; } } }"}, {"input": "package top . kangert . kspider . websocket ; import lombok . Getter ; import lombok . Setter ; @ Getter @ Setter public class WebSocketEvent < T > { public static final String LOG_EVENT_TYPE = \"<STR_LIT>\" ; public static final String DEBUG_EVENT_TYPE = \"<STR_LIT>\" ; public static final String OUTPUT_EVENT_TYPE = \"<STR_LIT>\" ; public static final String ERROR_EVENT_TYPE = \"<STR_LIT>\" ; public static final String FINISH_EVENT_TYPE = \"<STR_LIT>\" ; public static final String TEST_EVENT_TYPE = \"<STR_LIT>\" ; public static final String STOP_EVENT_TYPE = \"<STR_LIT>\" ; public static final String RESUME_EVENT_TYPE = \"<STR_LIT>\" ; public static final String COMMON_EVENT = \"<STR_LIT>\" ; public static final String REQUEST_PARAM_EVENT = \"<STR_LIT>\" ; public static final String REQUEST_HEADER_EVENT = \"<STR_LIT>\" ; public static final String REQUEST_BODY_EVENT = \"<STR_LIT>\" ; public static final String REQUEST_AUTO_COOKIE_EVENT = \"<STR_LIT>\" ; public static final String REQUEST_COOKIE_EVENT = \"<STR_LIT>\" ; private String eventType ; private String timestamp ; private T message ; public WebSocketEvent ( String eventType , T message ) { this . eventType = eventType ; this . message = message ; } public WebSocketEvent ( String eventType , String timestamp , T message ) { this . eventType = eventType ; this . timestamp = timestamp ; this . message = message ;", "output": "} }"}, {"input": "package org . springblade . cgform . enums ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public enum CgformEnum { ONE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , MANY ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , ERP ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , INNER_TABLE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) , TREE ( <NUM_LIT> , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; int type ; String code ; String templatePath ; String stylePath ; String note ; CgformEnum ( int type , String code , String templatePath , String stylePath , String note ) { this . type = type ; this . code = code ; this . templatePath = templatePath ; this . stylePath = stylePath ; this . note = note ; } public static String getTemplatePathByConfig ( String code ) { return getCgformEnumByConfig ( code ) . templatePath ; } public int getType ( ) { return type ; } public void setType ( int type ) { this . type = type ; } public String getTemplatePath ( ) { return templatePath ; } public void setTemplatePath ( String templatePath ) { this . templatePath = templatePath ; } public String getStylePath ( ) { return stylePath ; } public void setStylePath ( String stylePath ) { this . stylePath = stylePath ; } public static CgformEnum getCgformEnumByConfig ( String code ) { for ( CgformEnum e : CgformEnum . values ( ) ) { if ( e . code . equals ( code ) ) { return e ; } } return null ; } public static List < Map < String , Object > > getJspModelList ( int type ) { List < Map < String , Object > > ls = new ArrayList < Map < String , Object > > ( ) ; for ( CgformEnum e : CgformEnum . values ( ) ) { if ( e . type == type ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( \"<STR_LIT>\" , e . code ) ; map . put ( \"<STR_LIT>\" , e . note ) ; ls . add ( map ) ; } }", "output": "return ls ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . BeanFactory ; import org . springframework . beans . factory . BeanFactoryAware ; import org . springframework . beans . factory . support . BeanDefinitionRegistry ; import org . springframework . context . EnvironmentAware ; import org . springframework . context . annotation . ImportBeanDefinitionRegistrar ; import org . springframework . core . annotation . AnnotationAttributes ; import org . springframework . core . env . Environment ; import org . springframework . core . env . PropertyResolver ; import org . springframework . core . type . AnnotationMetadata ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . * ; import static org . springframework . core . annotation . AnnotationAttributes . fromMap ; public class NacosConfigBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar , EnvironmentAware , BeanFactoryAware { private Environment environment ; private BeanFactory beanFactory ; @ Override public void registerBeanDefinitions ( AnnotationMetadata metadata , BeanDefinitionRegistry registry ) { AnnotationAttributes attributes = fromMap ( metadata . getAnnotationAttributes ( EnableNacosConfig . class . getName ( ) ) ) ; registerGlobalNacosProperties ( attributes , registry , environment , CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) ; registerNacosCommonBeans ( registry ) ; registerNacosConfigBeans ( registry , environment , beanFactory ) ; invokeNacosPropertySourcePostProcessor ( beanFactory ) ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ;", "output": "} @ Override public void setBeanFactory ( BeanFactory beanFactory ) throws BeansException { this . beanFactory = beanFactory ; } }"}, {"input": "package com . youlai . system . model . query ; import com . youlai . system . common . base . BasePageQuery ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import org . springframework . format . annotation . DateTimeFormat ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class UserPageQuery extends BasePageQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" ) private Long deptId ; @ Schema ( description = \"<STR_LIT>\" ) @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private String startTime ; @ Schema ( description = \"<STR_LIT>\" ) @ DateTimeFormat ( pattern = \"<STR_LIT>\" ) private String endTime ;", "output": "}"}, {"input": "package me . zhengjie . service . impl ; import com . alipay . api . AlipayClient ; import com . alipay . api . DefaultAlipayClient ; import com . alipay . api . request . AlipayTradePagePayRequest ; import com . alipay . api . request . AlipayTradeWapPayRequest ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . vo . TradeVo ; import me . zhengjie . domain . AlipayConfig ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . AliPayConfigMapper ; import me . zhengjie . service . AliPayService ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . CachePut ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class AliPayServiceImpl extends ServiceImpl < AliPayConfigMapper , AlipayConfig > implements AliPayService { @ Override @ Cacheable ( key = \"<STR_LIT>\" ) public AlipayConfig find ( ) { AlipayConfig alipayConfig = getById ( <NUM_LIT> ) ; return alipayConfig == null ? new AlipayConfig ( ) : alipayConfig ; } @ Override @ CachePut ( key = \"<STR_LIT>\" ) @ Transactional ( rollbackFor = Exception . class ) public AlipayConfig config ( AlipayConfig alipayConfig ) { alipayConfig . setId ( <NUM_LIT> ) ; saveOrUpdate ( alipayConfig ) ; return alipayConfig ; } @ Override public String toPayAsPc ( AlipayConfig alipay , TradeVo trade ) throws Exception { if ( alipay . getId ( ) == null ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } AlipayClient alipayClient = new DefaultAlipayClient ( alipay . getGatewayUrl ( ) , alipay . getAppId ( ) , alipay . getPrivateKey ( ) , alipay . getFormat ( ) , alipay . getCharset ( ) , alipay . getPublicKey ( ) , alipay . getSignType ( ) ) ; AlipayTradePagePayRequest request = new AlipayTradePagePayRequest ( ) ; request . setReturnUrl ( alipay . getReturnUrl ( ) ) ; request . setNotifyUrl ( alipay . getNotifyUrl ( ) ) ; request . setBizContent ( \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getOutTradeNo ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getTotalAmount ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getSubject ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getBody ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + alipay . getSysServiceProviderId ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; return alipayClient . pageExecute ( request , \"<STR_LIT>\" ) . getBody ( ) ; } @ Override public String toPayAsWeb ( AlipayConfig alipay , TradeVo trade ) throws Exception { if ( alipay . getId ( ) == null ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } AlipayClient alipayClient = new DefaultAlipayClient ( alipay . getGatewayUrl ( ) , alipay . getAppId ( ) , alipay . getPrivateKey ( ) , alipay . getFormat ( ) , alipay . getCharset ( ) , alipay . getPublicKey ( ) , alipay . getSignType ( ) ) ;", "output": "double money = Double . parseDouble ( trade . getTotalAmount ( ) ) ; double maxMoney = <NUM_LIT> ; if ( money <= <NUM_LIT> || money >= maxMoney ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest ( ) ; request . setReturnUrl ( alipay . getReturnUrl ( ) ) ; request . setNotifyUrl ( alipay . getNotifyUrl ( ) ) ; request . setBizContent ( \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getOutTradeNo ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getTotalAmount ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getSubject ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + trade . getBody ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" + alipay . getSysServiceProviderId ( ) + \"<STR_LIT>\" + \"<STR_LIT>\" + \"<STR_LIT>\" ) ; return alipayClient . pageExecute ( request , \"<STR_LIT>\" ) . getBody ( ) ; } }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . HardLinkImageAttribute ; import org . apache . ibatis . annotations . Param ; public interface HardLinkImageAttributeMapper extends BaseMapper < HardLinkImageAttribute > { String queryHardLinkImage ( @ Param ( \"<STR_LIT>\" ) byte [ ] md5 ) ;", "output": "}"}, {"input": "package me . zhengjie . utils ; import lombok . extern . slf4j . Slf4j ; import org . springframework . beans . BeansException ; import org . springframework . beans . factory . DisposableBean ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . core . env . Environment ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @ Slf4j public class SpringContextHolder implements ApplicationContextAware , DisposableBean { private static ApplicationContext applicationContext = null ; private static final List < CallBack > CALL_BACKS = new ArrayList < > ( ) ; private static boolean addCallback = true ; public synchronized static void addCallBacks ( CallBack callBack ) { if ( addCallback ) { SpringContextHolder . CALL_BACKS . add ( callBack ) ; } else { log . warn ( \"<STR_LIT>\" , callBack . getCallBackName ( ) ) ; callBack . executor ( ) ; } } @ SuppressWarnings ( \"<STR_LIT>\" ) public static < T > T getBean ( String name ) { assertContextInjected ( ) ; return ( T ) applicationContext . getBean ( name ) ; } public static < T > T getBean ( Class < T > requiredType ) { assertContextInjected ( ) ; return applicationContext . getBean ( requiredType ) ; } public static < T > T getProperties ( String property , T defaultValue , Class < T > requiredType ) { T result = defaultValue ; try { result = getBean ( Environment . class ) . getProperty ( property , requiredType ) ; } catch ( Exception ignored ) { } return result ; } public static String getProperties ( String property ) { return getProperties ( property , null , String . class ) ; } public static < T > T getProperties ( String property , Class < T > requiredType ) { return getProperties ( property , null , requiredType ) ; } private static void assertContextInjected ( ) { if ( applicationContext == null ) { throw new IllegalStateException ( \"<STR_LIT>\" + \"<STR_LIT>\" ) ; } } private static void clearHolder ( ) { log . debug ( \"<STR_LIT>\" + applicationContext ) ; applicationContext = null ; } @ Override public void destroy ( ) { SpringContextHolder . clearHolder ( ) ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( SpringContextHolder . applicationContext != null ) { log . warn ( \"<STR_LIT>\" + SpringContextHolder . applicationContext ) ; } SpringContextHolder . applicationContext = applicationContext ; if ( addCallback ) { for ( CallBack callBack : SpringContextHolder . CALL_BACKS ) { callBack . executor ( ) ; } CALL_BACKS . clear ( ) ; } SpringContextHolder . addCallback = false ; } public static List < String > getAllServiceBeanName ( ) { return new ArrayList < > ( Arrays . asList ( applicationContext . getBeanNamesForAnnotation ( Service . class ) ) ) ; }", "output": "}"}, {"input": "package com . yf . system . modules . dict . dto . ext ; import com . yf . system . modules . dict . dto . SysDicValueDTO ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . util . List ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DicValueTreeDTO extends SysDicValueDTO { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private List < DicValueTreeDTO > children ;", "output": "}"}, {"input": "package org . springblade . cgform . service . impl ; import org . springblade . cgform . entity . SysDictItem ; import org . springblade . cgform . mapper . DictItemMapper ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictItemService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class DictItemServiceImpl extends BaseServiceImpl < DictItemMapper , SysDictItem > implements IDictItemService { @ Override public List < DictModel > queryDictItemsByCode ( String code ) { return baseMapper . queryDictItemsByCode ( code ) ;", "output": "} }"}, {"input": "package cn . org . alan . exam . model . form . answer ; import cn . org . alan . exam . common . group . AnswerGroup ; import jakarta . validation . constraints . NotBlank ; import lombok . Data ; @ Data public class CorrectAnswerFrom { @ NotBlank ( message = \"<STR_LIT>\" , groups = AnswerGroup . CorrectGroup . class ) private Integer userId ; @ NotBlank ( message = \"<STR_LIT>\" , groups = AnswerGroup . CorrectGroup . class ) private Integer examId ; @ NotBlank ( message = \"<STR_LIT>\" , groups = AnswerGroup . CorrectGroup . class ) private Integer questionId ; @ NotBlank ( message = \"<STR_LIT>\" , groups = AnswerGroup . CorrectGroup . class ) private Integer score ;", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . exam ; import cn . org . alan . exam . model . entity . ExamQuestion ; import lombok . Data ; import java . util . Calendar ; import java . util . List ; @ Data public class ExamQuestionListVO { private List < ExamQuestionVO > radioList ; private List < ExamQuestionVO > multiList ; private List < ExamQuestionVO > judgeList ; private List < ExamQuestionVO > saqList ; private Integer examDuration ; public Long leftSeconds ;", "output": "}"}, {"input": "package top . kangert . kspider . io ; import java . io . IOException ; import java . io . InputStream ; import java . util . Map ; import org . jsoup . Connection ; import org . jsoup . Connection . Method ; import org . jsoup . Connection . Response ; import org . jsoup . Jsoup ; public class HttpRequest { private Connection connection = null ; public static HttpRequest create ( ) { return new HttpRequest ( ) ; } public HttpRequest url ( String url ) { this . connection = Jsoup . connect ( url ) ; this . connection . method ( Method . GET ) ; this . connection . timeout ( <NUM_LIT> ) ; return this ; } public HttpRequest headers ( Map < String , String > headers ) { this . connection . headers ( headers ) ; return this ; } public HttpRequest header ( String key , String value ) { this . connection . header ( key , value ) ; return this ; } public HttpRequest header ( String key , Object value ) { if ( value != null ) { this . connection . header ( key , value . toString ( ) ) ; } return this ; } public HttpRequest cookies ( Map < String , String > cookies ) { this . connection . cookies ( cookies ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; this . connection . request ( ) . cookies ( ) . entrySet ( ) . forEach ( item -> { stringBuffer . append ( item . getKey ( ) + \"<STR_LIT>\" + item . getValue ( ) + \"<STR_LIT>\" ) ; } ) ; this . connection . header ( \"<STR_LIT>\" , stringBuffer . toString ( ) ) ; return this ; } public HttpRequest cookie ( String name , String value ) { if ( value != null ) { this . connection . cookie ( name , value ) ; } return this ; } public HttpRequest contentType ( String contentType ) { this . connection . header ( \"<STR_LIT>\" , contentType ) ; return this ; } public HttpRequest data ( String key , String value ) { this . connection . data ( key , value ) ; return this ; } public HttpRequest data ( String key , Object value ) { if ( value != null ) { this . connection . data ( key , value . toString ( ) ) ; } return this ; } public HttpRequest data ( String key , String filename , InputStream is ) { this . connection . data ( key , filename , is ) ; return this ; } public HttpRequest requestBody ( Object body ) { if ( body != null ) { this . connection . requestBody ( body . toString ( ) ) ; } return this ; } public HttpRequest data ( Map < String , String > data ) { this . connection . data ( data ) ; return this ; } public HttpRequest method ( String method ) { this . connection . method ( Method . valueOf ( method ) ) ; return this ; }", "output": "public HttpRequest followRedirects ( boolean followRedirects ) { this . connection . followRedirects ( followRedirects ) ; return this ; } public HttpRequest timeout ( int timeout ) { this . connection . timeout ( timeout ) ; return this ; } public HttpRequest proxy ( String host , int port ) { this . connection . proxy ( host , port ) ; return this ; } public HttpResponse execute ( ) throws IOException { this . connection . ignoreContentType ( true ) ; this . connection . ignoreHttpErrors ( true ) ; this . connection . maxBodySize ( <NUM_LIT> ) ; Response response = connection . execute ( ) ; return new HttpResponse ( response ) ; } }"}, {"input": "package org . springblade . gateway . dynamic ; import lombok . Data ; import java . util . ArrayList ; import java . util . List ; @ Data public class GatewayRoute { private String id ; private List < GatewayPredicate > predicates = new ArrayList < > ( ) ; private List < GatewayFilter > filters = new ArrayList < > ( ) ; private String uri ; private int order = <NUM_LIT> ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . collection . type . primitive ; import java . util . Iterator ; import java . util . Map ; public interface IntObjectMap < V > extends Map < Integer , V > { interface PrimitiveEntry < V > { int key ( ) ; V value ( ) ; void setValue ( V value ) ; } V get ( int key ) ; V put ( int key , V value ) ; V remove ( int key ) ; Iterable < PrimitiveEntry < V > > entries ( ) ;", "output": "boolean containsKey ( int key ) ; }"}, {"input": "package org . springblade . model ; import lombok . Data ; import org . springframework . stereotype . Component ; import java . math . BigDecimal ; import java . math . BigInteger ; @ Data @ Component public class Coin { private String name ; private String unit ; private String rpc ; private String keystorePath ; private BigDecimal defaultMinerFee ; private String withdrawAddress ; private String withdrawWallet ; private String withdrawWalletPassword ; private BigDecimal minCollectAmount ; private BigInteger gasLimit ; private BigDecimal gasSpeedUp = BigDecimal . ONE ; private BigDecimal rechargeMinerFee ; private String ignoreFromAddress ; private String masterAddress ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent ; import java . util . concurrent . TimeUnit ; public class ThreadUtil { public static void sleep ( long durationMillis ) { try { Thread . sleep ( durationMillis ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } public static void sleep ( long duration , TimeUnit unit ) { try {", "output": "Thread . sleep ( unit . toMillis ( duration ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } public static void handleInterruptedException ( ) { Thread . currentThread ( ) . interrupt ( ) ; } }"}, {"input": "package ginyi . framework . security . service ; import ginyi . system . domain . SysLogOperation ; import ginyi . system . service . ISysOperLogService ; import org . springframework . stereotype . Service ; import java . util . List ; @ Service public class SysOperationLogServiceImpl implements ISysOperLogService { @ Override public void insertOperlog ( SysLogOperation operLog ) { } @ Override public List < SysLogOperation > selectOperLogList ( SysLogOperation operLog ) { return null ; } @ Override public int deleteOperLogByIds ( Long [ ] operIds ) { return <NUM_LIT> ; }", "output": "@ Override public SysLogOperation selectOperLogById ( Long operId ) { return null ; } @ Override public void cleanOperLog ( ) { } }"}, {"input": "package org . springblade . model ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class MatchExchangeDelParam { private String exchangeType ; private String symbolName ; private String entrustId ;", "output": "}"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . redis . cache . RedisCache ; import ginyi . common . result . StateCode ; import ginyi . common . utils . DateUtils ; import ginyi . common . utils . NumberUtils ; import ginyi . common . utils . StringUtils ; import ginyi . common . utils . ip . IpUtils ; import ginyi . system . domain . * ; import ginyi . system . domain . model . dto . CacheDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . CacheKeyVo ; import ginyi . system . domain . model . vo . CacheVo ; import ginyi . system . service . ISysMonitorService ; import lombok . extern . slf4j . Slf4j ; import org . springframework . data . redis . connection . DataType ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . stereotype . Service ; import oshi . SystemInfo ; import oshi . hardware . CentralProcessor ; import oshi . hardware . HardwareAbstractionLayer ; import oshi . software . os . FileSystem ; import oshi . software . os . OSFileStore ; import javax . annotation . Resource ; import java . lang . management . ManagementFactory ; import java . util . * ; @ Slf4j @ Service public class SysMonitorServiceImpl implements ISysMonitorService { @ Resource private RedisCache redisCache ; @ Resource private RedisTemplate redisTemplate ; @ Override public SysServer getServerInfo ( ) throws InterruptedException { SysServer server = new SysServer ( ) ; SystemInfo systemInfo = new SystemInfo ( ) ; HardwareAbstractionLayer hardware = systemInfo . getHardware ( ) ; long [ ] prevTicks = hardware . getProcessor ( ) . getSystemCpuLoadTicks ( ) ; Thread . sleep ( <NUM_LIT> ) ; long [ ] ticks = hardware . getProcessor ( ) . getSystemCpuLoadTicks ( ) ; long nice = ticks [ CentralProcessor . TickType . NICE . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . NICE . getIndex ( ) ] ; long irq = ticks [ CentralProcessor . TickType . IRQ . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IRQ . getIndex ( ) ] ; long softIrq = ticks [ CentralProcessor . TickType . SOFTIRQ . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . SOFTIRQ . getIndex ( ) ] ; long steal = ticks [ CentralProcessor . TickType . STEAL . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . STEAL . getIndex ( ) ] ; long SysRate = ticks [ CentralProcessor . TickType . SYSTEM . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . SYSTEM . getIndex ( ) ] ; long userRate = ticks [ CentralProcessor . TickType . USER . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . USER . getIndex ( ) ] ; long waitRate = ticks [ CentralProcessor . TickType . IOWAIT . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IOWAIT . getIndex ( ) ] ; long IdleRate = ticks [ CentralProcessor . TickType . IDLE . getIndex ( ) ] - prevTicks [ CentralProcessor . TickType . IDLE . getIndex ( ) ] ; long totalCpu = userRate + nice + SysRate + IdleRate + waitRate + irq + softIrq + steal ; SysCpu sysCpu = new SysCpu ( ) ; sysCpu . setCpuNum ( hardware . getProcessor ( ) . getLogicalProcessorCount ( ) ) ; sysCpu . setTotal ( totalCpu ) ; sysCpu . setSys ( NumberUtils . round ( ( ( double ) SysRate / totalCpu ) * <NUM_LIT> , <NUM_LIT> ) ) ; sysCpu . setUsed ( NumberUtils . round ( ( ( double ) userRate / totalCpu ) * <NUM_LIT> , <NUM_LIT> ) ) ; sysCpu . setWait ( NumberUtils . round ( ( ( double ) waitRate / totalCpu ) * <NUM_LIT> , <NUM_LIT> ) ) ; sysCpu . setFree ( NumberUtils . round ( ( ( double ) IdleRate / totalCpu ) * <NUM_LIT> , <NUM_LIT> ) ) ; SysMemory sysMemory = new SysMemory ( ) ; sysMemory . setTotal ( NumberUtils . round ( ( double ) hardware . getMemory ( ) . getTotal ( ) / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysMemory . setUsed ( NumberUtils . round ( ( double ) ( hardware . getMemory ( ) . getTotal ( ) - hardware . getMemory ( ) . getAvailable ( ) ) / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysMemory . setFree ( NumberUtils . round ( ( double ) hardware . getMemory ( ) . getAvailable ( ) / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysMemory . setUsage ( NumberUtils . round ( ( sysMemory . getUsed ( ) / sysMemory . getTotal ( ) ) * <NUM_LIT> , <NUM_LIT> ) ) ; Properties properties = System . getProperties ( ) ; SysJvm sysJvm = new SysJvm ( ) ; sysJvm . setTotal ( NumberUtils . round ( ( double ) Runtime . getRuntime ( ) . totalMemory ( ) / ( <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysJvm . setMax ( NumberUtils . round ( ( double ) Runtime . getRuntime ( ) . maxMemory ( ) / ( <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysJvm . setFree ( NumberUtils . round ( ( double ) Runtime . getRuntime ( ) . freeMemory ( ) / ( <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysJvm . setUsed ( NumberUtils . round ( sysJvm . getTotal ( ) - sysJvm . getFree ( ) , <NUM_LIT> ) ) ; sysJvm . setUsage ( NumberUtils . round ( ( ( sysJvm . getTotal ( ) - sysJvm . getFree ( ) ) / sysJvm . getTotal ( ) ) * <NUM_LIT> , <NUM_LIT> ) ) ; sysJvm . setInputArgs ( ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) . toString ( ) ) ; sysJvm . setName ( ManagementFactory . getRuntimeMXBean ( ) . getVmName ( ) ) ; sysJvm . setRunTime ( DateUtils . getDatePoor ( DateUtils . getNowDate ( ) , DateUtils . getServerStartDate ( ) ) ) ; sysJvm . setStartTime ( DateUtils . parseDateToStr ( DateUtils . YYYY_MM_DD_HH_MM_SS , DateUtils . getServerStartDate ( ) ) ) ; sysJvm . setVersion ( properties . getProperty ( \"<STR_LIT>\" ) ) ; sysJvm . setHome ( properties . getProperty ( \"<STR_LIT>\" ) ) ; Sys sys = new Sys ( ) ; sys . setComputerName ( IpUtils . getHostName ( ) ) ; sys . setComputerIp ( IpUtils . getHostIp ( ) ) ; sys . setOsName ( properties . getProperty ( \"<STR_LIT>\" ) ) ; sys . setOsArch ( properties . getProperty ( \"<STR_LIT>\" ) ) ; sys . setUserDir ( properties . getProperty ( \"<STR_LIT>\" ) ) ; FileSystem fileSystem = systemInfo . getOperatingSystem ( ) . getFileSystem ( ) ; List < OSFileStore > fsArray = fileSystem . getFileStores ( ) ; List < SysFile > sysFiles = new LinkedList < > ( ) ; for ( OSFileStore fs : fsArray ) { long free = fs . getUsableSpace ( ) ; long total = fs . getTotalSpace ( ) ; long used = total - free ; SysFile sysFile = new SysFile ( ) ; sysFile . setDirName ( fs . getMount ( ) ) ; sysFile . setTypeName ( fs . getName ( ) ) ; sysFile . setTotal ( NumberUtils . round ( ( double ) total / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysFile . setFree ( NumberUtils . round ( ( double ) free / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysFile . setUsed ( NumberUtils . round ( ( double ) used / ( <NUM_LIT> * <NUM_LIT> * <NUM_LIT> ) , <NUM_LIT> ) ) ; sysFile . setUsage ( NumberUtils . round ( ( ( double ) used / total ) * <NUM_LIT> , <NUM_LIT> ) ) ; sysFiles . add ( sysFile ) ; } server . setCpu ( sysCpu ) ; server . setMemory ( sysMemory ) ; server . setJvm ( sysJvm ) ; server . setSys ( sys ) ; server . setFile ( sysFiles ) ; return server ; } @ Override public BaseVo < CacheKeyVo > getCacheList ( ) { BaseVo < CacheKeyVo > baseVo = new BaseVo < > ( ) ; Set < String > keys = redisCache . getKeys ( \"<STR_LIT>\" ) ; ArrayList < CacheKeyVo > list = new ArrayList < > ( ) ; for ( String key : keys ) { CacheKeyVo keyVo = new CacheKeyVo ( ) ; DataType type = redisCache . getType ( key ) ; keyVo . setKey ( key ) ; keyVo . setType ( type . code ( ) ) ; list . add ( keyVo ) ; } list . sort ( Comparator . comparing ( CacheKeyVo :: getKey ) ) ; baseVo . setList ( list ) ; baseVo . setCount ( keys . size ( ) ) ; return baseVo ; } @ Override public CacheVo getCacheDetails ( CacheDto cacheDto ) { if ( ! redisCache . hasKey ( cacheDto . getKey ( ) ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . REDIS_KEY_NOT_EXIST ) ; } Object object = null ; try { if ( \"<STR_LIT>\" . equalsIgnoreCase ( cacheDto . getType ( ) ) ) { object = redisCache . getCacheObject ( cacheDto . getKey ( ) , Object . class ) ; } if ( \"<STR_LIT>\" . equalsIgnoreCase ( cacheDto . getType ( ) ) ) { object = redisCache . getCacheList ( cacheDto . getKey ( ) , Object . class ) ; } } catch ( Exception e ) { throw new CommonException ( StateCode . ERROR_BUSINESS , CommonMessageConstants . REDIS_VALUE_TYPE_NOT_MATCH ) ; }", "output": "if ( StringUtils . isNull ( object ) ) { throw new CommonException ( StateCode . ERROR_BUSINESS , CommonMessageConstants . REDIS_VALUE_TYPE_NOT_MATCH ) ; } CacheVo cacheVo = new CacheVo ( ) ; cacheVo . setKey ( cacheDto . getKey ( ) ) ; cacheVo . setExpire ( redisCache . getExpire ( cacheDto . getKey ( ) ) ) ; cacheVo . setValue ( object ) ; return cacheVo ; } @ Override public void removeCache ( String key ) { if ( ! redisCache . hasKey ( key ) ) { throw new CommonException ( StateCode . ERROR_NOT_EXIST , CommonMessageConstants . REDIS_KEY_NOT_EXIST ) ; } redisCache . removeCacheObject ( key ) ; } }"}, {"input": "package top . kangert . kspider . driver ; import top . kangert . kspider . constant . Constants ; import top . kangert . kspider . model . SpiderNode ; import top . kangert . kspider . util . IoUtils ; import org . openqa . selenium . Proxy ; import org . openqa . selenium . WebDriver ; import org . openqa . selenium . chrome . ChromeOptions ; import org . openqa . selenium . remote . * ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import java . io . InputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; @ Component public class ChromeDriverProvider implements DriverProvider { private static final String USER_AGENT_OPTION = \"<STR_LIT>\" ; private static final String DISABLED_JAVASCRIPT_OPTION = \"<STR_LIT>\" ; private static final String IMAGES_DISABLED_OPTION = \"<STR_LIT>\" ; private static final String HIDE_SCROLLBARS_OPTION = \"<STR_LIT>\" ; private static final String NO_SANDBOX_OPTION = \"<STR_LIT>\" ; private static final String INCOGNITO_OPTION = \"<STR_LIT>\" ; private static final String DISABLE_PLUGINS_OPTION = \"<STR_LIT>\" ; private static final String DISABLE_JAVA_OPTION = \"<STR_LIT>\" ; private static final String WINDOW_SIZE_OPTION = \"<STR_LIT>\" ; private static final String MAXIMIZED_OPTION = \"<STR_LIT>\" ; private static final String DISABLE_GPU_OPTION = \"<STR_LIT>\" ; @ Override public String support ( ) { return Browser . CHROME . browserName ( ) ; } @ Override public WebDriver getWebDriver ( SpiderNode node , String proxyStr ) throws MalformedURLException { ChromeOptions options = new ChromeOptions ( ) ; String userAgent = node . getJsonProperty ( USER_AGENT ) ; if ( StrUtil . isNotBlank ( userAgent ) ) { options . addArguments ( String . format ( USER_AGENT_OPTION , userAgent ) ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( JAVASCRIPT_DISABLED ) ) ) { options . addArguments ( DISABLED_JAVASCRIPT_OPTION ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( IMAGE_DISABLED ) ) ) { options . addArguments ( IMAGES_DISABLED_OPTION ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( HIDE_SCROLLBAR ) ) ) { options . addArguments ( HIDE_SCROLLBARS_OPTION ) ; } options . setHeadless ( true ) ; if ( ! Constants . YES . equals ( node . getJsonProperty ( HEADLESS ) ) ) { options . setHeadless ( false ) ;", "output": "} if ( Constants . YES . equals ( node . getJsonProperty ( NO_SANDBOX ) ) ) { options . addArguments ( NO_SANDBOX_OPTION ) ; } options . addArguments ( INCOGNITO_OPTION ) ; if ( Constants . YES . equals ( node . getJsonProperty ( INCOGNITO ) ) ) { options . addArguments ( INCOGNITO_OPTION ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( PLUGIN_DISABLE ) ) ) { options . addArguments ( DISABLE_PLUGINS_OPTION ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( JAVA_DISABLE ) ) ) { options . addArguments ( DISABLE_JAVA_OPTION ) ; } String windowSize = node . getJsonProperty ( WINDOW_SIZE , \"<STR_LIT>\" ) ; if ( StrUtil . isNotBlank ( windowSize ) ) { options . addArguments ( String . format ( WINDOW_SIZE_OPTION , windowSize ) ) ; } options . addArguments ( MAXIMIZED_OPTION ) ; if ( Constants . YES . equals ( node . getJsonProperty ( MAXIMIZED ) ) ) { options . addArguments ( MAXIMIZED_OPTION ) ; } if ( Constants . YES . equals ( node . getJsonProperty ( GPU_DISABLE ) ) ) { options . addArguments ( DISABLE_GPU_OPTION ) ; } String arguments = node . getJsonProperty ( ARGUMENTS ) ; if ( StrUtil . isNotBlank ( arguments ) ) { options . addArguments ( Arrays . asList ( arguments . split ( \"<STR_LIT>\" ) ) ) ; } if ( StrUtil . isNotBlank ( proxyStr ) ) { Proxy proxy = new Proxy ( ) ; proxy . setHttpProxy ( proxyStr ) ; options . setProxy ( proxy ) ; } options . setExperimentalOption ( \"<STR_LIT>\" , false ) ; options . setExperimentalOption ( \"<STR_LIT>\" , Collections . singleton ( \"<STR_LIT>\" ) ) ; String remoteWebdriverUrl = node . getJsonProperty ( REMOTE_WEBDRIVER_URL , DEFAULT_REMOTE_WEBDRIVER_URL ) ; WebDriver driver = new CdpRemoteWebDriver ( new URL ( remoteWebdriverUrl ) , options ) ; InputStream input = ChromeDriverProvider . class . getClassLoader ( ) . getResourceAsStream ( \"<STR_LIT>\" ) ; String source = IoUtils . readStreamToString ( input ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( \"<STR_LIT>\" , source ) ; ( ( CdpRemoteWebDriver ) driver ) . executeCdpCommand ( \"<STR_LIT>\" , params ) ; return driver ; } }"}, {"input": "package com . youlai . system . model . bo ; import com . youlai . system . enums . MenuTypeEnum ; import lombok . Data ; @ Data public class RouteBO { private Long id ; private Long parentId ; private String name ; private MenuTypeEnum type ; private String routeName ; private String routePath ; private String component ; private String perm ; private Integer visible ; private Integer sort ; private String icon ; private String redirect ; private Integer alwaysShow ; private Integer keepAlive ; private String params ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . mybatis . config ; import com . baomidou . mybatisplus . autoconfigure . MybatisPlusAutoConfiguration ; import com . baomidou . mybatisplus . extension . plugins . MybatisPlusInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . InnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . OptimisticLockerInnerInterceptor ; import com . baomidou . mybatisplus . extension . plugins . inner . PaginationInnerInterceptor ; import org . apache . ibatis . session . SqlSessionFactory ; import org . springframework . boot . autoconfigure . AutoConfigureBefore ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import java . util . List ; import java . util . Optional ; @ Configuration @ ConditionalOnClass ( SqlSessionFactory . class ) @ AutoConfigureBefore ( MybatisPlusAutoConfiguration . class ) public class CustomMybatisAutoConfiguration { @ Bean public MybatisPlusInterceptor mybatisPlusInterceptor ( Optional < List < InnerInterceptor > > extraInterceptors ) { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( ) ; if ( extraInterceptors . isPresent ( ) ) { for ( InnerInterceptor innerInterceptor : extraInterceptors . get ( ) ) { interceptor . addInnerInterceptor ( innerInterceptor ) ; } } interceptor . addInnerInterceptor ( new PaginationInnerInterceptor ( ) ) ; interceptor . addInnerInterceptor ( new OptimisticLockerInnerInterceptor ( ) ) ; return interceptor ; }", "output": "}"}, {"input": "package top . kangert . kspider . script ; import lombok . extern . slf4j . Slf4j ; import top . kangert . kspider . expression . ExpressionTemplate ; import top . kangert . kspider . expression . ExpressionTemplateContext ; import javax . script . Invocable ; import javax . script . ScriptEngine ; import javax . script . ScriptException ; import org . graalvm . polyglot . Context ; import org . springframework . stereotype . Component ; import com . oracle . truffle . js . scriptengine . GraalJSScriptEngine ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; @ Component @ Slf4j public class ScriptManager { private static ScriptEngine scriptEngine ; private static Set < String > functions = new HashSet < > ( ) ; private static ReadWriteLock lock = new ReentrantReadWriteLock ( ) ; static { scriptEngine = createEngine ( ) ; StringBuffer script = new StringBuffer ( ) ; script . append ( \"<STR_LIT>\" ) . append ( ExpressionTemplate . class . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( \"<STR_LIT>\" ) . append ( ExpressionTemplateContext . class . getName ( ) ) . append ( \"<STR_LIT>\" ) . append ( \"<STR_LIT>\" ) . append ( \"<STR_LIT>\" ) . append ( \"<STR_LIT>\" ) ; try { scriptEngine . eval ( script . toString ( ) ) ; } catch ( ScriptException e ) { log . error ( \"<STR_LIT>\" , e ) ; } } public static ScriptEngine createEngine ( ) { Context . Builder contextBuilder = Context . newBuilder ( \"<STR_LIT>\" ) ; contextBuilder . allowAllAccess ( true ) ; GraalJSScriptEngine engine = GraalJSScriptEngine . create ( null , contextBuilder ) ; return engine ; } public static void clearFunctions ( ) { functions . clear ( ) ; } public static void lock ( ) { lock . writeLock ( ) . lock ( ) ; } public static void unlock ( ) { lock . writeLock ( ) . unlock ( ) ; } public static void registerFunction ( String functionName , String parameters , String script ) { try { validScript ( functionName , parameters , script ) ; functions . add ( functionName ) ; log . info ( \"<STR_LIT>\" , functionName ) ; } catch ( Exception e ) { log . warn ( \"<STR_LIT>\" , functionName , e ) ; } } private static String concatScript ( String functionName , String parameters , String script ) { StringBuffer scriptBuffer = new StringBuffer ( ) ; scriptBuffer . append ( \"<STR_LIT>\" ) . append ( functionName ) . append ( \"<STR_LIT>\" ) . append ( parameters == null ? \"<STR_LIT>\" : parameters ) . append ( \"<STR_LIT>\" ) . append ( script ) . append ( \"<STR_LIT>\" ) ; return scriptBuffer . toString ( ) ; } public static boolean containsFunction ( String functionName ) { try { lock . readLock ( ) . lock ( ) ; return functions . contains ( functionName ) ; } finally { lock . readLock ( ) . unlock ( ) ; } } public static void validScript ( String functionName , String parameters , String script ) throws Exception { scriptEngine . eval ( concatScript ( functionName , parameters , script ) ) ; } public static Object eval ( ExpressionTemplateContext context , String functionName , Object ... args ) throws ScriptException , NoSuchMethodException { if ( \"<STR_LIT>\" . equals ( functionName ) ) { if ( args == null || args . length != <NUM_LIT> ) { throw new ScriptException ( \"<STR_LIT>\" ) ; } else { return ExpressionTemplate . create ( args [ <NUM_LIT> ] . toString ( ) ) . render ( context ) ; }", "output": "} if ( scriptEngine == null ) { throw new NoSuchMethodException ( functionName ) ; } try { lock . readLock ( ) . lock ( ) ; return convertObject ( ( ( Invocable ) scriptEngine ) . invokeFunction ( functionName , args ) ) ; } finally { lock . readLock ( ) . unlock ( ) ; } } private static Object convertObject ( Object object ) { return object ; } }"}, {"input": "package com . yf . ability . task . enums ; public interface JobPrefix { String BREAK_EXAM = \"<STR_LIT>\" ; String GRANT_CERT = \"<STR_LIT>\" ; String ADD_BOOK = \"<STR_LIT>\" ;", "output": "String READ_DURATION = \"<STR_LIT>\" ; }"}, {"input": "package me . zhengjie . modules . mnt . util ; import cn . hutool . core . io . IoUtil ; import com . jcraft . jsch . ChannelShell ; import com . jcraft . jsch . JSch ; import com . jcraft . jsch . Session ; import lombok . extern . slf4j . Slf4j ; import java . io . * ; import java . util . Vector ; @ Slf4j public class ExecuteShellUtil { private Vector < String > stdout ; Session session ;", "output": "public ExecuteShellUtil ( final String ipAddress , final String username , final String password , int port ) { try { JSch jsch = new JSch ( ) ; session = jsch . getSession ( username , ipAddress , port ) ; session . setPassword ( password ) ; session . setConfig ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; session . connect ( <NUM_LIT> ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; } } public int execute ( final String command ) { int returnCode = <NUM_LIT> ; ChannelShell channel = null ; PrintWriter printWriter = null ; BufferedReader input = null ; stdout = new Vector < String > ( ) ; try { channel = ( ChannelShell ) session . openChannel ( \"<STR_LIT>\" ) ; channel . connect ( ) ; input = new BufferedReader ( new InputStreamReader ( channel . getInputStream ( ) ) ) ; printWriter = new PrintWriter ( channel . getOutputStream ( ) ) ; printWriter . println ( command ) ; printWriter . println ( \"<STR_LIT>\" ) ; printWriter . flush ( ) ; log . info ( \"<STR_LIT>\" ) ; String line ; while ( ( line = input . readLine ( ) ) != null ) { stdout . add ( line ) ; System . out . println ( line ) ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) , e ) ; return - <NUM_LIT> ; } finally { IoUtil . close ( printWriter ) ; IoUtil . close ( input ) ; if ( channel != null ) { channel . disconnect ( ) ; } } return returnCode ; } public void close ( ) { if ( session != null ) { session . disconnect ( ) ; } } public String executeForResult ( String command ) { execute ( command ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String str : stdout ) { sb . append ( str ) ; } return sb . toString ( ) ; } }"}, {"input": "package ginyi . system . domain ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; @ Data public class Sys { @ ApiModelProperty ( \"<STR_LIT>\" ) private String computerName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String computerIp ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String userDir ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String osName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String osArch ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . reader . xls ; import io . github . chensheng . dddboot . excel . core . WorkbookConfig ; import io . github . chensheng . dddboot . excel . reader . BaseExcelReader ; import io . github . chensheng . dddboot . excel . reader . RowReadingListener ; import java . io . InputStream ; public class XlsReader extends BaseExcelReader { @ Override protected void doRead ( InputStream inputStream , RowReadingListener rowReadingListener , WorkbookConfig workbookConfig ) throws Exception { XlsSheetProcessor processor = new XlsSheetProcessor ( rowReadingListener , workbookConfig , false ) ; processor . execute ( inputStream ) ; }", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . answer ; import lombok . Data ; @ Data public class AnswerExamVO { private Integer examId ; private String examTitle ; private Integer neededMark ; private Integer classSize ; private Integer numberOfApplicants ; private Integer correctedPaper ;", "output": "}"}, {"input": "package cn . org . alan . exam . common . result ; import org . springframework . core . MethodParameter ; import org . springframework . http . HttpInputMessage ; import org . springframework . http . HttpStatus ; import org . springframework . http . converter . HttpMessageConverter ; import org . springframework . util . StreamUtils ; import org . springframework . web . bind . annotation . ControllerAdvice ; import org . springframework . web . servlet . mvc . method . annotation . RequestBodyAdviceAdapter ; import java . io . ByteArrayInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Type ; @ ControllerAdvice public class DecryptRequestBodyAdvice extends RequestBodyAdviceAdapter { @ Override public boolean supports ( MethodParameter methodParameter , Type targetType , Class < ? extends HttpMessageConverter < ? > > converterType ) { return false ; }", "output": "}"}, {"input": "package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . PUT ) public @ interface AnonymousPutMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default \"<STR_LIT>\" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { }", "output": "; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; }"}, {"input": "package com . yf . system . modules . user . dto . response ; import com . yf . base . api . annon . Dict ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . util . Date ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class UserListRespDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String userName ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String avatar ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String realName ; @ Dict ( dictTable = \"<STR_LIT>\" , dicCode = \"<STR_LIT>\" , dicText = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private String deptCode ; @ Dict ( dicCode = \"<STR_LIT>\" ) @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Integer state ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String idCard ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String mobile ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String email ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date createTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" , required = true ) private Date updateTime ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String roleNames ;", "output": "}"}, {"input": "package me . zhengjie . modules . system . rest ; import cn . hutool . core . collection . CollectionUtil ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . annotation . Log ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . system . domain . Dept ; import me . zhengjie . modules . system . service . DeptService ; import me . zhengjie . modules . system . domain . vo . DeptQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . PageUtil ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . util . * ; import java . util . stream . Collectors ; @ RestController @ RequiredArgsConstructor @ Api ( tags = \"<STR_LIT>\" ) @ RequestMapping ( \"<STR_LIT>\" ) public class DeptController { private final DeptService deptService ; private static final String ENTITY_NAME = \"<STR_LIT>\" ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportDept ( HttpServletResponse response , DeptQueryCriteria criteria ) throws Exception { deptService . download ( deptService . queryAll ( criteria , false ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < Dept > > queryDept ( DeptQueryCriteria criteria ) throws Exception { List < Dept > depts = deptService . queryAll ( criteria , true ) ; return new ResponseEntity < > ( PageUtil . toPage ( depts ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > getDeptSuperior ( @ RequestBody List < Long > ids , @ RequestParam ( defaultValue = \"<STR_LIT>\" ) Boolean exclude ) { Set < Dept > deptSet = new LinkedHashSet < > ( ) ; for ( Long id : ids ) { Dept dept = deptService . findById ( id ) ; List < Dept > depts = deptService . getSuperior ( dept , new ArrayList < > ( ) ) ; if ( exclude ) { for ( Dept data : depts ) { if ( data . getId ( ) . equals ( dept . getPid ( ) ) ) { data . setSubCount ( data . getSubCount ( ) - <NUM_LIT> ) ; } } depts = depts . stream ( ) . filter ( i -> ! ids . contains ( i . getId ( ) ) ) . collect ( Collectors . toList ( ) ) ; } deptSet . addAll ( depts ) ; } return new ResponseEntity < > ( deptService . buildTree ( new ArrayList < > ( deptSet ) ) , HttpStatus . OK ) ;", "output": "} @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PostMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > createDept ( @ Validated @ RequestBody Dept resources ) { if ( resources . getId ( ) != null ) { throw new BadRequestException ( \"<STR_LIT>\" + ENTITY_NAME + \"<STR_LIT>\" ) ; } deptService . create ( resources ) ; return new ResponseEntity < > ( HttpStatus . CREATED ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ PutMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > updateDept ( @ Validated ( Dept . Update . class ) @ RequestBody Dept resources ) { deptService . update ( resources ) ; return new ResponseEntity < > ( HttpStatus . NO_CONTENT ) ; } @ Log ( \"<STR_LIT>\" ) @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteDept ( @ RequestBody Set < Long > ids ) { Set < Dept > depts = new HashSet < > ( ) ; for ( Long id : ids ) { List < Dept > deptList = deptService . findByPid ( id ) ; depts . add ( deptService . findById ( id ) ) ; if ( CollectionUtil . isNotEmpty ( deptList ) ) { depts = deptService . getDeleteDepts ( deptList , depts ) ; } } deptService . verification ( depts ) ; deptService . delete ( depts ) ; return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . config . ConfigType ; import com . alibaba . nacos . api . config . annotation . NacosConfigListener ; import com . alibaba . nacos . api . config . convert . NacosConfigConverter ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . annotation . ConfigServiceBeanBuilder ; import io . github . chensheng . dddboot . nacos . spring . config . DefaultNacosConfigConverter ; import io . github . chensheng . dddboot . nacos . spring . context . event . AnnotationListenerMethodProcessor ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . NacosConfigMetadataEvent ; import io . github . chensheng . dddboot . nacos . spring . context . event . config . TimeoutNacosConfigListener ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import org . springframework . beans . BeansException ; import org . springframework . context . * ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . Environment ; import org . springframework . format . support . DefaultFormattingConversionService ; import org . springframework . util . Assert ; import org . springframework . util . ReflectionUtils ; import org . springframework . util . StringUtils ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Properties ; import static io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource . CONFIG ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getConfigServiceBeanBuilder ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . getNacosServiceFactoryBean ; import static org . springframework . beans . BeanUtils . instantiateClass ; import static org . springframework . core . annotation . AnnotationUtils . getAnnotationAttributes ; public class NacosConfigListenerMethodProcessor extends AnnotationListenerMethodProcessor < NacosConfigListener > implements ApplicationContextAware , ApplicationEventPublisherAware , EnvironmentAware { public static final String BEAN_NAME = \"<STR_LIT>\" ; public static final String NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME = \"<STR_LIT>\" ; private Properties globalNacosProperties ; private NacosServiceFactory nacosServiceFactory ; private ConversionService conversionService ; private ConfigServiceBeanBuilder configServiceBeanBuilder ; private Environment environment ; private ApplicationEventPublisher applicationEventPublisher ; @ Override protected void processListenerMethod ( String beanName , final Object bean , Class < ? > beanClass , final NacosConfigListener listener , final Method method , ApplicationContext applicationContext ) { final String dataId = NacosUtils . readFromEnvironment ( listener . dataId ( ) , environment ) ; final String groupId = NacosUtils . readFromEnvironment ( listener . groupId ( ) , environment ) ; final String type ; ConfigType typeEnum = listener . type ( ) ; if ( ConfigType . UNSET . equals ( typeEnum ) ) { type = NacosUtils . readFileExtension ( dataId ) ; } else { type = typeEnum . getType ( ) ; } long timeout = listener . timeout ( ) ; Assert . isTrue ( StringUtils . hasText ( dataId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( StringUtils . hasText ( groupId ) , \"<STR_LIT>\" ) ; Assert . isTrue ( timeout > <NUM_LIT> , \"<STR_LIT>\" ) ; ConfigService configService = configServiceBeanBuilder . build ( listener . properties ( ) ) ; try { configService . addListener ( dataId , groupId , new TimeoutNacosConfigListener ( dataId , groupId , timeout ) { @ Override protected void onReceived ( String config ) { Class < ? > targetType = method . getParameterTypes ( ) [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , type ) ; Object parameterValue = configConverter . convert ( config ) ; ReflectionUtils . invokeMethod ( method , bean , parameterValue ) ; } } ) ; } catch ( NacosException e ) { logger . error ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId , e ) ; } publishMetadataEvent ( beanName , bean , beanClass , dataId , groupId , listener , method ) ; } private void publishMetadataEvent ( String beanName , Object bean , Class < ? > beanClass , String dataId , String groupId , NacosConfigListener listener , Method method ) { NacosProperties nacosProperties = listener . properties ( ) ; Properties resolvedNacosProperties = configServiceBeanBuilder . resolveProperties ( nacosProperties ) ; NacosConfigMetadataEvent metadataEvent = new NacosConfigMetadataEvent ( listener ) ; metadataEvent . setDataId ( dataId ) ; metadataEvent . setGroupId ( groupId ) ; Map < String , Object > nacosPropertiesAttributes = getAnnotationAttributes ( nacosProperties ) ;", "output": "metadataEvent . setNacosPropertiesAttributes ( nacosPropertiesAttributes ) ; metadataEvent . setNacosProperties ( resolvedNacosProperties ) ; metadataEvent . setBeanName ( beanName ) ; metadataEvent . setBean ( bean ) ; metadataEvent . setBeanType ( beanClass ) ; metadataEvent . setAnnotatedElement ( method ) ; applicationEventPublisher . publishEvent ( metadataEvent ) ; } @ Override protected boolean isCandidateMethod ( Object bean , Class < ? > beanClass , NacosConfigListener listener , Method method , ApplicationContext applicationContext ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length != <NUM_LIT> ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" ) ; } return false ; } Class < ? > targetType = parameterTypes [ <NUM_LIT> ] ; NacosConfigConverter configConverter = determineNacosConfigConverter ( targetType , listener , listener . type ( ) . getType ( ) ) ; if ( ! configConverter . canConvert ( targetType ) ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( \"<STR_LIT>\" + method + \"<STR_LIT>\" + targetType + \"<STR_LIT>\" + configConverter . getClass ( ) . getName ( ) ) ; } } return true ; } private NacosConfigConverter determineNacosConfigConverter ( Class < ? > targetType , NacosConfigListener listener , String type ) { Class < ? > converterClass = listener . converter ( ) ; NacosConfigConverter configConverter = null ; if ( NacosConfigConverter . class . equals ( converterClass ) ) { configConverter = new DefaultNacosConfigConverter ( targetType , conversionService , type ) ; } else { configConverter = ( NacosConfigConverter ) instantiateClass ( converterClass ) ; } return configConverter ; } @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { globalNacosProperties = CONFIG . getMergedGlobalProperties ( applicationContext ) ; nacosServiceFactory = getNacosServiceFactoryBean ( applicationContext ) ; conversionService = determineConversionService ( applicationContext ) ; configServiceBeanBuilder = getConfigServiceBeanBuilder ( applicationContext ) ; } private ConversionService determineConversionService ( ApplicationContext applicationContext ) { String beanName = NACOS_CONFIG_CONVERSION_SERVICE_BEAN_NAME ; ConversionService conversionService = applicationContext . containsBean ( beanName ) ? applicationContext . getBean ( beanName , ConversionService . class ) : null ; if ( conversionService == null ) { conversionService = new DefaultFormattingConversionService ( ) ; } return conversionService ; } @ Override public void setApplicationEventPublisher ( ApplicationEventPublisher applicationEventPublisher ) { this . applicationEventPublisher = applicationEventPublisher ; } @ Override public void setEnvironment ( Environment environment ) { this . environment = environment ; } }"}, {"input": "package com . oddfar . campus . business . controller ; import com . oddfar . campus . common . annotation . RateLimiter ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . enums . LimitType ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RestController ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class RedisRateLimiterController { @ RateLimiter ( count = <NUM_LIT> , time = <NUM_LIT> ) @ GetMapping ( \"<STR_LIT>\" ) public R test ( ) { return R . ok ( \"<STR_LIT>\" ) ; } @ RateLimiter ( count = <NUM_LIT> , time = <NUM_LIT> , limitType = LimitType . IP ) @ GetMapping ( \"<STR_LIT>\" ) public R testip ( String value ) {", "output": "return R . ok ( \"<STR_LIT>\" , value ) ; } @ RateLimiter ( count = <NUM_LIT> , time = <NUM_LIT> , limitType = LimitType . IP , key = \"<STR_LIT>\" ) @ GetMapping ( \"<STR_LIT>\" ) public R testObj ( String value ) { return R . ok ( \"<STR_LIT>\" , value ) ; } }"}, {"input": "package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import java . io . Serializable ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class App extends BaseEntity implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private int port ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String uploadPath ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deployPath ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String backupPath ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String startScript ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deployScript ; public void copy ( App source ) {", "output": "BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . config ; import java . lang . annotation . * ; @ Target ( { ElementType . TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface NacosPropertySources {", "output": "NacosPropertySource [ ] value ( ) ; }"}, {"input": "package io . github . chensheng . dddboot . openfeign . config ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class OpenFeignProperties { public static final String PROP_BASE_PACKAGE = \"<STR_LIT>\" ; private String basePackage ; private HttpClient httpclient = new HttpClient ( ) ; public String getBasePackage ( ) { return basePackage ; } public void setBasePackage ( String basePackage ) { this . basePackage = basePackage ; } public HttpClient getHttpclient ( ) { return httpclient ; } public void setHttpclient ( HttpClient httpclient ) { this . httpclient = httpclient ; } public static class HttpClient { private int maxConnTotal = <NUM_LIT> ; private int maxConnPerRoute = <NUM_LIT> ; private boolean tcpNoDelay = true ;", "output": "private int socketTimeoutMillis = <NUM_LIT> ; private int connectTimeoutMillis = <NUM_LIT> ; private int connectionRequestTimeoutMillis = <NUM_LIT> ; public int getMaxConnTotal ( ) { return maxConnTotal ; } public void setMaxConnTotal ( int maxConnTotal ) { this . maxConnTotal = maxConnTotal ; } public int getMaxConnPerRoute ( ) { return maxConnPerRoute ; } public void setMaxConnPerRoute ( int maxConnPerRoute ) { this . maxConnPerRoute = maxConnPerRoute ; } public boolean isTcpNoDelay ( ) { return tcpNoDelay ; } public void setTcpNoDelay ( boolean tcpNoDelay ) { this . tcpNoDelay = tcpNoDelay ; } public int getSocketTimeoutMillis ( ) { return socketTimeoutMillis ; } public void setSocketTimeoutMillis ( int socketTimeoutMillis ) { this . socketTimeoutMillis = socketTimeoutMillis ; } public int getConnectTimeoutMillis ( ) { return connectTimeoutMillis ; } public void setConnectTimeoutMillis ( int connectTimeoutMillis ) { this . connectTimeoutMillis = connectTimeoutMillis ; } public int getConnectionRequestTimeoutMillis ( ) { return connectionRequestTimeoutMillis ; } public void setConnectionRequestTimeoutMillis ( int connectionRequestTimeoutMillis ) { this . connectionRequestTimeoutMillis = connectionRequestTimeoutMillis ; } } }"}, {"input": "package com . xcs . wx . controller ; import com . xcs . wx . service . ImageService ; import lombok . RequiredArgsConstructor ; import org . springframework . core . io . Resource ; import org . springframework . http . ResponseEntity ; import org . springframework . stereotype . Controller ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestParam ; @ Controller @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) public class ImageController { private final ImageService imageService ; @ GetMapping ( \"<STR_LIT>\" ) public ResponseEntity < Resource > downloadImgMd5 ( @ RequestParam String md5 ) { return imageService . downloadImgMd5 ( md5 ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseEntity < Resource > downloadImg ( @ RequestParam String path ) { return imageService . downloadImg ( path ) ; } @ GetMapping ( \"<STR_LIT>\" ) public ResponseEntity < Resource > downloadImgFormLocal ( @ RequestParam String localPath ) { return imageService . downloadImgFormLocal ( localPath ) ;", "output": "} }"}, {"input": "package io . github . chensheng . dddboot . web . core ; import java . io . Serializable ; public class Response < T > implements Serializable { private static final long serialVersionUID = - <NUM_LIT> ; protected String code ; protected String msg ; protected T data ; public Response ( ) { }", "output": "public Response ( String code , String msg ) { this . code = code ; this . msg = msg ; } public Response ( String code , String msg , T data ) { this . code = code ; this . msg = msg ; this . data = data ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } public T getData ( ) { return data ; } public void setData ( T data ) { this . data = data ; } public boolean isSuccess ( ) { return ResponseType . BIZ_SUCCESS . getCode ( ) . equals ( code ) ; } }"}, {"input": "package com . oddfar . campus . framework . mapper ; import com . baomidou . mybatisplus . core . conditions . update . UpdateWrapper ; import com . oddfar . campus . common . core . BaseMapperX ; import com . oddfar . campus . common . core . LambdaQueryWrapperX ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . entity . SysDictDataEntity ; import org . apache . ibatis . annotations . Param ; import java . util . List ; public interface SysDictDataMapper extends BaseMapperX < SysDictDataEntity > { default PageResult < SysDictDataEntity > selectPage ( SysDictDataEntity dictData ) { return selectPage ( new LambdaQueryWrapperX < SysDictDataEntity > ( ) . likeIfPresent ( SysDictDataEntity :: getDictType , dictData . getDictType ( ) ) . likeIfPresent ( SysDictDataEntity :: getDictLabel , dictData . getDictLabel ( ) ) . eqIfPresent ( SysDictDataEntity :: getStatus , \"<STR_LIT>\" ) . betweenIfPresent ( SysDictDataEntity :: getCreateTime , dictData . getParams ( ) ) . orderByAsc ( SysDictDataEntity :: getDictSort ) ) ; } default List < SysDictDataEntity > selectDictDataByType ( String dictType ) { return selectList ( new LambdaQueryWrapperX < SysDictDataEntity > ( ) . eq ( SysDictDataEntity :: getDictType , dictType ) . eq ( SysDictDataEntity :: getStatus , \"<STR_LIT>\" ) . orderByAsc ( SysDictDataEntity :: getDictSort ) ) ;", "output": "} default int updateDictDataType ( @ Param ( \"<STR_LIT>\" ) String oldDictType , @ Param ( \"<STR_LIT>\" ) String newDictType ) { SysDictDataEntity dictData = new SysDictDataEntity ( ) ; dictData . setDictType ( newDictType ) ; return update ( dictData , new UpdateWrapper < SysDictDataEntity > ( ) . eq ( \"<STR_LIT>\" , oldDictType ) ) ; } default Long countDictDataByType ( String dictType ) { return selectCount ( \"<STR_LIT>\" , dictType ) ; } }"}, {"input": "package ginyi . common . annotation ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; @ Retention ( RetentionPolicy . RUNTIME ) @ Target ( { ElementType . FIELD } ) public @ interface UpdateBy {", "output": "String value ( ) default \"<STR_LIT>\" ; }"}, {"input": "package com . yf . system . modules . role . service ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import com . yf . system . modules . role . dto . SysRoleDTO ; import com . yf . system . modules . role . entity . SysRole ; import com . yf . base . api . api . dto . PagingReqDTO ; import java . util . List ; public interface SysRoleService extends IService < SysRole > { IPage < SysRoleDTO > paging ( PagingReqDTO < SysRoleDTO > reqDTO ) ; int findMaxLevel ( List < String > ids ) ;", "output": "void save ( SysRoleDTO reqDTO ) ; void delete ( List < String > ids ) ; }"}, {"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . field . TableFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import lombok . Data ; import lombok . EqualsAndHashCode ; import java . util . HashMap ; import java . util . Map ; @ Data @ EqualsAndHashCode ( callSuper = false ) public class CatTreeFieldCommentConverter extends TableFieldCommentConverter { private String treeText ; public CatTreeFieldCommentConverter ( CgformField onlCgformField ) { super ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; this . treeText = onlCgformField . getDictText ( ) ;", "output": "this . field = onlCgformField . getDbFieldName ( ) ; } @ Override public Map < String , String > getConfig ( ) { if ( ConvertUtils . isEmpty ( this . treeText ) ) { return null ; } else { Map < String , String > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , this . treeText ) ; hashMap . put ( \"<STR_LIT>\" , this . field ) ; return hashMap ; } } }"}, {"input": "package cn . org . alan . exam . util ; import java . security . SecureRandom ; public class ClassTokenGenerator { private static final String CHAR_POOL = \"<STR_LIT>\" ; public static String generateClassToken ( int length ) { SecureRandom random = new SecureRandom ( ) ; StringBuilder tokenBuilder = new StringBuilder ( length ) ; for ( int i = <NUM_LIT> ; i < length ; i ++ ) {", "output": "tokenBuilder . append ( CHAR_POOL . charAt ( random . nextInt ( CHAR_POOL . length ( ) ) ) ) ; } return tokenBuilder . toString ( ) ; } }"}, {"input": "package me . zhengjie . modules . security . service ; import cn . hutool . core . util . RandomUtil ; import me . zhengjie . modules . security . config . bean . LoginProperties ; import me . zhengjie . modules . security . service . dto . JwtUserDto ; import me . zhengjie . utils . RedisUtils ; import me . zhengjie . utils . StringUtils ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import javax . annotation . Resource ; @ Component public class UserCacheManager { @ Resource private RedisUtils redisUtils ; @ Value ( \"<STR_LIT>\" ) private long idleTime ; public JwtUserDto getUserCache ( String userName ) { if ( StringUtils . isNotEmpty ( userName ) ) { Object obj = redisUtils . get ( LoginProperties . cacheKey + userName ) ; if ( obj != null ) {", "output": "return ( JwtUserDto ) obj ; } } return null ; } @ Async public void addUserCache ( String userName , JwtUserDto user ) { if ( StringUtils . isNotEmpty ( userName ) ) { long time = idleTime + RandomUtil . randomInt ( <NUM_LIT> , <NUM_LIT> ) ; redisUtils . set ( LoginProperties . cacheKey + userName , user , time ) ; } } @ Async public void cleanUserCache ( String userName ) { if ( StringUtils . isNotEmpty ( userName ) ) { redisUtils . del ( LoginProperties . cacheKey + userName ) ; } } }"}, {"input": "package org . springblade ; import org . springblade . core . cloud . feign . EnableBladeFeign ; import org . springblade . core . launch . BladeApplication ; import org . springframework . cloud . client . SpringCloudApplication ; import org . springframework . scheduling . annotation . EnableAsync ; @ EnableAsync @ EnableBladeFeign @ SpringCloudApplication public class WebApplication { public static void main ( String [ ] args ) { BladeApplication . run ( \"<STR_LIT>\" , WebApplication . class , args ) ;", "output": "System . out . println ( \"<STR_LIT>\" ) ; } }"}, {"input": "package com . xcs . wx . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . xcs . wx . domain . ContactHeadImg ; public interface ContactHeadImgMapper extends BaseMapper < ContactHeadImg > { ContactHeadImg getContactHeadImg ( String usrName ) ;", "output": "}"}, {"input": "package com . oddfar . campus . framework . api . mail ; import com . oddfar . campus . framework . api . sysconfig . ConfigContext ; public class MailConfigRead { public static String getSmtpHost ( ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class ) ; } public static String getSmtpPort ( ) {", "output": "return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class ) ; } public static String getSendAccount ( ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class ) ; } public static String getPassword ( ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class ) ; } }"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; import java . util . List ; @ Data public class CbsxBuyOrderParam { private String wealthGoodsId ; private BigDecimal buyCou ;", "output": "}"}, {"input": "package me . zhengjie . utils . enums ; import lombok . AllArgsConstructor ; import lombok . Getter ; @ Getter @ AllArgsConstructor public enum CodeEnum { PHONE_RESET_EMAIL_CODE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL_RESET_EMAIL_CODE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , PHONE_RESET_PWD_CODE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) , EMAIL_RESET_PWD_CODE ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ;", "output": "private final String key ; private final String description ; }"}, {"input": "package com . xcs . wx . repository ; import com . xcs . wx . domain . ContactLabel ; import java . util . List ; import java . util . Map ; public interface ContactLabelRepository { Map < String , String > queryContactLabelAsMap ( ) ; List < ContactLabel > queryContactLabelAsList ( ) ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function . extension ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . io . SpiderResponse ; import top . kangert . kspider . util . ExtractUtils ; import org . jsoup . Jsoup ; import org . jsoup . nodes . Element ; import org . jsoup . select . Elements ; import org . springframework . stereotype . Component ; import cn . hutool . core . util . StrUtil ; import java . util . List ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; @ Component public class ResponseFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return SpiderResponse . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element element ( SpiderResponse response ) { return Jsoup . parse ( response . getHtml ( ) , response . getUrl ( ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String xpath ( SpiderResponse response , String xpath ) { return ExtractUtils . getValueByXPath ( element ( response ) , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > xpaths ( SpiderResponse response , String xpath ) { return ExtractUtils . getValuesByXPath ( element ( response ) , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( SpiderResponse response , String pattern ) { return ExtractUtils . getFirstMatcher ( response . getHtml ( ) , pattern , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( SpiderResponse response , String pattern , int groupIndex ) { return ExtractUtils . getFirstMatcher ( response . getHtml ( ) , pattern , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regx ( SpiderResponse response , String pattern , List < Integer > groups ) { return ExtractUtils . getFirstMatcher ( response . getHtml ( ) , pattern , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( SpiderResponse response , String pattern ) { return ExtractUtils . getMatchers ( response . getHtml ( ) , pattern , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( SpiderResponse response , String pattern , int groupIndex ) { return ExtractUtils . getMatchers ( response . getHtml ( ) , pattern , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < List < String > > regxs ( SpiderResponse response , String pattern , List < Integer > groups ) { return ExtractUtils . getMatchers ( response . getHtml ( ) , pattern , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element selector ( SpiderResponse response , String selector ) { return ElementFunctionExtension . selector ( element ( response ) , selector ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements selectors ( SpiderResponse response , String selector ) { return ElementFunctionExtension . selectors ( element ( response ) , selector ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object jsonpath ( SpiderResponse response , String path ) { return ExtractUtils . getValueByJsonPath ( response . getJson ( ) , path ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > links ( SpiderResponse response ) { return ExtractUtils . getAttrBySelector ( element ( response ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) . stream ( ) . filter ( link -> StrUtil . isNotBlank ( link ) ) . collect ( Collectors . toList ( ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > links ( SpiderResponse response , String regx ) {", "output": "Pattern pattern = Pattern . compile ( regx ) ; return links ( response ) . stream ( ) . filter ( link -> pattern . matcher ( link ) . matches ( ) ) . collect ( Collectors . toList ( ) ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > images ( SpiderResponse response ) { return ExtractUtils . getAttrBySelector ( element ( response ) , \"<STR_LIT>\" , \"<STR_LIT>\" ) . stream ( ) . filter ( link -> StrUtil . isNotBlank ( link ) ) . collect ( Collectors . toList ( ) ) ; } }"}, {"input": "package com . oddfar . campus . framework . expander ; import com . oddfar . campus . framework . api . sysconfig . ConfigContext ; import org . springframework . stereotype . Component ; @ Component public class SysFileConfigExpander { public static String getProfile ( ) { String osName = System . getProperty ( \"<STR_LIT>\" ) . toLowerCase ( ) ; if ( osName . contains ( \"<STR_LIT>\" ) ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } if ( osName . contains ( \"<STR_LIT>\" ) ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } if ( osName . contains ( \"<STR_LIT>\" ) ) { return ConfigContext . me ( ) . selectConfigByKey ( \"<STR_LIT>\" , String . class , \"<STR_LIT>\" ) ; } return null ; } public static String getImportPath ( ) { return getProfile ( ) + \"<STR_LIT>\" ; } public static String getAvatarPath ( ) { return getProfile ( ) + \"<STR_LIT>\" ; }", "output": "public static String getDownloadPath ( ) { return getProfile ( ) + \"<STR_LIT>\" ; } public static String getUploadPath ( ) { return getProfile ( ) + \"<STR_LIT>\" ; } }"}, {"input": "package cn . org . alan . exam . util ; import cn . hutool . core . util . BooleanUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONObject ; import cn . hutool . json . JSONUtil ; import cn . org . alan . exam . model . entity . RedisData ; import cn . org . alan . exam . model . vo . GradeVO ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import jakarta . annotation . Resource ; import lombok . extern . slf4j . Slf4j ; import org . apache . catalina . Pipeline ; import org . apache . catalina . connector . Response ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . data . redis . core . script . DefaultRedisScript ; import org . springframework . data . redis . core . script . RedisScript ; import org . springframework . stereotype . Component ; import java . time . LocalDateTime ; import java . util . * ; import java . util . concurrent . * ; import java . util . function . Function ; import java . util . stream . Collectors ; @ Slf4j @ Component public class CacheClient { @ Resource private StringRedisTemplate stringRedisTemplate ; private Random random = new Random ( ) ; public void set ( String key , Object value , Long time , TimeUnit unit ) { stringRedisTemplate . opsForValue ( ) . set ( key , JSONUtil . toJsonStr ( value ) , time , unit ) ; } public void setWithLogicalExpire ( String key , Object value , Long time , TimeUnit unit ) { RedisData redisData = new RedisData ( ) ; redisData . setData ( value ) ; redisData . setExpireTime ( LocalDateTime . now ( ) . plusSeconds ( unit . toSeconds ( time ) ) ) ; stringRedisTemplate . opsForValue ( ) . set ( key , JSONUtil . toJsonStr ( redisData ) ) ; } public < R , ID , T > R queryWithPassThrough ( String keyPrefix , ID id , Class < R > type , Function < ID , R > dbFallback , Class < T > voClass , Long time , TimeUnit unit ) { String key = keyPrefix + id ; String json = stringRedisTemplate . opsForValue ( ) . get ( key ) ; if ( StrUtil . isNotBlank ( json ) ) { if ( type . equals ( IPage . class ) ) { JSONObject jsonObject = JSONUtil . parseObj ( json ) ; List < T > dataList = JSONUtil . toList ( jsonObject . getJSONArray ( \"<STR_LIT>\" ) , voClass ) ; IPage < T > page = new Page < > ( ) ; page . setRecords ( dataList ) ; page . setTotal ( jsonObject . getInt ( \"<STR_LIT>\" ) ) ; page . setSize ( jsonObject . getInt ( \"<STR_LIT>\" ) ) ; page . setCurrent ( jsonObject . getInt ( \"<STR_LIT>\" ) ) ; return ( R ) page ; } else if ( type . equals ( List . class ) ) { List < T > gradeVOList = JSONUtil . toList ( json , voClass ) ; return ( R ) gradeVOList ; } else { return JSONUtil . toBean ( json , type ) ; } } if ( json != null ) { return null ; } R r = dbFallback . apply ( id ) ; if ( r == null ) { stringRedisTemplate . opsForValue ( ) . set ( key , \"<STR_LIT>\" , <NUM_LIT> , TimeUnit . MINUTES ) ; return null ; } String shopTOJson = JSONUtil . toJsonStr ( r ) ; stringRedisTemplate . opsForValue ( ) . set ( key , shopTOJson , time + random . nextInt ( <NUM_LIT> ) , unit ) ; return r ; } private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors . newFixedThreadPool ( <NUM_LIT> ) ; ; public < R , ID > R queryWithLogicalExpire ( String keyPrefix , ID id , Class < R > type , Function < ID , R > dbFallback , Long time , TimeUnit unit ) { String key = keyPrefix + id ; String json = stringRedisTemplate . opsForValue ( ) . get ( key ) ; if ( StrUtil . isBlank ( json ) ) { return null ; } RedisData redisData = JSONUtil . toBean ( json , RedisData . class ) ; JSONObject shopData = ( JSONObject ) redisData . getData ( ) ; R r = JSONUtil . toBean ( shopData , type ) ; LocalDateTime expireTime = redisData . getExpireTime ( ) ; if ( expireTime . isAfter ( LocalDateTime . now ( ) ) ) { return r ; } String lockKey = \"<STR_LIT>\" + id ; boolean isLock = tryLock ( lockKey ) ; if ( isLock ) { json = stringRedisTemplate . opsForValue ( ) . get ( \"<STR_LIT>\" + id ) ; redisData = JSONUtil . toBean ( json , RedisData . class ) ; shopData = ( JSONObject ) redisData . getData ( ) ; r = JSONUtil . toBean ( shopData , type ) ; expireTime = redisData . getExpireTime ( ) ; if ( expireTime . isAfter ( LocalDateTime . now ( ) ) ) { return r ; } CACHE_REBUILD_EXECUTOR . submit ( ( ) -> { try { R r1 = dbFallback . apply ( id ) ; this . setWithLogicalExpire ( key , r1 , time + random . nextInt ( <NUM_LIT> ) , unit ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } finally { unlock ( lockKey ) ; } } ) ; } return r ; } private boolean tryLock ( String key ) { Boolean flag = stringRedisTemplate . opsForValue ( ) . setIfAbsent ( key , \"<STR_LIT>\" , <NUM_LIT> , TimeUnit . SECONDS ) ; return BooleanUtil . isTrue ( flag ) ; } private void unlock ( String key ) { stringRedisTemplate . delete ( key ) ; } public < T > Map < Integer , T > batchGet ( String prefix , List < Integer > keys , Class < T > clazz ) { try { List < String > stringKeys = keys . stream ( ) . map ( key -> prefix + key . toString ( ) ) . collect ( Collectors . toList ( ) ) ; List < String > values = stringRedisTemplate . opsForValue ( ) . multiGet ( stringKeys ) ; Map < Integer , T > resultMap = new HashMap < > ( ) ; for ( int i = <NUM_LIT> ; i < stringKeys . size ( ) ; i ++ ) { String value = values . get ( i ) ; if ( value != null ) { T deserializedObject = deserialize ( value , clazz ) ; resultMap . put ( keys . get ( i ) , deserializedObject ) ; } } return resultMap ; } catch ( Exception e ) { throw new RuntimeException ( \"<STR_LIT>\" , e ) ; } } private static < T > T deserialize ( String value , Class < T > clazz ) { return JSONUtil . toBean ( value , clazz ) ; } public < K , V > void batchPut ( String prefix , Map < K , V > data , long expireTime , TimeUnit timeUnit ) { List < String > allArgs = new ArrayList < > ( ) ; for ( Map . Entry < K , V > entry : data . entrySet ( ) ) { String prefixedKey = prefix + entry . getKey ( ) . toString ( ) ; allArgs . add ( prefixedKey ) ; allArgs . add ( JSONUtil . toJsonStr ( entry . getValue ( ) ) ) ; stringRedisTemplate . opsForValue ( ) . set ( prefixedKey , JSONUtil . toJsonStr ( entry . getValue ( ) ) , expireTime + ( <NUM_LIT> + random . nextInt ( <NUM_LIT> ) ) , timeUnit ) ; }", "output": "} }"}, {"input": "package com . oddfar . campus . framework . handler ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import com . oddfar . campus . common . domain . BaseEntity ; import com . oddfar . campus . common . utils . ServletUtils ; import com . oddfar . campus . common . utils . web . WebFrameworkUtils ; import org . apache . ibatis . reflection . MetaObject ; import java . util . Date ; import java . util . Objects ; public class MyDBFieldHandler implements MetaObjectHandler { @ Override public void insertFill ( MetaObject metaObject ) { if ( Objects . nonNull ( metaObject ) && metaObject . getOriginalObject ( ) instanceof BaseEntity ) { BaseEntity baseEntity = ( BaseEntity ) metaObject . getOriginalObject ( ) ; Date current = new Date ( ) ;", "output": "if ( Objects . isNull ( baseEntity . getCreateTime ( ) ) ) { baseEntity . setCreateTime ( current ) ; } if ( Objects . isNull ( baseEntity . getUpdateTime ( ) ) ) { baseEntity . setUpdateTime ( current ) ; } Long userId = WebFrameworkUtils . getLoginUserId ( ServletUtils . getRequest ( ) ) ; if ( Objects . nonNull ( userId ) && Objects . isNull ( baseEntity . getCreateUser ( ) ) ) { baseEntity . setCreateUser ( userId ) ; } if ( Objects . nonNull ( userId ) && Objects . isNull ( baseEntity . getUpdateUser ( ) ) ) { baseEntity . setUpdateUser ( userId ) ; } if ( Objects . isNull ( baseEntity . getDelFlag ( ) ) ) { baseEntity . setDelFlag ( <NUM_LIT> ) ; } } } @ Override public void updateFill ( MetaObject metaObject ) { Object modifyTime = getFieldValByName ( \"<STR_LIT>\" , metaObject ) ; if ( Objects . isNull ( modifyTime ) ) { setFieldValByName ( \"<STR_LIT>\" , new Date ( ) , metaObject ) ; } Object modifier = getFieldValByName ( \"<STR_LIT>\" , metaObject ) ; Long userId = WebFrameworkUtils . getLoginUserId ( ServletUtils . getRequest ( ) ) ; if ( Objects . nonNull ( userId ) && Objects . isNull ( modifier ) ) { setFieldValByName ( \"<STR_LIT>\" , userId , metaObject ) ; } } }"}, {"input": "package org . example . ddduser . application . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . base . BeanUtil ; import org . example . ddduser . application . dto . result . UserProfile ; import org . example . ddduser . application . dto . query . UserProfilePageQuery ; import org . example . ddduser . application . service . UserMngQueryService ; import org . example . ddduser . infrastructure . repository . database . UserMapper ; import org . example . ddduser . infrastructure . repository . database . condition . UserProfilePageCondition ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Service ; @ Service public class UserMngQueryServiceImpl implements UserMngQueryService { @ Autowired private UserMapper userMapper ; @ Override public Page < UserProfile > profilePage ( UserProfilePageQuery query ) {", "output": "UserProfilePageCondition condition = new UserProfilePageCondition ( ) ; BeanUtil . copyNotBlankProperties ( query , condition ) ; return userMapper . selectProfilePage ( condition ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . number ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class UnitConverter { private static final long K = <NUM_LIT> ; private static final long M = K * <NUM_LIT> ; private static final long G = M * <NUM_LIT> ; private static final long T = G * <NUM_LIT> ; private static final long MILLIS_PER_SECOND = <NUM_LIT> ; private static final long MILLIS_PER_MINUTE = MILLIS_PER_SECOND * <NUM_LIT> ; private static final long MILLIS_PER_HOUR = MILLIS_PER_MINUTE * <NUM_LIT> ; private static final long MILLIS_PER_DAY = MILLIS_PER_HOUR * <NUM_LIT> ; private static final Pattern NUMBER_AND_UNIT = Pattern . compile ( \"<STR_LIT>\" ) ; public static long toDurationMillis ( String duration ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( duration ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" + duration ) ; } long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr == null ) { return number ; } char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number * MILLIS_PER_SECOND ; case '<STR_LIT>' : if ( unitStr . length ( ) >= <NUM_LIT> && unitStr . charAt ( <NUM_LIT> ) == '<STR_LIT>' ) { return number ; }", "output": "return number * MILLIS_PER_MINUTE ; case '<STR_LIT>' : return number * MILLIS_PER_HOUR ; case '<STR_LIT>' : return number * MILLIS_PER_DAY ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } public static long toBytes ( String size ) { Matcher matcher = NUMBER_AND_UNIT . matcher ( size ) ; if ( matcher . matches ( ) ) { long number = Long . parseLong ( matcher . group ( <NUM_LIT> ) ) ; String unitStr = matcher . group ( <NUM_LIT> ) ; if ( unitStr != null ) { char unit = unitStr . toLowerCase ( ) . charAt ( <NUM_LIT> ) ; switch ( unit ) { case '<STR_LIT>' : return number ; case '<STR_LIT>' : return number * K ; case '<STR_LIT>' : return number * M ; case '<STR_LIT>' : return number * G ; case '<STR_LIT>' : return number * T ; default : throw new IllegalArgumentException ( \"<STR_LIT>\" + unit ) ; } } else { return number ; } } else { throw new IllegalArgumentException ( \"<STR_LIT>\" + size ) ; } } public static String toSizeUnit ( Long bytes , int scale ) { if ( bytes == null ) { return \"<STR_LIT>\" ; } if ( bytes < K ) { return String . format ( \"<STR_LIT>\" , bytes ) ; } if ( bytes < M ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / K ) ; } if ( bytes < G ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / M ) ; } if ( bytes < T ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / G ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , bytes * <NUM_LIT> / T ) ; } public static String toTimeUnit ( long millis , int scale ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_SECOND ) ; } if ( millis < MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_MINUTE ) ; } if ( millis < MILLIS_PER_DAY ) { return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_HOUR ) ; } return String . format ( \"<STR_LIT>\" + ( scale == <NUM_LIT> ? <NUM_LIT> : <NUM_LIT> + scale ) + '<STR_LIT>' + scale + \"<STR_LIT>\" , millis * <NUM_LIT> / MILLIS_PER_DAY ) ; } public static String toTimeWithMinorUnit ( long millis ) { if ( millis < MILLIS_PER_SECOND ) { return String . format ( \"<STR_LIT>\" , millis ) ; } if ( millis < MILLIS_PER_MINUTE ) { return String . format ( \"<STR_LIT>\" , millis / MILLIS_PER_SECOND ) ; } if ( millis < MILLIS_PER_HOUR ) { return String . format ( \"<STR_LIT>\" , millis / MILLIS_PER_MINUTE , ( millis / MILLIS_PER_SECOND ) % <NUM_LIT> ) ; } if ( millis < MILLIS_PER_DAY ) { return String . format ( \"<STR_LIT>\" , millis / MILLIS_PER_HOUR , ( millis / MILLIS_PER_MINUTE ) % <NUM_LIT> ) ; } return String . format ( \"<STR_LIT>\" , millis / MILLIS_PER_DAY , ( millis / MILLIS_PER_HOUR ) % <NUM_LIT> ) ; } }"}, {"input": "package com . xcs . wx . domain . dto ; import lombok . Data ; @ Data public class DecryptDTO { private int pid ; private String basePath ; private String wxId ; private String nickname ; private String version ; private String account ; private String mobile ;", "output": "}"}, {"input": "package com . youlai . system . model . query ; import com . youlai . system . common . base . BasePageQuery ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Getter ; import lombok . Setter ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public class TablePageQuery extends BasePageQuery { @ Schema ( description = \"<STR_LIT>\" ) private String keywords ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . core ; import java . util . ArrayList ; import java . util . List ; public class WorkbookConfig { private List < SheetConfig > sheets = new ArrayList < SheetConfig > ( ) ; public void add ( SheetConfig sheet ) { if ( sheet != null ) { sheets . add ( sheet ) ; } }", "output": "public List < SheetConfig > getSheets ( ) { return sheets ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . config . autoconfigure ; import io . github . chensheng . dddboot . nacos . config . NacosConfigConstants ; import io . github . chensheng . dddboot . nacos . config . properties . NacosConfigProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . config . EnableNacosConfig ; import org . springframework . boot . autoconfigure . condition . ConditionalOnClass ; import org . springframework . boot . autoconfigure . condition . ConditionalOnMissingBean ; import org . springframework . boot . autoconfigure . condition . ConditionalOnProperty ; import org . springframework . boot . context . properties . EnableConfigurationProperties ; import org . springframework . context . annotation . Configuration ; import org . springframework . context . annotation . Import ; import static io . github . chensheng . dddboot . nacos . spring . util . NacosBeanUtils . CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ; @ ConditionalOnProperty ( name = NacosConfigConstants . ENABLED , matchIfMissing = true ) @ ConditionalOnMissingBean ( name = CONFIG_GLOBAL_NACOS_PROPERTIES_BEAN_NAME ) @ EnableConfigurationProperties ( value = NacosConfigProperties . class ) @ ConditionalOnClass ( name = \"<STR_LIT>\" ) @ Import ( value = { NacosConfigBootBeanDefinitionRegistrar . class }", "output": ") @ EnableNacosConfig public class NacosConfigAutoConfiguration { }"}, {"input": "package com . oddfar . campus . framework . config ; import com . oddfar . campus . common . constant . Constants ; import com . oddfar . campus . framework . api . sysconfig . ConfigExpander ; import com . oddfar . campus . framework . interceptor . RepeatSubmitInterceptor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . context . request . RequestContextListener ; import org . springframework . web . cors . CorsConfiguration ; import org . springframework . web . cors . UrlBasedCorsConfigurationSource ; import org . springframework . web . filter . CorsFilter ; import org . springframework . web . servlet . config . annotation . InterceptorRegistry ; import org . springframework . web . servlet . config . annotation . ResourceHandlerRegistry ; import org . springframework . web . servlet . config . annotation . WebMvcConfigurer ; @ Configuration public class MyWebMvcConfig implements WebMvcConfigurer { @ Autowired private RepeatSubmitInterceptor repeatSubmitInterceptor ; @ Override public void addResourceHandlers ( ResourceHandlerRegistry registry ) { registry . addResourceHandler ( Constants . RESOURCE_PREFIX + \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" + ConfigExpander . getFileProfile ( ) + \"<STR_LIT>\" ) ; registry . addResourceHandler ( \"<STR_LIT>\" ) . addResourceLocations ( \"<STR_LIT>\" ) ; }", "output": "@ Override public void addInterceptors ( InterceptorRegistry registry ) { registry . addInterceptor ( repeatSubmitInterceptor ) . addPathPatterns ( \"<STR_LIT>\" ) ; } @ Bean public CorsFilter corsFilter ( ) { CorsConfiguration config = new CorsConfiguration ( ) ; config . setAllowCredentials ( true ) ; config . addAllowedOriginPattern ( \"<STR_LIT>\" ) ; config . addAllowedHeader ( \"<STR_LIT>\" ) ; config . addAllowedMethod ( \"<STR_LIT>\" ) ; config . setMaxAge ( <NUM_LIT> ) ; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource ( ) ; source . registerCorsConfiguration ( \"<STR_LIT>\" , config ) ; return new CorsFilter ( source ) ; } @ Bean public RequestContextListener requestContextListenerBean ( ) { return new RequestContextListener ( ) ; } }"}, {"input": "package org . springblade . cgform . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import org . springblade . cgform . entity . CgformHead ; import org . apache . ibatis . annotations . Param ; import org . apache . ibatis . annotations . Select ; import java . util . List ; import java . util . Map ; public interface CgformHeadMapper extends BaseMapper < CgformHead > { List < Map < String , Object > > queryList ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; void executeDDL ( @ Param ( \"<STR_LIT>\" ) String var1 ) ;", "output": "Integer getMaxCopyVersion ( Long physicId ) ; Map < String , Object > queryOneByTableNameAndId ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 ) ; void deleteOne ( @ Param ( \"<STR_LIT>\" ) String var1 ) ; @ Select ( { \"<STR_LIT>\" } ) Integer queryChildNode ( @ Param ( \"<STR_LIT>\" ) String var1 , @ Param ( \"<STR_LIT>\" ) String var2 , @ Param ( \"<STR_LIT>\" ) String var3 ) ; @ Select ( { \"<STR_LIT>\" } ) List < String > queryCopyPhysicId ( ) ; @ Select ( { \"<STR_LIT>\" } ) List < String > getAllTableName ( ) ; }"}, {"input": "package com . xcs . wx . service . impl ; import cn . hutool . core . lang . Opt ; import cn . hutool . core . util . StrUtil ; import com . xcs . wx . domain . vo . SessionVO ; import com . xcs . wx . repository . SessionRepository ; import com . xcs . wx . service . SessionService ; import com . xcs . wx . util . DateFormatUtil ; import lombok . RequiredArgsConstructor ; import org . springframework . stereotype . Service ; import java . util . Collections ; import java . util . List ; @ Service @ RequiredArgsConstructor public class SessionServiceImpl implements SessionService { private final SessionRepository sessionRepository ; @ Override public List < SessionVO > querySession ( ) { return Opt . ofNullable ( sessionRepository . querySession ( ) ) . map ( sessions -> { for ( SessionVO session : sessions ) { if ( ! StrUtil . isBlank ( session . getHeadImgUrl ( ) ) ) { continue ; } session . setHeadImgUrl ( \"<STR_LIT>\" + session . getUserName ( ) ) ; } return sessions ; } ) . ifPresent ( sessionVos -> sessionVos . forEach ( sessionVo -> sessionVo . setShortTime ( DateFormatUtil . formatTimestamp ( sessionVo . getTime ( ) ) ) ) ) . orElse ( Collections . emptyList ( ) ) ; }", "output": "}"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . SysLog ; import me . zhengjie . domain . vo . SysLogQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface SysLogMapper extends BaseMapper < SysLog > { List < SysLog > queryAll ( @ Param ( \"<STR_LIT>\" ) SysLogQueryCriteria criteria ) ;", "output": "IPage < SysLog > queryAll ( @ Param ( \"<STR_LIT>\" ) SysLogQueryCriteria criteria , Page < SysLog > page ) ; IPage < SysLog > queryAllByUser ( @ Param ( \"<STR_LIT>\" ) SysLogQueryCriteria criteria , Page < SysLog > page ) ; String getExceptionDetails ( @ Param ( \"<STR_LIT>\" ) Long id ) ; void deleteByLevel ( @ Param ( \"<STR_LIT>\" ) String logType ) ; }"}, {"input": "package org . springblade . common ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import lombok . RequiredArgsConstructor ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . secure . utils . AuthUtil ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springframework . context . event . EventListener ; import org . springframework . core . annotation . Order ; import org . springframework . scheduling . annotation . Async ; import org . springframework . stereotype . Component ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; @ RequiredArgsConstructor @ Component public class ActionLogListener { private static final String filter = \"<STR_LIT>\" ; private static final String include = \"<STR_LIT>\" ; private final IMjkjBaseSqlService sqlService ; @ Order @ EventListener ( { ActionLogEvent . class } ) public void actionLogListener ( ActionLogEvent event ) { Map < String , Object > map = ( Map ) event . getSource ( ) ; String sqlString = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; int index = sqlString . indexOf ( \"<STR_LIT>\" ) ; String tableName = sqlString . substring ( index , sqlString . indexOf ( \"<STR_LIT>\" , index ) ) ; if ( include . contains ( tableName ) ) { String id = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; Map < String , Object > head = sqlService . getDataOneByField ( \"<STR_LIT>\" , \"<STR_LIT>\" , tableName ) ; String action = sqlString . contains ( \"<STR_LIT>\" ) ? getActionInsert ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map ) : getActionUpdate ( MjkjUtils . getMap2Str ( head , \"<STR_LIT>\" ) , map , sqlService . getTableById ( tableName , id ) ) ; if ( action . length ( ) == <NUM_LIT> ) return ; HashMap < String , Object > hashMap = new HashMap < > ( ) ; hashMap . put ( \"<STR_LIT>\" , tableName ) ; hashMap . put ( \"<STR_LIT>\" , id ) ; hashMap . put ( \"<STR_LIT>\" , action . substring ( <NUM_LIT> , action . length ( ) - <NUM_LIT> ) ) ; hashMap . put ( \"<STR_LIT>\" , AuthUtil . getUserId ( ) ) ; sqlService . baseInsertData ( \"<STR_LIT>\" , hashMap ) ; } } private String getActionInsert ( String headId , Map < String , Object > map ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) {", "output": "if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( map , s ) ; String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { stringBuilder . append ( title ) . append ( \"<STR_LIT>\" ) ; } } } else { stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) ; } } return stringBuilder . toString ( ) ; } private String getActionUpdate ( String headId , Map < String , Object > map , Map < String , Object > data ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( \"<STR_LIT>\" ) ; for ( String s : map . keySet ( ) ) { if ( filter . contains ( s ) ) { continue ; } Map < String , Object > field = sqlService . getDataOneByFieldParams ( \"<STR_LIT>\" , Wrappers . query ( ) . eq ( \"<STR_LIT>\" , <NUM_LIT> ) . eq ( \"<STR_LIT>\" , headId ) . eq ( \"<STR_LIT>\" , s ) ) ; String var1 = MjkjUtils . getMap2Str ( data , s ) ; String var2 = MjkjUtils . getMap2Str ( map , s ) ; if ( var1 . equals ( var2 ) ) { continue ; } String dictField = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dictTable = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String fieldExtendJson = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; String dbFieldTxt = MjkjUtils . getMap2Str ( field , \"<STR_LIT>\" ) ; stringBuilder . append ( dbFieldTxt ) . append ( \"<STR_LIT>\" ) ; if ( Func . isNotEmpty ( dictField ) ) { if ( Func . isNotEmpty ( dictTable ) ) { String dictText = MjkjUtils . getMap2Str ( map , \"<STR_LIT>\" ) ; String var1Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var1 ) , dictText ) ; String var2Text = MjkjUtils . getMap2Str ( sqlService . getDataOneByField ( dictTable , dictField , var2 ) , dictText ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) . append ( var2Text ) . append ( \"<STR_LIT>\" ) ; } else { String var1Text = sqlService . getSysDictItemValue ( dictField , var1 , false ) ; String var2Text = sqlService . getSysDictItemValue ( dictField , var2 , false ) ; stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) . append ( var2Text ) . append ( \"<STR_LIT>\" ) ; } } else if ( Func . isNotEmpty ( fieldExtendJson ) && fieldExtendJson . contains ( \"<STR_LIT>\" ) ) { Map < String , Object > kv = JsonUtil . toMap ( fieldExtendJson ) ; List < Map < String , Object > > list = MjkjUtils . getMapAll2List ( kv , \"<STR_LIT>\" ) ; String var1Text = \"<STR_LIT>\" ; String var2Text = \"<STR_LIT>\" ; for ( Map < String , Object > m : list ) { String title = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; String value = MjkjUtils . getMap2Str ( m , \"<STR_LIT>\" ) ; if ( value . equals ( var1 ) ) { var1Text = title ; } if ( value . equals ( var2 ) ) { var2Text = title ; } } stringBuilder . append ( var1Text ) . append ( \"<STR_LIT>\" ) . append ( var2Text ) . append ( \"<STR_LIT>\" ) ; } else { stringBuilder . append ( var1 ) . append ( \"<STR_LIT>\" ) . append ( var2 ) . append ( \"<STR_LIT>\" ) ; } } return stringBuilder . toString ( ) ; } }"}, {"input": "package org . springblade . config . util . converter . field ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . converter . FieldCommentConverter ; import org . springblade . cgform . model . DictModel ; import lombok . Data ; import lombok . NoArgsConstructor ; import java . util . List ; import java . util . Map ; @ Data @ NoArgsConstructor public class FieldFieldCommentConverter implements FieldCommentConverter { protected String filed ; protected List < DictModel > dictList ; @ Override public String converterToVal ( String txt ) { if ( ConvertUtils . isNotEmpty ( txt ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getText ( ) . equals ( txt ) ) { return dictModel . getValue ( ) ; } } } return null ; } @ Override public String converterToTxt ( String val ) { if ( ConvertUtils . isNotEmpty ( val ) ) { for ( DictModel dictModel : this . dictList ) { if ( dictModel . getValue ( ) . equals ( val ) ) { return dictModel . getText ( ) ; } } } return null ; }", "output": "@ Override public Map < String , String > getConfig ( ) { return null ; } }"}, {"input": "package com . oddfar . campus . framework . service ; import com . oddfar . campus . common . domain . TreeSelect ; import com . oddfar . campus . common . domain . entity . SysMenuEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import com . oddfar . campus . common . domain . vo . RouterVo ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Set ; public interface SysMenuService { List < SysMenuEntity > selectMenuList ( Long userId ) ; List < SysMenuEntity > selectMenuList ( SysMenuEntity menu , Long userId ) ; List < SysMenuEntity > selectMenuTreeByUserId ( Long userId ) ;", "output": "List < Long > selectMenuListByRoleId ( Long roleId ) ; SysMenuEntity selectMenuById ( Long menuId ) ; List < RouterVo > buildMenus ( List < SysMenuEntity > menus ) ; List < SysMenuEntity > buildMenuTree ( List < SysMenuEntity > menus ) ; List < TreeSelect > buildMenuTreeSelect ( List < SysMenuEntity > menus ) ; Set < String > selectMenuPermsByRoleId ( Long roleId ) ; Map < Long , List < SysRoleAuth > > selectMenuPermsAll ( ) ; Collection < String > selectMenuPermsByUserId ( Long userId ) ; int insertMenu ( SysMenuEntity menu ) ; int updateMenu ( SysMenuEntity menu ) ; int deleteMenuById ( Long menuId ) ; boolean checkMenuExistRole ( Long menuId ) ; boolean hasChildByMenuId ( Long menuId ) ; boolean checkMenuNameUnique ( SysMenuEntity menu ) ; }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . form . GradeForm ; import cn . org . alan . exam . model . vo . GradeVO ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import java . util . List ; public interface IGradeService extends IService < Grade > { Result < String > addGrade ( GradeForm gradeForm ) ; Result < String > updateGrade ( Integer id , GradeForm gradeForm ) ; Result < String > deleteGrade ( Integer id ) ; Result < IPage < GradeVO > > getPaging ( Integer pageNum , Integer pageSize , String gradeName ) ;", "output": "Result < String > removeUserGrade ( String ids ) ; Result < List < GradeVO > > getAllGrade ( ) ; }"}, {"input": "package com . yf . base . utils ; import java . text . MessageFormat ; public interface CacheKey { String SITE = \"<STR_LIT>\" ; String MENU = \"<STR_LIT>\" ; String DICT = \"<STR_LIT>\" ; String TOKEN = \"<STR_LIT>\" ; String UPLOAD = \"<STR_LIT>\" ; String SWITCH = \"<STR_LIT>\" ; static String unlockKey ( String userId , String courseId ) { return MessageFormat . format ( \"<STR_LIT>\" , userId , courseId ) ;", "output": "} }"}, {"input": "package ginyi . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import ginyi . system . domain . SysNotice ; import ginyi . system . domain . model . dto . NoticeDto ; import ginyi . system . domain . model . vo . NoticeVo ; import org . apache . ibatis . annotations . Param ; public interface SysNoticeMapper extends BaseMapper < SysNotice > { public IPage < SysNotice > list ( @ Param ( \"<STR_LIT>\" ) NoticeDto noticeDto , Page page ) ; public void addNotice ( @ Param ( \"<STR_LIT>\" ) NoticeDto noticeDto ) ; public IPage < SysNotice > getUserNoticeList ( Long userId , Page page ) ; public void haveRead ( @ Param ( \"<STR_LIT>\" ) SysNotice notice ) ; public SysNotice selectOne ( Long noticeId ) ; public void updateNotice ( @ Param ( \"<STR_LIT>\" ) NoticeDto noticeDto ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . event ; import org . springframework . context . * ; import org . springframework . context . event . ContextRefreshedEvent ; import org . springframework . context . support . AbstractApplicationContext ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; public class DeferredApplicationEventPublisher implements ApplicationEventPublisher , ApplicationListener < ContextRefreshedEvent > { private final ConfigurableApplicationContext context ; private final ConcurrentLinkedQueue < ApplicationEvent > deferredEvents = new ConcurrentLinkedQueue < ApplicationEvent > ( ) ; public DeferredApplicationEventPublisher ( ConfigurableApplicationContext context ) { this . context = context ; this . context . addApplicationListener ( this ) ; } @ Override public void publishEvent ( ApplicationEvent event ) { try { if ( context . isRunning ( ) ) { context . publishEvent ( event ) ; } else { deferredEvents . add ( event ) ; } } catch ( Exception ignore ) { deferredEvents . add ( event ) ; } } public void publishEvent ( Object event ) { } @ Override public void onApplicationEvent ( ContextRefreshedEvent event ) { ApplicationContext currentContext = event . getApplicationContext ( ) ; if ( ! currentContext . equals ( context ) ) { return ; } replayDeferredEvents ( ) ; }", "output": "private void replayDeferredEvents ( ) { Iterator < ApplicationEvent > iterator = deferredEvents . iterator ( ) ; while ( iterator . hasNext ( ) ) { ApplicationEvent event = iterator . next ( ) ; publishEvent ( event ) ; iterator . remove ( ) ; } } }"}, {"input": "package org . springblade . config . market ; import lombok . Data ; @ Data public class KlineTimeModel { private Long min1 ; private Long min5 ; private Long min15 ; private Long min30 ; private Long min60 ; private Long hour4 ; private Long day1 ; private Long week1 ; private Long mon1 ;", "output": "}"}, {"input": "package me . zhengjie . modules . mnt . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import cn . hutool . core . bean . BeanUtil ; import cn . hutool . core . bean . copier . CopyOptions ; import lombok . Getter ; import lombok . Setter ; import java . io . Serializable ; import java . sql . Timestamp ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class DeployHistory implements Serializable { @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String appName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ip ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Timestamp deployDate ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deployUser ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long deployId ; public void copy ( DeployHistory source ) { BeanUtil . copyProperties ( source , this , CopyOptions . create ( ) . setIgnoreNullValue ( true ) ) ; }", "output": "}"}, {"input": "package ginyi . framework . security . utils ; import ginyi . common . constant . CommonMessageConstants ; import ginyi . common . exception . CommonException ; import ginyi . common . result . StateCode ; import ginyi . system . domain . LoginUser ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . security . crypto . bcrypt . BCryptPasswordEncoder ; public class SecurityUtils { public static Authentication getAuthentication ( ) { return SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; } public static LoginUser getLoginUser ( ) { try { return ( LoginUser ) getAuthentication ( ) . getPrincipal ( ) ; } catch ( Exception e ) { throw new CommonException ( StateCode . ERROR_SYSTEM , CommonMessageConstants . USER_NOT_FOUND ) ; } } public static boolean matchesPassword ( String rawPassword , String encodedPassword ) { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder ( ) ; return passwordEncoder . matches ( rawPassword , encodedPassword ) ; } public static String encryptPassword ( String password ) { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder ( ) ; return passwordEncoder . encode ( password ) ; }", "output": "}"}, {"input": "package org . springblade . config . constant ; public interface WalletConstant { String WALLET_TYPE_SERVICE = \"<STR_LIT>\" ; String WALLET_TYPE_WALLET = \"<STR_LIT>\" ; String WALLET_TYPE_SPOT = \"<STR_LIT>\" ;", "output": "String WALLET_TYPE_MARGIN_FIXED = \"<STR_LIT>\" ; String WALLET_TYPE_MAGIN_ALL = \"<STR_LIT>\" ; String WALLET_TYPE_CONTRACT = \"<STR_LIT>\" ; String WALLET_TYPE_MARKET = \"<STR_LIT>\" ; String WALLET_TYPE_WEALTH = \"<STR_LIT>\" ; }"}, {"input": "package org . springblade . config . autopoi . poi . exception . excel . enums ; public enum ExcelExportEnum { PARAMETER_ERROR ( \"<STR_LIT>\" ) , EXPORT_ERROR ( \"<STR_LIT>\" ) ;", "output": "private String msg ; ExcelExportEnum ( String msg ) { this . msg = msg ; } public String getMsg ( ) { return msg ; } public void setMsg ( String msg ) { this . msg = msg ; } }"}, {"input": "package top . kangert . kspider . config ; import top . kangert . kspider . KspiderRuntime ; import top . kangert . kspider . websocket . WebSocketEditorHandler ; import top . kangert . kspider . websocket . WebSocketEditorInterceptor ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . context . annotation . Bean ; import org . springframework . context . annotation . Configuration ; import org . springframework . web . socket . config . annotation . EnableWebSocket ; import org . springframework . web . socket . config . annotation . WebSocketConfigurer ; import org . springframework . web . socket . config . annotation . WebSocketHandlerRegistry ; import org . springframework . web . socket . server . standard . ServletServerContainerFactoryBean ; @ Configuration @ EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { @ Autowired private KspiderRuntime spider ; @ Bean public ServletServerContainerFactoryBean createWebSocketContainer ( ) { ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean ( ) ; container . setMaxTextMessageBufferSize ( <NUM_LIT> * <NUM_LIT> ) ; return container ;", "output": "} @ Override public void registerWebSocketHandlers ( WebSocketHandlerRegistry registry ) { registry . addHandler ( webSocketEditorHandler ( ) , \"<STR_LIT>\" ) . addInterceptors ( webSocketEditorInterceptor ( ) ) . setAllowedOriginPatterns ( \"<STR_LIT>\" ) ; } @ Bean public WebSocketEditorInterceptor webSocketEditorInterceptor ( ) { return new WebSocketEditorInterceptor ( ) ; } @ Bean public WebSocketEditorHandler webSocketEditorHandler ( ) { return new WebSocketEditorHandler ( spider ) ; } }"}, {"input": "package org . springblade . common . constant ; import java . util . Arrays ; import java . util . List ; public interface TenantConstant { String PASSWORD_KEY = \"<STR_LIT>\" ; String ACCOUNT_NUMBER_KEY = \"<STR_LIT>\" ; String ACCOUNT_MENU_CODE_KEY = \"<STR_LIT>\" ; String DEFAULT_PASSWORD = \"<STR_LIT>\" ;", "output": "String DES_KEY = \"<STR_LIT>\" ; Integer DEFAULT_ACCOUNT_NUMBER = - <NUM_LIT> ; List < String > MENU_CODES = Arrays . asList ( \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" ) ; }"}, {"input": "package org . springblade . config . util ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import org . springblade . cgform . service . IMjkjBaseSqlService ; import org . springblade . common . utils . MjkjUtils ; import org . springblade . core . tool . jackson . JsonUtil ; import org . springblade . core . tool . utils . Func ; import org . springblade . core . tool . utils . SpringUtil ; import org . springblade . core . tool . utils . WebUtil ; import javax . mail . Message ; import javax . mail . Session ; import javax . mail . Transport ; import javax . mail . internet . InternetAddress ; import javax . mail . internet . MimeMessage ; import java . util . * ; public class EmailUtil { private static IMjkjBaseSqlService sqlService ; public static IMjkjBaseSqlService getSqlService ( ) { if ( sqlService == null ) sqlService = SpringUtil . getBean ( IMjkjBaseSqlService . class ) ; return sqlService ; } public static Boolean sendYmx ( String receiveMailAccount , String emailContent , String theme ) { Transport transport = null ; try { String FROM = \"<STR_LIT>\" ; String FROMNAME = \"<STR_LIT>\" ; String SMTP_USERNAME = \"<STR_LIT>\" ; String SMTP_PASSWORD = \"<STR_LIT>\" ; String HOST = \"<STR_LIT>\" ; int PORT = <NUM_LIT> ; Properties props = System . getProperties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , PORT ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getDefaultInstance ( props ) ; MimeMessage msg = new MimeMessage ( session ) ; msg . setFrom ( new InternetAddress ( FROM , FROMNAME ) ) ; msg . setRecipient ( Message . RecipientType . TO , new InternetAddress ( receiveMailAccount ) ) ; msg . setSubject ( theme ) ; msg . setContent ( emailContent , \"<STR_LIT>\" ) ; transport = session . getTransport ( ) ; transport . connect ( HOST , SMTP_USERNAME , SMTP_PASSWORD ) ; transport . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return true ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return false ; } finally { if ( Func . isNotEmpty ( transport ) ) { try { transport . close ( ) ; } catch ( Exception e ) { } } } } public static Boolean send ( String myEmailAccount , String myEmailPassword , String host , String receiveMailAccount , String emailContent , String theme , String fjrmc ) { try { Properties props = new Properties ( ) ; props . put ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; props . setProperty ( \"<STR_LIT>\" , host ) ; props . setProperty ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ; Session session = Session . getInstance ( props ) ;", "output": "session . setDebug ( true ) ; MimeMessage message = createMimeMessage ( session , myEmailAccount , receiveMailAccount , emailContent , theme , fjrmc ) ; Transport transport = session . getTransport ( ) ; transport . connect ( myEmailAccount , myEmailPassword ) ; transport . sendMessage ( message , message . getAllRecipients ( ) ) ; transport . close ( ) ; return true ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } private static MimeMessage createMimeMessage ( Session session , String myEmailAccount , String receiveMailAccount , String message , String yjzt , String fjrmc ) { try { MimeMessage mimeMessage = new MimeMessage ( session ) ; mimeMessage . setFrom ( new InternetAddress ( myEmailAccount , fjrmc , \"<STR_LIT>\" ) ) ; mimeMessage . setRecipient ( MimeMessage . RecipientType . TO , new InternetAddress ( receiveMailAccount , receiveMailAccount , \"<STR_LIT>\" ) ) ; mimeMessage . setSubject ( yjzt , \"<STR_LIT>\" ) ; mimeMessage . setContent ( message , \"<STR_LIT>\" ) ; mimeMessage . setSentDate ( new Date ( ) ) ; mimeMessage . saveChanges ( ) ; return mimeMessage ; } catch ( Exception e ) { } return null ; } }"}, {"input": "package org . springblade . web . model ; import com . alibaba . fastjson . JSON ; import lombok . Data ; import org . springblade . core . tool . utils . Func ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; @ Data public class ContractTrade implements Serializable { private String topic ; private String symbolName ; private BigDecimal price ; private BigDecimal amount ; private BigDecimal buyTurnover ; private BigDecimal sellTurnover ; private String direction ; private String buyOrderId ; private String sellOrderId ; private Long time ; private Date createTime ; @ Override public String toString ( ) { return JSON . toJSONString ( this ) ; } public void setCreateTime ( Date createTime ) { if ( Func . isNotEmpty ( createTime ) ) { time = createTime . getTime ( ) ; }", "output": "this . createTime = createTime ; } }"}, {"input": "package com . oddfar . campus . common . utils ; import com . alibaba . fastjson2 . JSONArray ; import com . oddfar . campus . common . constant . CacheConstants ; import com . oddfar . campus . common . core . RedisCache ; import com . oddfar . campus . common . domain . entity . SysDictDataEntity ; import java . util . Collection ; import java . util . List ; public class DictUtils { public static final String SEPARATOR = \"<STR_LIT>\" ; public static void setDictCache ( String key , List < SysDictDataEntity > dictDatas ) { SpringUtils . getBean ( RedisCache . class ) . setCacheObject ( getCacheKey ( key ) , dictDatas ) ; } public static List < SysDictDataEntity > getDictCache ( String key ) { JSONArray arrayCache = SpringUtils . getBean ( RedisCache . class ) . getCacheObject ( getCacheKey ( key ) ) ; if ( StringUtils . isNotNull ( arrayCache ) ) { return arrayCache . toList ( SysDictDataEntity . class ) ; } return null ; } public static String getDictLabel ( String dictType , String dictValue ) { return getDictLabel ( dictType , dictValue , SEPARATOR ) ; } public static String getDictValue ( String dictType , String dictLabel ) { return getDictValue ( dictType , dictLabel , SEPARATOR ) ; } public static String getDictLabel ( String dictType , String dictValue , String separator ) { StringBuilder propertyString = new StringBuilder ( ) ; List < SysDictDataEntity > datas = getDictCache ( dictType ) ; if ( StringUtils . isNotNull ( datas ) ) { if ( StringUtils . containsAny ( separator , dictValue ) ) { for ( SysDictDataEntity dict : datas ) { for ( String value : dictValue . split ( separator ) ) { if ( value . equals ( dict . getDictValue ( ) ) ) { propertyString . append ( dict . getDictLabel ( ) ) . append ( separator ) ; break ; } } } } else { for ( SysDictDataEntity dict : datas ) { if ( dictValue . equals ( dict . getDictValue ( ) ) ) { return dict . getDictLabel ( ) ; }", "output": "} } } return StringUtils . stripEnd ( propertyString . toString ( ) , separator ) ; } public static String getDictValue ( String dictType , String dictLabel , String separator ) { StringBuilder propertyString = new StringBuilder ( ) ; List < SysDictDataEntity > datas = getDictCache ( dictType ) ; if ( StringUtils . containsAny ( separator , dictLabel ) && StringUtils . isNotEmpty ( datas ) ) { for ( SysDictDataEntity dict : datas ) { for ( String label : dictLabel . split ( separator ) ) { if ( label . equals ( dict . getDictLabel ( ) ) ) { propertyString . append ( dict . getDictValue ( ) ) . append ( separator ) ; break ; } } } } else { for ( SysDictDataEntity dict : datas ) { if ( dictLabel . equals ( dict . getDictLabel ( ) ) ) { return dict . getDictValue ( ) ; } } } return StringUtils . stripEnd ( propertyString . toString ( ) , separator ) ; } public static void removeDictCache ( String key ) { SpringUtils . getBean ( RedisCache . class ) . deleteObject ( getCacheKey ( key ) ) ; } public static void clearDictCache ( ) { Collection < String > keys = SpringUtils . getBean ( RedisCache . class ) . keys ( CacheConstants . SYS_DICT_KEY + \"<STR_LIT>\" ) ; SpringUtils . getBean ( RedisCache . class ) . deleteObject ( keys ) ; } public static String getCacheKey ( String configKey ) { return CacheConstants . SYS_DICT_KEY + configKey ; } }"}, {"input": "package org . springblade . config . util . ip ; import cn . hutool . core . net . NetUtil ; import cn . hutool . core . util . StrUtil ; import cn . hutool . http . HtmlUtil ; import cn . hutool . http . HttpUtil ; import lombok . extern . slf4j . Slf4j ; import org . springblade . core . tool . jackson . JsonUtil ; import java . util . Map ; @ Slf4j public class AddressUtils { public static final String IP_URL = \"<STR_LIT>\" ; public static final String UNKNOWN = \"<STR_LIT>\" ; public static String getRealAddressByIP ( String ip ) { String address = UNKNOWN ; ip = \"<STR_LIT>\" . equals ( ip ) ? \"<STR_LIT>\" : HtmlUtil . cleanHtmlTag ( ip ) ; if ( NetUtil . isInnerIP ( ip ) ) { return \"<STR_LIT>\" ; } try { String rspStr = HttpUtil . createGet ( IP_URL ) . body ( \"<STR_LIT>\" + ip + \"<STR_LIT>\" , \"<STR_LIT>\" ) . execute ( ) . body ( ) ; if ( StrUtil . isEmpty ( rspStr ) ) { log . error ( \"<STR_LIT>\" , ip ) ; return UNKNOWN ; } Map < String , String > obj = JsonUtil . parse ( rspStr , Map . class ) ; String region = obj . get ( \"<STR_LIT>\" ) ; String city = obj . get ( \"<STR_LIT>\" ) ; return String . format ( \"<STR_LIT>\" , region , city ) ;", "output": "} catch ( Exception e ) { log . error ( \"<STR_LIT>\" , ip ) ; } return address ; } }"}, {"input": "package com . xcs . wx . repository . impl ; import cn . hutool . core . util . StrUtil ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . Contact ; import com . xcs . wx . domain . dto . ContactDTO ; import com . xcs . wx . domain . vo . AllContactVO ; import com . xcs . wx . domain . vo . ContactVO ; import com . xcs . wx . domain . vo . ExportContactVO ; import com . xcs . wx . mapper . ContactMapper ; import com . xcs . wx . repository . ContactRepository ; import org . springframework . stereotype . Repository ; import java . util . * ; import java . util . stream . Collectors ; @ Repository @ DS ( value = DataSourceType . MICRO_MSG_DB ) public class ContactRepositoryImpl extends ServiceImpl < ContactMapper , Contact > implements ContactRepository { @ Override public Page < ContactVO > queryContact ( ContactDTO contactDTO ) { return getBaseMapper ( ) . queryContact ( new Page < > ( contactDTO . getCurrent ( ) , contactDTO . getPageSize ( ) ) , contactDTO ) ; } @ Override public List < AllContactVO > queryAllContact ( ) { return getBaseMapper ( ) . queryAllContact ( ) . stream ( ) . filter ( contactVO -> ! contactVO . getNickName ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ; } @ Override public String getContactNickname ( String userName ) { LambdaQueryWrapper < Contact > wrapper = Wrappers . < Contact > lambdaQuery ( ) . select ( Contact :: getUserName , Contact :: getNickName , Contact :: getRemark ) . eq ( Contact :: getUserName , userName ) ; Contact contact = super . getOne ( wrapper ) ; if ( contact == null ) { return \"<STR_LIT>\" ; } return StrUtil . isNotBlank ( contact . getRemark ( ) ) ? contact . getRemark ( ) : contact . getNickName ( ) ; } @ Override public String getNickName ( String userName ) { LambdaQueryWrapper < Contact > wrapper = Wrappers . < Contact > lambdaQuery ( ) . select ( Contact :: getNickName ) . eq ( Contact :: getUserName , userName ) ; return Optional . ofNullable ( super . getOne ( wrapper ) ) . map ( Contact :: getNickName ) . orElse ( null ) ;", "output": "} @ Override public Set < String > getContactWithMp ( ) { return getBaseMapper ( ) . getContactWithMp ( ) ; } @ Override public Map < String , String > getContactNickname ( List < String > userNames ) { LambdaQueryWrapper < Contact > wrapper = Wrappers . < Contact > lambdaQuery ( ) . select ( Contact :: getUserName , Contact :: getNickName , Contact :: getRemark ) . in ( Contact :: getUserName , userNames ) ; Map < String , String > contactMap = Optional . ofNullable ( super . list ( wrapper ) ) . map ( contacts -> contacts . stream ( ) . collect ( Collectors . toMap ( Contact :: getUserName , contact -> StrUtil . isNotBlank ( contact . getRemark ( ) ) ? contact . getRemark ( ) : contact . getNickName ( ) ) ) ) . orElse ( Collections . emptyMap ( ) ) ; return userNames . stream ( ) . collect ( Collectors . toMap ( item -> item , item -> { String nickName = contactMap . get ( item ) ; if ( StrUtil . isBlank ( nickName ) ) { return \"<STR_LIT>\" ; } return nickName ; } ) ) ; } @ Override public int countContact ( ) { return getBaseMapper ( ) . countContact ( ) ; } @ Override public List < ExportContactVO > exportContact ( ) { return getBaseMapper ( ) . exportContact ( ) ; } }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . converter . NoticeConverter ; import cn . org . alan . exam . mapper . GradeMapper ; import cn . org . alan . exam . mapper . NoticeGradeMapper ; import cn . org . alan . exam . mapper . NoticeMapper ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . entity . Notice ; import cn . org . alan . exam . model . entity . NoticeGrade ; import cn . org . alan . exam . model . entity . User ; import cn . org . alan . exam . model . form . NoticeForm ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . model . vo . NoticeVO ; import cn . org . alan . exam . service . INoticeService ; import cn . org . alan . exam . util . CacheClient ; import cn . org . alan . exam . util . SecurityUtil ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . conditions . update . LambdaUpdateWrapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . core . toolkit . StringUtils ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import jakarta . annotation . Resource ; import org . springframework . data . redis . core . StringRedisTemplate ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import java . util . function . Function ; import java . util . stream . Collectors ; @ Service public class NoticeServiceImpl extends ServiceImpl < NoticeMapper , Notice > implements INoticeService { @ Resource private NoticeMapper noticeMapper ; @ Resource private NoticeConverter noticeConverter ; @ Resource private NoticeGradeMapper noticeGradeMapper ; @ Resource private GradeMapper gradeMapper ; @ Resource private CacheClient cacheClient ; @ Resource private StringRedisTemplate stringRedisTemplate ; @ Override @ Transactional public Result < String > addNotice ( NoticeForm noticeForm ) { noticeForm . setUserId ( SecurityUtil . getUserId ( ) ) ; Notice notice = noticeConverter . formToEntity ( noticeForm ) ; int rowsAffected = noticeMapper . insert ( notice ) ; if ( rowsAffected == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } LambdaQueryWrapper < Grade > gradeLambdaQueryWrapper = new LambdaQueryWrapper < > ( ) ; gradeLambdaQueryWrapper . eq ( Grade :: getUserId , SecurityUtil . getUserId ( ) ) ; List < Grade > grades = gradeMapper . selectList ( gradeLambdaQueryWrapper ) ; Integer noticeId = notice . getId ( ) ; if ( grades . isEmpty ( ) ) { return Result . failed ( \"<STR_LIT>\" ) ; } int addNoticeGradeRow = noticeGradeMapper . addNoticeGrade ( noticeId , grades ) ; if ( addNoticeGradeRow == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } if ( notice . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + notice . getId ( ) . toString ( ) ) ; stringRedisTemplate . delete ( \"<STR_LIT>\" + notice . getId ( ) . toString ( ) ) ; } return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ Transactional public Result < String > deleteNotice ( String ids ) { List < Integer > noticeIds = Arrays . stream ( ids . split ( \"<STR_LIT>\" ) ) . map ( Integer :: parseInt ) . toList ( ) ; int rowsAffected = noticeMapper . removeNotice ( noticeIds ) ; if ( rowsAffected == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } noticeIds . forEach ( id -> { stringRedisTemplate . delete ( \"<STR_LIT>\" + id ) ; stringRedisTemplate . delete ( \"<STR_LIT>\" + id ) ; } ) ; return Result . success ( \"<STR_LIT>\" ) ; } @ Override @ Transactional public Result < String > updateNotice ( String id , NoticeForm noticeForm ) { LambdaUpdateWrapper < Notice > noticeWrapper = new LambdaUpdateWrapper < > ( ) ; noticeWrapper . eq ( Notice :: getId , id ) . eq ( Notice :: getIsDeleted , <NUM_LIT> ) . set ( Notice :: getContent , noticeForm . getContent ( ) ) ; int rowsAffected = noticeMapper . update ( noticeWrapper ) ; if ( rowsAffected == <NUM_LIT> ) { return Result . failed ( \"<STR_LIT>\" ) ; } Notice byId = getById ( id ) ; if ( byId . getId ( ) != null ) { stringRedisTemplate . delete ( \"<STR_LIT>\" + byId . getId ( ) . toString ( ) ) ; stringRedisTemplate . delete ( \"<STR_LIT>\" + byId . getId ( ) . toString ( ) ) ; } return Result . success ( \"<STR_LIT>\" ) ; } @ Override public Result < IPage < NoticeVO > > getNotice ( Integer pageNum , Integer pageSize , String title ) { int total = noticeMapper . countByCondition ( SecurityUtil . getUserId ( ) , title ) ; int offset = ( pageNum - <NUM_LIT> ) * pageSize ; List < Integer > noticeIds = noticeMapper . selectNoticeIdsPage ( SecurityUtil . getUserId ( ) , title , offset , pageSize ) ; Map < Integer , NoticeVO > cachedGradesMap = cacheClient . batchGet ( \"<STR_LIT>\" , noticeIds , NoticeVO . class ) ; List < Integer > missIds = new ArrayList < > ( ) ; for ( Integer id : noticeIds ) { if ( ! cachedGradesMap . containsKey ( id ) ) { missIds . add ( id ) ; } } if ( ! missIds . isEmpty ( ) ) { List < NoticeVO > missedGrades = noticeMapper . batchSelectByIds ( missIds ) ; Map < Integer , NoticeVO > missedGradesMap = missedGrades . stream ( ) . collect ( Collectors . toMap ( NoticeVO :: getId , Function . identity ( ) ) ) ; cacheClient . batchPut ( \"<STR_LIT>\" , missedGradesMap , <NUM_LIT> , TimeUnit . MINUTES ) ; cachedGradesMap . putAll ( missedGradesMap ) ; } List < NoticeVO > finalResult = new ArrayList < > ( noticeIds . size ( ) ) ; for ( Integer id : noticeIds ) { finalResult . add ( cachedGradesMap . get ( id ) ) ; } IPage < NoticeVO > resultPage = new Page < > ( pageNum , pageSize , Long . valueOf ( total ) ) ; resultPage . setRecords ( finalResult ) ; return Result . success ( \"<STR_LIT>\" , resultPage ) ; } @ Override public Result < IPage < NoticeVO > > getNewNotice ( Integer pageNum , Integer pageSize ) { Page < NoticeVO > page = new Page < > ( pageNum , pageSize ) ; page = noticeMapper . selectNewNoticePage ( page , SecurityUtil . getUserId ( ) ) ; int total = noticeMapper . countByCondition ( SecurityUtil . getUserId ( ) , null ) ; int offset = ( pageNum - <NUM_LIT> ) * pageSize ; List < Integer > noticeIds = noticeMapper . selectNewNoticeIdsPage ( SecurityUtil . getUserId ( ) , offset , pageSize ) ; Map < Integer , NoticeVO > cachedGradesMap = cacheClient . batchGet ( \"<STR_LIT>\" , noticeIds , NoticeVO . class ) ; List < Integer > missIds = new ArrayList < > ( ) ; for ( Integer id : noticeIds ) { if ( ! cachedGradesMap . containsKey ( id ) ) { missIds . add ( id ) ; } } if ( ! missIds . isEmpty ( ) ) { List < NoticeVO > missedGrades = noticeMapper . batchSelectByIds ( missIds ) ; Map < Integer , NoticeVO > missedGradesMap = missedGrades . stream ( ) . collect ( Collectors . toMap ( NoticeVO :: getId , Function . identity ( ) ) ) ; cacheClient . batchPut ( \"<STR_LIT>\" , missedGradesMap , <NUM_LIT> , TimeUnit . MINUTES ) ; cachedGradesMap . putAll ( missedGradesMap ) ;", "output": "} List < NoticeVO > finalResult = new ArrayList < > ( noticeIds . size ( ) ) ; for ( Integer id : noticeIds ) { finalResult . add ( cachedGradesMap . get ( id ) ) ; } IPage < NoticeVO > resultPage = new Page < > ( pageNum , pageSize , Long . valueOf ( total ) ) ; resultPage . setRecords ( finalResult ) ; return Result . success ( \"<STR_LIT>\" , resultPage ) ; } }"}, {"input": "package cn . org . alan . exam . mapper ; import cn . org . alan . exam . model . entity . CertificateUser ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import java . util . List ; public interface CertificateUserMapper extends BaseMapper < CertificateUser > {", "output": "Integer deleteByUserIds ( List < Integer > userIds ) ; }"}, {"input": "package ginyi . system . domain . model . vo ; import ginyi . system . domain . BaseEntity ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ EqualsAndHashCode ( callSuper = true ) @ Data @ ApiModel ( \"<STR_LIT>\" ) public class DeptVo extends BaseEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long deptId ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Long parentId ; private String ancestors ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String leader ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String phone ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String email ; @ ApiModelProperty ( \"<STR_LIT>\" ) private String status ;", "output": "}"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Certificate ; import cn . org . alan . exam . model . form . CertificateForm ; import org . mapstruct . Mapper ; import org . mapstruct . Mapping ; import org . mapstruct . Mappings ; import org . springframework . stereotype . Component ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface CertificateConverter { @ Mappings ( { @ Mapping ( target = \"<STR_LIT>\" , source = \"<STR_LIT>\" ) } ) Certificate fromToEntity ( CertificateForm certificateForm ) ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import javax . validation . constraints . NotBlank ; @ Data public class TradePwdVerificationParam { @ NotBlank private String tradePwd ;", "output": "}"}, {"input": "package com . yf . system . modules . role . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . role . entity . SysRole ; public interface SysRoleMapper extends BaseMapper < SysRole > {", "output": "}"}, {"input": "package io . github . chensheng . dddboot . tools . concurrent . threadpool ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public final class QueuableCachedThreadPool extends java . util . concurrent . ThreadPoolExecutor { private final AtomicInteger submittedCount = new AtomicInteger ( <NUM_LIT> ) ; public QueuableCachedThreadPool ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , ControllableQueue workQueue , ThreadFactory threadFactory , RejectedExecutionHandler handler ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory , handler ) ; workQueue . setParent ( this ) ; prestartAllCoreThreads ( ) ; } @ Override protected void afterExecute ( Runnable r , Throwable t ) { submittedCount . decrementAndGet ( ) ; } public int getSubmittedCount ( ) { return submittedCount . get ( ) ; } @ Override public void execute ( Runnable command ) { execute ( command , <NUM_LIT> , TimeUnit . MILLISECONDS ) ; } public void execute ( Runnable command , long timeout , TimeUnit unit ) { submittedCount . incrementAndGet ( ) ; try { super . execute ( command ) ; } catch ( RejectedExecutionException rx ) { final ControllableQueue queue = ( ControllableQueue ) super . getQueue ( ) ; try { if ( ! queue . force ( command , timeout , unit ) ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } } catch ( InterruptedException ignore ) { submittedCount . decrementAndGet ( ) ; throw new RejectedExecutionException ( ignore ) ;", "output": "} } } protected static class ControllableQueue extends LinkedBlockingQueue < Runnable > { private static final long serialVersionUID = <NUM_LIT> ; private transient volatile QueuableCachedThreadPool parent = null ; public ControllableQueue ( int capacity ) { super ( capacity ) ; } public void setParent ( QueuableCachedThreadPool tp ) { parent = tp ; } public boolean force ( Runnable o ) { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o ) ; } public boolean force ( Runnable o , long timeout , TimeUnit unit ) throws InterruptedException { if ( parent . isShutdown ( ) ) { throw new RejectedExecutionException ( \"<STR_LIT>\" ) ; } return super . offer ( o , timeout , unit ) ; } @ Override public boolean offer ( Runnable o ) { int currentPoolSize = parent . getPoolSize ( ) ; if ( currentPoolSize >= parent . getMaximumPoolSize ( ) ) { return super . offer ( o ) ; } if ( parent . getSubmittedCount ( ) < currentPoolSize ) { return super . offer ( o ) ; } if ( currentPoolSize < parent . getMaximumPoolSize ( ) ) { return false ; } return super . offer ( o ) ; } } }"}, {"input": "package org . example . infrastructure . config ; import com . baomidou . mybatisplus . core . handlers . MetaObjectHandler ; import org . apache . ibatis . reflection . MetaObject ; import org . example . domain . example . repository . ExampleSecurityRepository ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . stereotype . Component ; import java . util . Date ; @ Component public class ExampleDataObjectHandler implements MetaObjectHandler { @ Autowired private ExampleSecurityRepository securityRepository ; @ Override public void insertFill ( MetaObject metaObject ) { this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ; this . strictInsertFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . getLoginUserQuietly ( ) ) ; } @ Override public void updateFill ( MetaObject metaObject ) { this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Date . class , new Date ( ) ) ;", "output": "this . strictUpdateFill ( metaObject , \"<STR_LIT>\" , Long . class , securityRepository . getLoginUserQuietly ( ) ) ; } }"}, {"input": "package top . kangert . kspider . expression ; import java . io . OutputStream ; import java . util . List ; import top . kangert . kspider . expression . interpreter . AstInterpreter ; import top . kangert . kspider . expression . parsing . Ast ; import top . kangert . kspider . expression . parsing . Parser ; public class ExpressionTemplate { private final List < Ast . Node > nodes ; private ExpressionTemplate ( List < Ast . Node > nodes ) { this . nodes = nodes ; } public static ExpressionTemplate create ( String source ) { return new ExpressionTemplate ( Parser . parse ( source ) ) ; } public List < Ast . Node > getNodes ( ) {", "output": "return nodes ; } public Object render ( ExpressionTemplateContext context ) { return AstInterpreter . interpret ( this , context ) ; } }"}, {"input": "package io . github . chensheng . dddboot . tools . base ; import com . google . common . base . Throwables ; import io . github . chensheng . dddboot . tools . base . annotation . NotNull ; import io . github . chensheng . dddboot . tools . base . annotation . Nullable ; import io . github . chensheng . dddboot . tools . base . type . UncheckedException ; import io . github . chensheng . dddboot . tools . io . type . StringBuilderWriter ; import org . apache . commons . lang3 . ClassUtils ; import org . apache . commons . lang3 . StringUtils ; import org . apache . commons . lang3 . exception . ExceptionUtils ; import java . io . PrintWriter ; import java . lang . reflect . UndeclaredThrowableException ; public class ExceptionUtil { private static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <NUM_LIT> ] ; public static RuntimeException unchecked ( @ Nullable Throwable t ) { if ( t instanceof RuntimeException ) {", "output": "throw ( RuntimeException ) t ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw new UncheckedException ( t ) ; } public static Throwable unwrap ( @ Nullable Throwable t ) { if ( t instanceof UncheckedException || t instanceof java . util . concurrent . ExecutionException || t instanceof java . lang . reflect . InvocationTargetException || t instanceof UndeclaredThrowableException ) { return t . getCause ( ) ; } return t ; } public static RuntimeException unwrapAndUnchecked ( @ Nullable Throwable t ) { throw unchecked ( unwrap ( t ) ) ; } public static String stackTraceText ( @ NotNull Throwable t ) { StringBuilderWriter stringWriter = new StringBuilderWriter ( ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } public static String toStringWithShortName ( @ Nullable Throwable t ) { return ExceptionUtils . getMessage ( t ) ; } public static String toStringWithRootCause ( @ Nullable Throwable t ) { if ( t == null ) { return StringUtils . EMPTY ; } final String clsName = ClassUtils . getShortClassName ( t , null ) ; final String message = StringUtils . defaultString ( t . getMessage ( ) ) ; Throwable cause = getRootCause ( t ) ; StringBuilder sb = new StringBuilder ( <NUM_LIT> ) . append ( clsName ) . append ( \"<STR_LIT>\" ) . append ( message ) ; if ( cause != t ) { sb . append ( \"<STR_LIT>\" ) . append ( toStringWithShortName ( cause ) ) ; } return sb . toString ( ) ; } public static Throwable getRootCause ( @ NotNull Throwable t ) { return Throwables . getRootCause ( t ) ; } public static < T extends Throwable > T findCause ( @ NotNull Throwable throwable , Class < T > cause ) { while ( throwable != null ) { if ( throwable . getClass ( ) . equals ( cause ) ) { return ( T ) throwable ; } throwable = throwable . getCause ( ) ; } return null ; } @ SuppressWarnings ( \"<STR_LIT>\" ) public static boolean isCausedBy ( @ Nullable Throwable throwable , Class < ? extends Exception > ... causeExceptionClasses ) { Throwable cause = throwable ; while ( cause != null ) { for ( Class < ? extends Exception > causeClass : causeExceptionClasses ) { if ( causeClass . isInstance ( cause ) ) { return true ; } } cause = cause . getCause ( ) ; } return false ; } public static < T extends Throwable > T setStackTrace ( @ NotNull T throwable , Class < ? > throwClass , String throwClazz ) { throwable . setStackTrace ( new StackTraceElement [ ] { new StackTraceElement ( throwClass . getName ( ) , throwClazz , null , - <NUM_LIT> ) } ) ; return throwable ; } public static < T extends Throwable > T clearStackTrace ( @ NotNull T throwable ) { Throwable cause = throwable ; while ( cause != null ) { cause . setStackTrace ( EMPTY_STACK_TRACE ) ; cause = cause . getCause ( ) ; } return throwable ; } }"}, {"input": "package top . kangert . kspider . util ; import org . springframework . data . domain . Page ; import java . util . List ; public class PageInfo < T > { private int pageSize = <NUM_LIT> ; private int currentPage = <NUM_LIT> ; private int pageNums = <NUM_LIT> ; private int total = <NUM_LIT> ; private List < T > data ; public PageInfo ( Page < T > page ) { setCurrentPage ( page . getNumber ( ) + <NUM_LIT> ) ;", "output": "setPageSize ( page . getSize ( ) ) ; setPageNums ( page . getTotalPages ( ) ) ; setTotal ( ( int ) page . getTotalElements ( ) ) ; setData ( page . toList ( ) ) ; } public int getPageSize ( ) { return pageSize ; } public void setPageSize ( int pageSize ) { this . pageSize = pageSize ; } public int getCurrentPage ( ) { return currentPage ; } public void setCurrentPage ( int currentPage ) { this . currentPage = currentPage ; } public int getPageNums ( ) { return pageNums ; } public void setPageNums ( int pageNums ) { this . pageNums = pageNums ; } public int getTotal ( ) { return total ; } public void setTotal ( int total ) { this . total = total ; } public List < T > getData ( ) { return data ; } public void setData ( List < T > data ) { this . data = data ; } }"}, {"input": "package com . oddfar . campus . admin . controller . system ; import com . oddfar . campus . common . annotation . Anonymous ; import com . oddfar . campus . common . annotation . ApiResource ; import com . oddfar . campus . common . domain . PageResult ; import com . oddfar . campus . common . domain . R ; import com . oddfar . campus . common . domain . entity . SysDictDataEntity ; import com . oddfar . campus . common . enums . ResBizTypeEnum ; import com . oddfar . campus . framework . service . SysDictDataService ; import com . oddfar . campus . framework . service . SysDictTypeService ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . util . StringUtils ; import org . springframework . validation . annotation . Validated ; import org . springframework . web . bind . annotation . * ; import java . util . ArrayList ; import java . util . List ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) @ ApiResource ( name = \"<STR_LIT>\" , resBizType = ResBizTypeEnum . SYSTEM ) public class SysDictDataController { @ Autowired private SysDictDataService dictDataService ; @ Autowired private SysDictTypeService dictTypeService ; @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R page ( SysDictDataEntity dictData ) { PageResult < SysDictDataEntity > page = dictDataService . page ( dictData ) ; return R . ok ( ) . put ( page ) ; } @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) @ Anonymous public R dictType ( @ PathVariable String dictType ) { List < SysDictDataEntity > data = dictTypeService . selectDictDataByType ( dictType ) ; if ( StringUtils . isEmpty ( data ) ) { data = new ArrayList < SysDictDataEntity > ( ) ; } return R . ok ( ) . put ( data ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R getInfo ( @ PathVariable Long dictCode ) { return R . ok ( dictDataService . selectDictDataById ( dictCode ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PostMapping ( name = \"<STR_LIT>\" ) public R add ( @ Validated @ RequestBody SysDictDataEntity dict ) {", "output": "return R . ok ( dictDataService . insertDictData ( dict ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ PutMapping ( name = \"<STR_LIT>\" ) public R edit ( @ Validated @ RequestBody SysDictDataEntity dict ) { return R . ok ( dictDataService . updateDictData ( dict ) ) ; } @ PreAuthorize ( \"<STR_LIT>\" ) @ DeleteMapping ( value = \"<STR_LIT>\" , name = \"<STR_LIT>\" ) public R remove ( @ PathVariable Long [ ] dictCodes ) { dictDataService . deleteDictDataByIds ( dictCodes ) ; return R . ok ( ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . factory ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingMaintainService ; import com . alibaba . nacos . api . naming . NamingService ; import java . util . Collection ; import java . util . Properties ; public interface NacosServiceFactory { String BEAN_NAME = \"<STR_LIT>\" ; ConfigService createConfigService ( Properties properties ) throws NacosException ; NamingService createNamingService ( Properties properties ) throws NacosException ; NamingMaintainService createNamingMaintainService ( Properties properties ) throws NacosException ; Collection < ConfigService > getConfigServices ( ) ; Collection < NamingService > getNamingServices ( ) ; Collection < NamingMaintainService > getNamingMaintainService ( ) ;", "output": "}"}, {"input": "package com . xcs . wx . domain . dto ; import lombok . Data ; import lombok . EqualsAndHashCode ; @ Data @ EqualsAndHashCode ( callSuper = true ) public class ChatRoomDTO extends PageDTO { private String chatRoomTitle ; private String selfDisplayName ; private String createBy ;", "output": "}"}, {"input": "package org . springblade . cgform . entity ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import lombok . EqualsAndHashCode ; import org . springblade . core . tenant . mp . TenantEntity ; @ Data @ TableName ( \"<STR_LIT>\" ) @ EqualsAndHashCode ( callSuper = true ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class CgformValid extends TenantEntity { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String msg ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String name ;", "output": "}"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . entity . SysDept ; import com . youlai . system . model . query . TablePageQuery ; import com . youlai . system . model . vo . TableColumnVO ; import com . youlai . system . model . vo . TablePageVO ; import org . apache . ibatis . annotations . Mapper ; import java . util . List ; @ Mapper public interface DatabaseMapper extends BaseMapper < SysDept > { Page < TablePageVO > getTablePage ( Page < TablePageVO > page , TablePageQuery queryParams ) ; List < TableColumnVO > getTableColumns ( String tableName ) ;", "output": "}"}, {"input": "package top . kangert . kspider . domain ; import lombok . Getter ; import lombok . Setter ; import lombok . ToString ; import top . kangert . kspider . entity . BaseEntity ; import java . util . Date ; import javax . persistence . * ; import org . hibernate . annotations . ColumnDefault ; import com . fasterxml . jackson . annotation . JsonProperty ; @ Table ( name = \"<STR_LIT>\" ) @ Entity @ Getter @ Setter @ ToString public class SpiderTask extends BaseEntity { @ Id @ GeneratedValue ( strategy = GenerationType . IDENTITY ) @ Column ( updatable = false ) private Long taskId ; @ Column ( name = \"<STR_LIT>\" ) private Long flowId ; @ Column ( name = \"<STR_LIT>\" ) private String taskName ; @ Column ( name = \"<STR_LIT>\" , columnDefinition = \"<STR_LIT>\" ) private String matedata ; @ Column ( name = \"<STR_LIT>\" ) private String cron ; @ Column ( name = \"<STR_LIT>\" , insertable = false ) @ ColumnDefault ( \"<STR_LIT>\" ) @ JsonProperty ( access = JsonProperty . Access . READ_ONLY ) private Integer executeCount ; @ Transient private Integer runningCount ; @ Column ( name = \"<STR_LIT>\" , insertable = false ) @ ColumnDefault ( \"<STR_LIT>\" ) private Boolean jobEnabled = false ; @ Column ( name = \"<STR_LIT>\" ) @ JsonProperty ( access = JsonProperty . Access . READ_ONLY ) private Date lastExecuteTime ; @ Column ( name = \"<STR_LIT>\" ) @ JsonProperty ( access = JsonProperty . Access . READ_ONLY ) private Date nextExecuteTime ; @ Column ( name = \"<STR_LIT>\" ) @ ColumnDefault ( \"<STR_LIT>\" ) private Integer runState = <NUM_LIT> ;", "output": "}"}, {"input": "package org . springblade . config . util . converter . impl ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . config . util . converter . field . FieldFieldCommentConverter ; import org . springblade . cgform . entity . CgformField ; import org . springblade . cgform . model . DictModel ; import org . springblade . cgform . service . IDictService ; import java . util . ArrayList ; import java . util . List ; public class RadioFieldCommentConverter extends FieldFieldCommentConverter { public RadioFieldCommentConverter ( CgformField onlCgformField ) { IDictService dictService = SpringContextUtils . getBean ( IDictService . class ) ; String dictTable = onlCgformField . getDictTable ( ) ; String dictText = onlCgformField . getDictText ( ) ; String dictField = onlCgformField . getDictField ( ) ; List < DictModel > arrayList = new ArrayList < > ( ) ; if ( ConvertUtils . isNotEmpty ( dictTable ) ) { arrayList = dictService . queryTableDictItemsByCode ( dictTable , dictText , dictField ) ; } else if ( ConvertUtils . isNotEmpty ( dictField ) ) { arrayList = dictService . queryDictItemsByCode ( dictField ) ;", "output": "} this . dictList = arrayList ; this . filed = onlCgformField . getDbFieldName ( ) ; } }"}, {"input": "package com . xcs . wx . mapping ; import com . xcs . wx . domain . FTSContactContent ; import com . xcs . wx . domain . vo . RecoverContactVO ; import org . mapstruct . Mapper ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface RecoverContactMapping {", "output": "RecoverContactVO convert ( FTSContactContent content ) ; }"}, {"input": "package me . zhengjie . modules . system . domain ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import io . swagger . annotations . ApiModelProperty ; import lombok . Getter ; import lombok . Setter ; import me . zhengjie . base . BaseEntity ; import me . zhengjie . utils . enums . DataScopeEnum ; import javax . validation . constraints . NotBlank ; import javax . validation . constraints . NotNull ; import java . io . Serializable ; import java . util . Objects ; import java . util . Set ; @ Getter @ Setter @ TableName ( \"<STR_LIT>\" ) public class Role extends BaseEntity implements Serializable { @ NotNull ( groups = { Update . class } ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . AUTO ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Long id ; @ TableField ( exist = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Set < User > users ; @ TableField ( exist = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Set < Menu > menus ; @ TableField ( exist = false ) @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private Set < Dept > depts ; @ NotBlank @ ApiModelProperty ( value = \"<STR_LIT>\" , hidden = true ) private String name ;", "output": "@ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dataScope = DataScopeEnum . THIS_LEVEL . getValue ( ) ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer level = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String description ; @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Role role = ( Role ) o ; return Objects . equals ( id , role . id ) ; } @ Override public int hashCode ( ) { return Objects . hash ( id ) ; } }"}, {"input": "package cn . org . alan . exam . service . impl ; import cn . org . alan . exam . mapper . ExamRepoMapper ; import cn . org . alan . exam . model . entity . ExamRepo ; import cn . org . alan . exam . service . IExamRepoService ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import org . springframework . stereotype . Service ; @ Service public class ExamRepoServiceImpl extends ServiceImpl < ExamRepoMapper , ExamRepo > implements IExamRepoService {", "output": "}"}, {"input": "package org . springblade . config . exception ; public class DBException extends Exception { private static final long serialVersionUID = <NUM_LIT> ; public DBException ( String msg ) {", "output": "super ( msg ) ; } }"}, {"input": "package org . springblade . cgform . service ; import com . alibaba . fastjson . JSONObject ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . exception . DBException ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . model . CgformModel ; import org . springblade . cgform . model . OnlGenerateModel ; import org . springblade . cgform . model . TreeDataModel ; import org . springblade . core . mp . base . BaseService ; import java . util . List ; import java . util . Map ; public interface ICgformHeadService extends BaseService < CgformHead > {", "output": "List < Map < String , Object > > queryListData ( String s ) ; }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . annotation ; import com . alibaba . nacos . api . exception . NacosException ; import com . alibaba . nacos . api . naming . NamingService ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . GlobalNacosPropertiesSource ; import java . util . Properties ; public class NamingServiceBeanBuilder extends AbstractNacosServiceBeanBuilder < NamingService > { public static final String BEAN_NAME = \"<STR_LIT>\" ; public NamingServiceBeanBuilder ( ) { super ( GlobalNacosPropertiesSource . DISCOVERY ) ; } @ Override protected NamingService createService ( NacosServiceFactory nacosServiceFactory , Properties properties ) throws NacosException {", "output": "return nacosServiceFactory . createNamingService ( properties ) ; } }"}, {"input": "package com . oddfar . campus . common . annotation ; import java . lang . annotation . * ; @ Target ( { ElementType . METHOD , ElementType . TYPE }", "output": ") @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface Log { boolean openLog ( ) default true ; }"}, {"input": "package me . zhengjie . service . impl ; import cn . hutool . core . collection . CollectionUtil ; import cn . hutool . core . util . ZipUtil ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import me . zhengjie . domain . GenConfig ; import me . zhengjie . domain . ColumnInfo ; import me . zhengjie . domain . vo . TableInfo ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . mapper . ColumnInfoMapper ; import me . zhengjie . service . GeneratorService ; import me . zhengjie . utils . * ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . File ; import java . io . IOException ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Slf4j @ Service @ RequiredArgsConstructor public class GeneratorServiceImpl extends ServiceImpl < ColumnInfoMapper , ColumnInfo > implements GeneratorService { private final ColumnInfoMapper columnInfoMapper ; private final String CONFIG_MESSAGE = \"<STR_LIT>\" ; @ Override public PageResult < TableInfo > getTables ( String name , Page < Object > page ) { return PageUtil . toPage ( columnInfoMapper . getTables ( name , page ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public List < ColumnInfo > getColumns ( String tableName ) { List < ColumnInfo > columnInfos = columnInfoMapper . findByTableNameOrderByIdAsc ( tableName ) ; if ( CollectionUtil . isNotEmpty ( columnInfos ) ) { return columnInfos ; } else { columnInfos = query ( tableName ) ; saveBatch ( columnInfos ) ; return columnInfos ; } } @ Override public List < ColumnInfo > query ( String tableName ) { List < ColumnInfo > columnInfos = columnInfoMapper . getColumns ( tableName ) ; for ( ColumnInfo columnInfo : columnInfos ) { columnInfo . setTableName ( tableName ) ; if ( GenUtil . PK . equalsIgnoreCase ( columnInfo . getKeyType ( ) ) && GenUtil . EXTRA . equalsIgnoreCase ( columnInfo . getExtra ( ) ) ) { columnInfo . setNotNull ( false ) ; } } return columnInfos ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void sync ( List < ColumnInfo > columnInfos , List < ColumnInfo > columnInfoList ) { for ( ColumnInfo columnInfo : columnInfoList ) { List < ColumnInfo > columns = columnInfos . stream ( ) . filter ( c -> c . getColumnName ( ) . equals ( columnInfo . getColumnName ( ) ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtil . isNotEmpty ( columns ) ) { ColumnInfo column = columns . get ( <NUM_LIT> ) ; column . setColumnType ( columnInfo . getColumnType ( ) ) ; column . setExtra ( columnInfo . getExtra ( ) ) ; column . setKeyType ( columnInfo . getKeyType ( ) ) ; if ( StringUtils . isBlank ( column . getRemark ( ) ) ) { column . setRemark ( columnInfo . getRemark ( ) ) ; } saveOrUpdate ( column ) ; } else { save ( columnInfo ) ; } } for ( ColumnInfo columnInfo : columnInfos ) { List < ColumnInfo > columns = columnInfoList . stream ( ) . filter ( c -> c . getColumnName ( ) . equals ( columnInfo . getColumnName ( ) ) ) . collect ( Collectors . toList ( ) ) ; if ( CollectionUtil . isEmpty ( columns ) ) { removeById ( columnInfo ) ; } } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void save ( List < ColumnInfo > columnInfos ) { saveOrUpdateBatch ( columnInfos ) ; } @ Override public void generator ( GenConfig genConfig , List < ColumnInfo > columns ) { if ( genConfig . getId ( ) == null ) { throw new BadRequestException ( CONFIG_MESSAGE ) ; } try { GenUtil . generatorCode ( columns , genConfig ) ; } catch ( IOException e ) { log . error ( e . getMessage ( ) , e ) ;", "output": "throw new BadRequestException ( \"<STR_LIT>\" ) ; } } @ Override public ResponseEntity < Object > preview ( GenConfig genConfig , List < ColumnInfo > columns ) { if ( genConfig . getId ( ) == null ) { throw new BadRequestException ( CONFIG_MESSAGE ) ; } List < Map < String , Object > > genList = GenUtil . preview ( columns , genConfig ) ; return new ResponseEntity < > ( genList , HttpStatus . OK ) ; } @ Override public void download ( GenConfig genConfig , List < ColumnInfo > columns , HttpServletRequest request , HttpServletResponse response ) { if ( genConfig . getId ( ) == null ) { throw new BadRequestException ( CONFIG_MESSAGE ) ; } try { File file = new File ( GenUtil . download ( columns , genConfig ) ) ; String zipPath = file . getPath ( ) + \"<STR_LIT>\" ; ZipUtil . zip ( file . getPath ( ) , zipPath ) ; FileUtil . downloadFile ( request , response , new File ( zipPath ) , true ) ; } catch ( IOException e ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } } }"}, {"input": "package top . kangert . kspider . io ; import java . io . Closeable ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . ArrayList ; import java . util . List ; import java . util . regex . Pattern ; public class RandomAccessFileReader implements Closeable { private RandomAccessFile raf ; private long index ; private boolean reversed ; private int bufSize ; public RandomAccessFileReader ( RandomAccessFile raf , long index , boolean reversed ) throws IOException { this ( raf , index , <NUM_LIT> , reversed ) ; } public RandomAccessFileReader ( RandomAccessFile raf , long index , int bufSize , boolean reversed ) throws IOException { if ( raf == null ) {", "output": "throw new NullPointerException ( \"<STR_LIT>\" ) ; } this . raf = raf ; this . reversed = reversed ; this . bufSize = bufSize ; this . index = index ; this . init ( ) ; } private void init ( ) throws IOException { if ( reversed ) { this . index = this . index == - <NUM_LIT> ? this . raf . length ( ) : Math . min ( this . index , this . raf . length ( ) ) ; } else { this . index = Math . min ( Math . max ( this . index , <NUM_LIT> ) , this . raf . length ( ) ) ; } if ( this . index > <NUM_LIT> ) { this . raf . seek ( this . index ) ; } } public List < Line > readLine ( int n , String keywords , boolean matchCase , boolean regx ) throws IOException { List < Line > lines = new ArrayList < > ( n ) ; long lastCRLFIndex = reversed ? this . index : ( this . index > <NUM_LIT> ? this . index + <NUM_LIT> : - <NUM_LIT> ) ; boolean find = keywords == null || keywords . isEmpty ( ) ; Pattern pattern = regx && ! find ? Pattern . compile ( keywords ) : null ; while ( n > <NUM_LIT> ) { byte [ ] buf = reversed ? new byte [ ( int ) Math . min ( this . bufSize , this . index ) ] : new byte [ this . bufSize ] ; if ( this . reversed ) { if ( this . index == <NUM_LIT> ) { break ; } this . raf . seek ( this . index -= buf . length ) ; } int len = this . raf . read ( buf , <NUM_LIT> , buf . length ) ; if ( len == - <NUM_LIT> ) { break ; } for ( int i = <NUM_LIT> ; i < len && n > <NUM_LIT> ; i ++ ) { int readIndex = reversed ? len - i - <NUM_LIT> : i ; if ( isCRLF ( buf [ readIndex ] ) ) { if ( Math . abs ( this . index + readIndex - lastCRLFIndex ) > <NUM_LIT> ) { long fromIndex = reversed ? this . index + readIndex : lastCRLFIndex ; long endIndex = reversed ? lastCRLFIndex : this . index + readIndex ; Line line = readLine ( fromIndex + <NUM_LIT> , endIndex ) ; if ( find || ( find = ( pattern == null ? find ( line . getText ( ) , keywords , matchCase ) : find ( line . getText ( ) , pattern ) ) ) ) { if ( reversed ) { lines . add ( <NUM_LIT> , line ) ; } else { lines . add ( line ) ; } n -- ; } } lastCRLFIndex = this . index + readIndex ; } } if ( ! reversed ) { this . index += buf . length ; } } if ( reversed && n > <NUM_LIT> && lastCRLFIndex > <NUM_LIT> && ( find || lines . size ( ) > <NUM_LIT> ) ) { lines . add ( <NUM_LIT> , readLine ( <NUM_LIT> , lastCRLFIndex ) ) ; } return lines ; } private boolean find ( String text , String keywords , boolean matchCase ) { return matchCase ? text . contains ( keywords ) : text . toLowerCase ( ) . contains ( keywords . toLowerCase ( ) ) ; } private boolean find ( String text , Pattern pattern ) { return pattern . matcher ( text ) . find ( ) ; } private Line readLine ( long fromIndex , long endIndex ) throws IOException { long index = this . raf . getFilePointer ( ) ; this . raf . seek ( fromIndex ) ; byte [ ] buf = new byte [ ( int ) ( endIndex - fromIndex ) ] ; this . raf . read ( buf , <NUM_LIT> , buf . length ) ; Line line = new Line ( fromIndex , new String ( buf ) , endIndex ) ; this . raf . seek ( index ) ; return line ; } private boolean isCRLF ( byte b ) { return b == <NUM_LIT> || b == <NUM_LIT> ; } @ Override public void close ( ) throws IOException { if ( this . raf != null ) { this . raf . close ( ) ; } } }"}, {"input": "package cn . org . alan . exam . common . group ; public interface UserGroup { interface CreateUserGroup extends UserGroup {", "output": "} interface UpdatePasswordGroup extends UserGroup { } interface RegisterGroup extends UserGroup { } }"}, {"input": "package top . kangert . kspider . executor . function ; import org . springframework . stereotype . Component ; import cn . hutool . core . date . DateField ; import cn . hutool . core . date . DateTime ; import cn . hutool . core . date . DateUtil ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExecutor ; import java . text . ParseException ; import java . util . Date ; @ Component @ Comment ( \"<STR_LIT>\" ) public class DateFunctionExecutor implements FunctionExecutor { @ Override public String getFunctionPrefix ( ) { return \"<STR_LIT>\" ; } private static final String DEFAULT_PATTERN = \"<STR_LIT>\" ; @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String format ( Date date ) { return format ( date , DEFAULT_PATTERN ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String format ( Long millis ) { return format ( millis , DEFAULT_PATTERN ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String format ( Date date , String pattern ) { return date != null ? DateUtil . format ( date , pattern ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String format ( Long millis , String pattern ) { return millis != null ? DateUtil . format ( new Date ( millis ) , pattern ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date parse ( String date ) throws ParseException { return date != null ? DateUtil . parse ( date , DEFAULT_PATTERN ) . toJdkDate ( ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date parse ( String date , String pattern ) throws ParseException { return date != null ? DateUtil . parse ( date , pattern ) . toJdkDate ( ) : null ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date parse ( Long millis ) { return new Date ( millis ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date now ( ) { return new Date ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date addYears ( Date date , int amount ) { DateTime tempDate = DateUtil . date ( date ) ; tempDate = tempDate . offset ( DateField . YEAR , amount ) ; return tempDate . toJdkDate ( ) ;", "output": "} @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date addMonths ( Date date , int amount ) { DateTime tempDate = DateUtil . date ( date ) ; tempDate = tempDate . offset ( DateField . MONTH , amount ) ; return tempDate . toJdkDate ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date addDays ( Date date , int amount ) { DateTime tempDate = DateUtil . date ( date ) ; tempDate = tempDate . offset ( DateField . DAY_OF_YEAR , amount ) ; return tempDate . toJdkDate ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date addHours ( Date date , int amount ) { DateTime tempDate = DateUtil . date ( date ) ; tempDate = tempDate . offset ( DateField . HOUR_OF_DAY , amount ) ; return tempDate . toJdkDate ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date addMinutes ( Date date , int amount ) { DateTime tempDate = DateUtil . date ( date ) ; tempDate = tempDate . offset ( DateField . MINUTE , amount ) ; return tempDate . toJdkDate ( ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date addSeconds ( Date date , int amount ) { DateTime tempDate = DateUtil . date ( date ) ; tempDate = tempDate . offset ( DateField . SECOND , amount ) ; return tempDate . toJdkDate ( ) ; } }"}, {"input": "package me . zhengjie . modules . system . service ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . IService ; import me . zhengjie . modules . system . domain . DictDetail ; import me . zhengjie . modules . system . domain . vo . DictDetailQueryCriteria ; import me . zhengjie . utils . PageResult ; import java . util . List ; public interface DictDetailService extends IService < DictDetail > { void create ( DictDetail resources ) ;", "output": "void update ( DictDetail resources ) ; void delete ( Long id ) ; PageResult < DictDetail > queryAll ( DictDetailQueryCriteria criteria , Page < Object > page ) ; List < DictDetail > getDictByName ( String name ) ; }"}, {"input": "package com . yf . system . modules . depart . dto . request ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class DepartSortReqDTO implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String form ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String to ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String dropType ;", "output": "}"}, {"input": "package org . springblade . cgform . model ; import lombok . Data ; @ Data public class OnlForeignKey { private String field ; private String table ; private String key ; public OnlForeignKey ( String field , String key ) { this . key = key ;", "output": "this . field = field ; } }"}, {"input": "package com . youlai . system . filter ; import cn . hutool . core . util . StrUtil ; import cn . hutool . json . JSONObject ; import cn . hutool . jwt . JWT ; import cn . hutool . jwt . JWTPayload ; import cn . hutool . jwt . JWTUtil ; import com . youlai . system . common . constant . SecurityConstants ; import com . youlai . system . common . result . ResultCode ; import com . youlai . system . security . util . JwtUtils ; import com . youlai . system . common . util . ResponseUtils ; import jakarta . servlet . FilterChain ; import jakarta . servlet . ServletException ; import jakarta . servlet . http . HttpServletRequest ; import jakarta . servlet . http . HttpServletResponse ; import org . springframework . data . redis . core . RedisTemplate ; import org . springframework . http . HttpHeaders ; import org . springframework . security . core . Authentication ; import org . springframework . security . core . context . SecurityContextHolder ; import org . springframework . web . filter . OncePerRequestFilter ; import java . io . IOException ; public class JwtValidationFilter extends OncePerRequestFilter { private final RedisTemplate < String , Object > redisTemplate ; private final byte [ ] secretKey ; public JwtValidationFilter ( RedisTemplate < String , Object > redisTemplate , String secretKey ) { this . redisTemplate = redisTemplate ; this . secretKey = secretKey . getBytes ( ) ; } @ Override protected void doFilterInternal ( HttpServletRequest request , HttpServletResponse response , FilterChain filterChain ) throws ServletException , IOException { String token = request . getHeader ( HttpHeaders . AUTHORIZATION ) ; try { if ( StrUtil . isNotBlank ( token ) && token . startsWith ( SecurityConstants . JWT_TOKEN_PREFIX ) ) { token = token . substring ( SecurityConstants . JWT_TOKEN_PREFIX . length ( ) ) ; JWT jwt = JWTUtil . parseToken ( token ) ; boolean isValidate = jwt . setKey ( secretKey ) . validate ( <NUM_LIT> ) ; if ( ! isValidate ) { ResponseUtils . writeErrMsg ( response , ResultCode . TOKEN_INVALID ) ; return ; } JSONObject payloads = jwt . getPayloads ( ) ; String jti = payloads . getStr ( JWTPayload . JWT_ID ) ; boolean isTokenBlacklisted = Boolean . TRUE . equals ( redisTemplate . hasKey ( SecurityConstants . BLACKLIST_TOKEN_PREFIX + jti ) ) ; if ( isTokenBlacklisted ) { ResponseUtils . writeErrMsg ( response , ResultCode . TOKEN_INVALID ) ; return ;", "output": "} Authentication authentication = JwtUtils . getAuthentication ( payloads ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; } } catch ( Exception e ) { SecurityContextHolder . clearContext ( ) ; ResponseUtils . writeErrMsg ( response , ResultCode . TOKEN_INVALID ) ; return ; } filterChain . doFilter ( request , response ) ; } }"}, {"input": "package io . github . chensheng . dddboot . microservice . core ; import com . baomidou . mybatisplus . core . conditions . query . QueryWrapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . OrderItem ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import io . github . chensheng . dddboot . tools . collection . CollectionUtil ; import io . github . chensheng . dddboot . tools . text . TextUtil ; import io . github . chensheng . dddboot . web . core . BizException ; import lombok . Data ; import org . springframework . beans . factory . annotation . Autowired ; import java . lang . reflect . Field ; import java . util . * ; public abstract class DDDQueryServiceImpl < E extends DDDEntity , D extends IDataObject , R , C extends DDDConvertor < E , D , R > , M extends BaseMapper < D > > implements DDDQueryService < R > { @ Autowired protected C convertor ; @ Autowired protected M mapper ; @ Override public Page < R > page ( PageQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; Page < D > dataObjectPage = new Page < D > ( query . getCurrent ( ) , query . getSize ( ) ) ; dataObjectPage . setOrders ( orderItems ) ; mapper . selectPage ( dataObjectPage , queryWrapper ) ; Page < R > resultPage = new Page < R > ( ) ; resultPage . setCurrent ( dataObjectPage . getCurrent ( ) ) ; resultPage . setSize ( dataObjectPage . getSize ( ) ) ; resultPage . setPages ( dataObjectPage . getPages ( ) ) ; resultPage . setTotal ( dataObjectPage . getTotal ( ) ) ; resultPage . setOrders ( dataObjectPage . getOrders ( ) ) ; if ( CollectionUtil . isNotEmpty ( dataObjectPage . getRecords ( ) ) ) { List < R > records = new ArrayList < R > ( ) ; for ( D dataObject : dataObjectPage . getRecords ( ) ) { R record = convertor . toResult ( dataObject ) ; records . add ( record ) ; } resultPage . setRecords ( records ) ; } return resultPage ; } @ Override public List < R > list ( ListQuery query ) { List < ColumnInfo > columns = doResolveColumns ( query ) ; QueryWrapper < D > queryWrapper = doCreateQueryWrapper ( columns ) ; List < OrderItem > orderItems = doCreateOrderItems ( columns , query ) ; for ( OrderItem orderItem : orderItems ) { if ( orderItem . isAsc ( ) ) { queryWrapper . orderByAsc ( orderItem . getColumn ( ) ) ; } else { queryWrapper . orderByDesc ( orderItem . getColumn ( ) ) ; } } Long limit = query . getLimit ( ) ; if ( limit != null ) { queryWrapper . last ( \"<STR_LIT>\" + limit ) ; } List < D > dataObjectList = mapper . selectList ( queryWrapper ) ; List < R > resultList = new ArrayList < R > ( ) ; if ( CollectionUtil . isNotEmpty ( dataObjectList ) ) { for ( D dataObject : dataObjectList ) { R result = convertor . toResult ( dataObject ) ; resultList . add ( result ) ; } } return resultList ; } @ Override public R detail ( Long id ) { if ( id == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } D dataObject = mapper . selectById ( id ) ; if ( dataObject == null ) { throw new BizException ( \"<STR_LIT>\" ) ; } return convertor . toResult ( dataObject ) ; } private List < OrderItem > doCreateOrderItems ( List < ColumnInfo > columns , SortableQuery query ) { if ( CollectionUtil . isEmpty ( columns ) ) { return Collections . emptyList ( ) ; } Map < String , OrderItem > defaultSortMap = new HashMap < String , OrderItem > ( ) ; Set < String > sortableColumns = new HashSet < String > ( ) ; for ( ColumnInfo columnInfo : columns ) { QuerySortable sortable = columnInfo . getSortable ( ) ; if ( sortable == null ) { continue ; } sortableColumns . add ( columnInfo . getName ( ) ) ; if ( sortable . order ( ) == OrderType . ASC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . asc ( columnInfo . getName ( ) ) ) ; } else if ( sortable . order ( ) == OrderType . DESC ) { defaultSortMap . put ( columnInfo . getName ( ) , OrderItem . desc ( columnInfo . getName ( ) ) ) ; } } List < OrderItem > orderItems = new ArrayList < OrderItem > ( ) ; if ( CollectionUtil . isNotEmpty ( query . getOrders ( ) ) ) { for ( io . github . chensheng . dddboot . microservice . core . OrderItem item : query . getOrders ( ) ) { if ( TextUtil . isBlank ( item . getColumn ( ) ) ) { continue ; } if ( ! sortableColumns . contains ( item . getColumn ( ) ) ) { continue ; } if ( item . isAsc ( ) ) { orderItems . add ( OrderItem . asc ( item . getColumn ( ) ) ) ; } else { orderItems . add ( OrderItem . desc ( item . getColumn ( ) ) ) ; } defaultSortMap . remove ( item . getColumn ( ) ) ; } } if ( defaultSortMap . size ( ) > <NUM_LIT> ) { orderItems . addAll ( defaultSortMap . values ( ) ) ; } return orderItems ; } private QueryWrapper < D > doCreateQueryWrapper ( List < ColumnInfo > columns ) { QueryWrapper < D > queryWrapper = new QueryWrapper < D > ( ) ; if ( CollectionUtil . isEmpty ( columns ) ) { return queryWrapper ; } for ( ColumnInfo column : columns ) { QueryCondition queryCondition = column . getCondition ( ) ; if ( queryCondition != null && queryCondition . ignore ( ) ) { continue ; } Object queryValue = column . getValue ( ) ; if ( isEmpty ( queryValue ) && ( queryCondition == null || ! queryCondition . allowEmpty ( ) ) ) { continue ; } ConditionOperator operator ; if ( queryCondition != null && queryCondition . operator ( ) != null ) { operator = queryCondition . operator ( ) ; } else { operator = ConditionOperator . eq ; } doAddQueryCondition ( queryWrapper , column . getName ( ) , operator , queryValue ) ; } return queryWrapper ; } private void doAddQueryCondition ( QueryWrapper < D > queryWrapper , String column , ConditionOperator operator , Object val ) { if ( operator == ConditionOperator . eq ) { queryWrapper . eq ( column , val ) ; } else if ( operator == ConditionOperator . ne ) { queryWrapper . ne ( column , val ) ; } else if ( operator == ConditionOperator . gt ) { queryWrapper . gt ( column , val ) ; } else if ( operator == ConditionOperator . ge ) { queryWrapper . ge ( column , val ) ; } else if ( operator == ConditionOperator . lt ) { queryWrapper . lt ( column , val ) ; } else if ( operator == ConditionOperator . le ) { queryWrapper . le ( column , val ) ; } else if ( operator == ConditionOperator . like ) { queryWrapper . like ( column , val ) ; } else if ( operator == ConditionOperator . not_like ) { queryWrapper . notLike ( column , val ) ; } else if ( operator == ConditionOperator . in ) { if ( val instanceof Collection ) { queryWrapper . in ( column , ( Collection < ? > ) val ) ; } else { queryWrapper . in ( column , ( Object [ ] ) val ) ; }", "output": "} else if ( operator == ConditionOperator . not_in ) { if ( val instanceof Collection ) { queryWrapper . notIn ( column , ( Collection < ? > ) val ) ; } else { queryWrapper . notIn ( column , ( Object [ ] ) val ) ; } } } private boolean isEmpty ( Object value ) { if ( value == null ) { return true ; } if ( value instanceof String ) { return TextUtil . isBlank ( ( String ) value ) ; } if ( value instanceof Collection ) { return CollectionUtil . isEmpty ( ( Collection ) value ) ; } return false ; } private List < ColumnInfo > doResolveColumns ( Object query ) { Class < ? > queryClass = query . getClass ( ) ; Field [ ] fields = queryClass . getDeclaredFields ( ) ; if ( fields == null || fields . length == <NUM_LIT> ) { return Collections . EMPTY_LIST ; } List < ColumnInfo > columns = new ArrayList < ColumnInfo > ( ) ; for ( Field field : fields ) { QueryCondition queryCondition = field . getDeclaredAnnotation ( QueryCondition . class ) ; QuerySortable querySortable = field . getDeclaredAnnotation ( QuerySortable . class ) ; Object queryValue = null ; try { field . setAccessible ( true ) ; queryValue = field . get ( query ) ; } catch ( IllegalAccessException e ) { } String column ; if ( queryCondition != null && TextUtil . isNotBlank ( queryCondition . column ( ) ) ) { column = queryCondition . column ( ) ; } else { column = TextUtil . camelToUnderscore ( field . getName ( ) ) ; } ColumnInfo columnInfo = new ColumnInfo ( ) ; columnInfo . condition = queryCondition ; columnInfo . sortable = querySortable ; columnInfo . value = queryValue ; columnInfo . name = column ; columns . add ( columnInfo ) ; } return columns ; } @ Data public static class ColumnInfo { QueryCondition condition ; QuerySortable sortable ; String name ; Object value ; } }"}, {"input": "package com . oddfar . campus . common . config . properties ; import lombok . Data ; import org . springframework . boot . context . properties . ConfigurationProperties ; @ Data @ ConfigurationProperties ( prefix = \"<STR_LIT>\" ) public class ThreadPoolProperties { private boolean enabled ; private int queueCapacity ; private int keepAliveSeconds ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import java . io . Serializable ; import java . math . BigDecimal ; import java . util . Date ; import lombok . Data ; import lombok . EqualsAndHashCode ; import javax . validation . constraints . NotNull ; import javax . validation . constraints . Positive ; @ Data public class CoinOrderParam implements Serializable { @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payPwd ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String type ; @ NotNull @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String serviceType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String payMethodId ; private String payServiceId ; private String memberId ; private String payService ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long advertiseId ; @ Positive @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String coinCou ; private BigDecimal rate ; private String countryId ; private String fiatCurrency ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fiatCurrencyAmount ; private String coinId ; private String coinSymbol ; private static final long serialVersionUID = <NUM_LIT> ;", "output": "}"}, {"input": "package cn . org . alan . exam . controller ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . vo . score . GradeScoreVO ; import cn . org . alan . exam . model . vo . score . QuestionAnalyseVO ; import cn . org . alan . exam . model . vo . score . UserScoreVO ; import cn . org . alan . exam . service . IStatService ; import cn . org . alan . exam . service . IExamQuAnswerService ; import cn . org . alan . exam . service . IUserExamsScoreService ; import com . baomidou . mybatisplus . core . metadata . IPage ; import jakarta . annotation . Resource ; import jakarta . servlet . http . HttpServletResponse ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; @ RestController @ RequestMapping ( \"<STR_LIT>\" ) public class ScoreController { @ Resource private IStatService iStatService ; @ Resource private IUserExamsScoreService iUserExamsScoreService ; @ Resource private IExamQuAnswerService iExamQuAnswerService ; @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < UserScoreVO > > pagingScore ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" ) Integer gradeId , @ RequestParam ( value = \"<STR_LIT>\" ) Integer examId , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String realName ) { return iUserExamsScoreService . pagingScore ( pageNum , pageSize , gradeId , examId , realName ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < QuestionAnalyseVO > questionAnalyse ( @ PathVariable ( \"<STR_LIT>\" ) Integer examId , @ PathVariable ( \"<STR_LIT>\" ) Integer questionId ) { return iExamQuAnswerService . questionAnalyse ( examId , questionId ) ; } @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public Result < IPage < GradeScoreVO > > getExamScoreInfo ( @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageNum , @ RequestParam ( value = \"<STR_LIT>\" , required = false , defaultValue = \"<STR_LIT>\" ) Integer pageSize , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) String examTitle , @ RequestParam ( value = \"<STR_LIT>\" , required = false ) Integer gradeId ) { return iUserExamsScoreService . getExamScoreInfo ( pageNum , pageSize , examTitle , gradeId ) ;", "output": "} @ GetMapping ( \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void scoreExport ( HttpServletResponse response , @ PathVariable ( \"<STR_LIT>\" ) Integer examId , @ PathVariable ( \"<STR_LIT>\" ) Integer gradeId ) { iUserExamsScoreService . exportScores ( response , examId , gradeId ) ; } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . constants ; import com . alibaba . nacos . api . annotation . NacosProperties ; public interface NacosConstants {", "output": "String NACOS_CONFIG_LISTENER_PARALLELISM = NacosProperties . PREFIX + \"<STR_LIT>\" ; int DEFAULT_NACOS_CONFIG_LISTENER_PARALLELISM = Runtime . getRuntime ( ) . availableProcessors ( ) ; }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . ExerciseRecord ; import cn . org . alan . exam . model . form . ExerciseFillAnswerFrom ; import cn . org . alan . exam . model . vo . QuestionVO ; import cn . org . alan . exam . model . vo . exercise . AnswerInfoVO ; import cn . org . alan . exam . model . vo . exercise . QuestionSheetVO ; import cn . org . alan . exam . model . vo . record . ExamRecordDetailVO ; import cn . org . alan . exam . model . vo . record . ExamRecordVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordDetailVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordVO ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import java . util . List ; public interface IExerciseRecordService extends IService < ExerciseRecord > { Result < List < QuestionSheetVO > > getQuestionSheet ( Integer repoId , Integer quType ) ; Result < IPage < ExamRecordVO > > getExamRecordPage ( Integer pageNum , Integer pageSize , String examName ) ; Result < List < ExamRecordDetailVO > > getExamRecordDetail ( Integer examId ) ; Result < IPage < ExerciseRecordVO > > getExerciseRecordPage ( Integer pageNum , Integer pageSize , String repoName ) ;", "output": "Result < List < ExerciseRecordDetailVO > > getExerciseRecordDetail ( Integer exerciseId ) ; Result < QuestionVO > fillAnswer ( ExerciseFillAnswerFrom exerciseFillAnswerFrom ) ; Result < QuestionVO > getSingle ( Integer id ) ; Result < AnswerInfoVO > getAnswerInfo ( Integer repoId , Integer quId ) ; }"}, {"input": "package top . kangert . kspider . model ; import lombok . AllArgsConstructor ; import lombok . Getter ; import lombok . Setter ; import java . util . ArrayList ; import java . util . List ; @ Getter @ Setter public class SpiderOutput { private String nodeName ; private String nodeId ; @ Getter private List < OutputItem > outputItems = new ArrayList < > ( ) ; @ AllArgsConstructor public static class OutputItem { @ Getter private String name ; @ Getter private Object value ; @ Override public String toString ( ) { return \"<STR_LIT>\" + \"<STR_LIT>\" + name + '<STR_LIT>' + \"<STR_LIT>\" + value + '<STR_LIT>' ; }", "output": "} public void addItem ( String name , Object value ) { this . outputItems . add ( new OutputItem ( name , value ) ) ; } }"}, {"input": "package cn . org . alan . exam . service ; import cn . org . alan . exam . common . result . Result ; import cn . org . alan . exam . model . entity . Certificate ; import cn . org . alan . exam . model . form . CertificateForm ; import cn . org . alan . exam . model . vo . certificate . MyCertificateVO ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . service . IService ; import org . springframework . stereotype . Service ; import java . util . List ; public interface ICertificateService extends IService < Certificate > { Result < String > addCertificate ( CertificateForm certificateForm ) ; Result < IPage < Certificate > > pagingCertificate ( Integer pageNum , Integer pageSize , String certificateName , String certificationUnit ) ; Result < String > updateCertificate ( CertificateForm certificateForm ) ; Result < String > deleteCertificate ( Integer id ) ;", "output": "Result < IPage < MyCertificateVO > > getMyCertificatePaging ( Integer pageNum , Integer pageSize , String examName ) ; }"}, {"input": "package top . kangert . kspider . util ; import lombok . AllArgsConstructor ; import lombok . NoArgsConstructor ; import top . kangert . kspider . vo . PageVo ; @ AllArgsConstructor @ NoArgsConstructor public class BaseResponse { private int code ; private String message ; private Object data ; private PageVo pageInfo ; public int getCode ( ) { return code ; } public void setCode ( int code ) { this . code = code ; } public String getMessage ( ) { return message ; } public void setMessage ( String message ) { this . message = message ; } public Object getData ( ) { return data ; } public void setData ( Object data ) { this . data = data ; } public PageVo getPageInfo ( ) {", "output": "return pageInfo ; } public void setPageInfo ( PageVo pageInfo ) { this . pageInfo = pageInfo ; } }"}, {"input": "package io . github . chensheng . dddboot . web . core ; public class SysException extends RuntimeException { private static final long serialVersionUID = - <NUM_LIT> ; private String code ; public SysException ( Throwable e ) { super ( e ) ; this . code = ResponseType . SYS_ERROR . getCode ( ) ; } public String getCode ( ) { return code ; } public void setCode ( String code ) { this . code = code ; }", "output": "}"}, {"input": "package cn . org . alan . exam . model . vo . userbook ; import cn . org . alan . exam . model . entity . Option ; import lombok . Data ; import java . util . List ; @ Data public class BookOneQuVO { private static final long serialVersionUID = <NUM_LIT> ; private String image ; private String content ; private Integer quType ; private List < Option > answerList ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . context . annotation . discovery ; import com . alibaba . nacos . api . annotation . NacosInjected ; import com . alibaba . nacos . api . annotation . NacosProperties ; import io . github . chensheng . dddboot . nacos . spring . context . annotation . NacosBeanDefinitionRegistrar ; import org . springframework . context . annotation . Import ; import java . lang . annotation . * ; import static com . alibaba . nacos . api . PropertyKeyConst . PASSWORD ; import static com . alibaba . nacos . api . PropertyKeyConst . USERNAME ; import static com . alibaba . nacos . api . annotation . NacosProperties . * ; @ Target ( { ElementType . TYPE , ElementType . ANNOTATION_TYPE } ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ Import ( NacosDiscoveryBeanDefinitionRegistrar . class ) public @ interface EnableNacosDiscovery {", "output": "String DISCOVERY_PREFIX = NacosProperties . PREFIX + \"<STR_LIT>\" ; String ENDPOINT_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENDPOINT + \"<STR_LIT>\" + NacosProperties . ENDPOINT_PLACEHOLDER + \"<STR_LIT>\" ; String NAMESPACE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + NAMESPACE + \"<STR_LIT>\" + NacosProperties . NAMESPACE_PLACEHOLDER + \"<STR_LIT>\" ; String ACCESS_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ACCESS_KEY + \"<STR_LIT>\" + NacosProperties . ACCESS_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SECRET_KEY_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SECRET_KEY + \"<STR_LIT>\" + NacosProperties . SECRET_KEY_PLACEHOLDER + \"<STR_LIT>\" ; String SERVER_ADDR_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + SERVER_ADDR + \"<STR_LIT>\" + NacosProperties . SERVER_ADDR_PLACEHOLDER + \"<STR_LIT>\" ; String CONTEXT_PATH_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CONTEXT_PATH + \"<STR_LIT>\" + NacosProperties . CONTEXT_PATH_PLACEHOLDER + \"<STR_LIT>\" ; String CLUSTER_NAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + CLUSTER_NAME + \"<STR_LIT>\" + NacosProperties . CLUSTER_NAME_PLACEHOLDER + \"<STR_LIT>\" ; String ENCODE_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + ENCODE + \"<STR_LIT>\" + NacosProperties . ENCODE_PLACEHOLDER + \"<STR_LIT>\" ; String USERNAME_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + USERNAME + \"<STR_LIT>\" + NacosProperties . USERNAME_PLACEHOLDER + \"<STR_LIT>\" ; String PASSWORD_PLACEHOLDER = \"<STR_LIT>\" + DISCOVERY_PREFIX + PASSWORD + \"<STR_LIT>\" + NacosProperties . PASSWORD_PLACEHOLDER + \"<STR_LIT>\" ; NacosProperties globalProperties ( ) default @ NacosProperties ( username = USERNAME_PLACEHOLDER , password = PASSWORD_PLACEHOLDER , endpoint = ENDPOINT_PLACEHOLDER , namespace = NAMESPACE_PLACEHOLDER , accessKey = ACCESS_KEY_PLACEHOLDER , secretKey = SECRET_KEY_PLACEHOLDER , serverAddr = SERVER_ADDR_PLACEHOLDER , contextPath = CONTEXT_PATH_PLACEHOLDER , clusterName = CLUSTER_NAME_PLACEHOLDER , encode = ENCODE_PLACEHOLDER ) ; }"}, {"input": "package com . xcs . wx . msg . impl ; import com . xcs . wx . domain . vo . MsgVO ; import com . xcs . wx . msg . MsgStrategy ; import org . springframework . stereotype . Service ; @ Service public class FileMsgStrategy implements MsgStrategy { @ Override public boolean support ( Integer type , Integer subType ) { return type == <NUM_LIT> && subType == <NUM_LIT> ; } @ Override public void process ( MsgVO msgVO ) {", "output": "msgVO . setStrContent ( \"<STR_LIT>\" ) ; } }"}, {"input": "package ginyi . framework . security . context ; import ginyi . common . utils . text . Convert ; import org . springframework . web . context . request . RequestAttributes ; import org . springframework . web . context . request . RequestContextHolder ; public class PermissionContextHolder { private static final String PERMISSION_CONTEXT_ATTRIBUTES = \"<STR_LIT>\" ; public static void setContext ( String permission ) { RequestContextHolder . currentRequestAttributes ( ) . setAttribute ( PERMISSION_CONTEXT_ATTRIBUTES , permission , RequestAttributes . SCOPE_REQUEST ) ; }", "output": "public static String getContext ( ) { return Convert . toStr ( RequestContextHolder . currentRequestAttributes ( ) . getAttribute ( PERMISSION_CONTEXT_ATTRIBUTES , RequestAttributes . SCOPE_REQUEST ) ) ; } }"}, {"input": "package io . github . chensheng . dddboot . openfeign . httpclient ; import io . github . chensheng . dddboot . openfeign . config . OpenFeignProperties ; import org . apache . http . client . config . CookieSpecs ; import org . apache . http . client . config . RequestConfig ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . config . SocketConfig ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . NoopHostnameVerifier ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClientBuilder ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . http . ssl . SSLContextBuilder ; import org . apache . http . ssl . TrustStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . springframework . util . Assert ; import javax . net . ssl . SSLContext ; import java . security . KeyManagementException ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; public class PoolingHttpClient { private static final Logger logger = LoggerFactory . getLogger ( PoolingHttpClient . class ) ; private static final String [ ] SUPPORTED_PROTOCOLS = new String [ ] { \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" , \"<STR_LIT>\" } ; private static final TrustStrategy TRUST_ALL_STRATEGY = new TrustStrategy ( ) { @ Override public boolean isTrusted ( X509Certificate [ ] chain , String authType ) throws CertificateException {", "output": "return true ; } } ; private OpenFeignProperties . HttpClient config ; private CloseableHttpClient client ; public PoolingHttpClient ( OpenFeignProperties properties ) { Assert . notNull ( properties , \"<STR_LIT>\" ) ; Assert . notNull ( properties . getHttpclient ( ) , \"<STR_LIT>\" ) ; this . config = properties . getHttpclient ( ) ; this . initClient ( ) ; } public CloseableHttpClient get ( ) { return client ; } private void initClient ( ) { Registry < ConnectionSocketFactory > registry = createRegistry ( ) ; PoolingHttpClientConnectionManager poolingConnMgr = new PoolingHttpClientConnectionManager ( registry ) ; poolingConnMgr . setMaxTotal ( config . getMaxConnTotal ( ) ) ; poolingConnMgr . setDefaultMaxPerRoute ( config . getMaxConnPerRoute ( ) ) ; SocketConfig socketConfig = SocketConfig . custom ( ) . setSoTimeout ( config . getSocketTimeoutMillis ( ) ) . setTcpNoDelay ( true ) . build ( ) ; RequestConfig requestConfig = RequestConfig . custom ( ) . setCookieSpec ( CookieSpecs . IGNORE_COOKIES ) . setSocketTimeout ( config . getSocketTimeoutMillis ( ) ) . setConnectTimeout ( config . getConnectTimeoutMillis ( ) ) . setConnectionRequestTimeout ( config . getConnectionRequestTimeoutMillis ( ) ) . build ( ) ; poolingConnMgr . setDefaultSocketConfig ( socketConfig ) ; HttpClientBuilder httpClientBuilder = HttpClients . custom ( ) . setDefaultSocketConfig ( socketConfig ) . setDefaultRequestConfig ( requestConfig ) . setConnectionManager ( poolingConnMgr ) ; client = httpClientBuilder . build ( ) ; } private Registry < ConnectionSocketFactory > createRegistry ( ) { try { SSLContext sslContext = new SSLContextBuilder ( ) . loadTrustMaterial ( null , TRUST_ALL_STRATEGY ) . build ( ) ; SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory ( sslContext , SUPPORTED_PROTOCOLS , null , NoopHostnameVerifier . INSTANCE ) ; return RegistryBuilder . < ConnectionSocketFactory > create ( ) . register ( \"<STR_LIT>\" , new PlainConnectionSocketFactory ( ) ) . register ( \"<STR_LIT>\" , sslConnectionSocketFactory ) . build ( ) ; } catch ( NoSuchAlgorithmException e ) { logger . error ( \"<STR_LIT>\" , e ) ; } catch ( KeyStoreException e ) { logger . error ( \"<STR_LIT>\" , e ) ; } catch ( KeyManagementException e ) { logger . error ( \"<STR_LIT>\" , e ) ; } return null ; } }"}, {"input": "package cn . org . alan . exam . converter ; import cn . org . alan . exam . model . entity . Exam ; import cn . org . alan . exam . model . entity . Grade ; import cn . org . alan . exam . model . entity . Repo ; import cn . org . alan . exam . model . vo . GradeVO ; import cn . org . alan . exam . model . vo . record . ExamRecordVO ; import cn . org . alan . exam . model . vo . record . ExerciseRecordVO ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import org . mapstruct . Mapper ; import org . springframework . stereotype . Component ; @ Component @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface RecordConverter {", "output": "Page < ExerciseRecordVO > pageRepoEntityToVo ( Page < Repo > page ) ; }"}, {"input": "package com . yf . system . modules . config . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . config . entity . CfgBase ; public interface CfgBaseMapper extends BaseMapper < CfgBase > {", "output": "}"}, {"input": "package org . springblade . web . model . param ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; import java . math . BigDecimal ; @ Data public class EntrustParam implements Serializable { @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String exchangeCoinStr ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal price ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String direction ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal amount ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal money ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal triggerPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal takeProfitPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private BigDecimal stopLossPrice ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer pattern ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer patternType ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer contractType ;", "output": "}"}, {"input": "package ginyi . system . service ; import ginyi . system . domain . SysDept ; import ginyi . system . domain . model . dto . DeptDto ; import ginyi . system . domain . model . vo . BaseVo ; import ginyi . system . domain . model . vo . DeptVo ; import java . util . Set ; public interface ISysDeptService { public BaseVo < SysDept > list ( DeptDto deptDto , Long page , Long pageSize ) ; public DeptVo getDeptByDeptId ( Long deptId ) ; public void addDept ( DeptDto deptDto ) ; public void updateDept ( DeptDto deptDto ) ; public void removeDeptById ( Long deptId ) ; public void removeDeptByIds ( Set < Long > ids ) ; public void updateStatus ( DeptDto deptDto ) ;", "output": "}"}, {"input": "package io . github . chensheng . dddboot . excel . test ; import io . github . chensheng . dddboot . excel . ExcelUtil ; import io . github . chensheng . dddboot . excel . core . NumericUtil ; import io . github . chensheng . dddboot . tools . io . FileUtil ; import io . github . chensheng . dddboot . tools . number . RandomUtil ; import org . junit . Assert ; import org . junit . Test ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Date ; import java . util . List ; public class ExcelUtilTest { @ Test public void testExport ( ) throws IOException { List < ExcelDto > excelDtoList = new ArrayList < ExcelDto > ( ) ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; i ++ ) { ExcelDto excelDto = new ExcelDto ( ) ; excelDto . setFieldString ( \"<STR_LIT>\" + RandomUtil . randomStringFixLength ( <NUM_LIT> ) ) ; excelDto . setFieldInteger ( RandomUtil . nextInt ( <NUM_LIT> , <NUM_LIT> ) ) ; Double doubleValue = RandomUtil . nextDouble ( <NUM_LIT> , <NUM_LIT> ) ; String doubleText = NumericUtil . formatNumericInNeed ( String . valueOf ( doubleValue ) , <NUM_LIT> ) ; excelDto . setFieldDouble ( Double . parseDouble ( doubleText ) ) ; excelDto . setFieldDate ( new Date ( System . currentTimeMillis ( ) + i * <NUM_LIT> * <NUM_LIT> ) ) ; excelDtoList . add ( excelDto ) ; } Path path = FileUtil . createTempFile ( ) ; File file = path . toFile ( ) ; ExcelUtil . write ( new FileOutputStream ( file ) , excelDtoList ) ; List < ExcelDto > readExcelDtoList = ExcelUtil . read ( new FileInputStream ( file ) , ExcelDto . class ) ; Assert . assertNotNull ( readExcelDtoList ) ; Assert . assertEquals ( excelDtoList . size ( ) , readExcelDtoList . size ( ) ) ; for ( int i = <NUM_LIT> ; i < excelDtoList . size ( ) ; i ++ ) { ExcelDto originalDto = excelDtoList . get ( i ) ; ExcelDto readDto = readExcelDtoList . get ( i ) ;", "output": "Assert . assertEquals ( originalDto . getFieldString ( ) , readDto . getFieldString ( ) ) ; Assert . assertEquals ( originalDto . getFieldInteger ( ) , readDto . getFieldInteger ( ) ) ; Assert . assertEquals ( originalDto . getFieldDouble ( ) , readDto . getFieldDouble ( ) ) ; Assert . assertEquals ( originalDto . getFieldDate ( ) . getTime ( ) , readDto . getFieldDate ( ) . getTime ( ) ) ; } } }"}, {"input": "package io . github . chensheng . dddboot . nacos . spring . util . config ; import com . alibaba . nacos . api . NacosFactory ; import com . alibaba . nacos . api . annotation . NacosProperties ; import com . alibaba . nacos . api . config . ConfigService ; import com . alibaba . nacos . api . exception . NacosException ; import io . github . chensheng . dddboot . nacos . spring . factory . NacosServiceFactory ; import io . github . chensheng . dddboot . nacos . spring . util . NacosUtils ; import io . github . chensheng . dddboot . nacos . spring . util . PropertiesPlaceholderResolver ; import org . springframework . core . convert . ConversionService ; import org . springframework . core . env . ConfigurableEnvironment ; import java . util . Properties ; public class NacosConfigLoader { private final ConfigurableEnvironment environment ; private final ConversionService conversionService ; private final PropertiesPlaceholderResolver resolver ; private NacosServiceFactory nacosServiceFactory ; private ConfigService configService ; public NacosConfigLoader ( ConfigurableEnvironment environment ) { this . environment = environment ; this . conversionService = environment . getConversionService ( ) ; this . resolver = new PropertiesPlaceholderResolver ( environment ) ; } public String load ( String dataId , String groupId , NacosProperties nacosProperties ) throws RuntimeException {", "output": "Properties properties = resolver . resolve ( nacosProperties ) ; return load ( dataId , groupId , properties ) ; } public String load ( String dataId , String groupId , Properties nacosProperties ) throws RuntimeException { try { configService = nacosServiceFactory != null ? nacosServiceFactory . createConfigService ( nacosProperties ) : NacosFactory . createConfigService ( nacosProperties ) ; } catch ( NacosException e ) { throw new RuntimeException ( \"<STR_LIT>\" + dataId + \"<STR_LIT>\" + groupId + \"<STR_LIT>\" + nacosProperties , e ) ; } return NacosUtils . getContent ( configService , dataId , groupId ) ; } public < T > T load ( String dataId , String groupId , NacosProperties nacosProperties , Class < T > targetClass ) throws RuntimeException { String config = load ( dataId , groupId , nacosProperties ) ; return conversionService . convert ( config , targetClass ) ; } public void setNacosServiceFactory ( NacosServiceFactory nacosServiceFactory ) { this . nacosServiceFactory = nacosServiceFactory ; } public ConfigService getConfigService ( ) { return configService ; } }"}, {"input": "package com . youlai . system . model . form ; import io . swagger . v3 . oas . annotations . media . Schema ; import lombok . Data ; import lombok . Getter ; import lombok . Setter ; import java . util . List ; @ Schema ( description = \"<STR_LIT>\" ) @ Data public class DictForm { @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private String code ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private Integer status ; @ Schema ( description = \"<STR_LIT>\" , example = \"<STR_LIT>\" ) private List < DictItem > dictItems ; @ Schema ( description = \"<STR_LIT>\" ) @ Getter @ Setter public static class DictItem { @ Schema ( description = \"<STR_LIT>\" ) private Long id ; @ Schema ( description = \"<STR_LIT>\" ) private String name ; @ Schema ( description = \"<STR_LIT>\" ) private String value ; @ Schema ( description = \"<STR_LIT>\" ) private Integer sort ; @ Schema ( description = \"<STR_LIT>\" ) private Integer status ; }", "output": "}"}, {"input": "package org . example . application . example . dto . command ; import lombok . Data ; import javax . validation . constraints . NotEmpty ; @ Data public class ExampleCreateCommand { @ NotEmpty ( message = \"<STR_LIT>\" ) private String username ; @ NotEmpty ( message = \"<STR_LIT>\" ) private String password ;", "output": "}"}, {"input": "package com . oddfar . campus . common . annotation ; import com . oddfar . campus . common . enums . LimitType ; import java . lang . annotation . * ; @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented public @ interface RateLimiter {", "output": "String key ( ) default \"<STR_LIT>\" ; int time ( ) default <NUM_LIT> ; int count ( ) default <NUM_LIT> ; LimitType limitType ( ) default LimitType . DEFAULT ; String message ( ) default \"<STR_LIT>\" ; }"}, {"input": "package me . zhengjie . annotation . rest ; import java . lang . annotation . Documented ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import me . zhengjie . annotation . AnonymousAccess ; import org . springframework . core . annotation . AliasFor ; import org . springframework . web . bind . annotation . RequestMapping ; import org . springframework . web . bind . annotation . RequestMethod ; @ AnonymousAccess @ Target ( ElementType . METHOD ) @ Retention ( RetentionPolicy . RUNTIME ) @ Documented @ RequestMapping ( method = RequestMethod . DELETE ) public @ interface AnonymousDeleteMapping { @ AliasFor ( annotation = RequestMapping . class ) String name ( ) default \"<STR_LIT>\" ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] value ( ) default { }", "output": "; @ AliasFor ( annotation = RequestMapping . class ) String [ ] path ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] params ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] headers ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] consumes ( ) default { } ; @ AliasFor ( annotation = RequestMapping . class ) String [ ] produces ( ) default { } ; }"}, {"input": "package com . yf . plugins . upload . local . controller ; import com . yf . ability . Constant ; import com . yf . ability . upload . factory . UploadFactory ; import com . yf . base . api . api . ApiRest ; import com . yf . base . api . api . controller . BaseController ; import com . yf . plugins . upload . local . dto . UploadReqDTO ; import com . yf . plugins . upload . local . dto . UploadRespDTO ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . extern . log4j . Log4j2 ; import org . springframework . beans . factory . annotation . Autowired ; import org . springframework . web . bind . annotation . GetMapping ; import org . springframework . web . bind . annotation . ModelAttribute ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RestController ; import javax . servlet . http . HttpServletRequest ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; @ Log4j2 @ Api ( tags = {", "output": "\"<STR_LIT>\" } ) @ RestController public class UploadController extends BaseController { @ Autowired private UploadFactory uploadFactory ; @ PostMapping ( \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public ApiRest < UploadRespDTO > upload ( @ ModelAttribute UploadReqDTO reqDTO ) { UploadRespDTO respDTO = uploadFactory . getService ( ) . upload ( reqDTO . getFile ( ) ) ; return super . success ( respDTO ) ; } @ GetMapping ( Constant . FILE_PREFIX + \"<STR_LIT>\" ) @ ApiOperation ( value = \"<STR_LIT>\" , notes = \"<STR_LIT>\" ) public void download ( HttpServletRequest request , HttpServletResponse response ) throws IOException { uploadFactory . getService ( ) . download ( request , response ) ; } }"}, {"input": "package com . xcs . wx . domain ; import com . baomidou . mybatisplus . annotation . TableField ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableName ; import lombok . Data ; @ Data @ TableName ( \"<STR_LIT>\" ) public class ContactLabel { @ TableId ( \"<STR_LIT>\" ) private String labelId ; @ TableField ( \"<STR_LIT>\" ) private String labelName ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved1 ; @ TableField ( \"<STR_LIT>\" ) private Integer reserved2 ; @ TableField ( \"<STR_LIT>\" ) private String reserved3 ; @ TableField ( \"<STR_LIT>\" ) private String reserved4 ; @ TableField ( \"<STR_LIT>\" ) private String reserved5 ; @ TableField ( \"<STR_LIT>\" ) private String respData ;", "output": "}"}, {"input": "package com . yf . ability . excel . service ; public interface ExcelDictService { String findDictText ( String code , String key ) ;", "output": "String findTableText ( String table , String text , String code , String key ) ; }"}, {"input": "package io . github . chensheng . dddboot . tools . base . type ; import io . github . chensheng . dddboot . tools . base . ExceptionUtil ; public class CloneableException extends Exception implements Cloneable { private static final long serialVersionUID = - <NUM_LIT> ; protected String message ; public CloneableException ( ) { super ( ( Throwable ) null ) ; } public CloneableException ( String message ) { super ( ( Throwable ) null ) ; this . message = message ; } public CloneableException ( String message , Throwable cause ) { super ( cause ) ; this . message = message ; } @ Override public CloneableException clone ( ) { try { return ( CloneableException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } } @ Override public String getMessage ( ) { return message ; } public CloneableException setStackTrace ( Class < ? > throwClazz , String throwMethod ) { ExceptionUtil . setStackTrace ( this , throwClazz , throwMethod ) ; return this ; } public CloneableException clone ( String message ) {", "output": "CloneableException newException = this . clone ( ) ; newException . setMessage ( message ) ; return newException ; } public CloneableException setMessage ( String message ) { this . message = message ; return this ; } }"}, {"input": "package org . springblade . entity ; import com . baomidou . mybatisplus . annotation . IdType ; import com . baomidou . mybatisplus . annotation . TableId ; import com . baomidou . mybatisplus . annotation . TableLogic ; import com . baomidou . mybatisplus . annotation . TableName ; import com . fasterxml . jackson . databind . annotation . JsonSerialize ; import com . fasterxml . jackson . databind . ser . std . ToStringSerializer ; import io . swagger . annotations . ApiModel ; import io . swagger . annotations . ApiModelProperty ; import lombok . Data ; import java . io . Serializable ; @ Data @ TableName ( \"<STR_LIT>\" ) @ ApiModel ( value = \"<STR_LIT>\" , description = \"<STR_LIT>\" ) public class BladeDept implements Serializable { private static final long serialVersionUID = <NUM_LIT> ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) @ TableId ( value = \"<STR_LIT>\" , type = IdType . ASSIGN_ID ) private Long id ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String tenantId ; @ JsonSerialize ( using = ToStringSerializer . class ) @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Long parentId ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String deptName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String fullName ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String ancestors ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer deptCategory ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer sort ; @ ApiModelProperty ( value = \"<STR_LIT>\" ) private String remark ; @ TableLogic @ ApiModelProperty ( value = \"<STR_LIT>\" ) private Integer isDeleted ;", "output": "}"}, {"input": "package org . springblade . config . util . converter ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformField ; import lombok . NoArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . config . util . converter . impl . * ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; @ Slf4j @ NoArgsConstructor public class ControlTypeUtil { public static FieldCommentConverter getFieldCommentConverter ( CgformField onlCgformField ) { String fieldShowType = onlCgformField . getFieldShowType ( ) ; FieldCommentConverter object = null ; switch ( fieldShowType ) { case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new RadioFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : case \"<STR_LIT>\" : object = new CheckboxFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelSearchFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new CatTreeFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new LinkDownFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelDepartFieldCommentConverter ( onlCgformField ) ; break ; case \"<STR_LIT>\" : object = new SelUserFieldCommentConverter ( onlCgformField ) ; break ; default : } return object ; } public static Map < String , FieldCommentConverter > getFieldCommentConverters ( List < CgformField > onlCgformFields ) { Map < String , FieldCommentConverter > hashMap = new HashMap < > ( ) ; for ( CgformField onlCgformField : onlCgformFields ) { FieldCommentConverter fieldCommentConverter ; if ( ConvertUtils . isNotEmpty ( onlCgformField . getConverter ( ) ) ) { fieldCommentConverter = getFieldCommentConverter ( onlCgformField . getConverter ( ) . trim ( ) ) ; } else { fieldCommentConverter = getFieldCommentConverter ( onlCgformField ) ; } if ( fieldCommentConverter != null ) {", "output": "hashMap . put ( onlCgformField . getDbFieldName ( ) , fieldCommentConverter ) ; } } return hashMap ; } private static FieldCommentConverter getFieldCommentConverter ( String s ) { Object object = null ; if ( s . indexOf ( \"<STR_LIT>\" ) > <NUM_LIT> ) { try { object = MyClassLoader . getClassByScn ( s ) . newInstance ( ) ; } catch ( InstantiationException | IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else { object = SpringContextUtils . getBean ( s ) ; } if ( object instanceof FieldCommentConverter ) { return ( FieldCommentConverter ) object ; } else { return null ; } } }"}, {"input": "package org . springblade . plugin . message . feign ; import org . springblade . core . tool . api . R ; import org . springblade . plugin . message . model . SocketMsgModel ; import org . springframework . cloud . openfeign . FeignClient ; import org . springframework . web . bind . annotation . PostMapping ; import org . springframework . web . bind . annotation . RequestBody ; @ FeignClient ( value = \"<STR_LIT>\" ) public interface IMessageClient {", "output": "String API_PREFIX = \"<STR_LIT>\" ; String SEND_SOCKET_MSG = API_PREFIX + \"<STR_LIT>\" ; @ PostMapping ( SEND_SOCKET_MSG ) R < Boolean > sendSocketMsg ( @ RequestBody SocketMsgModel model ) ; }"}, {"input": "package com . xcs . wx . service ; import com . xcs . wx . domain . dto . RecoverContactDTO ; import com . xcs . wx . domain . vo . RecoverContactVO ; import java . util . List ; public interface RecoverContactService {", "output": "List < RecoverContactVO > queryRecoverContact ( RecoverContactDTO recoverContactDTO ) ; String exportRecoverContact ( ) ; }"}, {"input": "package me . zhengjie . service . impl ; import com . alibaba . fastjson . JSON ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . qiniu . common . QiniuException ; import com . qiniu . http . Response ; import com . qiniu . storage . BucketManager ; import com . qiniu . storage . Configuration ; import com . qiniu . storage . UploadManager ; import com . qiniu . storage . model . DefaultPutRet ; import com . qiniu . storage . model . FileInfo ; import com . qiniu . util . Auth ; import lombok . RequiredArgsConstructor ; import me . zhengjie . domain . QiniuConfig ; import me . zhengjie . domain . QiniuContent ; import me . zhengjie . mapper . QiniuContentMapper ; import me . zhengjie . domain . vo . QiniuQueryCriteria ; import me . zhengjie . utils . PageResult ; import me . zhengjie . utils . QiNiuUtil ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . service . QiniuContentService ; import me . zhengjie . utils . FileUtil ; import me . zhengjie . utils . PageUtil ; import org . springframework . beans . factory . annotation . Value ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . * ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class QiniuContentServiceImpl extends ServiceImpl < QiniuContentMapper , QiniuContent > implements QiniuContentService { private final QiniuContentMapper qiniuContentMapper ; @ Value ( \"<STR_LIT>\" ) private Long maxSize ; @ Override public PageResult < QiniuContent > queryAll ( QiniuQueryCriteria criteria , Page < Object > page ) { return PageUtil . toPage ( qiniuContentMapper . findAll ( criteria , page ) ) ; } @ Override public List < QiniuContent > queryAll ( QiniuQueryCriteria criteria ) { return qiniuContentMapper . findAll ( criteria ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public QiniuContent upload ( MultipartFile file , QiniuConfig qiniuConfig ) { FileUtil . checkSize ( maxSize , file . getSize ( ) ) ; if ( qiniuConfig . getId ( ) == null ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } Configuration cfg = new Configuration ( QiNiuUtil . getRegion ( qiniuConfig . getZone ( ) ) ) ; UploadManager uploadManager = new UploadManager ( cfg ) ; Auth auth = Auth . create ( qiniuConfig . getAccessKey ( ) , qiniuConfig . getSecretKey ( ) ) ; String upToken = auth . uploadToken ( qiniuConfig . getBucket ( ) ) ; try { String key = file . getOriginalFilename ( ) ; if ( qiniuContentMapper . findByKey ( key ) != null ) { key = QiNiuUtil . getKey ( key ) ; } Response response = uploadManager . put ( file . getBytes ( ) , key , upToken ) ; DefaultPutRet putRet = JSON . parseObject ( response . bodyString ( ) , DefaultPutRet . class ) ; QiniuContent content = qiniuContentMapper . findByKey ( FileUtil . getFileNameNoEx ( putRet . key ) ) ; if ( content == null ) { QiniuContent qiniuContent = new QiniuContent ( ) ; qiniuContent . setSuffix ( FileUtil . getExtensionName ( putRet . key ) ) ; qiniuContent . setBucket ( qiniuConfig . getBucket ( ) ) ; qiniuContent . setType ( qiniuConfig . getType ( ) ) ; qiniuContent . setKey ( FileUtil . getFileNameNoEx ( putRet . key ) ) ; qiniuContent . setUrl ( qiniuConfig . getHost ( ) + \"<STR_LIT>\" + putRet . key ) ; qiniuContent . setSize ( FileUtil . getSize ( Integer . parseInt ( String . valueOf ( file . getSize ( ) ) ) ) ) ; save ( qiniuContent ) ; } return content ; } catch ( Exception e ) { throw new BadRequestException ( e . getMessage ( ) ) ; } } @ Override public String download ( QiniuContent content , QiniuConfig config ) { String finalUrl ; String type = \"<STR_LIT>\" ; if ( type . equals ( content . getType ( ) ) ) { finalUrl = content . getUrl ( ) ; } else {", "output": "Auth auth = Auth . create ( config . getAccessKey ( ) , config . getSecretKey ( ) ) ; long expireInSeconds = <NUM_LIT> ; finalUrl = auth . privateDownloadUrl ( content . getUrl ( ) , expireInSeconds ) ; } return finalUrl ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( QiniuContent content , QiniuConfig config ) { Configuration cfg = new Configuration ( QiNiuUtil . getRegion ( config . getZone ( ) ) ) ; Auth auth = Auth . create ( config . getAccessKey ( ) , config . getSecretKey ( ) ) ; BucketManager bucketManager = new BucketManager ( auth , cfg ) ; try { bucketManager . delete ( content . getBucket ( ) , content . getKey ( ) + \"<STR_LIT>\" + content . getSuffix ( ) ) ; } catch ( QiniuException ex ) { ex . printStackTrace ( ) ; } finally { removeById ( content ) ; } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void synchronize ( QiniuConfig config ) { if ( config . getId ( ) == null ) { throw new BadRequestException ( \"<STR_LIT>\" ) ; } Configuration cfg = new Configuration ( QiNiuUtil . getRegion ( config . getZone ( ) ) ) ; Auth auth = Auth . create ( config . getAccessKey ( ) , config . getSecretKey ( ) ) ; BucketManager bucketManager = new BucketManager ( auth , cfg ) ; String prefix = \"<STR_LIT>\" ; int limit = <NUM_LIT> ; String delimiter = \"<STR_LIT>\" ; BucketManager . FileListIterator fileListIterator = bucketManager . createFileListIterator ( config . getBucket ( ) , prefix , limit , delimiter ) ; while ( fileListIterator . hasNext ( ) ) { QiniuContent qiniuContent ; FileInfo [ ] items = fileListIterator . next ( ) ; for ( FileInfo item : items ) { if ( qiniuContentMapper . findByKey ( FileUtil . getFileNameNoEx ( item . key ) ) == null ) { qiniuContent = new QiniuContent ( ) ; qiniuContent . setSize ( FileUtil . getSize ( Integer . parseInt ( String . valueOf ( item . fsize ) ) ) ) ; qiniuContent . setSuffix ( FileUtil . getExtensionName ( item . key ) ) ; qiniuContent . setKey ( FileUtil . getFileNameNoEx ( item . key ) ) ; qiniuContent . setType ( config . getType ( ) ) ; qiniuContent . setBucket ( config . getBucket ( ) ) ; qiniuContent . setUrl ( config . getHost ( ) + \"<STR_LIT>\" + item . key ) ; save ( qiniuContent ) ; } } } } @ Override @ Transactional ( rollbackFor = Exception . class ) public void deleteAll ( Long [ ] ids , QiniuConfig config ) { for ( Long id : ids ) { delete ( getById ( id ) , config ) ; } } @ Override public void downloadList ( List < QiniuContent > queryAll , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( QiniuContent content : queryAll ) { Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , content . getKey ( ) ) ; map . put ( \"<STR_LIT>\" , content . getSuffix ( ) ) ; map . put ( \"<STR_LIT>\" , content . getBucket ( ) ) ; map . put ( \"<STR_LIT>\" , content . getSize ( ) ) ; map . put ( \"<STR_LIT>\" , content . getType ( ) ) ; map . put ( \"<STR_LIT>\" , content . getUpdateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } }"}, {"input": "package com . youlai . system . model . bo ; import lombok . Data ; import java . util . Set ; @ Data public class RolePermsBO { private String roleCode ; private Set < String > perms ;", "output": "}"}, {"input": "package org . springblade . gateway . filter ; import lombok . AllArgsConstructor ; import lombok . extern . slf4j . Slf4j ; import org . springblade . gateway . provider . AuthProvider ; import org . springframework . cloud . gateway . filter . GatewayFilterChain ; import org . springframework . cloud . gateway . filter . GlobalFilter ; import org . springframework . core . Ordered ; import org . springframework . core . io . buffer . DataBuffer ; import org . springframework . core . io . buffer . DataBufferUtils ; import org . springframework . http . HttpMethod ; import org . springframework . http . server . reactive . ServerHttpRequestDecorator ; import org . springframework . stereotype . Component ; import org . springframework . web . server . ServerWebExchange ; import reactor . core . publisher . Flux ; import reactor . core . publisher . Mono ; import java . nio . CharBuffer ; import java . nio . charset . StandardCharsets ; import java . util . concurrent . atomic . AtomicReference ; @ Slf4j @ Component @ AllArgsConstructor public class BodyFilter implements GlobalFilter , Ordered { @ Override public Mono < Void > filter ( ServerWebExchange exchange , GatewayFilterChain chain ) { if ( exchange . getRequest ( ) . getPath ( ) . toString ( ) . matches ( AuthProvider . API_PATH_REG ) && HttpMethod . POST . equals ( exchange . getRequest ( ) . getMethod ( ) ) ) { return DataBufferUtils . join ( exchange . getRequest ( ) . getBody ( ) ) . doOnNext ( buffer -> { CharBuffer charBuffer = StandardCharsets . UTF_8 . decode ( buffer . asByteBuffer ( ) ) ;", "output": "exchange . getAttributes ( ) . put ( AuthProvider . BODY_REQUEST_BODY_PARAMETERS , charBuffer . toString ( ) ) ; DataBufferUtils . release ( buffer ) ; } ) . then ( chain . filter ( exchange ) ) ; } return chain . filter ( exchange ) ; } @ Override public int getOrder ( ) { return - <NUM_LIT> ; } }"}, {"input": "package me . zhengjie . modules . system . service . impl ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import lombok . RequiredArgsConstructor ; import me . zhengjie . config . FileProperties ; import me . zhengjie . exception . BadRequestException ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . UserCacheManager ; import me . zhengjie . modules . system . domain . Job ; import me . zhengjie . modules . system . domain . Role ; import me . zhengjie . modules . system . domain . User ; import me . zhengjie . exception . EntityExistException ; import me . zhengjie . exception . EntityNotFoundException ; import me . zhengjie . modules . system . domain . vo . UserQueryCriteria ; import me . zhengjie . modules . system . mapper . UserJobMapper ; import me . zhengjie . modules . system . mapper . UserMapper ; import me . zhengjie . modules . system . mapper . UserRoleMapper ; import me . zhengjie . modules . system . service . UserService ; import me . zhengjie . utils . * ; import org . springframework . cache . annotation . CacheConfig ; import org . springframework . cache . annotation . Cacheable ; import org . springframework . stereotype . Service ; import org . springframework . transaction . annotation . Transactional ; import org . springframework . web . multipart . MultipartFile ; import javax . servlet . http . HttpServletResponse ; import javax . validation . constraints . NotBlank ; import java . io . File ; import java . io . IOException ; import java . util . * ; import java . util . stream . Collectors ; @ Service @ RequiredArgsConstructor @ CacheConfig ( cacheNames = \"<STR_LIT>\" ) public class UserServiceImpl extends ServiceImpl < UserMapper , User > implements UserService { private final UserMapper userMapper ; private final UserJobMapper userJobMapper ; private final UserRoleMapper userRoleMapper ; private final FileProperties properties ; private final RedisUtils redisUtils ; private final UserCacheManager userCacheManager ; private final OnlineUserService onlineUserService ; @ Override public PageResult < User > queryAll ( UserQueryCriteria criteria , Page < Object > page ) { criteria . setOffset ( page . offset ( ) ) ; List < User > users = userMapper . findAll ( criteria ) ; Long total = userMapper . countAll ( criteria ) ; return PageUtil . toPage ( users , total ) ; } @ Override public List < User > queryAll ( UserQueryCriteria criteria ) { return userMapper . findAll ( criteria ) ; } @ Override @ Cacheable ( key = \"<STR_LIT>\" ) @ Transactional ( rollbackFor = Exception . class ) public User findById ( long id ) { return getById ( id ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void create ( User resources ) { resources . setDeptId ( resources . getDept ( ) . getId ( ) ) ; if ( userMapper . findByUsername ( resources . getUsername ( ) ) != null ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getUsername ( ) ) ; } if ( userMapper . findByEmail ( resources . getEmail ( ) ) != null ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getEmail ( ) ) ; } if ( userMapper . findByPhone ( resources . getPhone ( ) ) != null ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getPhone ( ) ) ; } save ( resources ) ; userJobMapper . insertData ( resources . getId ( ) , resources . getJobs ( ) ) ; userRoleMapper . insertData ( resources . getId ( ) , resources . getRoles ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void update ( User resources ) throws Exception { User user = getById ( resources . getId ( ) ) ; User user1 = userMapper . findByUsername ( resources . getUsername ( ) ) ; User user2 = userMapper . findByEmail ( resources . getEmail ( ) ) ; User user3 = userMapper . findByPhone ( resources . getPhone ( ) ) ; if ( user1 != null && ! user . getId ( ) . equals ( user1 . getId ( ) ) ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getUsername ( ) ) ; } if ( user2 != null && ! user . getId ( ) . equals ( user2 . getId ( ) ) ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getEmail ( ) ) ; } if ( user3 != null && ! user . getId ( ) . equals ( user3 . getId ( ) ) ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getPhone ( ) ) ; } if ( ! resources . getRoles ( ) . equals ( user . getRoles ( ) ) ) { redisUtils . del ( CacheKey . DATA_USER + resources . getId ( ) ) ; redisUtils . del ( CacheKey . MENU_USER + resources . getId ( ) ) ; redisUtils . del ( CacheKey . ROLE_AUTH + resources . getId ( ) ) ; } if ( ! Objects . equals ( resources . getDept ( ) , user . getDept ( ) ) ) { redisUtils . del ( CacheKey . DATA_USER + resources . getId ( ) ) ; } if ( ! resources . getEnabled ( ) ) { onlineUserService . kickOutForUsername ( resources . getUsername ( ) ) ; } user . setDeptId ( resources . getDept ( ) . getId ( ) ) ; user . setUsername ( resources . getUsername ( ) ) ; user . setEmail ( resources . getEmail ( ) ) ; user . setEnabled ( resources . getEnabled ( ) ) ; user . setRoles ( resources . getRoles ( ) ) ; user . setDept ( resources . getDept ( ) ) ; user . setJobs ( resources . getJobs ( ) ) ; user . setPhone ( resources . getPhone ( ) ) ; user . setNickName ( resources . getNickName ( ) ) ; user . setGender ( resources . getGender ( ) ) ; saveOrUpdate ( user ) ; delCaches ( user . getId ( ) , user . getUsername ( ) ) ; userJobMapper . deleteByUserId ( resources . getId ( ) ) ; userJobMapper . insertData ( resources . getId ( ) , resources . getJobs ( ) ) ; userRoleMapper . deleteByUserId ( resources . getId ( ) ) ; userRoleMapper . insertData ( resources . getId ( ) , resources . getRoles ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateCenter ( User resources ) { User user = getById ( resources . getId ( ) ) ; User user1 = userMapper . findByPhone ( resources . getPhone ( ) ) ; if ( user1 != null && ! user . getId ( ) . equals ( user1 . getId ( ) ) ) { throw new EntityExistException ( User . class , \"<STR_LIT>\" , resources . getPhone ( ) ) ; } user . setNickName ( resources . getNickName ( ) ) ; user . setPhone ( resources . getPhone ( ) ) ; user . setGender ( resources . getGender ( ) ) ; saveOrUpdate ( user ) ; delCaches ( user . getId ( ) , user . getUsername ( ) ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void delete ( Set < Long > ids ) { for ( Long id : ids ) { User user = getById ( id ) ; delCaches ( user . getId ( ) , user . getUsername ( ) ) ; } userMapper . deleteBatchIds ( ids ) ; userJobMapper . deleteByUserIds ( ids ) ; userRoleMapper . deleteByUserIds ( ids ) ; } @ Override public User findByName ( String userName ) { return userMapper . findByUsername ( userName ) ; } @ Override public User getLoginData ( String userName ) { User user = userMapper . findByUsername ( userName ) ; if ( user == null ) { throw new EntityNotFoundException ( User . class , \"<STR_LIT>\" , userName ) ; } else { return user ; }", "output": "} @ Override @ Transactional ( rollbackFor = Exception . class ) public void updatePass ( String username , String pass ) { userMapper . updatePass ( username , pass , new Date ( ) ) ; flushCache ( username ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void resetPwd ( Set < Long > ids , String pwd ) { userMapper . resetPwd ( ids , pwd ) ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public Map < String , String > updateAvatar ( MultipartFile multipartFile ) { FileUtil . checkSize ( properties . getAvatarMaxSize ( ) , multipartFile . getSize ( ) ) ; String image = \"<STR_LIT>\" ; String fileType = FileUtil . getExtensionName ( multipartFile . getOriginalFilename ( ) ) ; if ( fileType != null && ! image . contains ( fileType ) ) { throw new BadRequestException ( \"<STR_LIT>\" + image + \"<STR_LIT>\" ) ; } User user = userMapper . findByUsername ( SecurityUtils . getCurrentUsername ( ) ) ; String oldPath = user . getAvatarPath ( ) ; File file = FileUtil . upload ( multipartFile , properties . getPath ( ) . getAvatar ( ) ) ; user . setAvatarPath ( Objects . requireNonNull ( file ) . getPath ( ) ) ; user . setAvatarName ( file . getName ( ) ) ; saveOrUpdate ( user ) ; if ( StringUtils . isNotBlank ( oldPath ) ) { FileUtil . del ( oldPath ) ; } @ NotBlank String username = user . getUsername ( ) ; flushCache ( username ) ; return new HashMap < String , String > ( <NUM_LIT> ) { { put ( \"<STR_LIT>\" , file . getName ( ) ) ; } } ; } @ Override @ Transactional ( rollbackFor = Exception . class ) public void updateEmail ( String username , String email ) { userMapper . updateEmail ( username , email ) ; flushCache ( username ) ; } @ Override public void download ( List < User > users , HttpServletResponse response ) throws IOException { List < Map < String , Object > > list = new ArrayList < > ( ) ; for ( User user : users ) { List < String > roles = user . getRoles ( ) . stream ( ) . map ( Role :: getName ) . collect ( Collectors . toList ( ) ) ; Map < String , Object > map = new LinkedHashMap < > ( ) ; map . put ( \"<STR_LIT>\" , user . getUsername ( ) ) ; map . put ( \"<STR_LIT>\" , roles ) ; map . put ( \"<STR_LIT>\" , user . getDept ( ) . getName ( ) ) ; map . put ( \"<STR_LIT>\" , user . getJobs ( ) . stream ( ) . map ( Job :: getName ) . collect ( Collectors . toList ( ) ) ) ; map . put ( \"<STR_LIT>\" , user . getEmail ( ) ) ; map . put ( \"<STR_LIT>\" , user . getEnabled ( ) ? \"<STR_LIT>\" : \"<STR_LIT>\" ) ; map . put ( \"<STR_LIT>\" , user . getPhone ( ) ) ; map . put ( \"<STR_LIT>\" , user . getPwdResetTime ( ) ) ; map . put ( \"<STR_LIT>\" , user . getCreateTime ( ) ) ; list . add ( map ) ; } FileUtil . downloadExcel ( list , response ) ; } public void delCaches ( Long id , String username ) { redisUtils . del ( CacheKey . USER_ID + id ) ; flushCache ( username ) ; } private void flushCache ( String username ) { userCacheManager . cleanUserCache ( username ) ; } }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . ChatRoom ; import com . xcs . wx . domain . dto . ChatRoomDTO ; import com . xcs . wx . domain . vo . ChatRoomVO ; import com . xcs . wx . domain . vo . ExportChatRoomVO ; import com . xcs . wx . mapper . ChatRoomMapper ; import com . xcs . wx . repository . ChatRoomRepository ; import org . springframework . stereotype . Repository ; import java . util . List ; @ Repository @ DS ( value = DataSourceType . MICRO_MSG_DB ) public class ChatRoomRepositoryImpl extends ServiceImpl < ChatRoomMapper , ChatRoom > implements ChatRoomRepository { @ Override public Page < ChatRoomVO > queryChatRoom ( ChatRoomDTO chatRoomDTO ) { return getBaseMapper ( ) . queryChatRoom ( new Page < > ( chatRoomDTO . getCurrent ( ) , chatRoomDTO . getPageSize ( ) ) , chatRoomDTO ) ; } @ Override public ChatRoom queryChatRoomDetail ( String chatRoomName ) { return super . getById ( chatRoomName ) ; } @ Override public int countChatRoom ( ) { return getBaseMapper ( ) . countChatRoom ( ) ; } @ Override public List < ExportChatRoomVO > exportChatRoom ( ) {", "output": "return getBaseMapper ( ) . exportChatRoom ( ) ; } }"}, {"input": "package com . xcs . wx . domain . vo ; import com . fasterxml . jackson . annotation . JsonIgnore ; import lombok . Data ; @ Data public class MsgVO { private Integer localId ; private String msgSvrId ; private Integer type ; private Integer subType ; private Long sequence ; private Integer isSender ; private Long createTime ; private String strCreateTime ; private String strContent ; private String referMsgContent ; private String strTalker ; private String avatar ; private String imgMd5 ; private String thumb ; private String image ; private String emojiUrl ; @ JsonIgnore private byte [ ] compressContent ; @ JsonIgnore private byte [ ] bytesExtra ; private WeAppInfoVO weAppInfo ; private CardLinkVO cardLink ; private String wxId ;", "output": "}"}, {"input": "package top . kangert . kspider . executor . function . extension ; import top . kangert . kspider . annotation . Comment ; import top . kangert . kspider . annotation . Example ; import top . kangert . kspider . executor . FunctionExtension ; import top . kangert . kspider . executor . function . DateFunctionExecutor ; import top . kangert . kspider . util . ExtractUtils ; import org . jsoup . nodes . Element ; import org . jsoup . parser . Parser ; import org . jsoup . select . Elements ; import org . springframework . stereotype . Component ; import cn . hutool . core . convert . Convert ; import cn . hutool . core . util . EscapeUtil ; import cn . hutool . json . JSONUtil ; import java . text . ParseException ; import java . util . Date ; import java . util . List ; @ Component public class StringFunctionExtension implements FunctionExtension { @ Override public Class < ? > support ( ) { return String . class ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( String source , String pattern ) { return ExtractUtils . getFirstMatcher ( source , pattern , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String regx ( String source , String pattern , int groupIndex ) { return ExtractUtils . getFirstMatcher ( source , pattern , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regx ( String source , String pattern , List < Integer > groups ) { return ExtractUtils . getFirstMatcher ( source , pattern , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( String source , String pattern ) { return ExtractUtils . getMatchers ( source , pattern , true ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > regxs ( String source , String pattern , int groupIndex ) { return ExtractUtils . getMatchers ( source , pattern , groupIndex ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < List < String > > regxs ( String source , String pattern , List < Integer > groups ) { return ExtractUtils . getMatchers ( source , pattern , groups ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String xpath ( String source , String xpath ) { return ExtractUtils . getValueByXPath ( element ( source ) , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static List < String > xpaths ( String source , String xpath ) { return ExtractUtils . getValuesByXPath ( element ( source ) , xpath ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element element ( String source ) { return Parser . xmlParser ( ) . parseInput ( source , \"<STR_LIT>\" ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Element selector ( String source , String cssQuery ) { return element ( source ) . selectFirst ( cssQuery ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Elements selectors ( String source , String cssQuery ) { return element ( source ) . select ( cssQuery ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object json ( String source ) { return JSONUtil . parse ( source ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Object jsonpath ( String source , String jsonPath ) { return ExtractUtils . getValueByJsonPath ( json ( source ) , jsonPath ) ;", "output": "} @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Integer toInt ( String source , int defaultValue ) { return Convert . toInt ( source , defaultValue ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Integer toInt ( String source ) { return Convert . toInt ( source , <NUM_LIT> ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Double toDouble ( String source ) { return Convert . toDouble ( source , <NUM_LIT> ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Long toLong ( String source ) { return Convert . toLong ( source , <NUM_LIT> ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static Date toDate ( String source , String pattern ) throws ParseException { return DateFunctionExecutor . parse ( source , pattern ) ; } @ Comment ( \"<STR_LIT>\" ) @ Example ( \"<STR_LIT>\" ) public static String unescape ( String source ) { return EscapeUtil . safeUnescape ( source ) ; } }"}, {"input": "package com . youlai . system . converter ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . entity . SysDict ; import com . youlai . system . model . form . DictForm ; import com . youlai . system . model . vo . DictPageVO ; import org . mapstruct . Mapper ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface DictConverter { Page < DictPageVO > convertToPageVo ( Page < SysDict > page ) ; DictForm toForm ( SysDict entity ) ; SysDict toEntity ( DictForm entity ) ;", "output": "}"}, {"input": "package com . youlai . system . mapper ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import com . youlai . system . model . bo . VisitCount ; import com . youlai . system . model . entity . SysLog ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . youlai . system . model . query . LogPageQuery ; import com . youlai . system . model . vo . LogPageVO ; import com . youlai . system . model . vo . VisitStatsVO ; import org . apache . ibatis . annotations . Mapper ; import java . util . List ; @ Mapper public interface SysLogMapper extends BaseMapper < SysLog > { Page < LogPageVO > listPagedLogs ( Page page , LogPageQuery queryParams ) ; List < VisitCount > getPvCounts ( String startDate , String endDate ) ; List < VisitCount > getIpCounts ( String startDate , String endDate ) ;", "output": "VisitStatsVO getPvStats ( ) ; VisitStatsVO getIpStats ( ) ; }"}, {"input": "package com . yf . system . modules . config . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . yf . system . modules . config . entity . CfgSwitch ; public interface CfgSwitchMapper extends BaseMapper < CfgSwitch > {", "output": "}"}, {"input": "package me . zhengjie . mapper ; import com . baomidou . mybatisplus . core . mapper . BaseMapper ; import com . baomidou . mybatisplus . core . metadata . IPage ; import com . baomidou . mybatisplus . extension . plugins . pagination . Page ; import me . zhengjie . domain . LocalStorage ; import me . zhengjie . domain . vo . LocalStorageQueryCriteria ; import org . apache . ibatis . annotations . Mapper ; import org . apache . ibatis . annotations . Param ; import java . util . List ; @ Mapper public interface LocalStorageMapper extends BaseMapper < LocalStorage > { IPage < LocalStorage > findAll ( @ Param ( \"<STR_LIT>\" ) LocalStorageQueryCriteria criteria , Page < Object > page ) ; List < LocalStorage > findAll ( @ Param ( \"<STR_LIT>\" ) LocalStorageQueryCriteria criteria ) ;", "output": "}"}, {"input": "package top . kangert . kspider . context ; import cn . hutool . core . date . DateUtil ; import cn . hutool . json . JSONUtil ; import lombok . AllArgsConstructor ; import lombok . Getter ; import lombok . Setter ; import top . kangert . kspider . context . SpiderContext ; import top . kangert . kspider . model . SpiderLog ; import top . kangert . kspider . model . SpiderOutput ; import top . kangert . kspider . websocket . WebSocketEvent ; import org . springframework . web . socket . TextMessage ; import org . springframework . web . socket . WebSocketSession ; import java . util . Date ; public class SpiderWebSocketContext extends SpiderContext { @ Getter @ Setter private boolean debug ; private WebSocketSession session ; private Object lock = new Object ( ) ; public SpiderWebSocketContext ( WebSocketSession session ) { this . session = session ; } @ Override public void addOutput ( SpiderOutput output ) { this . write ( new WebSocketEvent < > ( WebSocketEvent . OUTPUT_EVENT_TYPE , output ) ) ; } public void log ( SpiderLog log ) { write ( new WebSocketEvent < > ( WebSocketEvent . LOG_EVENT_TYPE , DateUtil . format ( new Date ( ) , \"<STR_LIT>\" ) , log ) ) ; } public < T > void write ( WebSocketEvent < T > event ) { try { String message = JSONUtil . toJsonStr ( event ) ; if ( session . isOpen ( ) ) { synchronized ( session ) { session . sendMessage ( new TextMessage ( message ) ) ; } } } catch ( Throwable ignored ) { } } @ Override public void pause ( String nodeId , String event , String key , Object value ) { if ( this . debug && this . isRunning ( ) ) { synchronized ( this ) { if ( this . debug && this . isRunning ( ) ) { synchronized ( lock ) { try { write ( new WebSocketEvent < > ( WebSocketEvent . DEBUG_EVENT_TYPE , new DebugInfo ( nodeId , event , key , value ) ) ) ; lock . wait ( ) ; } catch ( InterruptedException ignored ) { } } } } } } @ Override public void resume ( ) { if ( this . debug ) { synchronized ( lock ) { lock . notify ( ) ; } } } @ Override public void stop ( ) { if ( this . debug ) { synchronized ( lock ) { lock . notifyAll ( ) ; } }", "output": "} @ Getter @ Setter @ AllArgsConstructor class DebugInfo { private String nodeId ; private String event ; private String key ; private Object value ; } }"}, {"input": "package me . zhengjie . modules . security . rest ; import io . swagger . annotations . Api ; import io . swagger . annotations . ApiOperation ; import lombok . RequiredArgsConstructor ; import me . zhengjie . modules . security . service . OnlineUserService ; import me . zhengjie . modules . security . service . dto . OnlineUserDto ; import me . zhengjie . utils . EncryptUtils ; import me . zhengjie . utils . PageResult ; import org . springframework . data . domain . Pageable ; import org . springframework . http . HttpStatus ; import org . springframework . http . ResponseEntity ; import org . springframework . security . access . prepost . PreAuthorize ; import org . springframework . web . bind . annotation . * ; import javax . servlet . http . HttpServletResponse ; import java . io . IOException ; import java . util . Set ; @ RestController @ RequiredArgsConstructor @ RequestMapping ( \"<STR_LIT>\" ) @ Api ( tags = \"<STR_LIT>\" ) public class OnlineController { private final OnlineUserService onlineUserService ; @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < PageResult < OnlineUserDto > > queryOnlineUser ( String username , Pageable pageable ) { return new ResponseEntity < > ( onlineUserService . getAll ( username , pageable ) , HttpStatus . OK ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ GetMapping ( value = \"<STR_LIT>\" ) @ PreAuthorize ( \"<STR_LIT>\" ) public void exportOnlineUser ( HttpServletResponse response , String username ) throws IOException {", "output": "onlineUserService . download ( onlineUserService . getAll ( username ) , response ) ; } @ ApiOperation ( \"<STR_LIT>\" ) @ DeleteMapping @ PreAuthorize ( \"<STR_LIT>\" ) public ResponseEntity < Object > deleteOnlineUser ( @ RequestBody Set < String > keys ) throws Exception { for ( String token : keys ) { token = EncryptUtils . desDecrypt ( token ) ; onlineUserService . logout ( token ) ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } }"}, {"input": "package org . springblade . common . cache ; public interface CacheNames { static String cacheKey ( String cacheKey , String cacheKeyValue ) { return cacheKey . concat ( cacheKeyValue ) ; } static String tenantKey ( String tenantId , String cacheKey , String cacheKeyValue ) { return tenantId . concat ( \"<STR_LIT>\" ) . concat ( cacheKey ) . concat ( cacheKeyValue ) ; } String CAPTCHA_KEY = \"<STR_LIT>\" ; String EMAIL_KEY = \"<STR_LIT>\" ; String USER_FAIL_KEY = \"<STR_LIT>\" ;", "output": "}"}, {"input": "package org . springblade . web . model . param ; import lombok . Data ; import java . math . BigDecimal ; @ Data public class ContractBondParam { private String logContractId ; private String type ; private BigDecimal amount ;", "output": "}"}, {"input": "package top . kangert . kspider . service ; import top . kangert . kspider . domain . Variable ; import top . kangert . kspider . util . PageInfo ; import java . util . Map ; public interface VariableService { Variable addItem ( Map < String , Object > params ) ;", "output": "void deleteItem ( Map < String , Object > params ) ; void editItem ( Map < String , Object > params ) ; Variable queryItem ( Long varId ) ; PageInfo < Variable > queryItems ( Map < String , Object > params ) ; }"}, {"input": "package org . springblade . cgform . service . impl ; import com . alibaba . fastjson . JSONObject ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import org . springblade . config . exception . BusinessException ; import org . springblade . config . util . ConvertUtils ; import org . springblade . config . util . MyClassLoader ; import org . springblade . config . util . SpringContextUtils ; import org . springblade . cgform . entity . CgformEnhanceJava ; import org . springblade . cgform . entity . CgformHead ; import org . springblade . cgform . mapper . CgformEnhanceJavaMapper ; import org . springblade . cgform . model . CgformEnhanceJavaInter ; import org . springblade . cgform . model . CgformEnhanceJavaListInter ; import org . springblade . cgform . service . ICgformEnhanceJavaService ; import org . springblade . core . mp . base . BaseServiceImpl ; import org . springblade . core . tool . utils . Func ; import org . springframework . stereotype . Service ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Properties ; @ Service public class CgformEnhanceJavaServiceImpl extends BaseServiceImpl < CgformEnhanceJavaMapper , CgformEnhanceJava > implements ICgformEnhanceJavaService { public void executeEnhanceList ( CgformHead head , String buttonCode , List < Map < String , Object > > dataList , Map < String , Object > params ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) { enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaListInter ) { CgformEnhanceJavaListInter listInter = ( CgformEnhanceJavaListInter ) obj ; listInter . execute ( head . getTableName ( ) , head . getTenantId ( ) , dataList , params ) ; } } @ Override public Object getEnhanceJavaObj ( CgformEnhanceJava enhanceJava ) { if ( Func . isEmpty ( enhanceJava ) ) { return null ; } String javaType = enhanceJava . getCgJavaType ( ) ; String javaValue = enhanceJava . getCgJavaValue ( ) ; if ( ConvertUtils . isNotEmpty ( javaValue ) ) { Object resultObject = null ; if ( \"<STR_LIT>\" . equals ( javaType ) ) { try { resultObject = MyClassLoader . getClassByScn ( javaValue ) . newInstance ( ) ; } catch ( InstantiationException e ) { log . error ( e . getMessage ( ) , e ) ; } catch ( IllegalAccessException e ) { log . error ( e . getMessage ( ) , e ) ; } } else if ( \"<STR_LIT>\" . equals ( javaType ) ) { resultObject = SpringContextUtils . getBean ( javaValue ) ; } return resultObject ; } return null ; } @ Override public int executeEnhanceJava ( String buttonCode , String eventType , CgformHead head , JSONObject json ) throws BusinessException { LambdaQueryWrapper < CgformEnhanceJava > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( CgformEnhanceJava :: getActiveStatus , \"<STR_LIT>\" ) ; wrapper . eq ( CgformEnhanceJava :: getButtonCode , buttonCode ) ; wrapper . eq ( CgformEnhanceJava :: getCgformHeadId , head . getId ( ) ) ; wrapper . eq ( CgformEnhanceJava :: getEvent , eventType ) ; List < CgformEnhanceJava > enhanceJavaList = baseMapper . selectList ( wrapper ) ; if ( Func . isEmpty ( enhanceJavaList ) ) { return <NUM_LIT> ; } Properties props = System . getProperties ( ) ; String property = props . getProperty ( \"<STR_LIT>\" ) ; CgformEnhanceJava enhanceJava = null ; for ( CgformEnhanceJava enhance : enhanceJavaList ) { String serviceName = enhance . getServiceName ( ) ; if ( Func . isEmpty ( serviceName ) || Func . equals ( serviceName , \"<STR_LIT>\" ) || Func . equals ( property , serviceName ) ) {", "output": "enhanceJava = enhance ; break ; } } if ( Func . isEmpty ( enhanceJava ) ) { return <NUM_LIT> ; } Object obj = this . getEnhanceJavaObj ( enhanceJava ) ; if ( obj != null && obj instanceof CgformEnhanceJavaInter ) { CgformEnhanceJavaInter enhanceJavaInter = ( CgformEnhanceJavaInter ) obj ; return enhanceJavaInter . execute ( head , json ) ; } else { return <NUM_LIT> ; } } }"}, {"input": "package ginyi . framework . security . service ; import ginyi . common . exception . UnPermissionException ; import ginyi . common . utils . StringUtils ; import ginyi . framework . security . context . PermissionContextHolder ; import ginyi . framework . security . utils . SecurityUtils ; import ginyi . system . domain . LoginUser ; import ginyi . system . domain . SysRole ; import org . springframework . stereotype . Service ; import org . springframework . util . CollectionUtils ; import java . util . Set ; @ Service ( \"<STR_LIT>\" ) public class PermissionService { private static final String ALL_PERMISSION = \"<STR_LIT>\" ; private static final String SUPER_ADMIN = \"<STR_LIT>\" ; private static final String ROLE_DELIMETER = \"<STR_LIT>\" ; private static final String PERMISSION_DELIMETER = \"<STR_LIT>\" ; public boolean hasPermission ( String permission ) { if ( StringUtils . isEmpty ( permission ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getPermissions ( ) ) ) { return false ; } PermissionContextHolder . setContext ( permission ) ; return hasPermissions ( loginUser . getPermissions ( ) , permission ) ; } public boolean lacksPermi ( String permission ) { return hasPermission ( permission ) != true ;", "output": "} public boolean hasAnyPermi ( String permissions ) { if ( StringUtils . isEmpty ( permissions ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getPermissions ( ) ) ) { return false ; } PermissionContextHolder . setContext ( permissions ) ; Set < String > authorities = loginUser . getPermissions ( ) ; for ( String permission : permissions . split ( PERMISSION_DELIMETER ) ) { if ( permission != null && hasPermissions ( authorities , permission ) ) { return true ; } } return false ; } public boolean hasRole ( String role ) { if ( StringUtils . isEmpty ( role ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getUser ( ) . getRoles ( ) ) ) { return false ; } for ( SysRole sysRole : loginUser . getUser ( ) . getRoles ( ) ) { String roleKey = sysRole . getRoleKey ( ) ; if ( SUPER_ADMIN . equals ( roleKey ) || roleKey . equals ( StringUtils . trim ( role ) ) ) { return true ; } } return false ; } public boolean lacksRole ( String role ) { return hasRole ( role ) != true ; } public boolean hasAnyRoles ( String roles ) { if ( StringUtils . isEmpty ( roles ) ) { return false ; } LoginUser loginUser = SecurityUtils . getLoginUser ( ) ; if ( StringUtils . isNull ( loginUser ) || CollectionUtils . isEmpty ( loginUser . getUser ( ) . getRoles ( ) ) ) { return false ; } for ( String role : roles . split ( ROLE_DELIMETER ) ) { if ( hasRole ( role ) ) { return true ; } } return false ; } private boolean hasPermissions ( Set < String > permissions , String permission ) { boolean isHasPermission = permissions . contains ( ALL_PERMISSION ) || permissions . contains ( StringUtils . trim ( permission ) ) ; if ( isHasPermission ) { return true ; } else { throw new UnPermissionException ( ) ; } } }"}, {"input": "package com . xcs . wx . repository . impl ; import com . baomidou . dynamic . datasource . annotation . DS ; import com . baomidou . mybatisplus . core . conditions . query . LambdaQueryWrapper ; import com . baomidou . mybatisplus . core . toolkit . Wrappers ; import com . baomidou . mybatisplus . extension . service . impl . ServiceImpl ; import com . xcs . wx . constant . DataSourceType ; import com . xcs . wx . domain . FTSContactContent ; import com . xcs . wx . domain . dto . RecoverContactDTO ; import com . xcs . wx . mapper . FTSContactContentMapper ; import com . xcs . wx . repository . FTSContactContentRepository ; import org . springframework . stereotype . Repository ; import java . util . List ; @ Repository @ DS ( value = DataSourceType . FTS_CONTACT_DB ) public class FTSContactContentRepositoryImpl extends ServiceImpl < FTSContactContentMapper , FTSContactContent > implements FTSContactContentRepository { @ Override public List < FTSContactContent > queryContactContent ( RecoverContactDTO recoverContactDTO ) { LambdaQueryWrapper < FTSContactContent > wrapper = Wrappers . < FTSContactContent > lambdaQuery ( ) . ne ( FTSContactContent :: getAlias , \"<STR_LIT>\" ) . like ( recoverContactDTO . getNickname ( ) != null , FTSContactContent :: getNickname , recoverContactDTO . getNickname ( ) ) . like ( recoverContactDTO . getRemark ( ) != null , FTSContactContent :: getRemark , recoverContactDTO . getRemark ( ) ) . orderByAsc ( FTSContactContent :: getAlias ) ; return super . list ( wrapper ) ;", "output": "} }"}, {"input": "package com . xcs . wx . mapping ; import cn . hutool . core . util . StrUtil ; import com . xcs . wx . domain . ChatRoom ; import com . xcs . wx . domain . ChatRoomInfo ; import com . xcs . wx . domain . vo . ChatRoomDetailVO ; import com . xcs . wx . domain . vo . ChatRoomInfoVO ; import com . xcs . wx . domain . vo . ChatRoomMemberVO ; import com . xcs . wx . domain . vo . ChatRoomVO ; import com . xcs . wx . protobuf . ChatRoomProto ; import org . mapstruct . Mapper ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; @ Mapper ( componentModel = \"<STR_LIT>\" ) public interface ChatRoomMapping { List < ChatRoomVO > convert ( List < ChatRoom > chatRooms ) ; ChatRoomDetailVO convert ( ChatRoom chatRoom ) ; ChatRoomInfoVO convert ( ChatRoomInfo chatRoomInfo ) ; ChatRoomMemberVO convert ( ChatRoomProto . Member member ) ; default List < ChatRoomMemberVO > convert ( List < ChatRoomProto . Member > members , Map < String , String > headImgUrlMap , Map < String , String > contactNicknameMap ) { return members . stream ( ) . map ( this :: convert ) . peek ( member -> member . setHeadImgUrl ( headImgUrlMap . get ( member . getWxId ( ) ) ) ) . peek ( member -> { if ( StrUtil . isNotBlank ( member . getRemark ( ) ) ) { return ; } member . setRemark ( contactNicknameMap . get ( member . getWxId ( ) ) ) ; } ) . collect ( Collectors . toList ( ) ) ;", "output": "} }"}, {"input": "package com . oddfar . campus . framework . api . resource ; import com . oddfar . campus . common . domain . entity . SysResourceEntity ; import com . oddfar . campus . common . domain . model . SysRoleAuth ; import com . oddfar . campus . common . domain . model . SysRoleAuthList ; import java . util . List ; import java . util . Map ; public interface ResourceCollectorApi {", "output": "void collectResources ( List < SysResourceEntity > apiResource ) ; List < SysResourceEntity > getAllResources ( ) ; void setRoleAuthCache ( Map < Long , List < SysRoleAuth > > rolePermsMap , Map < Long , List < SysRoleAuth > > roleResourceMap ) ; Map < Long , SysRoleAuthList > getRoleListMap ( ) ; }"}, {"input": "package org . springblade . config . async ; import org . springframework . beans . BeansException ; import org . springframework . context . ApplicationContext ; import org . springframework . context . ApplicationContextAware ; import org . springframework . stereotype . Component ; @ Component public class MjkjSpringUtil implements ApplicationContextAware { private static ApplicationContext applicationContext = null ; @ Override public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { if ( MjkjSpringUtil . applicationContext == null ) { MjkjSpringUtil . applicationContext = applicationContext ;", "output": "} System . out . println ( \"<STR_LIT>\" ) ; } public static ApplicationContext getApplicationContext ( ) { return applicationContext ; } public static Object getBean ( String name ) { return getApplicationContext ( ) . getBean ( name ) ; } public static < T > T getBean ( Class < T > clazz ) { return getApplicationContext ( ) . getBean ( clazz ) ; } public static < T > T getBean ( String name , Class < T > clazz ) { return getApplicationContext ( ) . getBean ( name , clazz ) ; } }"}, {"input": "package com . youlai . system . model . bo ; import com . fasterxml . jackson . annotation . JsonFormat ; import lombok . Data ; import java . util . Date ; @ Data public class UserBO { private Long id ; private String username ; private String nickname ; private String mobile ; private Integer gender ; private String avatar ; private String email ; private Integer status ; private String deptName ; private String roleNames ; @ JsonFormat ( pattern = \"<STR_LIT>\" ) private Date createTime ;", "output": "}"}, {"input": "package top . kangert . kspider . expression . parsing ; public class Span { private final String source ; private int start ; private int end ; private final String cachedText ; public Span ( String source ) { this ( source , <NUM_LIT> , source . length ( ) ) ; } public Span ( String source , int start , int end ) { if ( start > end ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( start < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" ) ;", "output": "} if ( start > source . length ( ) - <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" ) ; } if ( end > source . length ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" ) ; } this . source = source ; this . start = start ; this . end = end ; this . cachedText = source . substring ( start , end ) ; } public Span ( Span start , Span end ) { if ( ! start . source . equals ( end . source ) ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( start . start > end . end ) { throw new IllegalArgumentException ( \"<STR_LIT>\" ) ; } if ( start . start < <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" ) ; } if ( start . start > start . source . length ( ) - <NUM_LIT> ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" ) ; } if ( end . end > start . source . length ( ) ) { throw new IndexOutOfBoundsException ( \"<STR_LIT>\" ) ; } this . source = start . source ; this . start = start . start ; this . end = end . end ; this . cachedText = source . substring ( this . start , this . end ) ; } public String getText ( ) { return cachedText ; } public int getStart ( ) { return start ; } public int getEnd ( ) { return end ; } public String getSource ( ) { return source ; } @ Override public String toString ( ) { return \"<STR_LIT>\" + getText ( ) + \"<STR_LIT>\" + start + \"<STR_LIT>\" + end + \"<STR_LIT>\" ; } public Line getLine ( ) { int lineStart = start ; while ( true ) { if ( lineStart < <NUM_LIT> ) { break ; } char c = source . charAt ( lineStart ) ; if ( c == '<STR_LIT>' ) { lineStart = lineStart + <NUM_LIT> ; break ; } lineStart -- ; } if ( lineStart < <NUM_LIT> ) { lineStart = <NUM_LIT> ; } int lineEnd = end ; while ( true ) { if ( lineEnd > source . length ( ) - <NUM_LIT> ) { break ; } char c = source . charAt ( lineEnd ) ; if ( c == '<STR_LIT>' ) { break ; } lineEnd ++ ; } int lineNumber = <NUM_LIT> ; int idx = lineStart ; while ( idx > <NUM_LIT> ) { char c = source . charAt ( idx ) ; if ( c == '<STR_LIT>' ) { lineNumber ++ ; } idx -- ; } lineNumber ++ ; return new Line ( source , lineStart , lineEnd , lineNumber ) ; } public static class Line { private final String source ; private final int start ; private final int end ; private final int lineNumber ; public Line ( String source , int start , int end , int lineNumber ) { this . source = source ; this . start = start ; this . end = end ; this . lineNumber = lineNumber ; } public String getSource ( ) { return source ; } public int getStart ( ) { return start ; } public int getEnd ( ) { return end ; } public int getLineNumber ( ) { return lineNumber ; } public String getText ( ) { return source . substring ( start , end ) ; } } }"}, {"input": "package org . springblade . web . utils . googleauth ; import org . apache . commons . codec . binary . Base32 ; import org . apache . commons . codec . binary . Hex ; import org . springframework . util . StringUtils ; import javax . crypto . Mac ; import javax . crypto . spec . SecretKeySpec ; import java . io . UnsupportedEncodingException ; import java . net . URLEncoder ; import java . security . InvalidKeyException ; import java . security . NoSuchAlgorithmException ; import java . security . SecureRandom ; public class GoogleAuthenticator { private static int WINDOW_SIZE = <NUM_LIT> ; private static String CRYPTO = \"<STR_LIT>\" ; public static String getSecretKey ( ) {", "output": "SecureRandom random = new SecureRandom ( ) ; byte [ ] bytes = new byte [ <NUM_LIT> ] ; random . nextBytes ( bytes ) ; Base32 base32 = new Base32 ( ) ; String secretKey = base32 . encodeToString ( bytes ) ; return secretKey . toUpperCase ( ) ; } public static String getQrCodeText ( String secretKey , String account , String issuer ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; try { return \"<STR_LIT>\" + URLEncoder . encode ( ( ! StringUtils . isEmpty ( issuer ) ? ( issuer + \"<STR_LIT>\" ) : \"<STR_LIT>\" ) + account , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + \"<STR_LIT>\" + URLEncoder . encode ( normalizedBase32Key , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) + ( ! StringUtils . isEmpty ( issuer ) ? ( \"<STR_LIT>\" + URLEncoder . encode ( issuer , \"<STR_LIT>\" ) . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) ) : \"<STR_LIT>\" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( e ) ; } } public static String getCode ( String secretKey ) { String normalizedBase32Key = secretKey . replace ( \"<STR_LIT>\" , \"<STR_LIT>\" ) . toUpperCase ( ) ; Base32 base32 = new Base32 ( ) ; byte [ ] bytes = base32 . decode ( normalizedBase32Key ) ; String hexKey = Hex . encodeHexString ( bytes ) ; long time = ( System . currentTimeMillis ( ) / <NUM_LIT> ) / <NUM_LIT> ; String hexTime = Long . toHexString ( time ) ; return TOTP . generateTOTP ( hexKey , hexTime , \"<STR_LIT>\" , CRYPTO ) ; } public static boolean checkCode ( String secret , long code , long time ) { Base32 codec = new Base32 ( ) ; byte [ ] decodedKey = codec . decode ( secret ) ; long t = ( time / <NUM_LIT> ) / <NUM_LIT> ; long hash ; for ( int i = - WINDOW_SIZE ; i <= WINDOW_SIZE ; ++ i ) { try { hash = verifyCode ( decodedKey , t + i ) ; } catch ( Exception e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } if ( hash == code ) { return true ; } } return false ; } private static long verifyCode ( byte [ ] key , long t ) throws NoSuchAlgorithmException , InvalidKeyException { byte [ ] data = new byte [ <NUM_LIT> ] ; long value = t ; for ( int i = <NUM_LIT> ; i -- > <NUM_LIT> ; value >>>= <NUM_LIT> ) { data [ i ] = ( byte ) value ; } SecretKeySpec signKey = new SecretKeySpec ( key , CRYPTO ) ; Mac mac = Mac . getInstance ( CRYPTO ) ; mac . init ( signKey ) ; byte [ ] hash = mac . doFinal ( data ) ; int offset = hash [ <NUM_LIT> - <NUM_LIT> ] & <NUM_LIT> ; long truncatedHash = <NUM_LIT> ; for ( int i = <NUM_LIT> ; i < <NUM_LIT> ; ++ i ) { truncatedHash <<= <NUM_LIT> ; truncatedHash |= ( hash [ offset + i ] & <NUM_LIT> ) ; } truncatedHash &= <NUM_LIT> ; truncatedHash %= <NUM_LIT> ; return truncatedHash ; } }"}]